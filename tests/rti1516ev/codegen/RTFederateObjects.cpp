
// Code automatically generated by T4 template from RTFederate.xml, do not edit

#include <vector>
#include <cassert>

#include "RTI/encoding/HLAopaqueData.h"
#include "RTI/encoding/HLAhandle.h"

#include "RTFederateObjects.h"

namespace NDistSimIB {
namespace NRTFederateEncoding {
HLAobjectRootObjectClass::HLAobjectRootObjectClass(rti1516ev::RTIambassador* rtiAmbassador)
{
  mRtiAmbassador = rtiAmbassador;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot");
// attribute HLAobjectRoot.HLAprivilegeToDeleteObject : no data type
}

void HLAobjectRootObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void HLAobjectRootObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void HLAobjectRootObjectClass::Subscribe()
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void HLAobjectRootObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

void HLAobjectRootObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle, const std::wstring& instanceName)
{
  assert(mObjectInstancesByName.find(instanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(instanceHandle) == mObjectInstancesByHandle.end());
  HLAobjectRoot* newObject = new HLAobjectRoot(this, instanceName, mRtiAmbassador);
  newObject->mObjectInstanceHandle = instanceHandle;
  newObject->mIsOwner = false;
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
}

void HLAobjectRootObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject)
{
  std::wstring instanceName = mRtiAmbassador->getObjectInstanceName(theObject);
  auto iter = mObjectInstancesByName.find(instanceName);
  assert(iter != mObjectInstancesByName.end());
  auto* objectInstance = iter->second;
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  mObjectInstancesByName.erase(iter);
  mObjectInstancesByHandle.erase(theObject);
}

IHLAobjectRoot* HLAobjectRootObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IHLAobjectRoot* HLAobjectRootObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IHLAobjectRoot* HLAobjectRootObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"HLAobjectRoot");
  }
  HLAobjectRoot* newObject = new HLAobjectRoot(this, instanceName, mRtiAmbassador);
  ObjectClassRegistry::GetInstance()->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
    }
  });
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  return newObject;
}

rti1516ev::AttributeHandleSet HLAobjectRootObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  return result;
}

uint32_t HLAobjectRootObjectClass::RegisterDiscoverCallback(DiscoverCallbackType callback)
{
  mLastCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void HLAobjectRootObjectClass::UnregisterDiscoverCallback(uint32_t callbackToken)
{
  mDiscoverCallbacks.erase(callbackToken);
}

void HLAobjectRootObjectClass::ExecuteDiscoverCallbacks(IHLAobjectRoot* newObjectInstance)
{
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

// object instances of type 'HLAobjectRoot'
HLAobjectRoot::HLAobjectRoot()
{
}

HLAobjectRoot::HLAobjectRoot(HLAobjectRootObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mObjectClass(objectClass)
  , mInstanceName(instanceName)
  , mRtiAmbassador(rtiAmbassador)
{
}

HLAobjectRoot::~HLAobjectRoot()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

// attribute HLAobjectRoot.HLAprivilegeToDeleteObject : no data type

rti1516ev::AttributeHandleValueMap HLAobjectRoot::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  return result;
}

rti1516ev::AttributeHandleValueMap HLAobjectRoot::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  return result;
}


// object class type 'SystemVariable'
SystemVariableObjectClass::SystemVariableObjectClass(rti1516ev::RTIambassador* rtiAmbassador, HLAobjectRootObjectClass* baseClass)
{
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.SystemVariable");
  // attribute Value : HLAopaqueData
  mValueAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"Value");
}

void SystemVariableObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void SystemVariableObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void SystemVariableObjectClass::Subscribe()
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void SystemVariableObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

void SystemVariableObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle, const std::wstring& instanceName)
{
  assert(mObjectInstancesByName.find(instanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(instanceHandle) == mObjectInstancesByHandle.end());
  SystemVariable* newObject = new SystemVariable(this, instanceName, mRtiAmbassador);
  newObject->mObjectInstanceHandle = instanceHandle;
  newObject->mIsOwner = false;
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
}

void SystemVariableObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject)
{
  std::wstring instanceName = mRtiAmbassador->getObjectInstanceName(theObject);
  auto iter = mObjectInstancesByName.find(instanceName);
  assert(iter != mObjectInstancesByName.end());
  auto* objectInstance = iter->second;
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  mObjectInstancesByName.erase(iter);
  mObjectInstancesByHandle.erase(theObject);
}

ISystemVariable* SystemVariableObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

ISystemVariable* SystemVariableObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

ISystemVariable* SystemVariableObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"SystemVariable");
  }
  SystemVariable* newObject = new SystemVariable(this, instanceName, mRtiAmbassador);
  ObjectClassRegistry::GetInstance()->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
    }
  });
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  return newObject;
}

rti1516ev::AttributeHandleSet SystemVariableObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetValueAttributeHandle());
  return result;
}

uint32_t SystemVariableObjectClass::RegisterDiscoverCallback(DiscoverCallbackType callback)
{
  mLastCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void SystemVariableObjectClass::UnregisterDiscoverCallback(uint32_t callbackToken)
{
  mDiscoverCallbacks.erase(callbackToken);
}

void SystemVariableObjectClass::ExecuteDiscoverCallbacks(ISystemVariable* newObjectInstance)
{
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

// object instances of type 'SystemVariable'
SystemVariable::SystemVariable()
{
}

SystemVariable::SystemVariable(SystemVariableObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mObjectClass(objectClass)
  , mInstanceName(instanceName)
  , mRtiAmbassador(rtiAmbassador)
{
}

SystemVariable::~SystemVariable()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

// attribute SystemVariable.HLAprivilegeToDeleteObject : no data type

// attribute Value : HLAopaqueData
std::vector<uint8_t> SystemVariable::GetValue() const
{
  return mValue.get();
}

void SystemVariable::SetValue(const std::vector<uint8_t>& newValue)
{
  // CanTranslateToCpp=True
  mValue.set(newValue);
  mDirty |= kValueBit;
}

rti1516ev::AttributeHandleValueMap SystemVariable::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetValueAttributeHandle()] = mValue.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap SystemVariable::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kValueBit)
  {
    result[mObjectClass->GetValueAttributeHandle()] = mValue.encode();
  }
  return result;
}

void SystemVariable::UpdateAllAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
  }
}

void SystemVariable::UpdateAllAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
  }
}

void SystemVariable::UpdateModifiedAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
    mDirty = kNone;
  }
}

void SystemVariable::UpdateModifiedAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
    mDirty = kNone;
  }
}

void SystemVariable::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetValueAttributeHandle())
    {
      mValue.decode(attributeHandleValue.second);
      mLastUpdated |= kValueBit;
    }
  } // for (auto& attributeHandleValue : attributes)
    ExecuteUpdateCallbacks();
} // SystemVariable::ReflectAttributeValues

void SystemVariable::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  if ((mLastUpdated & kValueBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetValueAttributeHandle());
  }
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void SystemVariable::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetValueAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void SystemVariable::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  for (auto& attributeHandle : attributeHandles)
  {
    if (attributeHandle == mObjectClass->GetValueAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mValue.encode()));
      mDirty &= ~kValueBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // SystemVariable::ReflectAttributeValues

uint32_t SystemVariable::RegisterUpdateCallback(UpdateCallbackType callback)
{
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void SystemVariable::UnregisterUpdateCallback(uint32_t callbackToken)
{
  mUpdateCallbacks.erase(callbackToken);
}

void SystemVariable::ExecuteUpdateCallbacks()
{
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(this);
  }
}

// object class type 'ValueEntity'
ValueEntityObjectClass::ValueEntityObjectClass(rti1516ev::RTIambassador* rtiAmbassador, HLAobjectRootObjectClass* baseClass)
{
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.ValueEntity");
  // attribute Value : HLAopaqueData
  mValueAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"Value");
}

void ValueEntityObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void ValueEntityObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void ValueEntityObjectClass::Subscribe()
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void ValueEntityObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

void ValueEntityObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle, const std::wstring& instanceName)
{
  assert(mObjectInstancesByName.find(instanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(instanceHandle) == mObjectInstancesByHandle.end());
  ValueEntity* newObject = new ValueEntity(this, instanceName, mRtiAmbassador);
  newObject->mObjectInstanceHandle = instanceHandle;
  newObject->mIsOwner = false;
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
}

void ValueEntityObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject)
{
  std::wstring instanceName = mRtiAmbassador->getObjectInstanceName(theObject);
  auto iter = mObjectInstancesByName.find(instanceName);
  assert(iter != mObjectInstancesByName.end());
  auto* objectInstance = iter->second;
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  mObjectInstancesByName.erase(iter);
  mObjectInstancesByHandle.erase(theObject);
}

IValueEntity* ValueEntityObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IValueEntity* ValueEntityObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IValueEntity* ValueEntityObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"ValueEntity");
  }
  ValueEntity* newObject = new ValueEntity(this, instanceName, mRtiAmbassador);
  ObjectClassRegistry::GetInstance()->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
    }
  });
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  return newObject;
}

rti1516ev::AttributeHandleSet ValueEntityObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetValueAttributeHandle());
  return result;
}

uint32_t ValueEntityObjectClass::RegisterDiscoverCallback(DiscoverCallbackType callback)
{
  mLastCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void ValueEntityObjectClass::UnregisterDiscoverCallback(uint32_t callbackToken)
{
  mDiscoverCallbacks.erase(callbackToken);
}

void ValueEntityObjectClass::ExecuteDiscoverCallbacks(IValueEntity* newObjectInstance)
{
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

// object instances of type 'ValueEntity'
ValueEntity::ValueEntity()
{
}

ValueEntity::ValueEntity(ValueEntityObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mObjectClass(objectClass)
  , mInstanceName(instanceName)
  , mRtiAmbassador(rtiAmbassador)
{
}

ValueEntity::~ValueEntity()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

// attribute ValueEntity.HLAprivilegeToDeleteObject : no data type

// attribute Value : HLAopaqueData
std::vector<uint8_t> ValueEntity::GetValue() const
{
  return mValue.get();
}

void ValueEntity::SetValue(const std::vector<uint8_t>& newValue)
{
  // CanTranslateToCpp=True
  mValue.set(newValue);
  mDirty |= kValueBit;
}

rti1516ev::AttributeHandleValueMap ValueEntity::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetValueAttributeHandle()] = mValue.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap ValueEntity::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kValueBit)
  {
    result[mObjectClass->GetValueAttributeHandle()] = mValue.encode();
  }
  return result;
}

void ValueEntity::UpdateAllAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
  }
}

void ValueEntity::UpdateAllAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
  }
}

void ValueEntity::UpdateModifiedAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
    mDirty = kNone;
  }
}

void ValueEntity::UpdateModifiedAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
    mDirty = kNone;
  }
}

void ValueEntity::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetValueAttributeHandle())
    {
      mValue.decode(attributeHandleValue.second);
      mLastUpdated |= kValueBit;
    }
  } // for (auto& attributeHandleValue : attributes)
    ExecuteUpdateCallbacks();
} // ValueEntity::ReflectAttributeValues

void ValueEntity::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  if ((mLastUpdated & kValueBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetValueAttributeHandle());
  }
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void ValueEntity::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetValueAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void ValueEntity::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  for (auto& attributeHandle : attributeHandles)
  {
    if (attributeHandle == mObjectClass->GetValueAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mValue.encode()));
      mDirty &= ~kValueBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // ValueEntity::ReflectAttributeValues

uint32_t ValueEntity::RegisterUpdateCallback(UpdateCallbackType callback)
{
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void ValueEntity::UnregisterUpdateCallback(uint32_t callbackToken)
{
  mUpdateCallbacks.erase(callbackToken);
}

void ValueEntity::ExecuteUpdateCallbacks()
{
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(this);
  }
}

// object class type 'DOMemberSource'
DOMemberSourceObjectClass::DOMemberSourceObjectClass(rti1516ev::RTIambassador* rtiAmbassador, HLAobjectRootObjectClass* baseClass)
{
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.DOMemberSource");
  // attribute DOSourceMemberName : HLAASCIIstring
  mDOSourceMemberNameAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"DOSourceMemberName");
  // attribute DOSourceMemberConnectionType : HLAASCIIstring
  mDOSourceMemberConnectionTypeAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"DOSourceMemberConnectionType");
  // attribute DOSourceMemberDataBytes : HLAopaqueData
  mDOSourceMemberDataBytesAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"DOSourceMemberDataBytes");
}

void DOMemberSourceObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void DOMemberSourceObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void DOMemberSourceObjectClass::Subscribe()
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void DOMemberSourceObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

void DOMemberSourceObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle, const std::wstring& instanceName)
{
  assert(mObjectInstancesByName.find(instanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(instanceHandle) == mObjectInstancesByHandle.end());
  DOMemberSource* newObject = new DOMemberSource(this, instanceName, mRtiAmbassador);
  newObject->mObjectInstanceHandle = instanceHandle;
  newObject->mIsOwner = false;
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
}

void DOMemberSourceObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject)
{
  std::wstring instanceName = mRtiAmbassador->getObjectInstanceName(theObject);
  auto iter = mObjectInstancesByName.find(instanceName);
  assert(iter != mObjectInstancesByName.end());
  auto* objectInstance = iter->second;
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  mObjectInstancesByName.erase(iter);
  mObjectInstancesByHandle.erase(theObject);
}

IDOMemberSource* DOMemberSourceObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IDOMemberSource* DOMemberSourceObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IDOMemberSource* DOMemberSourceObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"DOMemberSource");
  }
  DOMemberSource* newObject = new DOMemberSource(this, instanceName, mRtiAmbassador);
  ObjectClassRegistry::GetInstance()->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
    }
  });
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  return newObject;
}

rti1516ev::AttributeHandleSet DOMemberSourceObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetDOSourceMemberNameAttributeHandle());
  result.insert(GetDOSourceMemberConnectionTypeAttributeHandle());
  result.insert(GetDOSourceMemberDataBytesAttributeHandle());
  return result;
}

uint32_t DOMemberSourceObjectClass::RegisterDiscoverCallback(DiscoverCallbackType callback)
{
  mLastCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void DOMemberSourceObjectClass::UnregisterDiscoverCallback(uint32_t callbackToken)
{
  mDiscoverCallbacks.erase(callbackToken);
}

void DOMemberSourceObjectClass::ExecuteDiscoverCallbacks(IDOMemberSource* newObjectInstance)
{
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

// object instances of type 'DOMemberSource'
DOMemberSource::DOMemberSource()
{
}

DOMemberSource::DOMemberSource(DOMemberSourceObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mObjectClass(objectClass)
  , mInstanceName(instanceName)
  , mRtiAmbassador(rtiAmbassador)
{
}

DOMemberSource::~DOMemberSource()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

// attribute DOMemberSource.HLAprivilegeToDeleteObject : no data type

// attribute DOSourceMemberName : HLAASCIIstring
std::string DOMemberSource::GetDOSourceMemberName() const
{
  return mDOSourceMemberName.get();
}

void DOMemberSource::SetDOSourceMemberName(const std::string& newValue)
{
  // CanTranslateToCpp=True
  mDOSourceMemberName.set(newValue);
  mDirty |= kDOSourceMemberNameBit;
}

// attribute DOSourceMemberConnectionType : HLAASCIIstring
std::string DOMemberSource::GetDOSourceMemberConnectionType() const
{
  return mDOSourceMemberConnectionType.get();
}

void DOMemberSource::SetDOSourceMemberConnectionType(const std::string& newValue)
{
  // CanTranslateToCpp=True
  mDOSourceMemberConnectionType.set(newValue);
  mDirty |= kDOSourceMemberConnectionTypeBit;
}

// attribute DOSourceMemberDataBytes : HLAopaqueData
std::vector<uint8_t> DOMemberSource::GetDOSourceMemberDataBytes() const
{
  return mDOSourceMemberDataBytes.get();
}

void DOMemberSource::SetDOSourceMemberDataBytes(const std::vector<uint8_t>& newValue)
{
  // CanTranslateToCpp=True
  mDOSourceMemberDataBytes.set(newValue);
  mDirty |= kDOSourceMemberDataBytesBit;
}

rti1516ev::AttributeHandleValueMap DOMemberSource::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetDOSourceMemberNameAttributeHandle()] = mDOSourceMemberName.encode();
  result[mObjectClass->GetDOSourceMemberConnectionTypeAttributeHandle()] = mDOSourceMemberConnectionType.encode();
  result[mObjectClass->GetDOSourceMemberDataBytesAttributeHandle()] = mDOSourceMemberDataBytes.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap DOMemberSource::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kDOSourceMemberNameBit)
  {
    result[mObjectClass->GetDOSourceMemberNameAttributeHandle()] = mDOSourceMemberName.encode();
  }
  if (mDirty & kDOSourceMemberConnectionTypeBit)
  {
    result[mObjectClass->GetDOSourceMemberConnectionTypeAttributeHandle()] = mDOSourceMemberConnectionType.encode();
  }
  if (mDirty & kDOSourceMemberDataBytesBit)
  {
    result[mObjectClass->GetDOSourceMemberDataBytesAttributeHandle()] = mDOSourceMemberDataBytes.encode();
  }
  return result;
}

void DOMemberSource::UpdateAllAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
  }
}

void DOMemberSource::UpdateAllAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
  }
}

void DOMemberSource::UpdateModifiedAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
    mDirty = kNone;
  }
}

void DOMemberSource::UpdateModifiedAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
    mDirty = kNone;
  }
}

void DOMemberSource::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetDOSourceMemberNameAttributeHandle())
    {
      mDOSourceMemberName.decode(attributeHandleValue.second);
      mLastUpdated |= kDOSourceMemberNameBit;
    }
    else if (attributeHandle == mObjectClass->GetDOSourceMemberConnectionTypeAttributeHandle())
    {
      mDOSourceMemberConnectionType.decode(attributeHandleValue.second);
      mLastUpdated |= kDOSourceMemberConnectionTypeBit;
    }
    else if (attributeHandle == mObjectClass->GetDOSourceMemberDataBytesAttributeHandle())
    {
      mDOSourceMemberDataBytes.decode(attributeHandleValue.second);
      mLastUpdated |= kDOSourceMemberDataBytesBit;
    }
  } // for (auto& attributeHandleValue : attributes)
    ExecuteUpdateCallbacks();
} // DOMemberSource::ReflectAttributeValues

void DOMemberSource::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  if ((mLastUpdated & kDOSourceMemberNameBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetDOSourceMemberNameAttributeHandle());
  }
  if ((mLastUpdated & kDOSourceMemberConnectionTypeBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetDOSourceMemberConnectionTypeAttributeHandle());
  }
  if ((mLastUpdated & kDOSourceMemberDataBytesBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetDOSourceMemberDataBytesAttributeHandle());
  }
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void DOMemberSource::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetDOSourceMemberNameAttributeHandle());
  requestAttributes.insert(mObjectClass->GetDOSourceMemberConnectionTypeAttributeHandle());
  requestAttributes.insert(mObjectClass->GetDOSourceMemberDataBytesAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void DOMemberSource::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  for (auto& attributeHandle : attributeHandles)
  {
    if (attributeHandle == mObjectClass->GetDOSourceMemberNameAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mDOSourceMemberName.encode()));
      mDirty &= ~kDOSourceMemberNameBit;
    }
    else if (attributeHandle == mObjectClass->GetDOSourceMemberConnectionTypeAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mDOSourceMemberConnectionType.encode()));
      mDirty &= ~kDOSourceMemberConnectionTypeBit;
    }
    else if (attributeHandle == mObjectClass->GetDOSourceMemberDataBytesAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mDOSourceMemberDataBytes.encode()));
      mDirty &= ~kDOSourceMemberDataBytesBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // DOMemberSource::ReflectAttributeValues

uint32_t DOMemberSource::RegisterUpdateCallback(UpdateCallbackType callback)
{
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void DOMemberSource::UnregisterUpdateCallback(uint32_t callbackToken)
{
  mUpdateCallbacks.erase(callbackToken);
}

void DOMemberSource::ExecuteUpdateCallbacks()
{
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(this);
  }
}

// object class type 'DOMemberTarget'
DOMemberTargetObjectClass::DOMemberTargetObjectClass(rti1516ev::RTIambassador* rtiAmbassador, HLAobjectRootObjectClass* baseClass)
{
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.DOMemberTarget");
  // attribute DOTargetMemberName : HLAASCIIstring
  mDOTargetMemberNameAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"DOTargetMemberName");
  // attribute DOTargetMemberConnectionType : HLAASCIIstring
  mDOTargetMemberConnectionTypeAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"DOTargetMemberConnectionType");
}

void DOMemberTargetObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void DOMemberTargetObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void DOMemberTargetObjectClass::Subscribe()
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void DOMemberTargetObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

void DOMemberTargetObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle, const std::wstring& instanceName)
{
  assert(mObjectInstancesByName.find(instanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(instanceHandle) == mObjectInstancesByHandle.end());
  DOMemberTarget* newObject = new DOMemberTarget(this, instanceName, mRtiAmbassador);
  newObject->mObjectInstanceHandle = instanceHandle;
  newObject->mIsOwner = false;
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
}

void DOMemberTargetObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject)
{
  std::wstring instanceName = mRtiAmbassador->getObjectInstanceName(theObject);
  auto iter = mObjectInstancesByName.find(instanceName);
  assert(iter != mObjectInstancesByName.end());
  auto* objectInstance = iter->second;
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  mObjectInstancesByName.erase(iter);
  mObjectInstancesByHandle.erase(theObject);
}

IDOMemberTarget* DOMemberTargetObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IDOMemberTarget* DOMemberTargetObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IDOMemberTarget* DOMemberTargetObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"DOMemberTarget");
  }
  DOMemberTarget* newObject = new DOMemberTarget(this, instanceName, mRtiAmbassador);
  ObjectClassRegistry::GetInstance()->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
    }
  });
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  return newObject;
}

rti1516ev::AttributeHandleSet DOMemberTargetObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetDOTargetMemberNameAttributeHandle());
  result.insert(GetDOTargetMemberConnectionTypeAttributeHandle());
  return result;
}

uint32_t DOMemberTargetObjectClass::RegisterDiscoverCallback(DiscoverCallbackType callback)
{
  mLastCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void DOMemberTargetObjectClass::UnregisterDiscoverCallback(uint32_t callbackToken)
{
  mDiscoverCallbacks.erase(callbackToken);
}

void DOMemberTargetObjectClass::ExecuteDiscoverCallbacks(IDOMemberTarget* newObjectInstance)
{
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

// object instances of type 'DOMemberTarget'
DOMemberTarget::DOMemberTarget()
{
}

DOMemberTarget::DOMemberTarget(DOMemberTargetObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mObjectClass(objectClass)
  , mInstanceName(instanceName)
  , mRtiAmbassador(rtiAmbassador)
{
}

DOMemberTarget::~DOMemberTarget()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

// attribute DOMemberTarget.HLAprivilegeToDeleteObject : no data type

// attribute DOTargetMemberName : HLAASCIIstring
std::string DOMemberTarget::GetDOTargetMemberName() const
{
  return mDOTargetMemberName.get();
}

void DOMemberTarget::SetDOTargetMemberName(const std::string& newValue)
{
  // CanTranslateToCpp=True
  mDOTargetMemberName.set(newValue);
  mDirty |= kDOTargetMemberNameBit;
}

// attribute DOTargetMemberConnectionType : HLAASCIIstring
std::string DOMemberTarget::GetDOTargetMemberConnectionType() const
{
  return mDOTargetMemberConnectionType.get();
}

void DOMemberTarget::SetDOTargetMemberConnectionType(const std::string& newValue)
{
  // CanTranslateToCpp=True
  mDOTargetMemberConnectionType.set(newValue);
  mDirty |= kDOTargetMemberConnectionTypeBit;
}

rti1516ev::AttributeHandleValueMap DOMemberTarget::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetDOTargetMemberNameAttributeHandle()] = mDOTargetMemberName.encode();
  result[mObjectClass->GetDOTargetMemberConnectionTypeAttributeHandle()] = mDOTargetMemberConnectionType.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap DOMemberTarget::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kDOTargetMemberNameBit)
  {
    result[mObjectClass->GetDOTargetMemberNameAttributeHandle()] = mDOTargetMemberName.encode();
  }
  if (mDirty & kDOTargetMemberConnectionTypeBit)
  {
    result[mObjectClass->GetDOTargetMemberConnectionTypeAttributeHandle()] = mDOTargetMemberConnectionType.encode();
  }
  return result;
}

void DOMemberTarget::UpdateAllAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
  }
}

void DOMemberTarget::UpdateAllAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
  }
}

void DOMemberTarget::UpdateModifiedAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
    mDirty = kNone;
  }
}

void DOMemberTarget::UpdateModifiedAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
    mDirty = kNone;
  }
}

void DOMemberTarget::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetDOTargetMemberNameAttributeHandle())
    {
      mDOTargetMemberName.decode(attributeHandleValue.second);
      mLastUpdated |= kDOTargetMemberNameBit;
    }
    else if (attributeHandle == mObjectClass->GetDOTargetMemberConnectionTypeAttributeHandle())
    {
      mDOTargetMemberConnectionType.decode(attributeHandleValue.second);
      mLastUpdated |= kDOTargetMemberConnectionTypeBit;
    }
  } // for (auto& attributeHandleValue : attributes)
    ExecuteUpdateCallbacks();
} // DOMemberTarget::ReflectAttributeValues

void DOMemberTarget::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  if ((mLastUpdated & kDOTargetMemberNameBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetDOTargetMemberNameAttributeHandle());
  }
  if ((mLastUpdated & kDOTargetMemberConnectionTypeBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetDOTargetMemberConnectionTypeAttributeHandle());
  }
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void DOMemberTarget::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetDOTargetMemberNameAttributeHandle());
  requestAttributes.insert(mObjectClass->GetDOTargetMemberConnectionTypeAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void DOMemberTarget::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  for (auto& attributeHandle : attributeHandles)
  {
    if (attributeHandle == mObjectClass->GetDOTargetMemberNameAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mDOTargetMemberName.encode()));
      mDirty &= ~kDOTargetMemberNameBit;
    }
    else if (attributeHandle == mObjectClass->GetDOTargetMemberConnectionTypeAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mDOTargetMemberConnectionType.encode()));
      mDirty &= ~kDOTargetMemberConnectionTypeBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // DOMemberTarget::ReflectAttributeValues

uint32_t DOMemberTarget::RegisterUpdateCallback(UpdateCallbackType callback)
{
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void DOMemberTarget::UnregisterUpdateCallback(uint32_t callbackToken)
{
  mUpdateCallbacks.erase(callbackToken);
}

void DOMemberTarget::ExecuteUpdateCallbacks()
{
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(this);
  }
}

// object class type 'BusManagement'
BusManagementObjectClass::BusManagementObjectClass(rti1516ev::RTIambassador* rtiAmbassador, HLAobjectRootObjectClass* baseClass)
{
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.BusManagement");
  // attribute NetworkID : HLAASCIIstring
  mNetworkIDAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"NetworkID");
}

void BusManagementObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void BusManagementObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void BusManagementObjectClass::Subscribe()
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void BusManagementObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

void BusManagementObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle, const std::wstring& instanceName)
{
  assert(mObjectInstancesByName.find(instanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(instanceHandle) == mObjectInstancesByHandle.end());
  BusManagement* newObject = new BusManagement(this, instanceName, mRtiAmbassador);
  newObject->mObjectInstanceHandle = instanceHandle;
  newObject->mIsOwner = false;
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
}

void BusManagementObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject)
{
  std::wstring instanceName = mRtiAmbassador->getObjectInstanceName(theObject);
  auto iter = mObjectInstancesByName.find(instanceName);
  assert(iter != mObjectInstancesByName.end());
  auto* objectInstance = iter->second;
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  mObjectInstancesByName.erase(iter);
  mObjectInstancesByHandle.erase(theObject);
}

IBusManagement* BusManagementObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IBusManagement* BusManagementObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IBusManagement* BusManagementObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"BusManagement");
  }
  BusManagement* newObject = new BusManagement(this, instanceName, mRtiAmbassador);
  ObjectClassRegistry::GetInstance()->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
    }
  });
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  return newObject;
}

rti1516ev::AttributeHandleSet BusManagementObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetNetworkIDAttributeHandle());
  return result;
}

uint32_t BusManagementObjectClass::RegisterDiscoverCallback(DiscoverCallbackType callback)
{
  mLastCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void BusManagementObjectClass::UnregisterDiscoverCallback(uint32_t callbackToken)
{
  mDiscoverCallbacks.erase(callbackToken);
}

void BusManagementObjectClass::ExecuteDiscoverCallbacks(IBusManagement* newObjectInstance)
{
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

// object instances of type 'BusManagement'
BusManagement::BusManagement()
{
}

BusManagement::BusManagement(BusManagementObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mObjectClass(objectClass)
  , mInstanceName(instanceName)
  , mRtiAmbassador(rtiAmbassador)
{
}

BusManagement::~BusManagement()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

// attribute BusManagement.HLAprivilegeToDeleteObject : no data type

// attribute NetworkID : HLAASCIIstring
std::string BusManagement::GetNetworkID() const
{
  return mNetworkID.get();
}

void BusManagement::SetNetworkID(const std::string& newValue)
{
  // CanTranslateToCpp=True
  mNetworkID.set(newValue);
  mDirty |= kNetworkIDBit;
}

rti1516ev::AttributeHandleValueMap BusManagement::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap BusManagement::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kNetworkIDBit)
  {
    result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  }
  return result;
}

void BusManagement::UpdateAllAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
  }
}

void BusManagement::UpdateAllAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
  }
}

void BusManagement::UpdateModifiedAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
    mDirty = kNone;
  }
}

void BusManagement::UpdateModifiedAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
    mDirty = kNone;
  }
}

void BusManagement::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle())
    {
      mNetworkID.decode(attributeHandleValue.second);
      mLastUpdated |= kNetworkIDBit;
    }
  } // for (auto& attributeHandleValue : attributes)
} // BusManagement::ReflectAttributeValues

void BusManagement::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  if ((mLastUpdated & kNetworkIDBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetNetworkIDAttributeHandle());
  }
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void BusManagement::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetNetworkIDAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void BusManagement::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  for (auto& attributeHandle : attributeHandles)
  {
    if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mNetworkID.encode()));
      mDirty &= ~kNetworkIDBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // BusManagement::ReflectAttributeValues


// object class type 'BusManagementCan'
BusManagementCanObjectClass::BusManagementCanObjectClass(rti1516ev::RTIambassador* rtiAmbassador, BusManagementObjectClass* baseClass)
{
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.BusManagement.BusManagementCan");
  // attribute BusState : CanBusState
  mBusStateAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"BusState");
  // attribute TxErrorCount : HLAinteger32LE
  mTxErrorCountAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"TxErrorCount");
  // attribute RxErrorCount : HLAinteger32LE
  mRxErrorCountAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"RxErrorCount");
  // attribute SendMessagesAsRx : HLAboolean
  mSendMessagesAsRxAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"SendMessagesAsRx");
}

void BusManagementCanObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void BusManagementCanObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void BusManagementCanObjectClass::Subscribe()
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void BusManagementCanObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

void BusManagementCanObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle, const std::wstring& instanceName)
{
  assert(mObjectInstancesByName.find(instanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(instanceHandle) == mObjectInstancesByHandle.end());
  BusManagementCan* newObject = new BusManagementCan(this, instanceName, mRtiAmbassador);
  newObject->mObjectInstanceHandle = instanceHandle;
  newObject->mIsOwner = false;
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
}

void BusManagementCanObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject)
{
  std::wstring instanceName = mRtiAmbassador->getObjectInstanceName(theObject);
  auto iter = mObjectInstancesByName.find(instanceName);
  assert(iter != mObjectInstancesByName.end());
  auto* objectInstance = iter->second;
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  mObjectInstancesByName.erase(iter);
  mObjectInstancesByHandle.erase(theObject);
}

IBusManagementCan* BusManagementCanObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IBusManagementCan* BusManagementCanObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IBusManagementCan* BusManagementCanObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"BusManagementCan");
  }
  BusManagementCan* newObject = new BusManagementCan(this, instanceName, mRtiAmbassador);
  ObjectClassRegistry::GetInstance()->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
    }
  });
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  return newObject;
}

rti1516ev::AttributeHandleSet BusManagementCanObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetNetworkIDAttributeHandle());
  result.insert(GetBusStateAttributeHandle());
  result.insert(GetTxErrorCountAttributeHandle());
  result.insert(GetRxErrorCountAttributeHandle());
  result.insert(GetSendMessagesAsRxAttributeHandle());
  return result;
}

uint32_t BusManagementCanObjectClass::RegisterDiscoverCallback(DiscoverCallbackType callback)
{
  mLastCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void BusManagementCanObjectClass::UnregisterDiscoverCallback(uint32_t callbackToken)
{
  mDiscoverCallbacks.erase(callbackToken);
}

void BusManagementCanObjectClass::ExecuteDiscoverCallbacks(IBusManagementCan* newObjectInstance)
{
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

// object instances of type 'BusManagementCan'
BusManagementCan::BusManagementCan()
{
}

BusManagementCan::BusManagementCan(BusManagementCanObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mObjectClass(objectClass)
  , mInstanceName(instanceName)
  , mRtiAmbassador(rtiAmbassador)
{
}

BusManagementCan::~BusManagementCan()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

// attribute BusManagementCan.HLAprivilegeToDeleteObject : no data type

// attribute NetworkID : HLAASCIIstring
std::string BusManagementCan::GetNetworkID() const
{
  return mNetworkID.get();
}

void BusManagementCan::SetNetworkID(const std::string& newValue)
{
  // CanTranslateToCpp=True
  mNetworkID.set(newValue);
  mDirty |= kNetworkIDBit;
}

// attribute BusState : CanBusState
CanBusState BusManagementCan::GetBusState() const
{
  return static_cast<CanBusState>(mBusState.get());
}

void BusManagementCan::SetBusState(CanBusState newValue)
{
  // CanTranslateToCpp=True
  mBusState.set(static_cast<int32_t>(newValue));
  mDirty |= kBusStateBit;
}

// attribute TxErrorCount : HLAinteger32LE
int32_t BusManagementCan::GetTxErrorCount() const
{
  return mTxErrorCount.get();
}

void BusManagementCan::SetTxErrorCount(int32_t newValue)
{
  // CanTranslateToCpp=True
  mTxErrorCount.set(newValue);
  mDirty |= kTxErrorCountBit;
}

// attribute RxErrorCount : HLAinteger32LE
int32_t BusManagementCan::GetRxErrorCount() const
{
  return mRxErrorCount.get();
}

void BusManagementCan::SetRxErrorCount(int32_t newValue)
{
  // CanTranslateToCpp=True
  mRxErrorCount.set(newValue);
  mDirty |= kRxErrorCountBit;
}

// attribute SendMessagesAsRx : HLAboolean
bool BusManagementCan::GetSendMessagesAsRx() const
{
  return mSendMessagesAsRx.get();
}

void BusManagementCan::SetSendMessagesAsRx(bool newValue)
{
  // CanTranslateToCpp=True
  mSendMessagesAsRx.set(newValue);
  mDirty |= kSendMessagesAsRxBit;
}

rti1516ev::AttributeHandleValueMap BusManagementCan::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  result[mObjectClass->GetBusStateAttributeHandle()] = mBusState.encode();
  result[mObjectClass->GetTxErrorCountAttributeHandle()] = mTxErrorCount.encode();
  result[mObjectClass->GetRxErrorCountAttributeHandle()] = mRxErrorCount.encode();
  result[mObjectClass->GetSendMessagesAsRxAttributeHandle()] = mSendMessagesAsRx.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap BusManagementCan::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kBusStateBit)
  {
    result[mObjectClass->GetBusStateAttributeHandle()] = mBusState.encode();
  }
  if (mDirty & kTxErrorCountBit)
  {
    result[mObjectClass->GetTxErrorCountAttributeHandle()] = mTxErrorCount.encode();
  }
  if (mDirty & kRxErrorCountBit)
  {
    result[mObjectClass->GetRxErrorCountAttributeHandle()] = mRxErrorCount.encode();
  }
  if (mDirty & kSendMessagesAsRxBit)
  {
    result[mObjectClass->GetSendMessagesAsRxAttributeHandle()] = mSendMessagesAsRx.encode();
  }
  return result;
}

void BusManagementCan::UpdateAllAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
  }
}

void BusManagementCan::UpdateAllAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
  }
}

void BusManagementCan::UpdateModifiedAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
    mDirty = kNone;
  }
}

void BusManagementCan::UpdateModifiedAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
    mDirty = kNone;
  }
}

void BusManagementCan::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetBusStateAttributeHandle())
    {
      mBusState.decode(attributeHandleValue.second);
      mLastUpdated |= kBusStateBit;
    }
    else if (attributeHandle == mObjectClass->GetTxErrorCountAttributeHandle())
    {
      mTxErrorCount.decode(attributeHandleValue.second);
      mLastUpdated |= kTxErrorCountBit;
    }
    else if (attributeHandle == mObjectClass->GetRxErrorCountAttributeHandle())
    {
      mRxErrorCount.decode(attributeHandleValue.second);
      mLastUpdated |= kRxErrorCountBit;
    }
    else if (attributeHandle == mObjectClass->GetSendMessagesAsRxAttributeHandle())
    {
      mSendMessagesAsRx.decode(attributeHandleValue.second);
      mLastUpdated |= kSendMessagesAsRxBit;
    }
  } // for (auto& attributeHandleValue : attributes)
    ExecuteUpdateCallbacks();
} // BusManagementCan::ReflectAttributeValues

void BusManagementCan::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  if ((mLastUpdated & kBusStateBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetBusStateAttributeHandle());
  }
  if ((mLastUpdated & kTxErrorCountBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetTxErrorCountAttributeHandle());
  }
  if ((mLastUpdated & kRxErrorCountBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetRxErrorCountAttributeHandle());
  }
  if ((mLastUpdated & kSendMessagesAsRxBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetSendMessagesAsRxAttributeHandle());
  }
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void BusManagementCan::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetBusStateAttributeHandle());
  requestAttributes.insert(mObjectClass->GetTxErrorCountAttributeHandle());
  requestAttributes.insert(mObjectClass->GetRxErrorCountAttributeHandle());
  requestAttributes.insert(mObjectClass->GetSendMessagesAsRxAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void BusManagementCan::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  for (auto& attributeHandle : attributeHandles)
  {
    if (attributeHandle == mObjectClass->GetBusStateAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mBusState.encode()));
      mDirty &= ~kBusStateBit;
    }
    else if (attributeHandle == mObjectClass->GetTxErrorCountAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mTxErrorCount.encode()));
      mDirty &= ~kTxErrorCountBit;
    }
    else if (attributeHandle == mObjectClass->GetRxErrorCountAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mRxErrorCount.encode()));
      mDirty &= ~kRxErrorCountBit;
    }
    else if (attributeHandle == mObjectClass->GetSendMessagesAsRxAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mSendMessagesAsRx.encode()));
      mDirty &= ~kSendMessagesAsRxBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // BusManagementCan::ReflectAttributeValues

uint32_t BusManagementCan::RegisterUpdateCallback(UpdateCallbackType callback)
{
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void BusManagementCan::UnregisterUpdateCallback(uint32_t callbackToken)
{
  mUpdateCallbacks.erase(callbackToken);
}

void BusManagementCan::ExecuteUpdateCallbacks()
{
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(this);
  }
}

// object class type 'BusManagementEthernet'
BusManagementEthernetObjectClass::BusManagementEthernetObjectClass(rti1516ev::RTIambassador* rtiAmbassador, BusManagementObjectClass* baseClass)
{
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.BusManagement.BusManagementEthernet");
  // attribute PortName : HLAASCIIstring
  mPortNameAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"PortName");
  // attribute SendMessagesAsRx : HLAboolean
  mSendMessagesAsRxAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"SendMessagesAsRx");
}

void BusManagementEthernetObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void BusManagementEthernetObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void BusManagementEthernetObjectClass::Subscribe()
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void BusManagementEthernetObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

void BusManagementEthernetObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle, const std::wstring& instanceName)
{
  assert(mObjectInstancesByName.find(instanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(instanceHandle) == mObjectInstancesByHandle.end());
  BusManagementEthernet* newObject = new BusManagementEthernet(this, instanceName, mRtiAmbassador);
  newObject->mObjectInstanceHandle = instanceHandle;
  newObject->mIsOwner = false;
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
}

void BusManagementEthernetObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject)
{
  std::wstring instanceName = mRtiAmbassador->getObjectInstanceName(theObject);
  auto iter = mObjectInstancesByName.find(instanceName);
  assert(iter != mObjectInstancesByName.end());
  auto* objectInstance = iter->second;
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  mObjectInstancesByName.erase(iter);
  mObjectInstancesByHandle.erase(theObject);
}

IBusManagementEthernet* BusManagementEthernetObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IBusManagementEthernet* BusManagementEthernetObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IBusManagementEthernet* BusManagementEthernetObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"BusManagementEthernet");
  }
  BusManagementEthernet* newObject = new BusManagementEthernet(this, instanceName, mRtiAmbassador);
  ObjectClassRegistry::GetInstance()->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
    }
  });
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  return newObject;
}

rti1516ev::AttributeHandleSet BusManagementEthernetObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetNetworkIDAttributeHandle());
  result.insert(GetPortNameAttributeHandle());
  result.insert(GetSendMessagesAsRxAttributeHandle());
  return result;
}

uint32_t BusManagementEthernetObjectClass::RegisterDiscoverCallback(DiscoverCallbackType callback)
{
  mLastCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void BusManagementEthernetObjectClass::UnregisterDiscoverCallback(uint32_t callbackToken)
{
  mDiscoverCallbacks.erase(callbackToken);
}

void BusManagementEthernetObjectClass::ExecuteDiscoverCallbacks(IBusManagementEthernet* newObjectInstance)
{
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

// object instances of type 'BusManagementEthernet'
BusManagementEthernet::BusManagementEthernet()
{
}

BusManagementEthernet::BusManagementEthernet(BusManagementEthernetObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mObjectClass(objectClass)
  , mInstanceName(instanceName)
  , mRtiAmbassador(rtiAmbassador)
{
}

BusManagementEthernet::~BusManagementEthernet()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

// attribute BusManagementEthernet.HLAprivilegeToDeleteObject : no data type

// attribute NetworkID : HLAASCIIstring
std::string BusManagementEthernet::GetNetworkID() const
{
  return mNetworkID.get();
}

void BusManagementEthernet::SetNetworkID(const std::string& newValue)
{
  // CanTranslateToCpp=True
  mNetworkID.set(newValue);
  mDirty |= kNetworkIDBit;
}

// attribute PortName : HLAASCIIstring
std::string BusManagementEthernet::GetPortName() const
{
  return mPortName.get();
}

void BusManagementEthernet::SetPortName(const std::string& newValue)
{
  // CanTranslateToCpp=True
  mPortName.set(newValue);
  mDirty |= kPortNameBit;
}

// attribute SendMessagesAsRx : HLAboolean
bool BusManagementEthernet::GetSendMessagesAsRx() const
{
  return mSendMessagesAsRx.get();
}

void BusManagementEthernet::SetSendMessagesAsRx(bool newValue)
{
  // CanTranslateToCpp=True
  mSendMessagesAsRx.set(newValue);
  mDirty |= kSendMessagesAsRxBit;
}

rti1516ev::AttributeHandleValueMap BusManagementEthernet::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  result[mObjectClass->GetPortNameAttributeHandle()] = mPortName.encode();
  result[mObjectClass->GetSendMessagesAsRxAttributeHandle()] = mSendMessagesAsRx.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap BusManagementEthernet::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kPortNameBit)
  {
    result[mObjectClass->GetPortNameAttributeHandle()] = mPortName.encode();
  }
  if (mDirty & kSendMessagesAsRxBit)
  {
    result[mObjectClass->GetSendMessagesAsRxAttributeHandle()] = mSendMessagesAsRx.encode();
  }
  return result;
}

void BusManagementEthernet::UpdateAllAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
  }
}

void BusManagementEthernet::UpdateAllAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
  }
}

void BusManagementEthernet::UpdateModifiedAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
    mDirty = kNone;
  }
}

void BusManagementEthernet::UpdateModifiedAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
    mDirty = kNone;
  }
}

void BusManagementEthernet::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetPortNameAttributeHandle())
    {
      mPortName.decode(attributeHandleValue.second);
      mLastUpdated |= kPortNameBit;
    }
    else if (attributeHandle == mObjectClass->GetSendMessagesAsRxAttributeHandle())
    {
      mSendMessagesAsRx.decode(attributeHandleValue.second);
      mLastUpdated |= kSendMessagesAsRxBit;
    }
  } // for (auto& attributeHandleValue : attributes)
    ExecuteUpdateCallbacks();
} // BusManagementEthernet::ReflectAttributeValues

void BusManagementEthernet::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  if ((mLastUpdated & kPortNameBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetPortNameAttributeHandle());
  }
  if ((mLastUpdated & kSendMessagesAsRxBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetSendMessagesAsRxAttributeHandle());
  }
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void BusManagementEthernet::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetPortNameAttributeHandle());
  requestAttributes.insert(mObjectClass->GetSendMessagesAsRxAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void BusManagementEthernet::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  for (auto& attributeHandle : attributeHandles)
  {
    if (attributeHandle == mObjectClass->GetPortNameAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mPortName.encode()));
      mDirty &= ~kPortNameBit;
    }
    else if (attributeHandle == mObjectClass->GetSendMessagesAsRxAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mSendMessagesAsRx.encode()));
      mDirty &= ~kSendMessagesAsRxBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // BusManagementEthernet::ReflectAttributeValues

uint32_t BusManagementEthernet::RegisterUpdateCallback(UpdateCallbackType callback)
{
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void BusManagementEthernet::UnregisterUpdateCallback(uint32_t callbackToken)
{
  mUpdateCallbacks.erase(callbackToken);
}

void BusManagementEthernet::ExecuteUpdateCallbacks()
{
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(this);
  }
}

// object class type 'FlexRayCluster'
FlexRayClusterObjectClass::FlexRayClusterObjectClass(rti1516ev::RTIambassador* rtiAmbassador, BusManagementObjectClass* baseClass)
{
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.BusManagement.FlexRayCluster");
  // attribute gColdstartAttempts : HLAoctet
  mgColdstartAttemptsAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gColdstartAttempts");
  // attribute gCycleCountMax : HLAoctet
  mgCycleCountMaxAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gCycleCountMax");
  // attribute gdActionPointOffset : HLAinteger32LE
  mgdActionPointOffsetAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gdActionPointOffset");
  // attribute gdDynamicSlotIdlePhase : HLAinteger32LE
  mgdDynamicSlotIdlePhaseAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gdDynamicSlotIdlePhase");
  // attribute gdMiniSlot : HLAinteger32LE
  mgdMiniSlotAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gdMiniSlot");
  // attribute gdMiniSlotActionPointOffset : HLAinteger32LE
  mgdMiniSlotActionPointOffsetAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gdMiniSlotActionPointOffset");
  // attribute gdStaticSlot : HLAinteger32LE
  mgdStaticSlotAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gdStaticSlot");
  // attribute gdSymbolWindow : HLAinteger32LE
  mgdSymbolWindowAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gdSymbolWindow");
  // attribute gdSymbolWindowActionPointOffset : HLAinteger32LE
  mgdSymbolWindowActionPointOffsetAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gdSymbolWindowActionPointOffset");
  // attribute gdTSSTransmitter : HLAinteger32LE
  mgdTSSTransmitterAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gdTSSTransmitter");
  // attribute gdWakeupTxActive : HLAinteger32LE
  mgdWakeupTxActiveAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gdWakeupTxActive");
  // attribute gdWakeupTxIdle : HLAinteger32LE
  mgdWakeupTxIdleAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gdWakeupTxIdle");
  // attribute gListenNoise : HLAoctet
  mgListenNoiseAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gListenNoise");
  // attribute gMacroPerCycle : HLAinteger32LE
  mgMacroPerCycleAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gMacroPerCycle");
  // attribute gMaxWithoutClockCorrectionFatal : HLAoctet
  mgMaxWithoutClockCorrectionFatalAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gMaxWithoutClockCorrectionFatal");
  // attribute gMaxWithoutClockCorrectionPassive : HLAoctet
  mgMaxWithoutClockCorrectionPassiveAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gMaxWithoutClockCorrectionPassive");
  // attribute gNumberOfMiniSlots : HLAinteger32LE
  mgNumberOfMiniSlotsAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gNumberOfMiniSlots");
  // attribute gNumberOfStaticSlots : HLAinteger32LE
  mgNumberOfStaticSlotsAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gNumberOfStaticSlots");
  // attribute gPayloadLengthStatic : HLAinteger32LE
  mgPayloadLengthStaticAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gPayloadLengthStatic");
  // attribute gSyncFrameIDCountMax : HLAoctet
  mgSyncFrameIDCountMaxAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gSyncFrameIDCountMax");
}

void FlexRayClusterObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void FlexRayClusterObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void FlexRayClusterObjectClass::Subscribe()
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void FlexRayClusterObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

void FlexRayClusterObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle, const std::wstring& instanceName)
{
  assert(mObjectInstancesByName.find(instanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(instanceHandle) == mObjectInstancesByHandle.end());
  FlexRayCluster* newObject = new FlexRayCluster(this, instanceName, mRtiAmbassador);
  newObject->mObjectInstanceHandle = instanceHandle;
  newObject->mIsOwner = false;
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
}

void FlexRayClusterObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject)
{
  std::wstring instanceName = mRtiAmbassador->getObjectInstanceName(theObject);
  auto iter = mObjectInstancesByName.find(instanceName);
  assert(iter != mObjectInstancesByName.end());
  auto* objectInstance = iter->second;
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  mObjectInstancesByName.erase(iter);
  mObjectInstancesByHandle.erase(theObject);
}

IFlexRayCluster* FlexRayClusterObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IFlexRayCluster* FlexRayClusterObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IFlexRayCluster* FlexRayClusterObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"FlexRayCluster");
  }
  FlexRayCluster* newObject = new FlexRayCluster(this, instanceName, mRtiAmbassador);
  ObjectClassRegistry::GetInstance()->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
    }
  });
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  return newObject;
}

rti1516ev::AttributeHandleSet FlexRayClusterObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetNetworkIDAttributeHandle());
  result.insert(GetgColdstartAttemptsAttributeHandle());
  result.insert(GetgCycleCountMaxAttributeHandle());
  result.insert(GetgdActionPointOffsetAttributeHandle());
  result.insert(GetgdDynamicSlotIdlePhaseAttributeHandle());
  result.insert(GetgdMiniSlotAttributeHandle());
  result.insert(GetgdMiniSlotActionPointOffsetAttributeHandle());
  result.insert(GetgdStaticSlotAttributeHandle());
  result.insert(GetgdSymbolWindowAttributeHandle());
  result.insert(GetgdSymbolWindowActionPointOffsetAttributeHandle());
  result.insert(GetgdTSSTransmitterAttributeHandle());
  result.insert(GetgdWakeupTxActiveAttributeHandle());
  result.insert(GetgdWakeupTxIdleAttributeHandle());
  result.insert(GetgListenNoiseAttributeHandle());
  result.insert(GetgMacroPerCycleAttributeHandle());
  result.insert(GetgMaxWithoutClockCorrectionFatalAttributeHandle());
  result.insert(GetgMaxWithoutClockCorrectionPassiveAttributeHandle());
  result.insert(GetgNumberOfMiniSlotsAttributeHandle());
  result.insert(GetgNumberOfStaticSlotsAttributeHandle());
  result.insert(GetgPayloadLengthStaticAttributeHandle());
  result.insert(GetgSyncFrameIDCountMaxAttributeHandle());
  return result;
}

uint32_t FlexRayClusterObjectClass::RegisterDiscoverCallback(DiscoverCallbackType callback)
{
  mLastCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void FlexRayClusterObjectClass::UnregisterDiscoverCallback(uint32_t callbackToken)
{
  mDiscoverCallbacks.erase(callbackToken);
}

void FlexRayClusterObjectClass::ExecuteDiscoverCallbacks(IFlexRayCluster* newObjectInstance)
{
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

// object instances of type 'FlexRayCluster'
FlexRayCluster::FlexRayCluster()
{
}

FlexRayCluster::FlexRayCluster(FlexRayClusterObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mObjectClass(objectClass)
  , mInstanceName(instanceName)
  , mRtiAmbassador(rtiAmbassador)
{
}

FlexRayCluster::~FlexRayCluster()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

// attribute FlexRayCluster.HLAprivilegeToDeleteObject : no data type

// attribute NetworkID : HLAASCIIstring
std::string FlexRayCluster::GetNetworkID() const
{
  return mNetworkID.get();
}

void FlexRayCluster::SetNetworkID(const std::string& newValue)
{
  // CanTranslateToCpp=True
  mNetworkID.set(newValue);
  mDirty |= kNetworkIDBit;
}

// attribute gColdstartAttempts : HLAoctet
uint8_t FlexRayCluster::GetgColdstartAttempts() const
{
  return mgColdstartAttempts.get();
}

void FlexRayCluster::SetgColdstartAttempts(uint8_t newValue)
{
  // CanTranslateToCpp=True
  mgColdstartAttempts.set(newValue);
  mDirty |= kgColdstartAttemptsBit;
}

// attribute gCycleCountMax : HLAoctet
uint8_t FlexRayCluster::GetgCycleCountMax() const
{
  return mgCycleCountMax.get();
}

void FlexRayCluster::SetgCycleCountMax(uint8_t newValue)
{
  // CanTranslateToCpp=True
  mgCycleCountMax.set(newValue);
  mDirty |= kgCycleCountMaxBit;
}

// attribute gdActionPointOffset : HLAinteger32LE
int32_t FlexRayCluster::GetgdActionPointOffset() const
{
  return mgdActionPointOffset.get();
}

void FlexRayCluster::SetgdActionPointOffset(int32_t newValue)
{
  // CanTranslateToCpp=True
  mgdActionPointOffset.set(newValue);
  mDirty |= kgdActionPointOffsetBit;
}

// attribute gdDynamicSlotIdlePhase : HLAinteger32LE
int32_t FlexRayCluster::GetgdDynamicSlotIdlePhase() const
{
  return mgdDynamicSlotIdlePhase.get();
}

void FlexRayCluster::SetgdDynamicSlotIdlePhase(int32_t newValue)
{
  // CanTranslateToCpp=True
  mgdDynamicSlotIdlePhase.set(newValue);
  mDirty |= kgdDynamicSlotIdlePhaseBit;
}

// attribute gdMiniSlot : HLAinteger32LE
int32_t FlexRayCluster::GetgdMiniSlot() const
{
  return mgdMiniSlot.get();
}

void FlexRayCluster::SetgdMiniSlot(int32_t newValue)
{
  // CanTranslateToCpp=True
  mgdMiniSlot.set(newValue);
  mDirty |= kgdMiniSlotBit;
}

// attribute gdMiniSlotActionPointOffset : HLAinteger32LE
int32_t FlexRayCluster::GetgdMiniSlotActionPointOffset() const
{
  return mgdMiniSlotActionPointOffset.get();
}

void FlexRayCluster::SetgdMiniSlotActionPointOffset(int32_t newValue)
{
  // CanTranslateToCpp=True
  mgdMiniSlotActionPointOffset.set(newValue);
  mDirty |= kgdMiniSlotActionPointOffsetBit;
}

// attribute gdStaticSlot : HLAinteger32LE
int32_t FlexRayCluster::GetgdStaticSlot() const
{
  return mgdStaticSlot.get();
}

void FlexRayCluster::SetgdStaticSlot(int32_t newValue)
{
  // CanTranslateToCpp=True
  mgdStaticSlot.set(newValue);
  mDirty |= kgdStaticSlotBit;
}

// attribute gdSymbolWindow : HLAinteger32LE
int32_t FlexRayCluster::GetgdSymbolWindow() const
{
  return mgdSymbolWindow.get();
}

void FlexRayCluster::SetgdSymbolWindow(int32_t newValue)
{
  // CanTranslateToCpp=True
  mgdSymbolWindow.set(newValue);
  mDirty |= kgdSymbolWindowBit;
}

// attribute gdSymbolWindowActionPointOffset : HLAinteger32LE
int32_t FlexRayCluster::GetgdSymbolWindowActionPointOffset() const
{
  return mgdSymbolWindowActionPointOffset.get();
}

void FlexRayCluster::SetgdSymbolWindowActionPointOffset(int32_t newValue)
{
  // CanTranslateToCpp=True
  mgdSymbolWindowActionPointOffset.set(newValue);
  mDirty |= kgdSymbolWindowActionPointOffsetBit;
}

// attribute gdTSSTransmitter : HLAinteger32LE
int32_t FlexRayCluster::GetgdTSSTransmitter() const
{
  return mgdTSSTransmitter.get();
}

void FlexRayCluster::SetgdTSSTransmitter(int32_t newValue)
{
  // CanTranslateToCpp=True
  mgdTSSTransmitter.set(newValue);
  mDirty |= kgdTSSTransmitterBit;
}

// attribute gdWakeupTxActive : HLAinteger32LE
int32_t FlexRayCluster::GetgdWakeupTxActive() const
{
  return mgdWakeupTxActive.get();
}

void FlexRayCluster::SetgdWakeupTxActive(int32_t newValue)
{
  // CanTranslateToCpp=True
  mgdWakeupTxActive.set(newValue);
  mDirty |= kgdWakeupTxActiveBit;
}

// attribute gdWakeupTxIdle : HLAinteger32LE
int32_t FlexRayCluster::GetgdWakeupTxIdle() const
{
  return mgdWakeupTxIdle.get();
}

void FlexRayCluster::SetgdWakeupTxIdle(int32_t newValue)
{
  // CanTranslateToCpp=True
  mgdWakeupTxIdle.set(newValue);
  mDirty |= kgdWakeupTxIdleBit;
}

// attribute gListenNoise : HLAoctet
uint8_t FlexRayCluster::GetgListenNoise() const
{
  return mgListenNoise.get();
}

void FlexRayCluster::SetgListenNoise(uint8_t newValue)
{
  // CanTranslateToCpp=True
  mgListenNoise.set(newValue);
  mDirty |= kgListenNoiseBit;
}

// attribute gMacroPerCycle : HLAinteger32LE
int32_t FlexRayCluster::GetgMacroPerCycle() const
{
  return mgMacroPerCycle.get();
}

void FlexRayCluster::SetgMacroPerCycle(int32_t newValue)
{
  // CanTranslateToCpp=True
  mgMacroPerCycle.set(newValue);
  mDirty |= kgMacroPerCycleBit;
}

// attribute gMaxWithoutClockCorrectionFatal : HLAoctet
uint8_t FlexRayCluster::GetgMaxWithoutClockCorrectionFatal() const
{
  return mgMaxWithoutClockCorrectionFatal.get();
}

void FlexRayCluster::SetgMaxWithoutClockCorrectionFatal(uint8_t newValue)
{
  // CanTranslateToCpp=True
  mgMaxWithoutClockCorrectionFatal.set(newValue);
  mDirty |= kgMaxWithoutClockCorrectionFatalBit;
}

// attribute gMaxWithoutClockCorrectionPassive : HLAoctet
uint8_t FlexRayCluster::GetgMaxWithoutClockCorrectionPassive() const
{
  return mgMaxWithoutClockCorrectionPassive.get();
}

void FlexRayCluster::SetgMaxWithoutClockCorrectionPassive(uint8_t newValue)
{
  // CanTranslateToCpp=True
  mgMaxWithoutClockCorrectionPassive.set(newValue);
  mDirty |= kgMaxWithoutClockCorrectionPassiveBit;
}

// attribute gNumberOfMiniSlots : HLAinteger32LE
int32_t FlexRayCluster::GetgNumberOfMiniSlots() const
{
  return mgNumberOfMiniSlots.get();
}

void FlexRayCluster::SetgNumberOfMiniSlots(int32_t newValue)
{
  // CanTranslateToCpp=True
  mgNumberOfMiniSlots.set(newValue);
  mDirty |= kgNumberOfMiniSlotsBit;
}

// attribute gNumberOfStaticSlots : HLAinteger32LE
int32_t FlexRayCluster::GetgNumberOfStaticSlots() const
{
  return mgNumberOfStaticSlots.get();
}

void FlexRayCluster::SetgNumberOfStaticSlots(int32_t newValue)
{
  // CanTranslateToCpp=True
  mgNumberOfStaticSlots.set(newValue);
  mDirty |= kgNumberOfStaticSlotsBit;
}

// attribute gPayloadLengthStatic : HLAinteger32LE
int32_t FlexRayCluster::GetgPayloadLengthStatic() const
{
  return mgPayloadLengthStatic.get();
}

void FlexRayCluster::SetgPayloadLengthStatic(int32_t newValue)
{
  // CanTranslateToCpp=True
  mgPayloadLengthStatic.set(newValue);
  mDirty |= kgPayloadLengthStaticBit;
}

// attribute gSyncFrameIDCountMax : HLAoctet
uint8_t FlexRayCluster::GetgSyncFrameIDCountMax() const
{
  return mgSyncFrameIDCountMax.get();
}

void FlexRayCluster::SetgSyncFrameIDCountMax(uint8_t newValue)
{
  // CanTranslateToCpp=True
  mgSyncFrameIDCountMax.set(newValue);
  mDirty |= kgSyncFrameIDCountMaxBit;
}

rti1516ev::AttributeHandleValueMap FlexRayCluster::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  result[mObjectClass->GetgColdstartAttemptsAttributeHandle()] = mgColdstartAttempts.encode();
  result[mObjectClass->GetgCycleCountMaxAttributeHandle()] = mgCycleCountMax.encode();
  result[mObjectClass->GetgdActionPointOffsetAttributeHandle()] = mgdActionPointOffset.encode();
  result[mObjectClass->GetgdDynamicSlotIdlePhaseAttributeHandle()] = mgdDynamicSlotIdlePhase.encode();
  result[mObjectClass->GetgdMiniSlotAttributeHandle()] = mgdMiniSlot.encode();
  result[mObjectClass->GetgdMiniSlotActionPointOffsetAttributeHandle()] = mgdMiniSlotActionPointOffset.encode();
  result[mObjectClass->GetgdStaticSlotAttributeHandle()] = mgdStaticSlot.encode();
  result[mObjectClass->GetgdSymbolWindowAttributeHandle()] = mgdSymbolWindow.encode();
  result[mObjectClass->GetgdSymbolWindowActionPointOffsetAttributeHandle()] = mgdSymbolWindowActionPointOffset.encode();
  result[mObjectClass->GetgdTSSTransmitterAttributeHandle()] = mgdTSSTransmitter.encode();
  result[mObjectClass->GetgdWakeupTxActiveAttributeHandle()] = mgdWakeupTxActive.encode();
  result[mObjectClass->GetgdWakeupTxIdleAttributeHandle()] = mgdWakeupTxIdle.encode();
  result[mObjectClass->GetgListenNoiseAttributeHandle()] = mgListenNoise.encode();
  result[mObjectClass->GetgMacroPerCycleAttributeHandle()] = mgMacroPerCycle.encode();
  result[mObjectClass->GetgMaxWithoutClockCorrectionFatalAttributeHandle()] = mgMaxWithoutClockCorrectionFatal.encode();
  result[mObjectClass->GetgMaxWithoutClockCorrectionPassiveAttributeHandle()] = mgMaxWithoutClockCorrectionPassive.encode();
  result[mObjectClass->GetgNumberOfMiniSlotsAttributeHandle()] = mgNumberOfMiniSlots.encode();
  result[mObjectClass->GetgNumberOfStaticSlotsAttributeHandle()] = mgNumberOfStaticSlots.encode();
  result[mObjectClass->GetgPayloadLengthStaticAttributeHandle()] = mgPayloadLengthStatic.encode();
  result[mObjectClass->GetgSyncFrameIDCountMaxAttributeHandle()] = mgSyncFrameIDCountMax.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap FlexRayCluster::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kgColdstartAttemptsBit)
  {
    result[mObjectClass->GetgColdstartAttemptsAttributeHandle()] = mgColdstartAttempts.encode();
  }
  if (mDirty & kgCycleCountMaxBit)
  {
    result[mObjectClass->GetgCycleCountMaxAttributeHandle()] = mgCycleCountMax.encode();
  }
  if (mDirty & kgdActionPointOffsetBit)
  {
    result[mObjectClass->GetgdActionPointOffsetAttributeHandle()] = mgdActionPointOffset.encode();
  }
  if (mDirty & kgdDynamicSlotIdlePhaseBit)
  {
    result[mObjectClass->GetgdDynamicSlotIdlePhaseAttributeHandle()] = mgdDynamicSlotIdlePhase.encode();
  }
  if (mDirty & kgdMiniSlotBit)
  {
    result[mObjectClass->GetgdMiniSlotAttributeHandle()] = mgdMiniSlot.encode();
  }
  if (mDirty & kgdMiniSlotActionPointOffsetBit)
  {
    result[mObjectClass->GetgdMiniSlotActionPointOffsetAttributeHandle()] = mgdMiniSlotActionPointOffset.encode();
  }
  if (mDirty & kgdStaticSlotBit)
  {
    result[mObjectClass->GetgdStaticSlotAttributeHandle()] = mgdStaticSlot.encode();
  }
  if (mDirty & kgdSymbolWindowBit)
  {
    result[mObjectClass->GetgdSymbolWindowAttributeHandle()] = mgdSymbolWindow.encode();
  }
  if (mDirty & kgdSymbolWindowActionPointOffsetBit)
  {
    result[mObjectClass->GetgdSymbolWindowActionPointOffsetAttributeHandle()] = mgdSymbolWindowActionPointOffset.encode();
  }
  if (mDirty & kgdTSSTransmitterBit)
  {
    result[mObjectClass->GetgdTSSTransmitterAttributeHandle()] = mgdTSSTransmitter.encode();
  }
  if (mDirty & kgdWakeupTxActiveBit)
  {
    result[mObjectClass->GetgdWakeupTxActiveAttributeHandle()] = mgdWakeupTxActive.encode();
  }
  if (mDirty & kgdWakeupTxIdleBit)
  {
    result[mObjectClass->GetgdWakeupTxIdleAttributeHandle()] = mgdWakeupTxIdle.encode();
  }
  if (mDirty & kgListenNoiseBit)
  {
    result[mObjectClass->GetgListenNoiseAttributeHandle()] = mgListenNoise.encode();
  }
  if (mDirty & kgMacroPerCycleBit)
  {
    result[mObjectClass->GetgMacroPerCycleAttributeHandle()] = mgMacroPerCycle.encode();
  }
  if (mDirty & kgMaxWithoutClockCorrectionFatalBit)
  {
    result[mObjectClass->GetgMaxWithoutClockCorrectionFatalAttributeHandle()] = mgMaxWithoutClockCorrectionFatal.encode();
  }
  if (mDirty & kgMaxWithoutClockCorrectionPassiveBit)
  {
    result[mObjectClass->GetgMaxWithoutClockCorrectionPassiveAttributeHandle()] = mgMaxWithoutClockCorrectionPassive.encode();
  }
  if (mDirty & kgNumberOfMiniSlotsBit)
  {
    result[mObjectClass->GetgNumberOfMiniSlotsAttributeHandle()] = mgNumberOfMiniSlots.encode();
  }
  if (mDirty & kgNumberOfStaticSlotsBit)
  {
    result[mObjectClass->GetgNumberOfStaticSlotsAttributeHandle()] = mgNumberOfStaticSlots.encode();
  }
  if (mDirty & kgPayloadLengthStaticBit)
  {
    result[mObjectClass->GetgPayloadLengthStaticAttributeHandle()] = mgPayloadLengthStatic.encode();
  }
  if (mDirty & kgSyncFrameIDCountMaxBit)
  {
    result[mObjectClass->GetgSyncFrameIDCountMaxAttributeHandle()] = mgSyncFrameIDCountMax.encode();
  }
  return result;
}

void FlexRayCluster::UpdateAllAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
  }
}

void FlexRayCluster::UpdateAllAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
  }
}

void FlexRayCluster::UpdateModifiedAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
    mDirty = kNone;
  }
}

void FlexRayCluster::UpdateModifiedAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
    mDirty = kNone;
  }
}

void FlexRayCluster::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetgColdstartAttemptsAttributeHandle())
    {
      mgColdstartAttempts.decode(attributeHandleValue.second);
      mLastUpdated |= kgColdstartAttemptsBit;
    }
    else if (attributeHandle == mObjectClass->GetgCycleCountMaxAttributeHandle())
    {
      mgCycleCountMax.decode(attributeHandleValue.second);
      mLastUpdated |= kgCycleCountMaxBit;
    }
    else if (attributeHandle == mObjectClass->GetgdActionPointOffsetAttributeHandle())
    {
      mgdActionPointOffset.decode(attributeHandleValue.second);
      mLastUpdated |= kgdActionPointOffsetBit;
    }
    else if (attributeHandle == mObjectClass->GetgdDynamicSlotIdlePhaseAttributeHandle())
    {
      mgdDynamicSlotIdlePhase.decode(attributeHandleValue.second);
      mLastUpdated |= kgdDynamicSlotIdlePhaseBit;
    }
    else if (attributeHandle == mObjectClass->GetgdMiniSlotAttributeHandle())
    {
      mgdMiniSlot.decode(attributeHandleValue.second);
      mLastUpdated |= kgdMiniSlotBit;
    }
    else if (attributeHandle == mObjectClass->GetgdMiniSlotActionPointOffsetAttributeHandle())
    {
      mgdMiniSlotActionPointOffset.decode(attributeHandleValue.second);
      mLastUpdated |= kgdMiniSlotActionPointOffsetBit;
    }
    else if (attributeHandle == mObjectClass->GetgdStaticSlotAttributeHandle())
    {
      mgdStaticSlot.decode(attributeHandleValue.second);
      mLastUpdated |= kgdStaticSlotBit;
    }
    else if (attributeHandle == mObjectClass->GetgdSymbolWindowAttributeHandle())
    {
      mgdSymbolWindow.decode(attributeHandleValue.second);
      mLastUpdated |= kgdSymbolWindowBit;
    }
    else if (attributeHandle == mObjectClass->GetgdSymbolWindowActionPointOffsetAttributeHandle())
    {
      mgdSymbolWindowActionPointOffset.decode(attributeHandleValue.second);
      mLastUpdated |= kgdSymbolWindowActionPointOffsetBit;
    }
    else if (attributeHandle == mObjectClass->GetgdTSSTransmitterAttributeHandle())
    {
      mgdTSSTransmitter.decode(attributeHandleValue.second);
      mLastUpdated |= kgdTSSTransmitterBit;
    }
    else if (attributeHandle == mObjectClass->GetgdWakeupTxActiveAttributeHandle())
    {
      mgdWakeupTxActive.decode(attributeHandleValue.second);
      mLastUpdated |= kgdWakeupTxActiveBit;
    }
    else if (attributeHandle == mObjectClass->GetgdWakeupTxIdleAttributeHandle())
    {
      mgdWakeupTxIdle.decode(attributeHandleValue.second);
      mLastUpdated |= kgdWakeupTxIdleBit;
    }
    else if (attributeHandle == mObjectClass->GetgListenNoiseAttributeHandle())
    {
      mgListenNoise.decode(attributeHandleValue.second);
      mLastUpdated |= kgListenNoiseBit;
    }
    else if (attributeHandle == mObjectClass->GetgMacroPerCycleAttributeHandle())
    {
      mgMacroPerCycle.decode(attributeHandleValue.second);
      mLastUpdated |= kgMacroPerCycleBit;
    }
    else if (attributeHandle == mObjectClass->GetgMaxWithoutClockCorrectionFatalAttributeHandle())
    {
      mgMaxWithoutClockCorrectionFatal.decode(attributeHandleValue.second);
      mLastUpdated |= kgMaxWithoutClockCorrectionFatalBit;
    }
    else if (attributeHandle == mObjectClass->GetgMaxWithoutClockCorrectionPassiveAttributeHandle())
    {
      mgMaxWithoutClockCorrectionPassive.decode(attributeHandleValue.second);
      mLastUpdated |= kgMaxWithoutClockCorrectionPassiveBit;
    }
    else if (attributeHandle == mObjectClass->GetgNumberOfMiniSlotsAttributeHandle())
    {
      mgNumberOfMiniSlots.decode(attributeHandleValue.second);
      mLastUpdated |= kgNumberOfMiniSlotsBit;
    }
    else if (attributeHandle == mObjectClass->GetgNumberOfStaticSlotsAttributeHandle())
    {
      mgNumberOfStaticSlots.decode(attributeHandleValue.second);
      mLastUpdated |= kgNumberOfStaticSlotsBit;
    }
    else if (attributeHandle == mObjectClass->GetgPayloadLengthStaticAttributeHandle())
    {
      mgPayloadLengthStatic.decode(attributeHandleValue.second);
      mLastUpdated |= kgPayloadLengthStaticBit;
    }
    else if (attributeHandle == mObjectClass->GetgSyncFrameIDCountMaxAttributeHandle())
    {
      mgSyncFrameIDCountMax.decode(attributeHandleValue.second);
      mLastUpdated |= kgSyncFrameIDCountMaxBit;
    }
  } // for (auto& attributeHandleValue : attributes)
    ExecuteUpdateCallbacks();
} // FlexRayCluster::ReflectAttributeValues

void FlexRayCluster::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  if ((mLastUpdated & kgColdstartAttemptsBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetgColdstartAttemptsAttributeHandle());
  }
  if ((mLastUpdated & kgCycleCountMaxBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetgCycleCountMaxAttributeHandle());
  }
  if ((mLastUpdated & kgdActionPointOffsetBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetgdActionPointOffsetAttributeHandle());
  }
  if ((mLastUpdated & kgdDynamicSlotIdlePhaseBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetgdDynamicSlotIdlePhaseAttributeHandle());
  }
  if ((mLastUpdated & kgdMiniSlotBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetgdMiniSlotAttributeHandle());
  }
  if ((mLastUpdated & kgdMiniSlotActionPointOffsetBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetgdMiniSlotActionPointOffsetAttributeHandle());
  }
  if ((mLastUpdated & kgdStaticSlotBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetgdStaticSlotAttributeHandle());
  }
  if ((mLastUpdated & kgdSymbolWindowBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetgdSymbolWindowAttributeHandle());
  }
  if ((mLastUpdated & kgdSymbolWindowActionPointOffsetBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetgdSymbolWindowActionPointOffsetAttributeHandle());
  }
  if ((mLastUpdated & kgdTSSTransmitterBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetgdTSSTransmitterAttributeHandle());
  }
  if ((mLastUpdated & kgdWakeupTxActiveBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetgdWakeupTxActiveAttributeHandle());
  }
  if ((mLastUpdated & kgdWakeupTxIdleBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetgdWakeupTxIdleAttributeHandle());
  }
  if ((mLastUpdated & kgListenNoiseBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetgListenNoiseAttributeHandle());
  }
  if ((mLastUpdated & kgMacroPerCycleBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetgMacroPerCycleAttributeHandle());
  }
  if ((mLastUpdated & kgMaxWithoutClockCorrectionFatalBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetgMaxWithoutClockCorrectionFatalAttributeHandle());
  }
  if ((mLastUpdated & kgMaxWithoutClockCorrectionPassiveBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetgMaxWithoutClockCorrectionPassiveAttributeHandle());
  }
  if ((mLastUpdated & kgNumberOfMiniSlotsBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetgNumberOfMiniSlotsAttributeHandle());
  }
  if ((mLastUpdated & kgNumberOfStaticSlotsBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetgNumberOfStaticSlotsAttributeHandle());
  }
  if ((mLastUpdated & kgPayloadLengthStaticBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetgPayloadLengthStaticAttributeHandle());
  }
  if ((mLastUpdated & kgSyncFrameIDCountMaxBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetgSyncFrameIDCountMaxAttributeHandle());
  }
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void FlexRayCluster::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetgColdstartAttemptsAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgCycleCountMaxAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgdActionPointOffsetAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgdDynamicSlotIdlePhaseAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgdMiniSlotAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgdMiniSlotActionPointOffsetAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgdStaticSlotAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgdSymbolWindowAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgdSymbolWindowActionPointOffsetAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgdTSSTransmitterAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgdWakeupTxActiveAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgdWakeupTxIdleAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgListenNoiseAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgMacroPerCycleAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgMaxWithoutClockCorrectionFatalAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgMaxWithoutClockCorrectionPassiveAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgNumberOfMiniSlotsAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgNumberOfStaticSlotsAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgPayloadLengthStaticAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgSyncFrameIDCountMaxAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void FlexRayCluster::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  for (auto& attributeHandle : attributeHandles)
  {
    if (attributeHandle == mObjectClass->GetgColdstartAttemptsAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mgColdstartAttempts.encode()));
      mDirty &= ~kgColdstartAttemptsBit;
    }
    else if (attributeHandle == mObjectClass->GetgCycleCountMaxAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mgCycleCountMax.encode()));
      mDirty &= ~kgCycleCountMaxBit;
    }
    else if (attributeHandle == mObjectClass->GetgdActionPointOffsetAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mgdActionPointOffset.encode()));
      mDirty &= ~kgdActionPointOffsetBit;
    }
    else if (attributeHandle == mObjectClass->GetgdDynamicSlotIdlePhaseAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mgdDynamicSlotIdlePhase.encode()));
      mDirty &= ~kgdDynamicSlotIdlePhaseBit;
    }
    else if (attributeHandle == mObjectClass->GetgdMiniSlotAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mgdMiniSlot.encode()));
      mDirty &= ~kgdMiniSlotBit;
    }
    else if (attributeHandle == mObjectClass->GetgdMiniSlotActionPointOffsetAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mgdMiniSlotActionPointOffset.encode()));
      mDirty &= ~kgdMiniSlotActionPointOffsetBit;
    }
    else if (attributeHandle == mObjectClass->GetgdStaticSlotAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mgdStaticSlot.encode()));
      mDirty &= ~kgdStaticSlotBit;
    }
    else if (attributeHandle == mObjectClass->GetgdSymbolWindowAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mgdSymbolWindow.encode()));
      mDirty &= ~kgdSymbolWindowBit;
    }
    else if (attributeHandle == mObjectClass->GetgdSymbolWindowActionPointOffsetAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mgdSymbolWindowActionPointOffset.encode()));
      mDirty &= ~kgdSymbolWindowActionPointOffsetBit;
    }
    else if (attributeHandle == mObjectClass->GetgdTSSTransmitterAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mgdTSSTransmitter.encode()));
      mDirty &= ~kgdTSSTransmitterBit;
    }
    else if (attributeHandle == mObjectClass->GetgdWakeupTxActiveAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mgdWakeupTxActive.encode()));
      mDirty &= ~kgdWakeupTxActiveBit;
    }
    else if (attributeHandle == mObjectClass->GetgdWakeupTxIdleAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mgdWakeupTxIdle.encode()));
      mDirty &= ~kgdWakeupTxIdleBit;
    }
    else if (attributeHandle == mObjectClass->GetgListenNoiseAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mgListenNoise.encode()));
      mDirty &= ~kgListenNoiseBit;
    }
    else if (attributeHandle == mObjectClass->GetgMacroPerCycleAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mgMacroPerCycle.encode()));
      mDirty &= ~kgMacroPerCycleBit;
    }
    else if (attributeHandle == mObjectClass->GetgMaxWithoutClockCorrectionFatalAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mgMaxWithoutClockCorrectionFatal.encode()));
      mDirty &= ~kgMaxWithoutClockCorrectionFatalBit;
    }
    else if (attributeHandle == mObjectClass->GetgMaxWithoutClockCorrectionPassiveAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mgMaxWithoutClockCorrectionPassive.encode()));
      mDirty &= ~kgMaxWithoutClockCorrectionPassiveBit;
    }
    else if (attributeHandle == mObjectClass->GetgNumberOfMiniSlotsAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mgNumberOfMiniSlots.encode()));
      mDirty &= ~kgNumberOfMiniSlotsBit;
    }
    else if (attributeHandle == mObjectClass->GetgNumberOfStaticSlotsAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mgNumberOfStaticSlots.encode()));
      mDirty &= ~kgNumberOfStaticSlotsBit;
    }
    else if (attributeHandle == mObjectClass->GetgPayloadLengthStaticAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mgPayloadLengthStatic.encode()));
      mDirty &= ~kgPayloadLengthStaticBit;
    }
    else if (attributeHandle == mObjectClass->GetgSyncFrameIDCountMaxAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mgSyncFrameIDCountMax.encode()));
      mDirty &= ~kgSyncFrameIDCountMaxBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // FlexRayCluster::ReflectAttributeValues

uint32_t FlexRayCluster::RegisterUpdateCallback(UpdateCallbackType callback)
{
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void FlexRayCluster::UnregisterUpdateCallback(uint32_t callbackToken)
{
  mUpdateCallbacks.erase(callbackToken);
}

void FlexRayCluster::ExecuteUpdateCallbacks()
{
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(this);
  }
}

// object class type 'BusController'
BusControllerObjectClass::BusControllerObjectClass(rti1516ev::RTIambassador* rtiAmbassador, HLAobjectRootObjectClass* baseClass)
{
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.BusController");
  // attribute NetworkID : HLAASCIIstring
  mNetworkIDAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"NetworkID");
  // attribute DeviceID : HLAASCIIstring
  mDeviceIDAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"DeviceID");
}

void BusControllerObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void BusControllerObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void BusControllerObjectClass::Subscribe()
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void BusControllerObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

void BusControllerObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle, const std::wstring& instanceName)
{
  assert(mObjectInstancesByName.find(instanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(instanceHandle) == mObjectInstancesByHandle.end());
  BusController* newObject = new BusController(this, instanceName, mRtiAmbassador);
  newObject->mObjectInstanceHandle = instanceHandle;
  newObject->mIsOwner = false;
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
}

void BusControllerObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject)
{
  std::wstring instanceName = mRtiAmbassador->getObjectInstanceName(theObject);
  auto iter = mObjectInstancesByName.find(instanceName);
  assert(iter != mObjectInstancesByName.end());
  auto* objectInstance = iter->second;
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  mObjectInstancesByName.erase(iter);
  mObjectInstancesByHandle.erase(theObject);
}

IBusController* BusControllerObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IBusController* BusControllerObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IBusController* BusControllerObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"BusController");
  }
  BusController* newObject = new BusController(this, instanceName, mRtiAmbassador);
  ObjectClassRegistry::GetInstance()->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
    }
  });
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  return newObject;
}

rti1516ev::AttributeHandleSet BusControllerObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetNetworkIDAttributeHandle());
  result.insert(GetDeviceIDAttributeHandle());
  return result;
}

uint32_t BusControllerObjectClass::RegisterDiscoverCallback(DiscoverCallbackType callback)
{
  mLastCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void BusControllerObjectClass::UnregisterDiscoverCallback(uint32_t callbackToken)
{
  mDiscoverCallbacks.erase(callbackToken);
}

void BusControllerObjectClass::ExecuteDiscoverCallbacks(IBusController* newObjectInstance)
{
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

// object instances of type 'BusController'
BusController::BusController()
{
}

BusController::BusController(BusControllerObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mObjectClass(objectClass)
  , mInstanceName(instanceName)
  , mRtiAmbassador(rtiAmbassador)
{
}

BusController::~BusController()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

// attribute BusController.HLAprivilegeToDeleteObject : no data type

// attribute NetworkID : HLAASCIIstring
std::string BusController::GetNetworkID() const
{
  return mNetworkID.get();
}

void BusController::SetNetworkID(const std::string& newValue)
{
  // CanTranslateToCpp=True
  mNetworkID.set(newValue);
  mDirty |= kNetworkIDBit;
}

// attribute DeviceID : HLAASCIIstring
std::string BusController::GetDeviceID() const
{
  return mDeviceID.get();
}

void BusController::SetDeviceID(const std::string& newValue)
{
  // CanTranslateToCpp=True
  mDeviceID.set(newValue);
  mDirty |= kDeviceIDBit;
}

rti1516ev::AttributeHandleValueMap BusController::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  result[mObjectClass->GetDeviceIDAttributeHandle()] = mDeviceID.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap BusController::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kNetworkIDBit)
  {
    result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  }
  if (mDirty & kDeviceIDBit)
  {
    result[mObjectClass->GetDeviceIDAttributeHandle()] = mDeviceID.encode();
  }
  return result;
}

void BusController::UpdateAllAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
  }
}

void BusController::UpdateAllAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
  }
}

void BusController::UpdateModifiedAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
    mDirty = kNone;
  }
}

void BusController::UpdateModifiedAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
    mDirty = kNone;
  }
}

void BusController::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle())
    {
      mNetworkID.decode(attributeHandleValue.second);
      mLastUpdated |= kNetworkIDBit;
    }
    else if (attributeHandle == mObjectClass->GetDeviceIDAttributeHandle())
    {
      mDeviceID.decode(attributeHandleValue.second);
      mLastUpdated |= kDeviceIDBit;
    }
  } // for (auto& attributeHandleValue : attributes)
} // BusController::ReflectAttributeValues

void BusController::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  if ((mLastUpdated & kNetworkIDBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetNetworkIDAttributeHandle());
  }
  if ((mLastUpdated & kDeviceIDBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetDeviceIDAttributeHandle());
  }
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void BusController::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetNetworkIDAttributeHandle());
  requestAttributes.insert(mObjectClass->GetDeviceIDAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void BusController::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  for (auto& attributeHandle : attributeHandles)
  {
    if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mNetworkID.encode()));
      mDirty &= ~kNetworkIDBit;
    }
    else if (attributeHandle == mObjectClass->GetDeviceIDAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mDeviceID.encode()));
      mDirty &= ~kDeviceIDBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // BusController::ReflectAttributeValues


// object class type 'BusControllerCan'
BusControllerCanObjectClass::BusControllerCanObjectClass(rti1516ev::RTIambassador* rtiAmbassador, BusControllerObjectClass* baseClass)
{
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.BusController.BusControllerCan");
  // attribute BaudRate : HLAinteger32LE
  mBaudRateAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"BaudRate");
  // attribute DataBaudRate : HLAinteger32LE
  mDataBaudRateAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"DataBaudRate");
  // attribute PreScaler : HLAinteger32LE
  mPreScalerAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"PreScaler");
  // attribute OperationMode : CanOperationMode
  mOperationModeAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"OperationMode");
  // attribute Sync_Seg : HLAinteger32LE
  mSync_SegAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"Sync_Seg");
  // attribute Prop_Seg : HLAinteger32LE
  mProp_SegAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"Prop_Seg");
  // attribute Phase_Seg1 : HLAinteger32LE
  mPhase_Seg1AttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"Phase_Seg1");
  // attribute Phase_Seg2 : HLAinteger32LE
  mPhase_Seg2AttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"Phase_Seg2");
  // attribute SamplingMode : CanSamplingMode
  mSamplingModeAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"SamplingMode");
}

void BusControllerCanObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void BusControllerCanObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void BusControllerCanObjectClass::Subscribe()
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void BusControllerCanObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

void BusControllerCanObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle, const std::wstring& instanceName)
{
  assert(mObjectInstancesByName.find(instanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(instanceHandle) == mObjectInstancesByHandle.end());
  BusControllerCan* newObject = new BusControllerCan(this, instanceName, mRtiAmbassador);
  newObject->mObjectInstanceHandle = instanceHandle;
  newObject->mIsOwner = false;
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
}

void BusControllerCanObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject)
{
  std::wstring instanceName = mRtiAmbassador->getObjectInstanceName(theObject);
  auto iter = mObjectInstancesByName.find(instanceName);
  assert(iter != mObjectInstancesByName.end());
  auto* objectInstance = iter->second;
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  mObjectInstancesByName.erase(iter);
  mObjectInstancesByHandle.erase(theObject);
}

IBusControllerCan* BusControllerCanObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IBusControllerCan* BusControllerCanObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IBusControllerCan* BusControllerCanObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"BusControllerCan");
  }
  BusControllerCan* newObject = new BusControllerCan(this, instanceName, mRtiAmbassador);
  ObjectClassRegistry::GetInstance()->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
    }
  });
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  return newObject;
}

rti1516ev::AttributeHandleSet BusControllerCanObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetNetworkIDAttributeHandle());
  result.insert(GetDeviceIDAttributeHandle());
  result.insert(GetBaudRateAttributeHandle());
  result.insert(GetDataBaudRateAttributeHandle());
  result.insert(GetPreScalerAttributeHandle());
  result.insert(GetOperationModeAttributeHandle());
  result.insert(GetSync_SegAttributeHandle());
  result.insert(GetProp_SegAttributeHandle());
  result.insert(GetPhase_Seg1AttributeHandle());
  result.insert(GetPhase_Seg2AttributeHandle());
  result.insert(GetSamplingModeAttributeHandle());
  return result;
}

uint32_t BusControllerCanObjectClass::RegisterDiscoverCallback(DiscoverCallbackType callback)
{
  mLastCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void BusControllerCanObjectClass::UnregisterDiscoverCallback(uint32_t callbackToken)
{
  mDiscoverCallbacks.erase(callbackToken);
}

void BusControllerCanObjectClass::ExecuteDiscoverCallbacks(IBusControllerCan* newObjectInstance)
{
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

// object instances of type 'BusControllerCan'
BusControllerCan::BusControllerCan()
{
}

BusControllerCan::BusControllerCan(BusControllerCanObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mObjectClass(objectClass)
  , mInstanceName(instanceName)
  , mRtiAmbassador(rtiAmbassador)
{
}

BusControllerCan::~BusControllerCan()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

// attribute BusControllerCan.HLAprivilegeToDeleteObject : no data type

// attribute NetworkID : HLAASCIIstring
std::string BusControllerCan::GetNetworkID() const
{
  return mNetworkID.get();
}

void BusControllerCan::SetNetworkID(const std::string& newValue)
{
  // CanTranslateToCpp=True
  mNetworkID.set(newValue);
  mDirty |= kNetworkIDBit;
}

// attribute DeviceID : HLAASCIIstring
std::string BusControllerCan::GetDeviceID() const
{
  return mDeviceID.get();
}

void BusControllerCan::SetDeviceID(const std::string& newValue)
{
  // CanTranslateToCpp=True
  mDeviceID.set(newValue);
  mDirty |= kDeviceIDBit;
}

// attribute BaudRate : HLAinteger32LE
int32_t BusControllerCan::GetBaudRate() const
{
  return mBaudRate.get();
}

void BusControllerCan::SetBaudRate(int32_t newValue)
{
  // CanTranslateToCpp=True
  mBaudRate.set(newValue);
  mDirty |= kBaudRateBit;
}

// attribute DataBaudRate : HLAinteger32LE
int32_t BusControllerCan::GetDataBaudRate() const
{
  return mDataBaudRate.get();
}

void BusControllerCan::SetDataBaudRate(int32_t newValue)
{
  // CanTranslateToCpp=True
  mDataBaudRate.set(newValue);
  mDirty |= kDataBaudRateBit;
}

// attribute PreScaler : HLAinteger32LE
int32_t BusControllerCan::GetPreScaler() const
{
  return mPreScaler.get();
}

void BusControllerCan::SetPreScaler(int32_t newValue)
{
  // CanTranslateToCpp=True
  mPreScaler.set(newValue);
  mDirty |= kPreScalerBit;
}

// attribute OperationMode : CanOperationMode
CanOperationMode BusControllerCan::GetOperationMode() const
{
  return static_cast<CanOperationMode>(mOperationMode.get());
}

void BusControllerCan::SetOperationMode(CanOperationMode newValue)
{
  // CanTranslateToCpp=True
  mOperationMode.set(static_cast<int32_t>(newValue));
  mDirty |= kOperationModeBit;
}

// attribute Sync_Seg : HLAinteger32LE
int32_t BusControllerCan::GetSync_Seg() const
{
  return mSync_Seg.get();
}

void BusControllerCan::SetSync_Seg(int32_t newValue)
{
  // CanTranslateToCpp=True
  mSync_Seg.set(newValue);
  mDirty |= kSync_SegBit;
}

// attribute Prop_Seg : HLAinteger32LE
int32_t BusControllerCan::GetProp_Seg() const
{
  return mProp_Seg.get();
}

void BusControllerCan::SetProp_Seg(int32_t newValue)
{
  // CanTranslateToCpp=True
  mProp_Seg.set(newValue);
  mDirty |= kProp_SegBit;
}

// attribute Phase_Seg1 : HLAinteger32LE
int32_t BusControllerCan::GetPhase_Seg1() const
{
  return mPhase_Seg1.get();
}

void BusControllerCan::SetPhase_Seg1(int32_t newValue)
{
  // CanTranslateToCpp=True
  mPhase_Seg1.set(newValue);
  mDirty |= kPhase_Seg1Bit;
}

// attribute Phase_Seg2 : HLAinteger32LE
int32_t BusControllerCan::GetPhase_Seg2() const
{
  return mPhase_Seg2.get();
}

void BusControllerCan::SetPhase_Seg2(int32_t newValue)
{
  // CanTranslateToCpp=True
  mPhase_Seg2.set(newValue);
  mDirty |= kPhase_Seg2Bit;
}

// attribute SamplingMode : CanSamplingMode
CanSamplingMode BusControllerCan::GetSamplingMode() const
{
  return static_cast<CanSamplingMode>(mSamplingMode.get());
}

void BusControllerCan::SetSamplingMode(CanSamplingMode newValue)
{
  // CanTranslateToCpp=True
  mSamplingMode.set(static_cast<int32_t>(newValue));
  mDirty |= kSamplingModeBit;
}

rti1516ev::AttributeHandleValueMap BusControllerCan::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  result[mObjectClass->GetDeviceIDAttributeHandle()] = mDeviceID.encode();
  result[mObjectClass->GetBaudRateAttributeHandle()] = mBaudRate.encode();
  result[mObjectClass->GetDataBaudRateAttributeHandle()] = mDataBaudRate.encode();
  result[mObjectClass->GetPreScalerAttributeHandle()] = mPreScaler.encode();
  result[mObjectClass->GetOperationModeAttributeHandle()] = mOperationMode.encode();
  result[mObjectClass->GetSync_SegAttributeHandle()] = mSync_Seg.encode();
  result[mObjectClass->GetProp_SegAttributeHandle()] = mProp_Seg.encode();
  result[mObjectClass->GetPhase_Seg1AttributeHandle()] = mPhase_Seg1.encode();
  result[mObjectClass->GetPhase_Seg2AttributeHandle()] = mPhase_Seg2.encode();
  result[mObjectClass->GetSamplingModeAttributeHandle()] = mSamplingMode.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap BusControllerCan::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kBaudRateBit)
  {
    result[mObjectClass->GetBaudRateAttributeHandle()] = mBaudRate.encode();
  }
  if (mDirty & kDataBaudRateBit)
  {
    result[mObjectClass->GetDataBaudRateAttributeHandle()] = mDataBaudRate.encode();
  }
  if (mDirty & kPreScalerBit)
  {
    result[mObjectClass->GetPreScalerAttributeHandle()] = mPreScaler.encode();
  }
  if (mDirty & kOperationModeBit)
  {
    result[mObjectClass->GetOperationModeAttributeHandle()] = mOperationMode.encode();
  }
  if (mDirty & kSync_SegBit)
  {
    result[mObjectClass->GetSync_SegAttributeHandle()] = mSync_Seg.encode();
  }
  if (mDirty & kProp_SegBit)
  {
    result[mObjectClass->GetProp_SegAttributeHandle()] = mProp_Seg.encode();
  }
  if (mDirty & kPhase_Seg1Bit)
  {
    result[mObjectClass->GetPhase_Seg1AttributeHandle()] = mPhase_Seg1.encode();
  }
  if (mDirty & kPhase_Seg2Bit)
  {
    result[mObjectClass->GetPhase_Seg2AttributeHandle()] = mPhase_Seg2.encode();
  }
  if (mDirty & kSamplingModeBit)
  {
    result[mObjectClass->GetSamplingModeAttributeHandle()] = mSamplingMode.encode();
  }
  return result;
}

void BusControllerCan::UpdateAllAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
  }
}

void BusControllerCan::UpdateAllAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
  }
}

void BusControllerCan::UpdateModifiedAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
    mDirty = kNone;
  }
}

void BusControllerCan::UpdateModifiedAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
    mDirty = kNone;
  }
}

void BusControllerCan::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetBaudRateAttributeHandle())
    {
      mBaudRate.decode(attributeHandleValue.second);
      mLastUpdated |= kBaudRateBit;
    }
    else if (attributeHandle == mObjectClass->GetDataBaudRateAttributeHandle())
    {
      mDataBaudRate.decode(attributeHandleValue.second);
      mLastUpdated |= kDataBaudRateBit;
    }
    else if (attributeHandle == mObjectClass->GetPreScalerAttributeHandle())
    {
      mPreScaler.decode(attributeHandleValue.second);
      mLastUpdated |= kPreScalerBit;
    }
    else if (attributeHandle == mObjectClass->GetOperationModeAttributeHandle())
    {
      mOperationMode.decode(attributeHandleValue.second);
      mLastUpdated |= kOperationModeBit;
    }
    else if (attributeHandle == mObjectClass->GetSync_SegAttributeHandle())
    {
      mSync_Seg.decode(attributeHandleValue.second);
      mLastUpdated |= kSync_SegBit;
    }
    else if (attributeHandle == mObjectClass->GetProp_SegAttributeHandle())
    {
      mProp_Seg.decode(attributeHandleValue.second);
      mLastUpdated |= kProp_SegBit;
    }
    else if (attributeHandle == mObjectClass->GetPhase_Seg1AttributeHandle())
    {
      mPhase_Seg1.decode(attributeHandleValue.second);
      mLastUpdated |= kPhase_Seg1Bit;
    }
    else if (attributeHandle == mObjectClass->GetPhase_Seg2AttributeHandle())
    {
      mPhase_Seg2.decode(attributeHandleValue.second);
      mLastUpdated |= kPhase_Seg2Bit;
    }
    else if (attributeHandle == mObjectClass->GetSamplingModeAttributeHandle())
    {
      mSamplingMode.decode(attributeHandleValue.second);
      mLastUpdated |= kSamplingModeBit;
    }
  } // for (auto& attributeHandleValue : attributes)
    ExecuteUpdateCallbacks();
} // BusControllerCan::ReflectAttributeValues

void BusControllerCan::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  if ((mLastUpdated & kBaudRateBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetBaudRateAttributeHandle());
  }
  if ((mLastUpdated & kDataBaudRateBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetDataBaudRateAttributeHandle());
  }
  if ((mLastUpdated & kPreScalerBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetPreScalerAttributeHandle());
  }
  if ((mLastUpdated & kOperationModeBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetOperationModeAttributeHandle());
  }
  if ((mLastUpdated & kSync_SegBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetSync_SegAttributeHandle());
  }
  if ((mLastUpdated & kProp_SegBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetProp_SegAttributeHandle());
  }
  if ((mLastUpdated & kPhase_Seg1Bit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetPhase_Seg1AttributeHandle());
  }
  if ((mLastUpdated & kPhase_Seg2Bit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetPhase_Seg2AttributeHandle());
  }
  if ((mLastUpdated & kSamplingModeBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetSamplingModeAttributeHandle());
  }
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void BusControllerCan::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetBaudRateAttributeHandle());
  requestAttributes.insert(mObjectClass->GetDataBaudRateAttributeHandle());
  requestAttributes.insert(mObjectClass->GetPreScalerAttributeHandle());
  requestAttributes.insert(mObjectClass->GetOperationModeAttributeHandle());
  requestAttributes.insert(mObjectClass->GetSync_SegAttributeHandle());
  requestAttributes.insert(mObjectClass->GetProp_SegAttributeHandle());
  requestAttributes.insert(mObjectClass->GetPhase_Seg1AttributeHandle());
  requestAttributes.insert(mObjectClass->GetPhase_Seg2AttributeHandle());
  requestAttributes.insert(mObjectClass->GetSamplingModeAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void BusControllerCan::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  for (auto& attributeHandle : attributeHandles)
  {
    if (attributeHandle == mObjectClass->GetBaudRateAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mBaudRate.encode()));
      mDirty &= ~kBaudRateBit;
    }
    else if (attributeHandle == mObjectClass->GetDataBaudRateAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mDataBaudRate.encode()));
      mDirty &= ~kDataBaudRateBit;
    }
    else if (attributeHandle == mObjectClass->GetPreScalerAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mPreScaler.encode()));
      mDirty &= ~kPreScalerBit;
    }
    else if (attributeHandle == mObjectClass->GetOperationModeAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mOperationMode.encode()));
      mDirty &= ~kOperationModeBit;
    }
    else if (attributeHandle == mObjectClass->GetSync_SegAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mSync_Seg.encode()));
      mDirty &= ~kSync_SegBit;
    }
    else if (attributeHandle == mObjectClass->GetProp_SegAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mProp_Seg.encode()));
      mDirty &= ~kProp_SegBit;
    }
    else if (attributeHandle == mObjectClass->GetPhase_Seg1AttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mPhase_Seg1.encode()));
      mDirty &= ~kPhase_Seg1Bit;
    }
    else if (attributeHandle == mObjectClass->GetPhase_Seg2AttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mPhase_Seg2.encode()));
      mDirty &= ~kPhase_Seg2Bit;
    }
    else if (attributeHandle == mObjectClass->GetSamplingModeAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mSamplingMode.encode()));
      mDirty &= ~kSamplingModeBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // BusControllerCan::ReflectAttributeValues

uint32_t BusControllerCan::RegisterUpdateCallback(UpdateCallbackType callback)
{
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void BusControllerCan::UnregisterUpdateCallback(uint32_t callbackToken)
{
  mUpdateCallbacks.erase(callbackToken);
}

void BusControllerCan::ExecuteUpdateCallbacks()
{
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(this);
  }
}

// object class type 'BusControllerEthernet'
BusControllerEthernetObjectClass::BusControllerEthernetObjectClass(rti1516ev::RTIambassador* rtiAmbassador, BusControllerObjectClass* baseClass)
{
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.BusController.BusControllerEthernet");
  // attribute PortName : HLAASCIIstring
  mPortNameAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"PortName");
}

void BusControllerEthernetObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void BusControllerEthernetObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void BusControllerEthernetObjectClass::Subscribe()
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void BusControllerEthernetObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

void BusControllerEthernetObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle, const std::wstring& instanceName)
{
  assert(mObjectInstancesByName.find(instanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(instanceHandle) == mObjectInstancesByHandle.end());
  BusControllerEthernet* newObject = new BusControllerEthernet(this, instanceName, mRtiAmbassador);
  newObject->mObjectInstanceHandle = instanceHandle;
  newObject->mIsOwner = false;
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
}

void BusControllerEthernetObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject)
{
  std::wstring instanceName = mRtiAmbassador->getObjectInstanceName(theObject);
  auto iter = mObjectInstancesByName.find(instanceName);
  assert(iter != mObjectInstancesByName.end());
  auto* objectInstance = iter->second;
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  mObjectInstancesByName.erase(iter);
  mObjectInstancesByHandle.erase(theObject);
}

IBusControllerEthernet* BusControllerEthernetObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IBusControllerEthernet* BusControllerEthernetObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IBusControllerEthernet* BusControllerEthernetObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"BusControllerEthernet");
  }
  BusControllerEthernet* newObject = new BusControllerEthernet(this, instanceName, mRtiAmbassador);
  ObjectClassRegistry::GetInstance()->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
    }
  });
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  return newObject;
}

rti1516ev::AttributeHandleSet BusControllerEthernetObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetNetworkIDAttributeHandle());
  result.insert(GetDeviceIDAttributeHandle());
  result.insert(GetPortNameAttributeHandle());
  return result;
}

uint32_t BusControllerEthernetObjectClass::RegisterDiscoverCallback(DiscoverCallbackType callback)
{
  mLastCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void BusControllerEthernetObjectClass::UnregisterDiscoverCallback(uint32_t callbackToken)
{
  mDiscoverCallbacks.erase(callbackToken);
}

void BusControllerEthernetObjectClass::ExecuteDiscoverCallbacks(IBusControllerEthernet* newObjectInstance)
{
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

// object instances of type 'BusControllerEthernet'
BusControllerEthernet::BusControllerEthernet()
{
}

BusControllerEthernet::BusControllerEthernet(BusControllerEthernetObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mObjectClass(objectClass)
  , mInstanceName(instanceName)
  , mRtiAmbassador(rtiAmbassador)
{
}

BusControllerEthernet::~BusControllerEthernet()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

// attribute BusControllerEthernet.HLAprivilegeToDeleteObject : no data type

// attribute NetworkID : HLAASCIIstring
std::string BusControllerEthernet::GetNetworkID() const
{
  return mNetworkID.get();
}

void BusControllerEthernet::SetNetworkID(const std::string& newValue)
{
  // CanTranslateToCpp=True
  mNetworkID.set(newValue);
  mDirty |= kNetworkIDBit;
}

// attribute DeviceID : HLAASCIIstring
std::string BusControllerEthernet::GetDeviceID() const
{
  return mDeviceID.get();
}

void BusControllerEthernet::SetDeviceID(const std::string& newValue)
{
  // CanTranslateToCpp=True
  mDeviceID.set(newValue);
  mDirty |= kDeviceIDBit;
}

// attribute PortName : HLAASCIIstring
std::string BusControllerEthernet::GetPortName() const
{
  return mPortName.get();
}

void BusControllerEthernet::SetPortName(const std::string& newValue)
{
  // CanTranslateToCpp=True
  mPortName.set(newValue);
  mDirty |= kPortNameBit;
}

rti1516ev::AttributeHandleValueMap BusControllerEthernet::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  result[mObjectClass->GetDeviceIDAttributeHandle()] = mDeviceID.encode();
  result[mObjectClass->GetPortNameAttributeHandle()] = mPortName.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap BusControllerEthernet::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kPortNameBit)
  {
    result[mObjectClass->GetPortNameAttributeHandle()] = mPortName.encode();
  }
  return result;
}

void BusControllerEthernet::UpdateAllAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
  }
}

void BusControllerEthernet::UpdateAllAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
  }
}

void BusControllerEthernet::UpdateModifiedAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
    mDirty = kNone;
  }
}

void BusControllerEthernet::UpdateModifiedAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
    mDirty = kNone;
  }
}

void BusControllerEthernet::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetPortNameAttributeHandle())
    {
      mPortName.decode(attributeHandleValue.second);
      mLastUpdated |= kPortNameBit;
    }
  } // for (auto& attributeHandleValue : attributes)
    ExecuteUpdateCallbacks();
} // BusControllerEthernet::ReflectAttributeValues

void BusControllerEthernet::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  if ((mLastUpdated & kPortNameBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetPortNameAttributeHandle());
  }
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void BusControllerEthernet::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetPortNameAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void BusControllerEthernet::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  for (auto& attributeHandle : attributeHandles)
  {
    if (attributeHandle == mObjectClass->GetPortNameAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mPortName.encode()));
      mDirty &= ~kPortNameBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // BusControllerEthernet::ReflectAttributeValues

uint32_t BusControllerEthernet::RegisterUpdateCallback(UpdateCallbackType callback)
{
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void BusControllerEthernet::UnregisterUpdateCallback(uint32_t callbackToken)
{
  mUpdateCallbacks.erase(callbackToken);
}

void BusControllerEthernet::ExecuteUpdateCallbacks()
{
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(this);
  }
}

// object class type 'FlexRayControllerStatus'
FlexRayControllerStatusObjectClass::FlexRayControllerStatusObjectClass(rti1516ev::RTIambassador* rtiAmbassador, BusControllerObjectClass* baseClass)
{
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.BusController.FlexRayControllerStatus");
  // attribute PocState : FlexRayPocState
  mPocStateAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"PocState");
  // attribute chiHaltRequest : HLAboolean
  mchiHaltRequestAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"chiHaltRequest");
  // attribute coldstartNoise : HLAboolean
  mcoldstartNoiseAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"coldstartNoise");
  // attribute freeze : HLAboolean
  mfreezeAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"freeze");
  // attribute chiReadyRequest : HLAboolean
  mchiReadyRequestAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"chiReadyRequest");
  // attribute errorMode : FlexRayErrorModeType
  merrorModeAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"errorMode");
  // attribute slotMode : FlexRaySlotModeType
  mslotModeAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"slotMode");
  // attribute startupState : FlexRayStartupStateType
  mstartupStateAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"startupState");
  // attribute wakeupStatus : FlexRayWakeupStatusType
  mwakeupStatusAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"wakeupStatus");
}

void FlexRayControllerStatusObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void FlexRayControllerStatusObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void FlexRayControllerStatusObjectClass::Subscribe()
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void FlexRayControllerStatusObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

void FlexRayControllerStatusObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle, const std::wstring& instanceName)
{
  assert(mObjectInstancesByName.find(instanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(instanceHandle) == mObjectInstancesByHandle.end());
  FlexRayControllerStatus* newObject = new FlexRayControllerStatus(this, instanceName, mRtiAmbassador);
  newObject->mObjectInstanceHandle = instanceHandle;
  newObject->mIsOwner = false;
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
}

void FlexRayControllerStatusObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject)
{
  std::wstring instanceName = mRtiAmbassador->getObjectInstanceName(theObject);
  auto iter = mObjectInstancesByName.find(instanceName);
  assert(iter != mObjectInstancesByName.end());
  auto* objectInstance = iter->second;
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  mObjectInstancesByName.erase(iter);
  mObjectInstancesByHandle.erase(theObject);
}

IFlexRayControllerStatus* FlexRayControllerStatusObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IFlexRayControllerStatus* FlexRayControllerStatusObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IFlexRayControllerStatus* FlexRayControllerStatusObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"FlexRayControllerStatus");
  }
  FlexRayControllerStatus* newObject = new FlexRayControllerStatus(this, instanceName, mRtiAmbassador);
  ObjectClassRegistry::GetInstance()->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
    }
  });
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  return newObject;
}

rti1516ev::AttributeHandleSet FlexRayControllerStatusObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetNetworkIDAttributeHandle());
  result.insert(GetDeviceIDAttributeHandle());
  result.insert(GetPocStateAttributeHandle());
  result.insert(GetchiHaltRequestAttributeHandle());
  result.insert(GetcoldstartNoiseAttributeHandle());
  result.insert(GetfreezeAttributeHandle());
  result.insert(GetchiReadyRequestAttributeHandle());
  result.insert(GeterrorModeAttributeHandle());
  result.insert(GetslotModeAttributeHandle());
  result.insert(GetstartupStateAttributeHandle());
  result.insert(GetwakeupStatusAttributeHandle());
  return result;
}

uint32_t FlexRayControllerStatusObjectClass::RegisterDiscoverCallback(DiscoverCallbackType callback)
{
  mLastCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void FlexRayControllerStatusObjectClass::UnregisterDiscoverCallback(uint32_t callbackToken)
{
  mDiscoverCallbacks.erase(callbackToken);
}

void FlexRayControllerStatusObjectClass::ExecuteDiscoverCallbacks(IFlexRayControllerStatus* newObjectInstance)
{
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

// object instances of type 'FlexRayControllerStatus'
FlexRayControllerStatus::FlexRayControllerStatus()
{
}

FlexRayControllerStatus::FlexRayControllerStatus(FlexRayControllerStatusObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mObjectClass(objectClass)
  , mInstanceName(instanceName)
  , mRtiAmbassador(rtiAmbassador)
{
}

FlexRayControllerStatus::~FlexRayControllerStatus()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

// attribute FlexRayControllerStatus.HLAprivilegeToDeleteObject : no data type

// attribute NetworkID : HLAASCIIstring
std::string FlexRayControllerStatus::GetNetworkID() const
{
  return mNetworkID.get();
}

void FlexRayControllerStatus::SetNetworkID(const std::string& newValue)
{
  // CanTranslateToCpp=True
  mNetworkID.set(newValue);
  mDirty |= kNetworkIDBit;
}

// attribute DeviceID : HLAASCIIstring
std::string FlexRayControllerStatus::GetDeviceID() const
{
  return mDeviceID.get();
}

void FlexRayControllerStatus::SetDeviceID(const std::string& newValue)
{
  // CanTranslateToCpp=True
  mDeviceID.set(newValue);
  mDirty |= kDeviceIDBit;
}

// attribute PocState : FlexRayPocState
FlexRayPocState FlexRayControllerStatus::GetPocState() const
{
  return static_cast<FlexRayPocState>(mPocState.get());
}

void FlexRayControllerStatus::SetPocState(FlexRayPocState newValue)
{
  // CanTranslateToCpp=True
  mPocState.set(static_cast<uint8_t>(newValue));
  mDirty |= kPocStateBit;
}

// attribute chiHaltRequest : HLAboolean
bool FlexRayControllerStatus::GetchiHaltRequest() const
{
  return mchiHaltRequest.get();
}

void FlexRayControllerStatus::SetchiHaltRequest(bool newValue)
{
  // CanTranslateToCpp=True
  mchiHaltRequest.set(newValue);
  mDirty |= kchiHaltRequestBit;
}

// attribute coldstartNoise : HLAboolean
bool FlexRayControllerStatus::GetcoldstartNoise() const
{
  return mcoldstartNoise.get();
}

void FlexRayControllerStatus::SetcoldstartNoise(bool newValue)
{
  // CanTranslateToCpp=True
  mcoldstartNoise.set(newValue);
  mDirty |= kcoldstartNoiseBit;
}

// attribute freeze : HLAboolean
bool FlexRayControllerStatus::Getfreeze() const
{
  return mfreeze.get();
}

void FlexRayControllerStatus::Setfreeze(bool newValue)
{
  // CanTranslateToCpp=True
  mfreeze.set(newValue);
  mDirty |= kfreezeBit;
}

// attribute chiReadyRequest : HLAboolean
bool FlexRayControllerStatus::GetchiReadyRequest() const
{
  return mchiReadyRequest.get();
}

void FlexRayControllerStatus::SetchiReadyRequest(bool newValue)
{
  // CanTranslateToCpp=True
  mchiReadyRequest.set(newValue);
  mDirty |= kchiReadyRequestBit;
}

// attribute errorMode : FlexRayErrorModeType
FlexRayErrorModeType FlexRayControllerStatus::GeterrorMode() const
{
  return static_cast<FlexRayErrorModeType>(merrorMode.get());
}

void FlexRayControllerStatus::SeterrorMode(FlexRayErrorModeType newValue)
{
  // CanTranslateToCpp=True
  merrorMode.set(static_cast<uint8_t>(newValue));
  mDirty |= kerrorModeBit;
}

// attribute slotMode : FlexRaySlotModeType
FlexRaySlotModeType FlexRayControllerStatus::GetslotMode() const
{
  return static_cast<FlexRaySlotModeType>(mslotMode.get());
}

void FlexRayControllerStatus::SetslotMode(FlexRaySlotModeType newValue)
{
  // CanTranslateToCpp=True
  mslotMode.set(static_cast<uint8_t>(newValue));
  mDirty |= kslotModeBit;
}

// attribute startupState : FlexRayStartupStateType
FlexRayStartupStateType FlexRayControllerStatus::GetstartupState() const
{
  return static_cast<FlexRayStartupStateType>(mstartupState.get());
}

void FlexRayControllerStatus::SetstartupState(FlexRayStartupStateType newValue)
{
  // CanTranslateToCpp=True
  mstartupState.set(static_cast<uint8_t>(newValue));
  mDirty |= kstartupStateBit;
}

// attribute wakeupStatus : FlexRayWakeupStatusType
FlexRayWakeupStatusType FlexRayControllerStatus::GetwakeupStatus() const
{
  return static_cast<FlexRayWakeupStatusType>(mwakeupStatus.get());
}

void FlexRayControllerStatus::SetwakeupStatus(FlexRayWakeupStatusType newValue)
{
  // CanTranslateToCpp=True
  mwakeupStatus.set(static_cast<uint8_t>(newValue));
  mDirty |= kwakeupStatusBit;
}

rti1516ev::AttributeHandleValueMap FlexRayControllerStatus::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  result[mObjectClass->GetDeviceIDAttributeHandle()] = mDeviceID.encode();
  result[mObjectClass->GetPocStateAttributeHandle()] = mPocState.encode();
  result[mObjectClass->GetchiHaltRequestAttributeHandle()] = mchiHaltRequest.encode();
  result[mObjectClass->GetcoldstartNoiseAttributeHandle()] = mcoldstartNoise.encode();
  result[mObjectClass->GetfreezeAttributeHandle()] = mfreeze.encode();
  result[mObjectClass->GetchiReadyRequestAttributeHandle()] = mchiReadyRequest.encode();
  result[mObjectClass->GeterrorModeAttributeHandle()] = merrorMode.encode();
  result[mObjectClass->GetslotModeAttributeHandle()] = mslotMode.encode();
  result[mObjectClass->GetstartupStateAttributeHandle()] = mstartupState.encode();
  result[mObjectClass->GetwakeupStatusAttributeHandle()] = mwakeupStatus.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap FlexRayControllerStatus::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kPocStateBit)
  {
    result[mObjectClass->GetPocStateAttributeHandle()] = mPocState.encode();
  }
  if (mDirty & kchiHaltRequestBit)
  {
    result[mObjectClass->GetchiHaltRequestAttributeHandle()] = mchiHaltRequest.encode();
  }
  if (mDirty & kcoldstartNoiseBit)
  {
    result[mObjectClass->GetcoldstartNoiseAttributeHandle()] = mcoldstartNoise.encode();
  }
  if (mDirty & kfreezeBit)
  {
    result[mObjectClass->GetfreezeAttributeHandle()] = mfreeze.encode();
  }
  if (mDirty & kchiReadyRequestBit)
  {
    result[mObjectClass->GetchiReadyRequestAttributeHandle()] = mchiReadyRequest.encode();
  }
  if (mDirty & kerrorModeBit)
  {
    result[mObjectClass->GeterrorModeAttributeHandle()] = merrorMode.encode();
  }
  if (mDirty & kslotModeBit)
  {
    result[mObjectClass->GetslotModeAttributeHandle()] = mslotMode.encode();
  }
  if (mDirty & kstartupStateBit)
  {
    result[mObjectClass->GetstartupStateAttributeHandle()] = mstartupState.encode();
  }
  if (mDirty & kwakeupStatusBit)
  {
    result[mObjectClass->GetwakeupStatusAttributeHandle()] = mwakeupStatus.encode();
  }
  return result;
}

void FlexRayControllerStatus::UpdateAllAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
  }
}

void FlexRayControllerStatus::UpdateAllAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
  }
}

void FlexRayControllerStatus::UpdateModifiedAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
    mDirty = kNone;
  }
}

void FlexRayControllerStatus::UpdateModifiedAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
    mDirty = kNone;
  }
}

void FlexRayControllerStatus::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetPocStateAttributeHandle())
    {
      mPocState.decode(attributeHandleValue.second);
      mLastUpdated |= kPocStateBit;
    }
    else if (attributeHandle == mObjectClass->GetchiHaltRequestAttributeHandle())
    {
      mchiHaltRequest.decode(attributeHandleValue.second);
      mLastUpdated |= kchiHaltRequestBit;
    }
    else if (attributeHandle == mObjectClass->GetcoldstartNoiseAttributeHandle())
    {
      mcoldstartNoise.decode(attributeHandleValue.second);
      mLastUpdated |= kcoldstartNoiseBit;
    }
    else if (attributeHandle == mObjectClass->GetfreezeAttributeHandle())
    {
      mfreeze.decode(attributeHandleValue.second);
      mLastUpdated |= kfreezeBit;
    }
    else if (attributeHandle == mObjectClass->GetchiReadyRequestAttributeHandle())
    {
      mchiReadyRequest.decode(attributeHandleValue.second);
      mLastUpdated |= kchiReadyRequestBit;
    }
    else if (attributeHandle == mObjectClass->GeterrorModeAttributeHandle())
    {
      merrorMode.decode(attributeHandleValue.second);
      mLastUpdated |= kerrorModeBit;
    }
    else if (attributeHandle == mObjectClass->GetslotModeAttributeHandle())
    {
      mslotMode.decode(attributeHandleValue.second);
      mLastUpdated |= kslotModeBit;
    }
    else if (attributeHandle == mObjectClass->GetstartupStateAttributeHandle())
    {
      mstartupState.decode(attributeHandleValue.second);
      mLastUpdated |= kstartupStateBit;
    }
    else if (attributeHandle == mObjectClass->GetwakeupStatusAttributeHandle())
    {
      mwakeupStatus.decode(attributeHandleValue.second);
      mLastUpdated |= kwakeupStatusBit;
    }
  } // for (auto& attributeHandleValue : attributes)
    ExecuteUpdateCallbacks();
} // FlexRayControllerStatus::ReflectAttributeValues

void FlexRayControllerStatus::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  if ((mLastUpdated & kPocStateBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetPocStateAttributeHandle());
  }
  if ((mLastUpdated & kchiHaltRequestBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetchiHaltRequestAttributeHandle());
  }
  if ((mLastUpdated & kcoldstartNoiseBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetcoldstartNoiseAttributeHandle());
  }
  if ((mLastUpdated & kfreezeBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetfreezeAttributeHandle());
  }
  if ((mLastUpdated & kchiReadyRequestBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetchiReadyRequestAttributeHandle());
  }
  if ((mLastUpdated & kerrorModeBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GeterrorModeAttributeHandle());
  }
  if ((mLastUpdated & kslotModeBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetslotModeAttributeHandle());
  }
  if ((mLastUpdated & kstartupStateBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetstartupStateAttributeHandle());
  }
  if ((mLastUpdated & kwakeupStatusBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetwakeupStatusAttributeHandle());
  }
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void FlexRayControllerStatus::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetPocStateAttributeHandle());
  requestAttributes.insert(mObjectClass->GetchiHaltRequestAttributeHandle());
  requestAttributes.insert(mObjectClass->GetcoldstartNoiseAttributeHandle());
  requestAttributes.insert(mObjectClass->GetfreezeAttributeHandle());
  requestAttributes.insert(mObjectClass->GetchiReadyRequestAttributeHandle());
  requestAttributes.insert(mObjectClass->GeterrorModeAttributeHandle());
  requestAttributes.insert(mObjectClass->GetslotModeAttributeHandle());
  requestAttributes.insert(mObjectClass->GetstartupStateAttributeHandle());
  requestAttributes.insert(mObjectClass->GetwakeupStatusAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void FlexRayControllerStatus::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  for (auto& attributeHandle : attributeHandles)
  {
    if (attributeHandle == mObjectClass->GetPocStateAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mPocState.encode()));
      mDirty &= ~kPocStateBit;
    }
    else if (attributeHandle == mObjectClass->GetchiHaltRequestAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mchiHaltRequest.encode()));
      mDirty &= ~kchiHaltRequestBit;
    }
    else if (attributeHandle == mObjectClass->GetcoldstartNoiseAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mcoldstartNoise.encode()));
      mDirty &= ~kcoldstartNoiseBit;
    }
    else if (attributeHandle == mObjectClass->GetfreezeAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mfreeze.encode()));
      mDirty &= ~kfreezeBit;
    }
    else if (attributeHandle == mObjectClass->GetchiReadyRequestAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mchiReadyRequest.encode()));
      mDirty &= ~kchiReadyRequestBit;
    }
    else if (attributeHandle == mObjectClass->GeterrorModeAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, merrorMode.encode()));
      mDirty &= ~kerrorModeBit;
    }
    else if (attributeHandle == mObjectClass->GetslotModeAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mslotMode.encode()));
      mDirty &= ~kslotModeBit;
    }
    else if (attributeHandle == mObjectClass->GetstartupStateAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mstartupState.encode()));
      mDirty &= ~kstartupStateBit;
    }
    else if (attributeHandle == mObjectClass->GetwakeupStatusAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mwakeupStatus.encode()));
      mDirty &= ~kwakeupStatusBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // FlexRayControllerStatus::ReflectAttributeValues

uint32_t FlexRayControllerStatus::RegisterUpdateCallback(UpdateCallbackType callback)
{
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void FlexRayControllerStatus::UnregisterUpdateCallback(uint32_t callbackToken)
{
  mUpdateCallbacks.erase(callbackToken);
}

void FlexRayControllerStatus::ExecuteUpdateCallbacks()
{
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(this);
  }
}

// object class type 'FlexRayController'
FlexRayControllerObjectClass::FlexRayControllerObjectClass(rti1516ev::RTIambassador* rtiAmbassador, BusControllerObjectClass* baseClass)
{
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.BusController.FlexRayController");
  // attribute PocRequest : FlexRayPocState
  mPocRequestAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"PocRequest");
  // attribute ChiCommand : FlexRayChiCommand
  mChiCommandAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"ChiCommand");
  // attribute pAllowHaltDueToClock : HLAoctet
  mpAllowHaltDueToClockAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pAllowHaltDueToClock");
  // attribute pAllowPassiveToActive : HLAoctet
  mpAllowPassiveToActiveAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pAllowPassiveToActive");
  // attribute pChannels : FlexRayChannel
  mpChannelsAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pChannels");
  // attribute pClusterDriftDamping : HLAoctet
  mpClusterDriftDampingAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pClusterDriftDamping");
  // attribute pdAcceptedStartupRange : HLAinteger32LE
  mpdAcceptedStartupRangeAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pdAcceptedStartupRange");
  // attribute pdListenTimeout : HLAinteger32LE
  mpdListenTimeoutAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pdListenTimeout");
  // attribute pKeySlotId : HLAinteger16LE
  mpKeySlotIdAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pKeySlotId");
  // attribute pKeySlotOnlyEnabled : HLAoctet
  mpKeySlotOnlyEnabledAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pKeySlotOnlyEnabled");
  // attribute pKeySlotUsedForStartup : HLAoctet
  mpKeySlotUsedForStartupAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pKeySlotUsedForStartup");
  // attribute pKeySlotUsedForSync : HLAoctet
  mpKeySlotUsedForSyncAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pKeySlotUsedForSync");
  // attribute pLatestTx : HLAinteger16LE
  mpLatestTxAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pLatestTx");
  // attribute pMacroInitialOffsetA : HLAoctet
  mpMacroInitialOffsetAAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pMacroInitialOffsetA");
  // attribute pMacroInitialOffsetB : HLAoctet
  mpMacroInitialOffsetBAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pMacroInitialOffsetB");
  // attribute pMicroInitialOffsetA : HLAinteger32LE
  mpMicroInitialOffsetAAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pMicroInitialOffsetA");
  // attribute pMicroInitialOffsetB : HLAinteger32LE
  mpMicroInitialOffsetBAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pMicroInitialOffsetB");
  // attribute pMicroPerCycle : HLAinteger32LE
  mpMicroPerCycleAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pMicroPerCycle");
  // attribute pOffsetCorrectionOut : HLAinteger32LE
  mpOffsetCorrectionOutAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pOffsetCorrectionOut");
  // attribute pOffsetCorrectionStart : HLAinteger16LE
  mpOffsetCorrectionStartAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pOffsetCorrectionStart");
  // attribute pRateCorrectionOut : HLAinteger32LE
  mpRateCorrectionOutAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pRateCorrectionOut");
  // attribute pWakeupChannel : FlexRayChannel
  mpWakeupChannelAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pWakeupChannel");
  // attribute pWakeupPattern : HLAoctet
  mpWakeupPatternAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pWakeupPattern");
  // attribute pdMicrotick : FlexRayClockPeriod
  mpdMicrotickAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pdMicrotick");
  // attribute pSamplesPerMicrotick : HLAoctet
  mpSamplesPerMicrotickAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pSamplesPerMicrotick");
}

void FlexRayControllerObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void FlexRayControllerObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void FlexRayControllerObjectClass::Subscribe()
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void FlexRayControllerObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

void FlexRayControllerObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle, const std::wstring& instanceName)
{
  assert(mObjectInstancesByName.find(instanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(instanceHandle) == mObjectInstancesByHandle.end());
  FlexRayController* newObject = new FlexRayController(this, instanceName, mRtiAmbassador);
  newObject->mObjectInstanceHandle = instanceHandle;
  newObject->mIsOwner = false;
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
}

void FlexRayControllerObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject)
{
  std::wstring instanceName = mRtiAmbassador->getObjectInstanceName(theObject);
  auto iter = mObjectInstancesByName.find(instanceName);
  assert(iter != mObjectInstancesByName.end());
  auto* objectInstance = iter->second;
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  mObjectInstancesByName.erase(iter);
  mObjectInstancesByHandle.erase(theObject);
}

IFlexRayController* FlexRayControllerObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IFlexRayController* FlexRayControllerObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IFlexRayController* FlexRayControllerObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"FlexRayController");
  }
  FlexRayController* newObject = new FlexRayController(this, instanceName, mRtiAmbassador);
  ObjectClassRegistry::GetInstance()->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
    }
  });
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  return newObject;
}

rti1516ev::AttributeHandleSet FlexRayControllerObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetNetworkIDAttributeHandle());
  result.insert(GetDeviceIDAttributeHandle());
  result.insert(GetPocRequestAttributeHandle());
  result.insert(GetChiCommandAttributeHandle());
  result.insert(GetpAllowHaltDueToClockAttributeHandle());
  result.insert(GetpAllowPassiveToActiveAttributeHandle());
  result.insert(GetpChannelsAttributeHandle());
  result.insert(GetpClusterDriftDampingAttributeHandle());
  result.insert(GetpdAcceptedStartupRangeAttributeHandle());
  result.insert(GetpdListenTimeoutAttributeHandle());
  result.insert(GetpKeySlotIdAttributeHandle());
  result.insert(GetpKeySlotOnlyEnabledAttributeHandle());
  result.insert(GetpKeySlotUsedForStartupAttributeHandle());
  result.insert(GetpKeySlotUsedForSyncAttributeHandle());
  result.insert(GetpLatestTxAttributeHandle());
  result.insert(GetpMacroInitialOffsetAAttributeHandle());
  result.insert(GetpMacroInitialOffsetBAttributeHandle());
  result.insert(GetpMicroInitialOffsetAAttributeHandle());
  result.insert(GetpMicroInitialOffsetBAttributeHandle());
  result.insert(GetpMicroPerCycleAttributeHandle());
  result.insert(GetpOffsetCorrectionOutAttributeHandle());
  result.insert(GetpOffsetCorrectionStartAttributeHandle());
  result.insert(GetpRateCorrectionOutAttributeHandle());
  result.insert(GetpWakeupChannelAttributeHandle());
  result.insert(GetpWakeupPatternAttributeHandle());
  result.insert(GetpdMicrotickAttributeHandle());
  result.insert(GetpSamplesPerMicrotickAttributeHandle());
  return result;
}

uint32_t FlexRayControllerObjectClass::RegisterDiscoverCallback(DiscoverCallbackType callback)
{
  mLastCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void FlexRayControllerObjectClass::UnregisterDiscoverCallback(uint32_t callbackToken)
{
  mDiscoverCallbacks.erase(callbackToken);
}

void FlexRayControllerObjectClass::ExecuteDiscoverCallbacks(IFlexRayController* newObjectInstance)
{
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

// object instances of type 'FlexRayController'
FlexRayController::FlexRayController()
{
}

FlexRayController::FlexRayController(FlexRayControllerObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mObjectClass(objectClass)
  , mInstanceName(instanceName)
  , mRtiAmbassador(rtiAmbassador)
{
}

FlexRayController::~FlexRayController()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

// attribute FlexRayController.HLAprivilegeToDeleteObject : no data type

// attribute NetworkID : HLAASCIIstring
std::string FlexRayController::GetNetworkID() const
{
  return mNetworkID.get();
}

void FlexRayController::SetNetworkID(const std::string& newValue)
{
  // CanTranslateToCpp=True
  mNetworkID.set(newValue);
  mDirty |= kNetworkIDBit;
}

// attribute DeviceID : HLAASCIIstring
std::string FlexRayController::GetDeviceID() const
{
  return mDeviceID.get();
}

void FlexRayController::SetDeviceID(const std::string& newValue)
{
  // CanTranslateToCpp=True
  mDeviceID.set(newValue);
  mDirty |= kDeviceIDBit;
}

// attribute PocRequest : FlexRayPocState
FlexRayPocState FlexRayController::GetPocRequest() const
{
  return static_cast<FlexRayPocState>(mPocRequest.get());
}

void FlexRayController::SetPocRequest(FlexRayPocState newValue)
{
  // CanTranslateToCpp=True
  mPocRequest.set(static_cast<uint8_t>(newValue));
  mDirty |= kPocRequestBit;
}

// attribute ChiCommand : FlexRayChiCommand
FlexRayChiCommand FlexRayController::GetChiCommand() const
{
  return static_cast<FlexRayChiCommand>(mChiCommand.get());
}

void FlexRayController::SetChiCommand(FlexRayChiCommand newValue)
{
  // CanTranslateToCpp=True
  mChiCommand.set(static_cast<uint8_t>(newValue));
  mDirty |= kChiCommandBit;
}

// attribute pAllowHaltDueToClock : HLAoctet
uint8_t FlexRayController::GetpAllowHaltDueToClock() const
{
  return mpAllowHaltDueToClock.get();
}

void FlexRayController::SetpAllowHaltDueToClock(uint8_t newValue)
{
  // CanTranslateToCpp=True
  mpAllowHaltDueToClock.set(newValue);
  mDirty |= kpAllowHaltDueToClockBit;
}

// attribute pAllowPassiveToActive : HLAoctet
uint8_t FlexRayController::GetpAllowPassiveToActive() const
{
  return mpAllowPassiveToActive.get();
}

void FlexRayController::SetpAllowPassiveToActive(uint8_t newValue)
{
  // CanTranslateToCpp=True
  mpAllowPassiveToActive.set(newValue);
  mDirty |= kpAllowPassiveToActiveBit;
}

// attribute pChannels : FlexRayChannel
FlexRayChannel FlexRayController::GetpChannels() const
{
  return static_cast<FlexRayChannel>(mpChannels.get());
}

void FlexRayController::SetpChannels(FlexRayChannel newValue)
{
  // CanTranslateToCpp=True
  mpChannels.set(static_cast<uint8_t>(newValue));
  mDirty |= kpChannelsBit;
}

// attribute pClusterDriftDamping : HLAoctet
uint8_t FlexRayController::GetpClusterDriftDamping() const
{
  return mpClusterDriftDamping.get();
}

void FlexRayController::SetpClusterDriftDamping(uint8_t newValue)
{
  // CanTranslateToCpp=True
  mpClusterDriftDamping.set(newValue);
  mDirty |= kpClusterDriftDampingBit;
}

// attribute pdAcceptedStartupRange : HLAinteger32LE
int32_t FlexRayController::GetpdAcceptedStartupRange() const
{
  return mpdAcceptedStartupRange.get();
}

void FlexRayController::SetpdAcceptedStartupRange(int32_t newValue)
{
  // CanTranslateToCpp=True
  mpdAcceptedStartupRange.set(newValue);
  mDirty |= kpdAcceptedStartupRangeBit;
}

// attribute pdListenTimeout : HLAinteger32LE
int32_t FlexRayController::GetpdListenTimeout() const
{
  return mpdListenTimeout.get();
}

void FlexRayController::SetpdListenTimeout(int32_t newValue)
{
  // CanTranslateToCpp=True
  mpdListenTimeout.set(newValue);
  mDirty |= kpdListenTimeoutBit;
}

// attribute pKeySlotId : HLAinteger16LE
int16_t FlexRayController::GetpKeySlotId() const
{
  return mpKeySlotId.get();
}

void FlexRayController::SetpKeySlotId(int16_t newValue)
{
  // CanTranslateToCpp=True
  mpKeySlotId.set(newValue);
  mDirty |= kpKeySlotIdBit;
}

// attribute pKeySlotOnlyEnabled : HLAoctet
uint8_t FlexRayController::GetpKeySlotOnlyEnabled() const
{
  return mpKeySlotOnlyEnabled.get();
}

void FlexRayController::SetpKeySlotOnlyEnabled(uint8_t newValue)
{
  // CanTranslateToCpp=True
  mpKeySlotOnlyEnabled.set(newValue);
  mDirty |= kpKeySlotOnlyEnabledBit;
}

// attribute pKeySlotUsedForStartup : HLAoctet
uint8_t FlexRayController::GetpKeySlotUsedForStartup() const
{
  return mpKeySlotUsedForStartup.get();
}

void FlexRayController::SetpKeySlotUsedForStartup(uint8_t newValue)
{
  // CanTranslateToCpp=True
  mpKeySlotUsedForStartup.set(newValue);
  mDirty |= kpKeySlotUsedForStartupBit;
}

// attribute pKeySlotUsedForSync : HLAoctet
uint8_t FlexRayController::GetpKeySlotUsedForSync() const
{
  return mpKeySlotUsedForSync.get();
}

void FlexRayController::SetpKeySlotUsedForSync(uint8_t newValue)
{
  // CanTranslateToCpp=True
  mpKeySlotUsedForSync.set(newValue);
  mDirty |= kpKeySlotUsedForSyncBit;
}

// attribute pLatestTx : HLAinteger16LE
int16_t FlexRayController::GetpLatestTx() const
{
  return mpLatestTx.get();
}

void FlexRayController::SetpLatestTx(int16_t newValue)
{
  // CanTranslateToCpp=True
  mpLatestTx.set(newValue);
  mDirty |= kpLatestTxBit;
}

// attribute pMacroInitialOffsetA : HLAoctet
uint8_t FlexRayController::GetpMacroInitialOffsetA() const
{
  return mpMacroInitialOffsetA.get();
}

void FlexRayController::SetpMacroInitialOffsetA(uint8_t newValue)
{
  // CanTranslateToCpp=True
  mpMacroInitialOffsetA.set(newValue);
  mDirty |= kpMacroInitialOffsetABit;
}

// attribute pMacroInitialOffsetB : HLAoctet
uint8_t FlexRayController::GetpMacroInitialOffsetB() const
{
  return mpMacroInitialOffsetB.get();
}

void FlexRayController::SetpMacroInitialOffsetB(uint8_t newValue)
{
  // CanTranslateToCpp=True
  mpMacroInitialOffsetB.set(newValue);
  mDirty |= kpMacroInitialOffsetBBit;
}

// attribute pMicroInitialOffsetA : HLAinteger32LE
int32_t FlexRayController::GetpMicroInitialOffsetA() const
{
  return mpMicroInitialOffsetA.get();
}

void FlexRayController::SetpMicroInitialOffsetA(int32_t newValue)
{
  // CanTranslateToCpp=True
  mpMicroInitialOffsetA.set(newValue);
  mDirty |= kpMicroInitialOffsetABit;
}

// attribute pMicroInitialOffsetB : HLAinteger32LE
int32_t FlexRayController::GetpMicroInitialOffsetB() const
{
  return mpMicroInitialOffsetB.get();
}

void FlexRayController::SetpMicroInitialOffsetB(int32_t newValue)
{
  // CanTranslateToCpp=True
  mpMicroInitialOffsetB.set(newValue);
  mDirty |= kpMicroInitialOffsetBBit;
}

// attribute pMicroPerCycle : HLAinteger32LE
int32_t FlexRayController::GetpMicroPerCycle() const
{
  return mpMicroPerCycle.get();
}

void FlexRayController::SetpMicroPerCycle(int32_t newValue)
{
  // CanTranslateToCpp=True
  mpMicroPerCycle.set(newValue);
  mDirty |= kpMicroPerCycleBit;
}

// attribute pOffsetCorrectionOut : HLAinteger32LE
int32_t FlexRayController::GetpOffsetCorrectionOut() const
{
  return mpOffsetCorrectionOut.get();
}

void FlexRayController::SetpOffsetCorrectionOut(int32_t newValue)
{
  // CanTranslateToCpp=True
  mpOffsetCorrectionOut.set(newValue);
  mDirty |= kpOffsetCorrectionOutBit;
}

// attribute pOffsetCorrectionStart : HLAinteger16LE
int16_t FlexRayController::GetpOffsetCorrectionStart() const
{
  return mpOffsetCorrectionStart.get();
}

void FlexRayController::SetpOffsetCorrectionStart(int16_t newValue)
{
  // CanTranslateToCpp=True
  mpOffsetCorrectionStart.set(newValue);
  mDirty |= kpOffsetCorrectionStartBit;
}

// attribute pRateCorrectionOut : HLAinteger32LE
int32_t FlexRayController::GetpRateCorrectionOut() const
{
  return mpRateCorrectionOut.get();
}

void FlexRayController::SetpRateCorrectionOut(int32_t newValue)
{
  // CanTranslateToCpp=True
  mpRateCorrectionOut.set(newValue);
  mDirty |= kpRateCorrectionOutBit;
}

// attribute pWakeupChannel : FlexRayChannel
FlexRayChannel FlexRayController::GetpWakeupChannel() const
{
  return static_cast<FlexRayChannel>(mpWakeupChannel.get());
}

void FlexRayController::SetpWakeupChannel(FlexRayChannel newValue)
{
  // CanTranslateToCpp=True
  mpWakeupChannel.set(static_cast<uint8_t>(newValue));
  mDirty |= kpWakeupChannelBit;
}

// attribute pWakeupPattern : HLAoctet
uint8_t FlexRayController::GetpWakeupPattern() const
{
  return mpWakeupPattern.get();
}

void FlexRayController::SetpWakeupPattern(uint8_t newValue)
{
  // CanTranslateToCpp=True
  mpWakeupPattern.set(newValue);
  mDirty |= kpWakeupPatternBit;
}

// attribute pdMicrotick : FlexRayClockPeriod
FlexRayClockPeriod FlexRayController::GetpdMicrotick() const
{
  return static_cast<FlexRayClockPeriod>(mpdMicrotick.get());
}

void FlexRayController::SetpdMicrotick(FlexRayClockPeriod newValue)
{
  // CanTranslateToCpp=True
  mpdMicrotick.set(static_cast<uint8_t>(newValue));
  mDirty |= kpdMicrotickBit;
}

// attribute pSamplesPerMicrotick : HLAoctet
uint8_t FlexRayController::GetpSamplesPerMicrotick() const
{
  return mpSamplesPerMicrotick.get();
}

void FlexRayController::SetpSamplesPerMicrotick(uint8_t newValue)
{
  // CanTranslateToCpp=True
  mpSamplesPerMicrotick.set(newValue);
  mDirty |= kpSamplesPerMicrotickBit;
}

rti1516ev::AttributeHandleValueMap FlexRayController::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  result[mObjectClass->GetDeviceIDAttributeHandle()] = mDeviceID.encode();
  result[mObjectClass->GetPocRequestAttributeHandle()] = mPocRequest.encode();
  result[mObjectClass->GetChiCommandAttributeHandle()] = mChiCommand.encode();
  result[mObjectClass->GetpAllowHaltDueToClockAttributeHandle()] = mpAllowHaltDueToClock.encode();
  result[mObjectClass->GetpAllowPassiveToActiveAttributeHandle()] = mpAllowPassiveToActive.encode();
  result[mObjectClass->GetpChannelsAttributeHandle()] = mpChannels.encode();
  result[mObjectClass->GetpClusterDriftDampingAttributeHandle()] = mpClusterDriftDamping.encode();
  result[mObjectClass->GetpdAcceptedStartupRangeAttributeHandle()] = mpdAcceptedStartupRange.encode();
  result[mObjectClass->GetpdListenTimeoutAttributeHandle()] = mpdListenTimeout.encode();
  result[mObjectClass->GetpKeySlotIdAttributeHandle()] = mpKeySlotId.encode();
  result[mObjectClass->GetpKeySlotOnlyEnabledAttributeHandle()] = mpKeySlotOnlyEnabled.encode();
  result[mObjectClass->GetpKeySlotUsedForStartupAttributeHandle()] = mpKeySlotUsedForStartup.encode();
  result[mObjectClass->GetpKeySlotUsedForSyncAttributeHandle()] = mpKeySlotUsedForSync.encode();
  result[mObjectClass->GetpLatestTxAttributeHandle()] = mpLatestTx.encode();
  result[mObjectClass->GetpMacroInitialOffsetAAttributeHandle()] = mpMacroInitialOffsetA.encode();
  result[mObjectClass->GetpMacroInitialOffsetBAttributeHandle()] = mpMacroInitialOffsetB.encode();
  result[mObjectClass->GetpMicroInitialOffsetAAttributeHandle()] = mpMicroInitialOffsetA.encode();
  result[mObjectClass->GetpMicroInitialOffsetBAttributeHandle()] = mpMicroInitialOffsetB.encode();
  result[mObjectClass->GetpMicroPerCycleAttributeHandle()] = mpMicroPerCycle.encode();
  result[mObjectClass->GetpOffsetCorrectionOutAttributeHandle()] = mpOffsetCorrectionOut.encode();
  result[mObjectClass->GetpOffsetCorrectionStartAttributeHandle()] = mpOffsetCorrectionStart.encode();
  result[mObjectClass->GetpRateCorrectionOutAttributeHandle()] = mpRateCorrectionOut.encode();
  result[mObjectClass->GetpWakeupChannelAttributeHandle()] = mpWakeupChannel.encode();
  result[mObjectClass->GetpWakeupPatternAttributeHandle()] = mpWakeupPattern.encode();
  result[mObjectClass->GetpdMicrotickAttributeHandle()] = mpdMicrotick.encode();
  result[mObjectClass->GetpSamplesPerMicrotickAttributeHandle()] = mpSamplesPerMicrotick.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap FlexRayController::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kPocRequestBit)
  {
    result[mObjectClass->GetPocRequestAttributeHandle()] = mPocRequest.encode();
  }
  if (mDirty & kChiCommandBit)
  {
    result[mObjectClass->GetChiCommandAttributeHandle()] = mChiCommand.encode();
  }
  if (mDirty & kpAllowHaltDueToClockBit)
  {
    result[mObjectClass->GetpAllowHaltDueToClockAttributeHandle()] = mpAllowHaltDueToClock.encode();
  }
  if (mDirty & kpAllowPassiveToActiveBit)
  {
    result[mObjectClass->GetpAllowPassiveToActiveAttributeHandle()] = mpAllowPassiveToActive.encode();
  }
  if (mDirty & kpChannelsBit)
  {
    result[mObjectClass->GetpChannelsAttributeHandle()] = mpChannels.encode();
  }
  if (mDirty & kpClusterDriftDampingBit)
  {
    result[mObjectClass->GetpClusterDriftDampingAttributeHandle()] = mpClusterDriftDamping.encode();
  }
  if (mDirty & kpdAcceptedStartupRangeBit)
  {
    result[mObjectClass->GetpdAcceptedStartupRangeAttributeHandle()] = mpdAcceptedStartupRange.encode();
  }
  if (mDirty & kpdListenTimeoutBit)
  {
    result[mObjectClass->GetpdListenTimeoutAttributeHandle()] = mpdListenTimeout.encode();
  }
  if (mDirty & kpKeySlotIdBit)
  {
    result[mObjectClass->GetpKeySlotIdAttributeHandle()] = mpKeySlotId.encode();
  }
  if (mDirty & kpKeySlotOnlyEnabledBit)
  {
    result[mObjectClass->GetpKeySlotOnlyEnabledAttributeHandle()] = mpKeySlotOnlyEnabled.encode();
  }
  if (mDirty & kpKeySlotUsedForStartupBit)
  {
    result[mObjectClass->GetpKeySlotUsedForStartupAttributeHandle()] = mpKeySlotUsedForStartup.encode();
  }
  if (mDirty & kpKeySlotUsedForSyncBit)
  {
    result[mObjectClass->GetpKeySlotUsedForSyncAttributeHandle()] = mpKeySlotUsedForSync.encode();
  }
  if (mDirty & kpLatestTxBit)
  {
    result[mObjectClass->GetpLatestTxAttributeHandle()] = mpLatestTx.encode();
  }
  if (mDirty & kpMacroInitialOffsetABit)
  {
    result[mObjectClass->GetpMacroInitialOffsetAAttributeHandle()] = mpMacroInitialOffsetA.encode();
  }
  if (mDirty & kpMacroInitialOffsetBBit)
  {
    result[mObjectClass->GetpMacroInitialOffsetBAttributeHandle()] = mpMacroInitialOffsetB.encode();
  }
  if (mDirty & kpMicroInitialOffsetABit)
  {
    result[mObjectClass->GetpMicroInitialOffsetAAttributeHandle()] = mpMicroInitialOffsetA.encode();
  }
  if (mDirty & kpMicroInitialOffsetBBit)
  {
    result[mObjectClass->GetpMicroInitialOffsetBAttributeHandle()] = mpMicroInitialOffsetB.encode();
  }
  if (mDirty & kpMicroPerCycleBit)
  {
    result[mObjectClass->GetpMicroPerCycleAttributeHandle()] = mpMicroPerCycle.encode();
  }
  if (mDirty & kpOffsetCorrectionOutBit)
  {
    result[mObjectClass->GetpOffsetCorrectionOutAttributeHandle()] = mpOffsetCorrectionOut.encode();
  }
  if (mDirty & kpOffsetCorrectionStartBit)
  {
    result[mObjectClass->GetpOffsetCorrectionStartAttributeHandle()] = mpOffsetCorrectionStart.encode();
  }
  if (mDirty & kpRateCorrectionOutBit)
  {
    result[mObjectClass->GetpRateCorrectionOutAttributeHandle()] = mpRateCorrectionOut.encode();
  }
  if (mDirty & kpWakeupChannelBit)
  {
    result[mObjectClass->GetpWakeupChannelAttributeHandle()] = mpWakeupChannel.encode();
  }
  if (mDirty & kpWakeupPatternBit)
  {
    result[mObjectClass->GetpWakeupPatternAttributeHandle()] = mpWakeupPattern.encode();
  }
  if (mDirty & kpdMicrotickBit)
  {
    result[mObjectClass->GetpdMicrotickAttributeHandle()] = mpdMicrotick.encode();
  }
  if (mDirty & kpSamplesPerMicrotickBit)
  {
    result[mObjectClass->GetpSamplesPerMicrotickAttributeHandle()] = mpSamplesPerMicrotick.encode();
  }
  return result;
}

void FlexRayController::UpdateAllAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
  }
}

void FlexRayController::UpdateAllAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
  }
}

void FlexRayController::UpdateModifiedAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
    mDirty = kNone;
  }
}

void FlexRayController::UpdateModifiedAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
    mDirty = kNone;
  }
}

void FlexRayController::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetPocRequestAttributeHandle())
    {
      mPocRequest.decode(attributeHandleValue.second);
      mLastUpdated |= kPocRequestBit;
    }
    else if (attributeHandle == mObjectClass->GetChiCommandAttributeHandle())
    {
      mChiCommand.decode(attributeHandleValue.second);
      mLastUpdated |= kChiCommandBit;
    }
    else if (attributeHandle == mObjectClass->GetpAllowHaltDueToClockAttributeHandle())
    {
      mpAllowHaltDueToClock.decode(attributeHandleValue.second);
      mLastUpdated |= kpAllowHaltDueToClockBit;
    }
    else if (attributeHandle == mObjectClass->GetpAllowPassiveToActiveAttributeHandle())
    {
      mpAllowPassiveToActive.decode(attributeHandleValue.second);
      mLastUpdated |= kpAllowPassiveToActiveBit;
    }
    else if (attributeHandle == mObjectClass->GetpChannelsAttributeHandle())
    {
      mpChannels.decode(attributeHandleValue.second);
      mLastUpdated |= kpChannelsBit;
    }
    else if (attributeHandle == mObjectClass->GetpClusterDriftDampingAttributeHandle())
    {
      mpClusterDriftDamping.decode(attributeHandleValue.second);
      mLastUpdated |= kpClusterDriftDampingBit;
    }
    else if (attributeHandle == mObjectClass->GetpdAcceptedStartupRangeAttributeHandle())
    {
      mpdAcceptedStartupRange.decode(attributeHandleValue.second);
      mLastUpdated |= kpdAcceptedStartupRangeBit;
    }
    else if (attributeHandle == mObjectClass->GetpdListenTimeoutAttributeHandle())
    {
      mpdListenTimeout.decode(attributeHandleValue.second);
      mLastUpdated |= kpdListenTimeoutBit;
    }
    else if (attributeHandle == mObjectClass->GetpKeySlotIdAttributeHandle())
    {
      mpKeySlotId.decode(attributeHandleValue.second);
      mLastUpdated |= kpKeySlotIdBit;
    }
    else if (attributeHandle == mObjectClass->GetpKeySlotOnlyEnabledAttributeHandle())
    {
      mpKeySlotOnlyEnabled.decode(attributeHandleValue.second);
      mLastUpdated |= kpKeySlotOnlyEnabledBit;
    }
    else if (attributeHandle == mObjectClass->GetpKeySlotUsedForStartupAttributeHandle())
    {
      mpKeySlotUsedForStartup.decode(attributeHandleValue.second);
      mLastUpdated |= kpKeySlotUsedForStartupBit;
    }
    else if (attributeHandle == mObjectClass->GetpKeySlotUsedForSyncAttributeHandle())
    {
      mpKeySlotUsedForSync.decode(attributeHandleValue.second);
      mLastUpdated |= kpKeySlotUsedForSyncBit;
    }
    else if (attributeHandle == mObjectClass->GetpLatestTxAttributeHandle())
    {
      mpLatestTx.decode(attributeHandleValue.second);
      mLastUpdated |= kpLatestTxBit;
    }
    else if (attributeHandle == mObjectClass->GetpMacroInitialOffsetAAttributeHandle())
    {
      mpMacroInitialOffsetA.decode(attributeHandleValue.second);
      mLastUpdated |= kpMacroInitialOffsetABit;
    }
    else if (attributeHandle == mObjectClass->GetpMacroInitialOffsetBAttributeHandle())
    {
      mpMacroInitialOffsetB.decode(attributeHandleValue.second);
      mLastUpdated |= kpMacroInitialOffsetBBit;
    }
    else if (attributeHandle == mObjectClass->GetpMicroInitialOffsetAAttributeHandle())
    {
      mpMicroInitialOffsetA.decode(attributeHandleValue.second);
      mLastUpdated |= kpMicroInitialOffsetABit;
    }
    else if (attributeHandle == mObjectClass->GetpMicroInitialOffsetBAttributeHandle())
    {
      mpMicroInitialOffsetB.decode(attributeHandleValue.second);
      mLastUpdated |= kpMicroInitialOffsetBBit;
    }
    else if (attributeHandle == mObjectClass->GetpMicroPerCycleAttributeHandle())
    {
      mpMicroPerCycle.decode(attributeHandleValue.second);
      mLastUpdated |= kpMicroPerCycleBit;
    }
    else if (attributeHandle == mObjectClass->GetpOffsetCorrectionOutAttributeHandle())
    {
      mpOffsetCorrectionOut.decode(attributeHandleValue.second);
      mLastUpdated |= kpOffsetCorrectionOutBit;
    }
    else if (attributeHandle == mObjectClass->GetpOffsetCorrectionStartAttributeHandle())
    {
      mpOffsetCorrectionStart.decode(attributeHandleValue.second);
      mLastUpdated |= kpOffsetCorrectionStartBit;
    }
    else if (attributeHandle == mObjectClass->GetpRateCorrectionOutAttributeHandle())
    {
      mpRateCorrectionOut.decode(attributeHandleValue.second);
      mLastUpdated |= kpRateCorrectionOutBit;
    }
    else if (attributeHandle == mObjectClass->GetpWakeupChannelAttributeHandle())
    {
      mpWakeupChannel.decode(attributeHandleValue.second);
      mLastUpdated |= kpWakeupChannelBit;
    }
    else if (attributeHandle == mObjectClass->GetpWakeupPatternAttributeHandle())
    {
      mpWakeupPattern.decode(attributeHandleValue.second);
      mLastUpdated |= kpWakeupPatternBit;
    }
    else if (attributeHandle == mObjectClass->GetpdMicrotickAttributeHandle())
    {
      mpdMicrotick.decode(attributeHandleValue.second);
      mLastUpdated |= kpdMicrotickBit;
    }
    else if (attributeHandle == mObjectClass->GetpSamplesPerMicrotickAttributeHandle())
    {
      mpSamplesPerMicrotick.decode(attributeHandleValue.second);
      mLastUpdated |= kpSamplesPerMicrotickBit;
    }
  } // for (auto& attributeHandleValue : attributes)
    ExecuteUpdateCallbacks();
} // FlexRayController::ReflectAttributeValues

void FlexRayController::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  if ((mLastUpdated & kPocRequestBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetPocRequestAttributeHandle());
  }
  if ((mLastUpdated & kChiCommandBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetChiCommandAttributeHandle());
  }
  if ((mLastUpdated & kpAllowHaltDueToClockBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetpAllowHaltDueToClockAttributeHandle());
  }
  if ((mLastUpdated & kpAllowPassiveToActiveBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetpAllowPassiveToActiveAttributeHandle());
  }
  if ((mLastUpdated & kpChannelsBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetpChannelsAttributeHandle());
  }
  if ((mLastUpdated & kpClusterDriftDampingBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetpClusterDriftDampingAttributeHandle());
  }
  if ((mLastUpdated & kpdAcceptedStartupRangeBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetpdAcceptedStartupRangeAttributeHandle());
  }
  if ((mLastUpdated & kpdListenTimeoutBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetpdListenTimeoutAttributeHandle());
  }
  if ((mLastUpdated & kpKeySlotIdBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetpKeySlotIdAttributeHandle());
  }
  if ((mLastUpdated & kpKeySlotOnlyEnabledBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetpKeySlotOnlyEnabledAttributeHandle());
  }
  if ((mLastUpdated & kpKeySlotUsedForStartupBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetpKeySlotUsedForStartupAttributeHandle());
  }
  if ((mLastUpdated & kpKeySlotUsedForSyncBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetpKeySlotUsedForSyncAttributeHandle());
  }
  if ((mLastUpdated & kpLatestTxBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetpLatestTxAttributeHandle());
  }
  if ((mLastUpdated & kpMacroInitialOffsetABit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetpMacroInitialOffsetAAttributeHandle());
  }
  if ((mLastUpdated & kpMacroInitialOffsetBBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetpMacroInitialOffsetBAttributeHandle());
  }
  if ((mLastUpdated & kpMicroInitialOffsetABit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetpMicroInitialOffsetAAttributeHandle());
  }
  if ((mLastUpdated & kpMicroInitialOffsetBBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetpMicroInitialOffsetBAttributeHandle());
  }
  if ((mLastUpdated & kpMicroPerCycleBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetpMicroPerCycleAttributeHandle());
  }
  if ((mLastUpdated & kpOffsetCorrectionOutBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetpOffsetCorrectionOutAttributeHandle());
  }
  if ((mLastUpdated & kpOffsetCorrectionStartBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetpOffsetCorrectionStartAttributeHandle());
  }
  if ((mLastUpdated & kpRateCorrectionOutBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetpRateCorrectionOutAttributeHandle());
  }
  if ((mLastUpdated & kpWakeupChannelBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetpWakeupChannelAttributeHandle());
  }
  if ((mLastUpdated & kpWakeupPatternBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetpWakeupPatternAttributeHandle());
  }
  if ((mLastUpdated & kpdMicrotickBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetpdMicrotickAttributeHandle());
  }
  if ((mLastUpdated & kpSamplesPerMicrotickBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetpSamplesPerMicrotickAttributeHandle());
  }
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void FlexRayController::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetPocRequestAttributeHandle());
  requestAttributes.insert(mObjectClass->GetChiCommandAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpAllowHaltDueToClockAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpAllowPassiveToActiveAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpChannelsAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpClusterDriftDampingAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpdAcceptedStartupRangeAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpdListenTimeoutAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpKeySlotIdAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpKeySlotOnlyEnabledAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpKeySlotUsedForStartupAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpKeySlotUsedForSyncAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpLatestTxAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpMacroInitialOffsetAAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpMacroInitialOffsetBAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpMicroInitialOffsetAAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpMicroInitialOffsetBAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpMicroPerCycleAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpOffsetCorrectionOutAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpOffsetCorrectionStartAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpRateCorrectionOutAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpWakeupChannelAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpWakeupPatternAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpdMicrotickAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpSamplesPerMicrotickAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void FlexRayController::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  for (auto& attributeHandle : attributeHandles)
  {
    if (attributeHandle == mObjectClass->GetPocRequestAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mPocRequest.encode()));
      mDirty &= ~kPocRequestBit;
    }
    else if (attributeHandle == mObjectClass->GetChiCommandAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mChiCommand.encode()));
      mDirty &= ~kChiCommandBit;
    }
    else if (attributeHandle == mObjectClass->GetpAllowHaltDueToClockAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mpAllowHaltDueToClock.encode()));
      mDirty &= ~kpAllowHaltDueToClockBit;
    }
    else if (attributeHandle == mObjectClass->GetpAllowPassiveToActiveAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mpAllowPassiveToActive.encode()));
      mDirty &= ~kpAllowPassiveToActiveBit;
    }
    else if (attributeHandle == mObjectClass->GetpChannelsAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mpChannels.encode()));
      mDirty &= ~kpChannelsBit;
    }
    else if (attributeHandle == mObjectClass->GetpClusterDriftDampingAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mpClusterDriftDamping.encode()));
      mDirty &= ~kpClusterDriftDampingBit;
    }
    else if (attributeHandle == mObjectClass->GetpdAcceptedStartupRangeAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mpdAcceptedStartupRange.encode()));
      mDirty &= ~kpdAcceptedStartupRangeBit;
    }
    else if (attributeHandle == mObjectClass->GetpdListenTimeoutAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mpdListenTimeout.encode()));
      mDirty &= ~kpdListenTimeoutBit;
    }
    else if (attributeHandle == mObjectClass->GetpKeySlotIdAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mpKeySlotId.encode()));
      mDirty &= ~kpKeySlotIdBit;
    }
    else if (attributeHandle == mObjectClass->GetpKeySlotOnlyEnabledAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mpKeySlotOnlyEnabled.encode()));
      mDirty &= ~kpKeySlotOnlyEnabledBit;
    }
    else if (attributeHandle == mObjectClass->GetpKeySlotUsedForStartupAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mpKeySlotUsedForStartup.encode()));
      mDirty &= ~kpKeySlotUsedForStartupBit;
    }
    else if (attributeHandle == mObjectClass->GetpKeySlotUsedForSyncAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mpKeySlotUsedForSync.encode()));
      mDirty &= ~kpKeySlotUsedForSyncBit;
    }
    else if (attributeHandle == mObjectClass->GetpLatestTxAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mpLatestTx.encode()));
      mDirty &= ~kpLatestTxBit;
    }
    else if (attributeHandle == mObjectClass->GetpMacroInitialOffsetAAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mpMacroInitialOffsetA.encode()));
      mDirty &= ~kpMacroInitialOffsetABit;
    }
    else if (attributeHandle == mObjectClass->GetpMacroInitialOffsetBAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mpMacroInitialOffsetB.encode()));
      mDirty &= ~kpMacroInitialOffsetBBit;
    }
    else if (attributeHandle == mObjectClass->GetpMicroInitialOffsetAAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mpMicroInitialOffsetA.encode()));
      mDirty &= ~kpMicroInitialOffsetABit;
    }
    else if (attributeHandle == mObjectClass->GetpMicroInitialOffsetBAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mpMicroInitialOffsetB.encode()));
      mDirty &= ~kpMicroInitialOffsetBBit;
    }
    else if (attributeHandle == mObjectClass->GetpMicroPerCycleAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mpMicroPerCycle.encode()));
      mDirty &= ~kpMicroPerCycleBit;
    }
    else if (attributeHandle == mObjectClass->GetpOffsetCorrectionOutAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mpOffsetCorrectionOut.encode()));
      mDirty &= ~kpOffsetCorrectionOutBit;
    }
    else if (attributeHandle == mObjectClass->GetpOffsetCorrectionStartAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mpOffsetCorrectionStart.encode()));
      mDirty &= ~kpOffsetCorrectionStartBit;
    }
    else if (attributeHandle == mObjectClass->GetpRateCorrectionOutAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mpRateCorrectionOut.encode()));
      mDirty &= ~kpRateCorrectionOutBit;
    }
    else if (attributeHandle == mObjectClass->GetpWakeupChannelAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mpWakeupChannel.encode()));
      mDirty &= ~kpWakeupChannelBit;
    }
    else if (attributeHandle == mObjectClass->GetpWakeupPatternAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mpWakeupPattern.encode()));
      mDirty &= ~kpWakeupPatternBit;
    }
    else if (attributeHandle == mObjectClass->GetpdMicrotickAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mpdMicrotick.encode()));
      mDirty &= ~kpdMicrotickBit;
    }
    else if (attributeHandle == mObjectClass->GetpSamplesPerMicrotickAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mpSamplesPerMicrotick.encode()));
      mDirty &= ~kpSamplesPerMicrotickBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // FlexRayController::ReflectAttributeValues

uint32_t FlexRayController::RegisterUpdateCallback(UpdateCallbackType callback)
{
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void FlexRayController::UnregisterUpdateCallback(uint32_t callbackToken)
{
  mUpdateCallbacks.erase(callbackToken);
}

void FlexRayController::ExecuteUpdateCallbacks()
{
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(this);
  }
}

// object class type 'FlexRaySendBuffer'
FlexRaySendBufferObjectClass::FlexRaySendBufferObjectClass(rti1516ev::RTIambassador* rtiAmbassador, HLAobjectRootObjectClass* baseClass)
{
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.FlexRaySendBuffer");
  // attribute Sender : HLAhandle
  mSenderAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"Sender");
  // attribute TransmissionMode : FlexRayTransmissionMode
  mTransmissionModeAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"TransmissionMode");
  // attribute Payload : FlexRayPayload
  mPayloadAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"Payload");
  // attribute CycleOffset : HLAoctet
  mCycleOffsetAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"CycleOffset");
  // attribute CycleRepetition : HLAoctet
  mCycleRepetitionAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"CycleRepetition");
  // attribute SlotId : HLAinteger16LE
  mSlotIdAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"SlotId");
  // attribute Channel : FlexRayChannel
  mChannelAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"Channel");
  // attribute PPIndicator : HLAboolean
  mPPIndicatorAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"PPIndicator");
  // attribute HeaderCRC : HLAinteger16LE
  mHeaderCRCAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HeaderCRC");
}

void FlexRaySendBufferObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void FlexRaySendBufferObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void FlexRaySendBufferObjectClass::Subscribe()
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void FlexRaySendBufferObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

void FlexRaySendBufferObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle, const std::wstring& instanceName)
{
  assert(mObjectInstancesByName.find(instanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(instanceHandle) == mObjectInstancesByHandle.end());
  FlexRaySendBuffer* newObject = new FlexRaySendBuffer(this, instanceName, mRtiAmbassador);
  newObject->mObjectInstanceHandle = instanceHandle;
  newObject->mIsOwner = false;
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
}

void FlexRaySendBufferObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject)
{
  std::wstring instanceName = mRtiAmbassador->getObjectInstanceName(theObject);
  auto iter = mObjectInstancesByName.find(instanceName);
  assert(iter != mObjectInstancesByName.end());
  auto* objectInstance = iter->second;
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  mObjectInstancesByName.erase(iter);
  mObjectInstancesByHandle.erase(theObject);
}

IFlexRaySendBuffer* FlexRaySendBufferObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IFlexRaySendBuffer* FlexRaySendBufferObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

IFlexRaySendBuffer* FlexRaySendBufferObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"FlexRaySendBuffer");
  }
  FlexRaySendBuffer* newObject = new FlexRaySendBuffer(this, instanceName, mRtiAmbassador);
  ObjectClassRegistry::GetInstance()->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      mObjectInstancesByHandle.insert(std::make_pair(instanceHandle, newObject));
    }
  });
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  return newObject;
}

rti1516ev::AttributeHandleSet FlexRaySendBufferObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetSenderAttributeHandle());
  result.insert(GetTransmissionModeAttributeHandle());
  result.insert(GetPayloadAttributeHandle());
  result.insert(GetCycleOffsetAttributeHandle());
  result.insert(GetCycleRepetitionAttributeHandle());
  result.insert(GetSlotIdAttributeHandle());
  result.insert(GetChannelAttributeHandle());
  result.insert(GetPPIndicatorAttributeHandle());
  result.insert(GetHeaderCRCAttributeHandle());
  return result;
}

uint32_t FlexRaySendBufferObjectClass::RegisterDiscoverCallback(DiscoverCallbackType callback)
{
  mLastCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void FlexRaySendBufferObjectClass::UnregisterDiscoverCallback(uint32_t callbackToken)
{
  mDiscoverCallbacks.erase(callbackToken);
}

void FlexRaySendBufferObjectClass::ExecuteDiscoverCallbacks(IFlexRaySendBuffer* newObjectInstance)
{
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

// object instances of type 'FlexRaySendBuffer'
FlexRaySendBuffer::FlexRaySendBuffer()
{
}

FlexRaySendBuffer::FlexRaySendBuffer(FlexRaySendBufferObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mObjectClass(objectClass)
  , mInstanceName(instanceName)
  , mRtiAmbassador(rtiAmbassador)
{
}

FlexRaySendBuffer::~FlexRaySendBuffer()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

// attribute FlexRaySendBuffer.HLAprivilegeToDeleteObject : no data type

// attribute Sender : HLAhandle
rti1516ev::HLAhandle FlexRaySendBuffer::GetSender() const
{
  return mSender;
}

void FlexRaySendBuffer::SetSender(rti1516ev::HLAhandle newValue)
{
  // CanTranslateToCpp=False
  mSender.set(newValue);
  mDirty |= kSenderBit;
}

// attribute TransmissionMode : FlexRayTransmissionMode
FlexRayTransmissionMode FlexRaySendBuffer::GetTransmissionMode() const
{
  return static_cast<FlexRayTransmissionMode>(mTransmissionMode.get());
}

void FlexRaySendBuffer::SetTransmissionMode(FlexRayTransmissionMode newValue)
{
  // CanTranslateToCpp=True
  mTransmissionMode.set(static_cast<uint8_t>(newValue));
  mDirty |= kTransmissionModeBit;
}

// attribute Payload : FlexRayPayload
const FlexRayPayload& FlexRaySendBuffer::GetPayload() const
{
  return mPayload;
}

void FlexRaySendBuffer::SetPayload(const FlexRayPayload& newValue)
{
  // CanTranslateToCpp=True
  mPayload = newValue;
  mDirty |= kPayloadBit;
}

// attribute CycleOffset : HLAoctet
uint8_t FlexRaySendBuffer::GetCycleOffset() const
{
  return mCycleOffset.get();
}

void FlexRaySendBuffer::SetCycleOffset(uint8_t newValue)
{
  // CanTranslateToCpp=True
  mCycleOffset.set(newValue);
  mDirty |= kCycleOffsetBit;
}

// attribute CycleRepetition : HLAoctet
uint8_t FlexRaySendBuffer::GetCycleRepetition() const
{
  return mCycleRepetition.get();
}

void FlexRaySendBuffer::SetCycleRepetition(uint8_t newValue)
{
  // CanTranslateToCpp=True
  mCycleRepetition.set(newValue);
  mDirty |= kCycleRepetitionBit;
}

// attribute SlotId : HLAinteger16LE
int16_t FlexRaySendBuffer::GetSlotId() const
{
  return mSlotId.get();
}

void FlexRaySendBuffer::SetSlotId(int16_t newValue)
{
  // CanTranslateToCpp=True
  mSlotId.set(newValue);
  mDirty |= kSlotIdBit;
}

// attribute Channel : FlexRayChannel
FlexRayChannel FlexRaySendBuffer::GetChannel() const
{
  return static_cast<FlexRayChannel>(mChannel.get());
}

void FlexRaySendBuffer::SetChannel(FlexRayChannel newValue)
{
  // CanTranslateToCpp=True
  mChannel.set(static_cast<uint8_t>(newValue));
  mDirty |= kChannelBit;
}

// attribute PPIndicator : HLAboolean
bool FlexRaySendBuffer::GetPPIndicator() const
{
  return mPPIndicator.get();
}

void FlexRaySendBuffer::SetPPIndicator(bool newValue)
{
  // CanTranslateToCpp=True
  mPPIndicator.set(newValue);
  mDirty |= kPPIndicatorBit;
}

// attribute HeaderCRC : HLAinteger16LE
int16_t FlexRaySendBuffer::GetHeaderCRC() const
{
  return mHeaderCRC.get();
}

void FlexRaySendBuffer::SetHeaderCRC(int16_t newValue)
{
  // CanTranslateToCpp=True
  mHeaderCRC.set(newValue);
  mDirty |= kHeaderCRCBit;
}

rti1516ev::AttributeHandleValueMap FlexRaySendBuffer::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetSenderAttributeHandle()] = mSender.encode();
  result[mObjectClass->GetTransmissionModeAttributeHandle()] = mTransmissionMode.encode();
  result[mObjectClass->GetPayloadAttributeHandle()] = mPayload.encode();
  result[mObjectClass->GetCycleOffsetAttributeHandle()] = mCycleOffset.encode();
  result[mObjectClass->GetCycleRepetitionAttributeHandle()] = mCycleRepetition.encode();
  result[mObjectClass->GetSlotIdAttributeHandle()] = mSlotId.encode();
  result[mObjectClass->GetChannelAttributeHandle()] = mChannel.encode();
  result[mObjectClass->GetPPIndicatorAttributeHandle()] = mPPIndicator.encode();
  result[mObjectClass->GetHeaderCRCAttributeHandle()] = mHeaderCRC.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap FlexRaySendBuffer::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kSenderBit)
  {
    result[mObjectClass->GetSenderAttributeHandle()] = mSender.encode();
  }
  if (mDirty & kTransmissionModeBit)
  {
    result[mObjectClass->GetTransmissionModeAttributeHandle()] = mTransmissionMode.encode();
  }
  if (mDirty & kPayloadBit)
  {
    result[mObjectClass->GetPayloadAttributeHandle()] = mPayload.encode();
  }
  if (mDirty & kCycleOffsetBit)
  {
    result[mObjectClass->GetCycleOffsetAttributeHandle()] = mCycleOffset.encode();
  }
  if (mDirty & kCycleRepetitionBit)
  {
    result[mObjectClass->GetCycleRepetitionAttributeHandle()] = mCycleRepetition.encode();
  }
  if (mDirty & kSlotIdBit)
  {
    result[mObjectClass->GetSlotIdAttributeHandle()] = mSlotId.encode();
  }
  if (mDirty & kChannelBit)
  {
    result[mObjectClass->GetChannelAttributeHandle()] = mChannel.encode();
  }
  if (mDirty & kPPIndicatorBit)
  {
    result[mObjectClass->GetPPIndicatorAttributeHandle()] = mPPIndicator.encode();
  }
  if (mDirty & kHeaderCRCBit)
  {
    result[mObjectClass->GetHeaderCRCAttributeHandle()] = mHeaderCRC.encode();
  }
  return result;
}

void FlexRaySendBuffer::UpdateAllAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
  }
}

void FlexRaySendBuffer::UpdateAllAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
  }
}

void FlexRaySendBuffer::UpdateModifiedAttributeValues()
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
    mDirty = kNone;
  }
}

void FlexRaySendBuffer::UpdateModifiedAttributeValues(const rti1516ev::LogicalTime& time)
{
  if (IsValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), time);
    mDirty = kNone;
  }
}

void FlexRaySendBuffer::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetSenderAttributeHandle())
    {
      mSender.decode(attributeHandleValue.second);
      mLastUpdated |= kSenderBit;
    }
    else if (attributeHandle == mObjectClass->GetTransmissionModeAttributeHandle())
    {
      mTransmissionMode.decode(attributeHandleValue.second);
      mLastUpdated |= kTransmissionModeBit;
    }
    else if (attributeHandle == mObjectClass->GetPayloadAttributeHandle())
    {
      mPayload.decode(attributeHandleValue.second);
      mLastUpdated |= kPayloadBit;
    }
    else if (attributeHandle == mObjectClass->GetCycleOffsetAttributeHandle())
    {
      mCycleOffset.decode(attributeHandleValue.second);
      mLastUpdated |= kCycleOffsetBit;
    }
    else if (attributeHandle == mObjectClass->GetCycleRepetitionAttributeHandle())
    {
      mCycleRepetition.decode(attributeHandleValue.second);
      mLastUpdated |= kCycleRepetitionBit;
    }
    else if (attributeHandle == mObjectClass->GetSlotIdAttributeHandle())
    {
      mSlotId.decode(attributeHandleValue.second);
      mLastUpdated |= kSlotIdBit;
    }
    else if (attributeHandle == mObjectClass->GetChannelAttributeHandle())
    {
      mChannel.decode(attributeHandleValue.second);
      mLastUpdated |= kChannelBit;
    }
    else if (attributeHandle == mObjectClass->GetPPIndicatorAttributeHandle())
    {
      mPPIndicator.decode(attributeHandleValue.second);
      mLastUpdated |= kPPIndicatorBit;
    }
    else if (attributeHandle == mObjectClass->GetHeaderCRCAttributeHandle())
    {
      mHeaderCRC.decode(attributeHandleValue.second);
      mLastUpdated |= kHeaderCRCBit;
    }
  } // for (auto& attributeHandleValue : attributes)
    ExecuteUpdateCallbacks();
} // FlexRaySendBuffer::ReflectAttributeValues

void FlexRaySendBuffer::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  if ((mLastUpdated & kSenderBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetSenderAttributeHandle());
  }
  if ((mLastUpdated & kTransmissionModeBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetTransmissionModeAttributeHandle());
  }
  if ((mLastUpdated & kPayloadBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetPayloadAttributeHandle());
  }
  if ((mLastUpdated & kCycleOffsetBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetCycleOffsetAttributeHandle());
  }
  if ((mLastUpdated & kCycleRepetitionBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetCycleRepetitionAttributeHandle());
  }
  if ((mLastUpdated & kSlotIdBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetSlotIdAttributeHandle());
  }
  if ((mLastUpdated & kChannelBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetChannelAttributeHandle());
  }
  if ((mLastUpdated & kPPIndicatorBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetPPIndicatorAttributeHandle());
  }
  if ((mLastUpdated & kHeaderCRCBit) == 0)
  {
    requestAttributes.insert(mObjectClass->GetHeaderCRCAttributeHandle());
  }
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void FlexRaySendBuffer::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetSenderAttributeHandle());
  requestAttributes.insert(mObjectClass->GetTransmissionModeAttributeHandle());
  requestAttributes.insert(mObjectClass->GetPayloadAttributeHandle());
  requestAttributes.insert(mObjectClass->GetCycleOffsetAttributeHandle());
  requestAttributes.insert(mObjectClass->GetCycleRepetitionAttributeHandle());
  requestAttributes.insert(mObjectClass->GetSlotIdAttributeHandle());
  requestAttributes.insert(mObjectClass->GetChannelAttributeHandle());
  requestAttributes.insert(mObjectClass->GetPPIndicatorAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHeaderCRCAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

void FlexRaySendBuffer::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  for (auto& attributeHandle : attributeHandles)
  {
    if (attributeHandle == mObjectClass->GetSenderAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mSender.encode()));
      mDirty &= ~kSenderBit;
    }
    else if (attributeHandle == mObjectClass->GetTransmissionModeAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mTransmissionMode.encode()));
      mDirty &= ~kTransmissionModeBit;
    }
    else if (attributeHandle == mObjectClass->GetPayloadAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mPayload.encode()));
      mDirty &= ~kPayloadBit;
    }
    else if (attributeHandle == mObjectClass->GetCycleOffsetAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mCycleOffset.encode()));
      mDirty &= ~kCycleOffsetBit;
    }
    else if (attributeHandle == mObjectClass->GetCycleRepetitionAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mCycleRepetition.encode()));
      mDirty &= ~kCycleRepetitionBit;
    }
    else if (attributeHandle == mObjectClass->GetSlotIdAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mSlotId.encode()));
      mDirty &= ~kSlotIdBit;
    }
    else if (attributeHandle == mObjectClass->GetChannelAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mChannel.encode()));
      mDirty &= ~kChannelBit;
    }
    else if (attributeHandle == mObjectClass->GetPPIndicatorAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mPPIndicator.encode()));
      mDirty &= ~kPPIndicatorBit;
    }
    else if (attributeHandle == mObjectClass->GetHeaderCRCAttributeHandle())
    {
      updateAttributes.insert(std::make_pair(attributeHandle, mHeaderCRC.encode()));
      mDirty &= ~kHeaderCRCBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // FlexRaySendBuffer::ReflectAttributeValues

uint32_t FlexRaySendBuffer::RegisterUpdateCallback(UpdateCallbackType callback)
{
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void FlexRaySendBuffer::UnregisterUpdateCallback(uint32_t callbackToken)
{
  mUpdateCallbacks.erase(callbackToken);
}

void FlexRaySendBuffer::ExecuteUpdateCallbacks()
{
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(this);
  }
}

 

ObjectClassRegistry* ObjectClassRegistry::sClassRegistry = nullptr;

ObjectClassRegistry::ObjectClassRegistry()
{
  assert(sClassRegistry == nullptr);
  sClassRegistry = this;
}

ObjectClassRegistry::~ObjectClassRegistry()
{
  sClassRegistry = nullptr;
}

void ObjectClassRegistry::Initialize(rti1516ev::RTIambassador* rtiAmbassador)
{
  mRtiAmbassador = rtiAmbassador;
  mHLAobjectRootObjectClass = std::unique_ptr<HLAobjectRootObjectClass>(new HLAobjectRootObjectClass(mRtiAmbassador));
  mSystemVariableObjectClass = std::unique_ptr<SystemVariableObjectClass>(new SystemVariableObjectClass(mRtiAmbassador, mHLAobjectRootObjectClass.get()));
  mValueEntityObjectClass = std::unique_ptr<ValueEntityObjectClass>(new ValueEntityObjectClass(mRtiAmbassador, mHLAobjectRootObjectClass.get()));
  mDOMemberSourceObjectClass = std::unique_ptr<DOMemberSourceObjectClass>(new DOMemberSourceObjectClass(mRtiAmbassador, mHLAobjectRootObjectClass.get()));
  mDOMemberTargetObjectClass = std::unique_ptr<DOMemberTargetObjectClass>(new DOMemberTargetObjectClass(mRtiAmbassador, mHLAobjectRootObjectClass.get()));
  mBusManagementObjectClass = std::unique_ptr<BusManagementObjectClass>(new BusManagementObjectClass(mRtiAmbassador, mHLAobjectRootObjectClass.get()));
  mBusManagementCanObjectClass = std::unique_ptr<BusManagementCanObjectClass>(new BusManagementCanObjectClass(mRtiAmbassador, mBusManagementObjectClass.get()));
  mBusManagementEthernetObjectClass = std::unique_ptr<BusManagementEthernetObjectClass>(new BusManagementEthernetObjectClass(mRtiAmbassador, mBusManagementObjectClass.get()));
  mFlexRayClusterObjectClass = std::unique_ptr<FlexRayClusterObjectClass>(new FlexRayClusterObjectClass(mRtiAmbassador, mBusManagementObjectClass.get()));
  mBusControllerObjectClass = std::unique_ptr<BusControllerObjectClass>(new BusControllerObjectClass(mRtiAmbassador, mHLAobjectRootObjectClass.get()));
  mBusControllerCanObjectClass = std::unique_ptr<BusControllerCanObjectClass>(new BusControllerCanObjectClass(mRtiAmbassador, mBusControllerObjectClass.get()));
  mBusControllerEthernetObjectClass = std::unique_ptr<BusControllerEthernetObjectClass>(new BusControllerEthernetObjectClass(mRtiAmbassador, mBusControllerObjectClass.get()));
  mFlexRayControllerStatusObjectClass = std::unique_ptr<FlexRayControllerStatusObjectClass>(new FlexRayControllerStatusObjectClass(mRtiAmbassador, mBusControllerObjectClass.get()));
  mFlexRayControllerObjectClass = std::unique_ptr<FlexRayControllerObjectClass>(new FlexRayControllerObjectClass(mRtiAmbassador, mBusControllerObjectClass.get()));
  mFlexRaySendBufferObjectClass = std::unique_ptr<FlexRaySendBufferObjectClass>(new FlexRaySendBufferObjectClass(mRtiAmbassador, mHLAobjectRootObjectClass.get()));
} // Initialize

void ObjectClassRegistry::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName)
{
  rti1516ev::ObjectClassHandle theObjectClass = mRtiAmbassador->getKnownObjectClassHandle(theObject);
  if (theObjectClass == mHLAobjectRootObjectClass->GetObjectClassHandle())
  {
    mHLAobjectRootObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (theObjectClass == mSystemVariableObjectClass->GetObjectClassHandle())
  {
    mSystemVariableObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (theObjectClass == mValueEntityObjectClass->GetObjectClassHandle())
  {
    mValueEntityObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (theObjectClass == mDOMemberSourceObjectClass->GetObjectClassHandle())
  {
    mDOMemberSourceObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (theObjectClass == mDOMemberTargetObjectClass->GetObjectClassHandle())
  {
    mDOMemberTargetObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (theObjectClass == mBusManagementObjectClass->GetObjectClassHandle())
  {
    mBusManagementObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (theObjectClass == mBusManagementCanObjectClass->GetObjectClassHandle())
  {
    mBusManagementCanObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (theObjectClass == mBusManagementEthernetObjectClass->GetObjectClassHandle())
  {
    mBusManagementEthernetObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (theObjectClass == mFlexRayClusterObjectClass->GetObjectClassHandle())
  {
    mFlexRayClusterObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (theObjectClass == mBusControllerObjectClass->GetObjectClassHandle())
  {
    mBusControllerObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (theObjectClass == mBusControllerCanObjectClass->GetObjectClassHandle())
  {
    mBusControllerCanObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (theObjectClass == mBusControllerEthernetObjectClass->GetObjectClassHandle())
  {
    mBusControllerEthernetObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (theObjectClass == mFlexRayControllerStatusObjectClass->GetObjectClassHandle())
  {
    mFlexRayControllerStatusObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (theObjectClass == mFlexRayControllerObjectClass->GetObjectClassHandle())
  {
    mFlexRayControllerObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (theObjectClass == mFlexRaySendBufferObjectClass->GetObjectClassHandle())
  {
    mFlexRaySendBufferObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
}

void ObjectClassRegistry::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject)
{
  rti1516ev::ObjectClassHandle theObjectClass = mRtiAmbassador->getKnownObjectClassHandle(theObject);
  if (theObjectClass == mHLAobjectRootObjectClass->GetObjectClassHandle())
  {
    mHLAobjectRootObjectClass->RemoveObjectInstance(theObject);
  }
  else if (theObjectClass == mSystemVariableObjectClass->GetObjectClassHandle())
  {
    mSystemVariableObjectClass->RemoveObjectInstance(theObject);
  }
  else if (theObjectClass == mValueEntityObjectClass->GetObjectClassHandle())
  {
    mValueEntityObjectClass->RemoveObjectInstance(theObject);
  }
  else if (theObjectClass == mDOMemberSourceObjectClass->GetObjectClassHandle())
  {
    mDOMemberSourceObjectClass->RemoveObjectInstance(theObject);
  }
  else if (theObjectClass == mDOMemberTargetObjectClass->GetObjectClassHandle())
  {
    mDOMemberTargetObjectClass->RemoveObjectInstance(theObject);
  }
  else if (theObjectClass == mBusManagementObjectClass->GetObjectClassHandle())
  {
    mBusManagementObjectClass->RemoveObjectInstance(theObject);
  }
  else if (theObjectClass == mBusManagementCanObjectClass->GetObjectClassHandle())
  {
    mBusManagementCanObjectClass->RemoveObjectInstance(theObject);
  }
  else if (theObjectClass == mBusManagementEthernetObjectClass->GetObjectClassHandle())
  {
    mBusManagementEthernetObjectClass->RemoveObjectInstance(theObject);
  }
  else if (theObjectClass == mFlexRayClusterObjectClass->GetObjectClassHandle())
  {
    mFlexRayClusterObjectClass->RemoveObjectInstance(theObject);
  }
  else if (theObjectClass == mBusControllerObjectClass->GetObjectClassHandle())
  {
    mBusControllerObjectClass->RemoveObjectInstance(theObject);
  }
  else if (theObjectClass == mBusControllerCanObjectClass->GetObjectClassHandle())
  {
    mBusControllerCanObjectClass->RemoveObjectInstance(theObject);
  }
  else if (theObjectClass == mBusControllerEthernetObjectClass->GetObjectClassHandle())
  {
    mBusControllerEthernetObjectClass->RemoveObjectInstance(theObject);
  }
  else if (theObjectClass == mFlexRayControllerStatusObjectClass->GetObjectClassHandle())
  {
    mFlexRayControllerStatusObjectClass->RemoveObjectInstance(theObject);
  }
  else if (theObjectClass == mFlexRayControllerObjectClass->GetObjectClassHandle())
  {
    mFlexRayControllerObjectClass->RemoveObjectInstance(theObject);
  }
  else if (theObjectClass == mFlexRaySendBufferObjectClass->GetObjectClassHandle())
  {
    mFlexRaySendBufferObjectClass->RemoveObjectInstance(theObject);
  }
}

void ObjectClassRegistry::ReflectAttributeValues(rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes)
{
  rti1516ev::ObjectClassHandle theObjectClass = mRtiAmbassador->getKnownObjectClassHandle(theObject);
  if (theObjectClass == mSystemVariableObjectClass->GetObjectClassHandle())
  {
    static_cast<SystemVariable*>(mSystemVariableObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (theObjectClass == mValueEntityObjectClass->GetObjectClassHandle())
  {
    static_cast<ValueEntity*>(mValueEntityObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (theObjectClass == mDOMemberSourceObjectClass->GetObjectClassHandle())
  {
    static_cast<DOMemberSource*>(mDOMemberSourceObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (theObjectClass == mDOMemberTargetObjectClass->GetObjectClassHandle())
  {
    static_cast<DOMemberTarget*>(mDOMemberTargetObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (theObjectClass == mBusManagementObjectClass->GetObjectClassHandle())
  {
    static_cast<BusManagement*>(mBusManagementObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (theObjectClass == mBusManagementCanObjectClass->GetObjectClassHandle())
  {
    static_cast<BusManagementCan*>(mBusManagementCanObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (theObjectClass == mBusManagementEthernetObjectClass->GetObjectClassHandle())
  {
    static_cast<BusManagementEthernet*>(mBusManagementEthernetObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (theObjectClass == mFlexRayClusterObjectClass->GetObjectClassHandle())
  {
    static_cast<FlexRayCluster*>(mFlexRayClusterObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (theObjectClass == mBusControllerObjectClass->GetObjectClassHandle())
  {
    static_cast<BusController*>(mBusControllerObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (theObjectClass == mBusControllerCanObjectClass->GetObjectClassHandle())
  {
    static_cast<BusControllerCan*>(mBusControllerCanObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (theObjectClass == mBusControllerEthernetObjectClass->GetObjectClassHandle())
  {
    static_cast<BusControllerEthernet*>(mBusControllerEthernetObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (theObjectClass == mFlexRayControllerStatusObjectClass->GetObjectClassHandle())
  {
    static_cast<FlexRayControllerStatus*>(mFlexRayControllerStatusObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (theObjectClass == mFlexRayControllerObjectClass->GetObjectClassHandle())
  {
    static_cast<FlexRayController*>(mFlexRayControllerObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (theObjectClass == mFlexRaySendBufferObjectClass->GetObjectClassHandle())
  {
    static_cast<FlexRaySendBuffer*>(mFlexRaySendBufferObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
}

void ObjectClassRegistry::ProvideAttributeValues(rti1516ev::ObjectClassHandle theObjectClass, rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleSet& attributeHandles)
{
  if (theObjectClass == mSystemVariableObjectClass->GetObjectClassHandle())
  {
    static_cast<SystemVariable*>(mSystemVariableObjectClass->GetObjectInstance(theObject))->ProvideAttributeValues(attributeHandles);
  }
  else if (theObjectClass == mValueEntityObjectClass->GetObjectClassHandle())
  {
    static_cast<ValueEntity*>(mValueEntityObjectClass->GetObjectInstance(theObject))->ProvideAttributeValues(attributeHandles);
  }
  else if (theObjectClass == mDOMemberSourceObjectClass->GetObjectClassHandle())
  {
    static_cast<DOMemberSource*>(mDOMemberSourceObjectClass->GetObjectInstance(theObject))->ProvideAttributeValues(attributeHandles);
  }
  else if (theObjectClass == mDOMemberTargetObjectClass->GetObjectClassHandle())
  {
    static_cast<DOMemberTarget*>(mDOMemberTargetObjectClass->GetObjectInstance(theObject))->ProvideAttributeValues(attributeHandles);
  }
  else if (theObjectClass == mBusManagementObjectClass->GetObjectClassHandle())
  {
    static_cast<BusManagement*>(mBusManagementObjectClass->GetObjectInstance(theObject))->ProvideAttributeValues(attributeHandles);
  }
  else if (theObjectClass == mBusManagementCanObjectClass->GetObjectClassHandle())
  {
    static_cast<BusManagementCan*>(mBusManagementCanObjectClass->GetObjectInstance(theObject))->ProvideAttributeValues(attributeHandles);
  }
  else if (theObjectClass == mBusManagementEthernetObjectClass->GetObjectClassHandle())
  {
    static_cast<BusManagementEthernet*>(mBusManagementEthernetObjectClass->GetObjectInstance(theObject))->ProvideAttributeValues(attributeHandles);
  }
  else if (theObjectClass == mFlexRayClusterObjectClass->GetObjectClassHandle())
  {
    static_cast<FlexRayCluster*>(mFlexRayClusterObjectClass->GetObjectInstance(theObject))->ProvideAttributeValues(attributeHandles);
  }
  else if (theObjectClass == mBusControllerObjectClass->GetObjectClassHandle())
  {
    static_cast<BusController*>(mBusControllerObjectClass->GetObjectInstance(theObject))->ProvideAttributeValues(attributeHandles);
  }
  else if (theObjectClass == mBusControllerCanObjectClass->GetObjectClassHandle())
  {
    static_cast<BusControllerCan*>(mBusControllerCanObjectClass->GetObjectInstance(theObject))->ProvideAttributeValues(attributeHandles);
  }
  else if (theObjectClass == mBusControllerEthernetObjectClass->GetObjectClassHandle())
  {
    static_cast<BusControllerEthernet*>(mBusControllerEthernetObjectClass->GetObjectInstance(theObject))->ProvideAttributeValues(attributeHandles);
  }
  else if (theObjectClass == mFlexRayControllerStatusObjectClass->GetObjectClassHandle())
  {
    static_cast<FlexRayControllerStatus*>(mFlexRayControllerStatusObjectClass->GetObjectInstance(theObject))->ProvideAttributeValues(attributeHandles);
  }
  else if (theObjectClass == mFlexRayControllerObjectClass->GetObjectClassHandle())
  {
    static_cast<FlexRayController*>(mFlexRayControllerObjectClass->GetObjectInstance(theObject))->ProvideAttributeValues(attributeHandles);
  }
  else if (theObjectClass == mFlexRaySendBufferObjectClass->GetObjectClassHandle())
  {
    static_cast<FlexRaySendBuffer*>(mFlexRaySendBufferObjectClass->GetObjectInstance(theObject))->ProvideAttributeValues(attributeHandles);
  }
}

void ObjectClassRegistry::RegisterObjectInstanceName(const std::wstring& theObjectInstanceName, std::function<void(bool)> completionCallback)
{
  mInstanceNameReservationCallbacks.insert(std::make_pair(theObjectInstanceName, completionCallback));
  mRtiAmbassador->reserveObjectInstanceName(theObjectInstanceName);
}

void ObjectClassRegistry::ObjectInstanceNameReservationSucceeded(const std::wstring& theObjectInstanceName)
{
  auto iter = mInstanceNameReservationCallbacks.find(theObjectInstanceName);
  iter->second(true);
  mInstanceNameReservationCallbacks.erase(iter);
}

void ObjectClassRegistry::ObjectInstanceNameReservationFailed(const std::wstring& theObjectInstanceName)
{
  auto iter = mInstanceNameReservationCallbacks.find(theObjectInstanceName);
  iter->second(false);
  mInstanceNameReservationCallbacks.erase(iter);
}

IObjectClassRegistry* GetObjectClassRegistry()
{
  return ObjectClassRegistry::GetInstance();
}

} // namespace NDistSimIB
} // namespace NRTFederateEncoding
