
// Code automatically generated by FOMCodeGen version 2.0.1.17 from RTFederate.xml, do not edit

#include <vector>
#include <cstring>

#include "RTI/encoding/BasicDataElements.h"
#include "RTI/encoding/HLAfixedRecord.h"
#include "RTI/encoding/HLAfixedArray.h"
#include "RTI/encoding/HLAvariableArray.h"
#include "RTFederateEncodings.h"

namespace NDistSimIB {
namespace NRTFederateEncoding {



// 
// Bytes carried in a CAN frame. Note that the actual number of bytes is carried in
// a distinct member field of the CANFrame.
//         
// fixed array of simple type HLAbyte
CANMessageDataEncoding::CANMessageDataEncoding()
  : HLAfixedArray(rti1516ev::HLAbyte(), 64)
  , mData(64)
{
  for (int i=0; i < 64; i++)
  {
    mEncoding[i].setDataPointer(&mData[i]);
    setElementPointer(i, &mEncoding[i]);
  }
}
CANMessageDataEncoding::CANMessageDataEncoding(const CANMessageDataEncoding& rhs)
  : HLAfixedArray(rti1516ev::HLAbyte(), 64)
  , mData(64)
{
  set(rhs.mData.data(), rhs.mData.size());
  for (int i=0; i < 64; i++)
  {
    mEncoding[i].setDataPointer(&mData[i]);
    setElementPointer(i, &mEncoding[i]);
  }
}
CANMessageDataEncoding::CANMessageDataEncoding(const std::vector<uint8_t>& data)
  : HLAfixedArray(rti1516ev::HLAbyte(), 64)
  , mData(64)
{
  set(data.data(), data.size());
  for (int i=0;i<64;i++)
  {
    mEncoding[i].setDataPointer(&mData[i]);
    setElementPointer(i, &mEncoding[i]);
  }
}
void CANMessageDataEncoding::set(const std::vector<uint8_t>& data) {
  set(data.data(), data.size());
}
void CANMessageDataEncoding::set(const uint8_t* data, size_t size) 
{
  if (size <= 64) {
    memcpy(mData.data(), data, size);
  } else {
    memcpy(mData.data(), data, 64);
  }
}
const std::vector<uint8_t>& CANMessageDataEncoding::get() const
{
  return mData;
}
// 
// Bytes carried in a Ethernet Packet. The data is variable-sized and carries the
// actual number of bytes used.
//         
// variable array of simple type HLAbyte
EthernetPacketDataEncoding::EthernetPacketDataEncoding()
  : HLAvariableArray(rti1516ev::HLAbyte())
  , mData()
{
}
EthernetPacketDataEncoding::EthernetPacketDataEncoding(const EthernetPacketDataEncoding& rhs)
  : HLAvariableArray(rti1516ev::HLAbyte())
  , mData(rhs.mData)
{
  update();
}
EthernetPacketDataEncoding::EthernetPacketDataEncoding(const std::vector<uint8_t>& data)
  : HLAvariableArray(rti1516ev::HLAbyte())
  , mData(data)
{
  update();
}
void EthernetPacketDataEncoding::set(const std::vector<uint8_t>& data)
{
  if (mData.size() != data.size()) {
    mData = data;
    update();
  } else {
    memcpy(mData.data(), data.data(), mData.size());
  }
}
void EthernetPacketDataEncoding::set(const uint8_t* data, size_t size)
{
  if (mData.size() != size) {
    mData.resize(size);
    update();
  }
  memcpy(mData.data(), data, size);
}
const std::vector<uint8_t>& EthernetPacketDataEncoding::get() const { return mData; }
void EthernetPacketDataEncoding::resize(size_t size)
{
  mData.resize(size);
  update();
}
// resize buffer and encoder array before actually decoding 
size_t EthernetPacketDataEncoding::decodeFrom(const rti1516ev::Octet* buffer, size_t bufferSize, size_t index)
{
  size_t newSize = decodedSize(buffer, bufferSize, index);
  resize(newSize);
  return HLAvariableArray::decodeFrom(buffer, bufferSize, index);
}
void EthernetPacketDataEncoding::update()
{
  size_t size = mData.size();
  mEncoding.resize(size);
  for (size_t i=0; i < size; i++)
  {
    mEncoding[i].setDataPointer(&mData.data()[i]);
    if (i >= HLAvariableArray::size()) {
      addElementPointer(&mEncoding[i]);
    } else {
      setElementPointer(i, &mEncoding[i]);
    }
  }
}

// Bytes carried in a FlexRay Frame. The data is variable-sized and carries the actual number of bytes used.
// variable array of simple type HLAbyte
FlexRayPayloadDataEncoding::FlexRayPayloadDataEncoding()
  : HLAvariableArray(rti1516ev::HLAbyte())
  , mData()
{
}
FlexRayPayloadDataEncoding::FlexRayPayloadDataEncoding(const FlexRayPayloadDataEncoding& rhs)
  : HLAvariableArray(rti1516ev::HLAbyte())
  , mData(rhs.mData)
{
  update();
}
FlexRayPayloadDataEncoding::FlexRayPayloadDataEncoding(const std::vector<uint8_t>& data)
  : HLAvariableArray(rti1516ev::HLAbyte())
  , mData(data)
{
  update();
}
void FlexRayPayloadDataEncoding::set(const std::vector<uint8_t>& data)
{
  if (mData.size() != data.size()) {
    mData = data;
    update();
  } else {
    memcpy(mData.data(), data.data(), mData.size());
  }
}
void FlexRayPayloadDataEncoding::set(const uint8_t* data, size_t size)
{
  if (mData.size() != size) {
    mData.resize(size);
    update();
  }
  memcpy(mData.data(), data, size);
}
const std::vector<uint8_t>& FlexRayPayloadDataEncoding::get() const { return mData; }
void FlexRayPayloadDataEncoding::resize(size_t size)
{
  mData.resize(size);
  update();
}
// resize buffer and encoder array before actually decoding 
size_t FlexRayPayloadDataEncoding::decodeFrom(const rti1516ev::Octet* buffer, size_t bufferSize, size_t index)
{
  size_t newSize = decodedSize(buffer, bufferSize, index);
  resize(newSize);
  return HLAvariableArray::decodeFrom(buffer, bufferSize, index);
}
void FlexRayPayloadDataEncoding::update()
{
  size_t size = mData.size();
  mEncoding.resize(size);
  for (size_t i=0; i < size; i++)
  {
    mEncoding[i].setDataPointer(&mData.data()[i]);
    if (i >= HLAvariableArray::size()) {
      addElementPointer(&mEncoding[i]);
    } else {
      setElementPointer(i, &mEncoding[i]);
    }
  }
}

// CAN Frame
CANFrameEncoding::CANFrameEncoding() : rti1516ev::HLAfixedRecord(1)
{
  rti1516ev::HLAfixedRecord::appendElementPointer(&mClientIndex, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mDir, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mOriginalTimeStamp, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mSimulated, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mId, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mFlags, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mDataLength, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mData, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mFrameLengthNS, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mBitCount, 1);
}

CANFrameEncoding::CANFrameEncoding(const CANFrameEncoding& ref)
  : rti1516ev::HLAfixedRecord(1)
  , mClientIndex(ref.mClientIndex)
  , mDir(ref.mDir)
  , mOriginalTimeStamp(ref.mOriginalTimeStamp)
  , mSimulated(ref.mSimulated)
  , mId(ref.mId)
  , mFlags(ref.mFlags)
  , mDataLength(ref.mDataLength)
  , mData(ref.mData)
  , mFrameLengthNS(ref.mFrameLengthNS)
  , mBitCount(ref.mBitCount)
{
  rti1516ev::HLAfixedRecord::appendElementPointer(&mClientIndex, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mDir, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mOriginalTimeStamp, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mSimulated, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mId, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mFlags, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mDataLength, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mData, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mFrameLengthNS, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mBitCount, 1);
}

CANFrameEncoding::~CANFrameEncoding()
{
}

CANFrameEncoding& CANFrameEncoding::operator=(const CANFrame& ref)
{
  if (this != &ref)
  {
  SetClientIndex(ref.GetClientIndex());
  SetDir(ref.GetDir());
  SetOriginalTimeStamp(ref.GetOriginalTimeStamp());
  SetSimulated(ref.GetSimulated());
  SetId(ref.GetId());
  SetFlags(ref.GetFlags());
  SetDataLength(ref.GetDataLength());
  SetData(ref.GetData());
  SetFrameLengthNS(ref.GetFrameLengthNS());
  SetBitCount(ref.GetBitCount());
  }
  return *this;
}

uint32_t CANFrameEncoding::getVersion() const { return rti1516ev::HLAfixedRecord::getVersion(); }
void CANFrameEncoding::SetClientIndex(int16_t value)
{
  mClientIndex.set(value);
}
int16_t CANFrameEncoding::GetClientIndex() const
{
  return mClientIndex.get();
}
bool CANFrameEncoding::IsClientIndexAvailable() const
{
  return true;
}
void CANFrameEncoding::SetDir(DirMask value)
{
  // FOMCodeGen.FOMParser+EnumeratedDataType
  mDir = static_cast<uint8_t>(value);
}
DirMask CANFrameEncoding::GetDir() const
{
  return static_cast<DirMask>(mDir.get());
}
bool CANFrameEncoding::IsDirAvailable() const
{
  return true;
}
void CANFrameEncoding::SetOriginalTimeStamp(VTimeNS value)
{
  mOriginalTimeStamp.set(value);
}
VTimeNS CANFrameEncoding::GetOriginalTimeStamp() const
{
  return mOriginalTimeStamp.get();
}
bool CANFrameEncoding::IsOriginalTimeStampAvailable() const
{
  return true;
}
void CANFrameEncoding::SetSimulated(SimulatedFlag value)
{
  // FOMCodeGen.FOMParser+EnumeratedDataType
  mSimulated = static_cast<uint8_t>(value);
}
SimulatedFlag CANFrameEncoding::GetSimulated() const
{
  return static_cast<SimulatedFlag>(mSimulated.get());
}
bool CANFrameEncoding::IsSimulatedAvailable() const
{
  return true;
}
void CANFrameEncoding::SetId(VMessageId value)
{
  mId.set(value);
}
VMessageId CANFrameEncoding::GetId() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"Id\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mId.get();
}
bool CANFrameEncoding::IsIdAvailable() const
{
  return (getVersion() >= 1);
}
void CANFrameEncoding::SetFlags(int32_t value)
{
  mFlags.set(value);
}
int32_t CANFrameEncoding::GetFlags() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"Flags\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mFlags.get();
}
bool CANFrameEncoding::IsFlagsAvailable() const
{
  return (getVersion() >= 1);
}
void CANFrameEncoding::SetDataLength(uint8_t value)
{
  mDataLength.set(value);
}
uint8_t CANFrameEncoding::GetDataLength() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"DataLength\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mDataLength.get();
}
bool CANFrameEncoding::IsDataLengthAvailable() const
{
  return (getVersion() >= 1);
}
void CANFrameEncoding::SetData(const std::vector<uint8_t>& value)
{
  mData.set(value);
}
void CANFrameEncoding::SetData(const uint8_t* value, size_t size)
{
	mData.set(value, size);
}
const std::vector<uint8_t>& CANFrameEncoding::GetData() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"Data\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mData.get();
}
bool CANFrameEncoding::IsDataAvailable() const
{
  return (getVersion() >= 1);
}
void CANFrameEncoding::SetFrameLengthNS(int32_t value)
{
  mFrameLengthNS.set(value);
}
int32_t CANFrameEncoding::GetFrameLengthNS() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"FrameLengthNS\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mFrameLengthNS.get();
}
bool CANFrameEncoding::IsFrameLengthNSAvailable() const
{
  return (getVersion() >= 1);
}
void CANFrameEncoding::SetBitCount(int16_t value)
{
  mBitCount.set(value);
}
int16_t CANFrameEncoding::GetBitCount() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"BitCount\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mBitCount.get();
}
bool CANFrameEncoding::IsBitCountAvailable() const
{
  return (getVersion() >= 1);
}
// CAN Error Frame
CANErrorFrameEncoding::CANErrorFrameEncoding() : rti1516ev::HLAfixedRecord(1)
{
  rti1516ev::HLAfixedRecord::appendElementPointer(&mErrorBitPosition, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mFrameLengthNS, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mClientIndex, 1);
}

CANErrorFrameEncoding::CANErrorFrameEncoding(const CANErrorFrameEncoding& ref)
  : rti1516ev::HLAfixedRecord(1)
  , mErrorBitPosition(ref.mErrorBitPosition)
  , mFrameLengthNS(ref.mFrameLengthNS)
  , mClientIndex(ref.mClientIndex)
{
  rti1516ev::HLAfixedRecord::appendElementPointer(&mErrorBitPosition, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mFrameLengthNS, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mClientIndex, 1);
}

CANErrorFrameEncoding::~CANErrorFrameEncoding()
{
}

CANErrorFrameEncoding& CANErrorFrameEncoding::operator=(const CANErrorFrame& ref)
{
  if (this != &ref)
  {
  SetErrorBitPosition(ref.GetErrorBitPosition());
  SetFrameLengthNS(ref.GetFrameLengthNS());
  SetClientIndex(ref.GetClientIndex());
  }
  return *this;
}

uint32_t CANErrorFrameEncoding::getVersion() const { return rti1516ev::HLAfixedRecord::getVersion(); }
void CANErrorFrameEncoding::SetErrorBitPosition(int16_t value)
{
  mErrorBitPosition.set(value);
}
int16_t CANErrorFrameEncoding::GetErrorBitPosition() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"ErrorBitPosition\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mErrorBitPosition.get();
}
bool CANErrorFrameEncoding::IsErrorBitPositionAvailable() const
{
  return (getVersion() >= 1);
}
void CANErrorFrameEncoding::SetFrameLengthNS(int32_t value)
{
  mFrameLengthNS.set(value);
}
int32_t CANErrorFrameEncoding::GetFrameLengthNS() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"FrameLengthNS\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mFrameLengthNS.get();
}
bool CANErrorFrameEncoding::IsFrameLengthNSAvailable() const
{
  return (getVersion() >= 1);
}
void CANErrorFrameEncoding::SetClientIndex(int16_t value)
{
  mClientIndex.set(value);
}
int16_t CANErrorFrameEncoding::GetClientIndex() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"ClientIndex\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mClientIndex.get();
}
bool CANErrorFrameEncoding::IsClientIndexAvailable() const
{
  return (getVersion() >= 1);
}
// Ethernet Status Event
EthernetStatusEncoding::EthernetStatusEncoding() : rti1516ev::HLAfixedRecord(1)
{
  rti1516ev::HLAfixedRecord::appendElementPointer(&mBusType, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mHardwareChannel, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mLinkStatus, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mBitrate, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mEthernetPhy, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mDuplex, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mMdiType, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mConnector, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mClockMode, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mBrPair, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mDeviceOperationMode, 1);
}

EthernetStatusEncoding::EthernetStatusEncoding(const EthernetStatusEncoding& ref)
  : rti1516ev::HLAfixedRecord(1)
  , mBusType(ref.mBusType)
  , mHardwareChannel(ref.mHardwareChannel)
  , mLinkStatus(ref.mLinkStatus)
  , mBitrate(ref.mBitrate)
  , mEthernetPhy(ref.mEthernetPhy)
  , mDuplex(ref.mDuplex)
  , mMdiType(ref.mMdiType)
  , mConnector(ref.mConnector)
  , mClockMode(ref.mClockMode)
  , mBrPair(ref.mBrPair)
  , mDeviceOperationMode(ref.mDeviceOperationMode)
{
  rti1516ev::HLAfixedRecord::appendElementPointer(&mBusType, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mHardwareChannel, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mLinkStatus, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mBitrate, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mEthernetPhy, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mDuplex, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mMdiType, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mConnector, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mClockMode, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mBrPair, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mDeviceOperationMode, 1);
}

EthernetStatusEncoding::~EthernetStatusEncoding()
{
}

EthernetStatusEncoding& EthernetStatusEncoding::operator=(const EthernetStatus& ref)
{
  if (this != &ref)
  {
  SetBusType(ref.GetBusType());
  SetHardwareChannel(ref.GetHardwareChannel());
  SetLinkStatus(ref.GetLinkStatus());
  SetBitrate(ref.GetBitrate());
  SetEthernetPhy(ref.GetEthernetPhy());
  SetDuplex(ref.GetDuplex());
  SetMdiType(ref.GetMdiType());
  SetConnector(ref.GetConnector());
  SetClockMode(ref.GetClockMode());
  SetBrPair(ref.GetBrPair());
  SetDeviceOperationMode(ref.GetDeviceOperationMode());
  }
  return *this;
}

uint32_t EthernetStatusEncoding::getVersion() const { return rti1516ev::HLAfixedRecord::getVersion(); }
void EthernetStatusEncoding::SetBusType(int16_t value)
{
  mBusType.set(value);
}
int16_t EthernetStatusEncoding::GetBusType() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"BusType\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mBusType.get();
}
bool EthernetStatusEncoding::IsBusTypeAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetStatusEncoding::SetHardwareChannel(int64_t value)
{
  mHardwareChannel.set(value);
}
int64_t EthernetStatusEncoding::GetHardwareChannel() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"HardwareChannel\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mHardwareChannel.get();
}
bool EthernetStatusEncoding::IsHardwareChannelAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetStatusEncoding::SetLinkStatus(LinkStatus value)
{
  // FOMCodeGen.FOMParser+EnumeratedDataType
  mLinkStatus = static_cast<int32_t>(value);
}
LinkStatus EthernetStatusEncoding::GetLinkStatus() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"LinkStatus\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return static_cast<LinkStatus>(mLinkStatus.get());
}
bool EthernetStatusEncoding::IsLinkStatusAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetStatusEncoding::SetBitrate(int32_t value)
{
  mBitrate.set(value);
}
int32_t EthernetStatusEncoding::GetBitrate() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"Bitrate\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mBitrate.get();
}
bool EthernetStatusEncoding::IsBitrateAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetStatusEncoding::SetEthernetPhy(EthernetPhy value)
{
  // FOMCodeGen.FOMParser+EnumeratedDataType
  mEthernetPhy = static_cast<int32_t>(value);
}
EthernetPhy EthernetStatusEncoding::GetEthernetPhy() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"EthernetPhy\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return static_cast<EthernetPhy>(mEthernetPhy.get());
}
bool EthernetStatusEncoding::IsEthernetPhyAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetStatusEncoding::SetDuplex(Duplex value)
{
  // FOMCodeGen.FOMParser+EnumeratedDataType
  mDuplex = static_cast<int32_t>(value);
}
Duplex EthernetStatusEncoding::GetDuplex() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"Duplex\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return static_cast<Duplex>(mDuplex.get());
}
bool EthernetStatusEncoding::IsDuplexAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetStatusEncoding::SetMdiType(MdiType value)
{
  // FOMCodeGen.FOMParser+EnumeratedDataType
  mMdiType = static_cast<int32_t>(value);
}
MdiType EthernetStatusEncoding::GetMdiType() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"MdiType\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return static_cast<MdiType>(mMdiType.get());
}
bool EthernetStatusEncoding::IsMdiTypeAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetStatusEncoding::SetConnector(Connector value)
{
  // FOMCodeGen.FOMParser+EnumeratedDataType
  mConnector = static_cast<int32_t>(value);
}
Connector EthernetStatusEncoding::GetConnector() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"Connector\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return static_cast<Connector>(mConnector.get());
}
bool EthernetStatusEncoding::IsConnectorAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetStatusEncoding::SetClockMode(ClockMode value)
{
  // FOMCodeGen.FOMParser+EnumeratedDataType
  mClockMode = static_cast<int32_t>(value);
}
ClockMode EthernetStatusEncoding::GetClockMode() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"ClockMode\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return static_cast<ClockMode>(mClockMode.get());
}
bool EthernetStatusEncoding::IsClockModeAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetStatusEncoding::SetBrPair(BrPair value)
{
  // FOMCodeGen.FOMParser+EnumeratedDataType
  mBrPair = static_cast<int32_t>(value);
}
BrPair EthernetStatusEncoding::GetBrPair() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"BrPair\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return static_cast<BrPair>(mBrPair.get());
}
bool EthernetStatusEncoding::IsBrPairAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetStatusEncoding::SetDeviceOperationMode(int32_t value)
{
  mDeviceOperationMode.set(value);
}
int32_t EthernetStatusEncoding::GetDeviceOperationMode() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"DeviceOperationMode\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mDeviceOperationMode.get();
}
bool EthernetStatusEncoding::IsDeviceOperationModeAvailable() const
{
  return (getVersion() >= 1);
}
// Ethernet Packet
EthernetPacketEncoding::EthernetPacketEncoding() : rti1516ev::HLAfixedRecord(1)
{
  rti1516ev::HLAfixedRecord::appendElementPointer(&mClientIndex, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mDir, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mOriginalTimeStamp, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mSimulated, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mBusType, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mHardwareChannel, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mFrameDuration, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mEthernetChecksum, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mPacketData, 1);
}

EthernetPacketEncoding::EthernetPacketEncoding(const EthernetPacketEncoding& ref)
  : rti1516ev::HLAfixedRecord(1)
  , mClientIndex(ref.mClientIndex)
  , mDir(ref.mDir)
  , mOriginalTimeStamp(ref.mOriginalTimeStamp)
  , mSimulated(ref.mSimulated)
  , mBusType(ref.mBusType)
  , mHardwareChannel(ref.mHardwareChannel)
  , mFrameDuration(ref.mFrameDuration)
  , mEthernetChecksum(ref.mEthernetChecksum)
  , mPacketData(ref.mPacketData)
{
  rti1516ev::HLAfixedRecord::appendElementPointer(&mClientIndex, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mDir, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mOriginalTimeStamp, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mSimulated, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mBusType, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mHardwareChannel, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mFrameDuration, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mEthernetChecksum, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mPacketData, 1);
}

EthernetPacketEncoding::~EthernetPacketEncoding()
{
}

EthernetPacketEncoding& EthernetPacketEncoding::operator=(const EthernetPacket& ref)
{
  if (this != &ref)
  {
  SetClientIndex(ref.GetClientIndex());
  SetDir(ref.GetDir());
  SetOriginalTimeStamp(ref.GetOriginalTimeStamp());
  SetSimulated(ref.GetSimulated());
  SetBusType(ref.GetBusType());
  SetHardwareChannel(ref.GetHardwareChannel());
  SetFrameDuration(ref.GetFrameDuration());
  SetEthernetChecksum(ref.GetEthernetChecksum());
  SetPacketData(ref.GetPacketData());
  }
  return *this;
}

uint32_t EthernetPacketEncoding::getVersion() const { return rti1516ev::HLAfixedRecord::getVersion(); }
void EthernetPacketEncoding::SetClientIndex(int16_t value)
{
  mClientIndex.set(value);
}
int16_t EthernetPacketEncoding::GetClientIndex() const
{
  return mClientIndex.get();
}
bool EthernetPacketEncoding::IsClientIndexAvailable() const
{
  return true;
}
void EthernetPacketEncoding::SetDir(DirMask value)
{
  // FOMCodeGen.FOMParser+EnumeratedDataType
  mDir = static_cast<uint8_t>(value);
}
DirMask EthernetPacketEncoding::GetDir() const
{
  return static_cast<DirMask>(mDir.get());
}
bool EthernetPacketEncoding::IsDirAvailable() const
{
  return true;
}
void EthernetPacketEncoding::SetOriginalTimeStamp(VTimeNS value)
{
  mOriginalTimeStamp.set(value);
}
VTimeNS EthernetPacketEncoding::GetOriginalTimeStamp() const
{
  return mOriginalTimeStamp.get();
}
bool EthernetPacketEncoding::IsOriginalTimeStampAvailable() const
{
  return true;
}
void EthernetPacketEncoding::SetSimulated(SimulatedFlag value)
{
  // FOMCodeGen.FOMParser+EnumeratedDataType
  mSimulated = static_cast<uint8_t>(value);
}
SimulatedFlag EthernetPacketEncoding::GetSimulated() const
{
  return static_cast<SimulatedFlag>(mSimulated.get());
}
bool EthernetPacketEncoding::IsSimulatedAvailable() const
{
  return true;
}
void EthernetPacketEncoding::SetBusType(int16_t value)
{
  mBusType.set(value);
}
int16_t EthernetPacketEncoding::GetBusType() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"BusType\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mBusType.get();
}
bool EthernetPacketEncoding::IsBusTypeAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetPacketEncoding::SetHardwareChannel(int64_t value)
{
  mHardwareChannel.set(value);
}
int64_t EthernetPacketEncoding::GetHardwareChannel() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"HardwareChannel\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mHardwareChannel.get();
}
bool EthernetPacketEncoding::IsHardwareChannelAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetPacketEncoding::SetFrameDuration(VTimeNS value)
{
  mFrameDuration.set(value);
}
VTimeNS EthernetPacketEncoding::GetFrameDuration() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"FrameDuration\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mFrameDuration.get();
}
bool EthernetPacketEncoding::IsFrameDurationAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetPacketEncoding::SetEthernetChecksum(int32_t value)
{
  mEthernetChecksum.set(value);
}
int32_t EthernetPacketEncoding::GetEthernetChecksum() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"EthernetChecksum\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mEthernetChecksum.get();
}
bool EthernetPacketEncoding::IsEthernetChecksumAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetPacketEncoding::SetPacketData(const std::vector<uint8_t>& value)
{
  mPacketData.set(value);
}
void EthernetPacketEncoding::SetPacketData(const uint8_t* value, size_t size)
{
	mPacketData.set(value, size);
}
const std::vector<uint8_t>& EthernetPacketEncoding::GetPacketData() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"PacketData\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mPacketData.get();
}
bool EthernetPacketEncoding::IsPacketDataAvailable() const
{
  return (getVersion() >= 1);
}
EthernetPacketForwardedEncoding::EthernetPacketForwardedEncoding() : rti1516ev::HLAfixedRecord(1)
{
  rti1516ev::HLAfixedRecord::appendElementPointer(&mClientIndex, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mDir, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mOriginalTimeStamp, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mSimulated, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mBusType, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mHardwareChannel, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mFrameDuration, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mEthernetChecksum, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mPacketData, 1);
}

EthernetPacketForwardedEncoding::EthernetPacketForwardedEncoding(const EthernetPacketForwardedEncoding& ref)
  : rti1516ev::HLAfixedRecord(1)
  , mClientIndex(ref.mClientIndex)
  , mDir(ref.mDir)
  , mOriginalTimeStamp(ref.mOriginalTimeStamp)
  , mSimulated(ref.mSimulated)
  , mBusType(ref.mBusType)
  , mHardwareChannel(ref.mHardwareChannel)
  , mFrameDuration(ref.mFrameDuration)
  , mEthernetChecksum(ref.mEthernetChecksum)
  , mPacketData(ref.mPacketData)
{
  rti1516ev::HLAfixedRecord::appendElementPointer(&mClientIndex, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mDir, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mOriginalTimeStamp, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mSimulated, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mBusType, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mHardwareChannel, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mFrameDuration, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mEthernetChecksum, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mPacketData, 1);
}

EthernetPacketForwardedEncoding::~EthernetPacketForwardedEncoding()
{
}

EthernetPacketForwardedEncoding& EthernetPacketForwardedEncoding::operator=(const EthernetPacketForwarded& ref)
{
  if (this != &ref)
  {
  SetClientIndex(ref.GetClientIndex());
  SetDir(ref.GetDir());
  SetOriginalTimeStamp(ref.GetOriginalTimeStamp());
  SetSimulated(ref.GetSimulated());
  SetBusType(ref.GetBusType());
  SetHardwareChannel(ref.GetHardwareChannel());
  SetFrameDuration(ref.GetFrameDuration());
  SetEthernetChecksum(ref.GetEthernetChecksum());
  SetPacketData(ref.GetPacketData());
  }
  return *this;
}

uint32_t EthernetPacketForwardedEncoding::getVersion() const { return rti1516ev::HLAfixedRecord::getVersion(); }
void EthernetPacketForwardedEncoding::SetClientIndex(int16_t value)
{
  mClientIndex.set(value);
}
int16_t EthernetPacketForwardedEncoding::GetClientIndex() const
{
  return mClientIndex.get();
}
bool EthernetPacketForwardedEncoding::IsClientIndexAvailable() const
{
  return true;
}
void EthernetPacketForwardedEncoding::SetDir(DirMask value)
{
  // FOMCodeGen.FOMParser+EnumeratedDataType
  mDir = static_cast<uint8_t>(value);
}
DirMask EthernetPacketForwardedEncoding::GetDir() const
{
  return static_cast<DirMask>(mDir.get());
}
bool EthernetPacketForwardedEncoding::IsDirAvailable() const
{
  return true;
}
void EthernetPacketForwardedEncoding::SetOriginalTimeStamp(VTimeNS value)
{
  mOriginalTimeStamp.set(value);
}
VTimeNS EthernetPacketForwardedEncoding::GetOriginalTimeStamp() const
{
  return mOriginalTimeStamp.get();
}
bool EthernetPacketForwardedEncoding::IsOriginalTimeStampAvailable() const
{
  return true;
}
void EthernetPacketForwardedEncoding::SetSimulated(SimulatedFlag value)
{
  // FOMCodeGen.FOMParser+EnumeratedDataType
  mSimulated = static_cast<uint8_t>(value);
}
SimulatedFlag EthernetPacketForwardedEncoding::GetSimulated() const
{
  return static_cast<SimulatedFlag>(mSimulated.get());
}
bool EthernetPacketForwardedEncoding::IsSimulatedAvailable() const
{
  return true;
}
void EthernetPacketForwardedEncoding::SetBusType(int16_t value)
{
  mBusType.set(value);
}
int16_t EthernetPacketForwardedEncoding::GetBusType() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"BusType\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mBusType.get();
}
bool EthernetPacketForwardedEncoding::IsBusTypeAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetPacketForwardedEncoding::SetHardwareChannel(int64_t value)
{
  mHardwareChannel.set(value);
}
int64_t EthernetPacketForwardedEncoding::GetHardwareChannel() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"HardwareChannel\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mHardwareChannel.get();
}
bool EthernetPacketForwardedEncoding::IsHardwareChannelAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetPacketForwardedEncoding::SetFrameDuration(VTimeNS value)
{
  mFrameDuration.set(value);
}
VTimeNS EthernetPacketForwardedEncoding::GetFrameDuration() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"FrameDuration\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mFrameDuration.get();
}
bool EthernetPacketForwardedEncoding::IsFrameDurationAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetPacketForwardedEncoding::SetEthernetChecksum(int32_t value)
{
  mEthernetChecksum.set(value);
}
int32_t EthernetPacketForwardedEncoding::GetEthernetChecksum() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"EthernetChecksum\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mEthernetChecksum.get();
}
bool EthernetPacketForwardedEncoding::IsEthernetChecksumAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetPacketForwardedEncoding::SetPacketData(const std::vector<uint8_t>& value)
{
  mPacketData.set(value);
}
void EthernetPacketForwardedEncoding::SetPacketData(const uint8_t* value, size_t size)
{
	mPacketData.set(value, size);
}
const std::vector<uint8_t>& EthernetPacketForwardedEncoding::GetPacketData() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"PacketData\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mPacketData.get();
}
bool EthernetPacketForwardedEncoding::IsPacketDataAvailable() const
{
  return (getVersion() >= 1);
}
EthernetPacketErrorEncoding::EthernetPacketErrorEncoding() : rti1516ev::HLAfixedRecord(1)
{
  rti1516ev::HLAfixedRecord::appendElementPointer(&mClientIndex, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mDir, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mOriginalTimeStamp, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mSimulated, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mBusType, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mHardwareChannel, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mFrameDuration, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mErrorCode, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mEthernetChecksum, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mPacketData, 1);
}

EthernetPacketErrorEncoding::EthernetPacketErrorEncoding(const EthernetPacketErrorEncoding& ref)
  : rti1516ev::HLAfixedRecord(1)
  , mClientIndex(ref.mClientIndex)
  , mDir(ref.mDir)
  , mOriginalTimeStamp(ref.mOriginalTimeStamp)
  , mSimulated(ref.mSimulated)
  , mBusType(ref.mBusType)
  , mHardwareChannel(ref.mHardwareChannel)
  , mFrameDuration(ref.mFrameDuration)
  , mErrorCode(ref.mErrorCode)
  , mEthernetChecksum(ref.mEthernetChecksum)
  , mPacketData(ref.mPacketData)
{
  rti1516ev::HLAfixedRecord::appendElementPointer(&mClientIndex, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mDir, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mOriginalTimeStamp, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mSimulated, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mBusType, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mHardwareChannel, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mFrameDuration, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mErrorCode, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mEthernetChecksum, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mPacketData, 1);
}

EthernetPacketErrorEncoding::~EthernetPacketErrorEncoding()
{
}

EthernetPacketErrorEncoding& EthernetPacketErrorEncoding::operator=(const EthernetPacketError& ref)
{
  if (this != &ref)
  {
  SetClientIndex(ref.GetClientIndex());
  SetDir(ref.GetDir());
  SetOriginalTimeStamp(ref.GetOriginalTimeStamp());
  SetSimulated(ref.GetSimulated());
  SetBusType(ref.GetBusType());
  SetHardwareChannel(ref.GetHardwareChannel());
  SetFrameDuration(ref.GetFrameDuration());
  SetErrorCode(ref.GetErrorCode());
  SetEthernetChecksum(ref.GetEthernetChecksum());
  SetPacketData(ref.GetPacketData());
  }
  return *this;
}

uint32_t EthernetPacketErrorEncoding::getVersion() const { return rti1516ev::HLAfixedRecord::getVersion(); }
void EthernetPacketErrorEncoding::SetClientIndex(int16_t value)
{
  mClientIndex.set(value);
}
int16_t EthernetPacketErrorEncoding::GetClientIndex() const
{
  return mClientIndex.get();
}
bool EthernetPacketErrorEncoding::IsClientIndexAvailable() const
{
  return true;
}
void EthernetPacketErrorEncoding::SetDir(DirMask value)
{
  // FOMCodeGen.FOMParser+EnumeratedDataType
  mDir = static_cast<uint8_t>(value);
}
DirMask EthernetPacketErrorEncoding::GetDir() const
{
  return static_cast<DirMask>(mDir.get());
}
bool EthernetPacketErrorEncoding::IsDirAvailable() const
{
  return true;
}
void EthernetPacketErrorEncoding::SetOriginalTimeStamp(VTimeNS value)
{
  mOriginalTimeStamp.set(value);
}
VTimeNS EthernetPacketErrorEncoding::GetOriginalTimeStamp() const
{
  return mOriginalTimeStamp.get();
}
bool EthernetPacketErrorEncoding::IsOriginalTimeStampAvailable() const
{
  return true;
}
void EthernetPacketErrorEncoding::SetSimulated(SimulatedFlag value)
{
  // FOMCodeGen.FOMParser+EnumeratedDataType
  mSimulated = static_cast<uint8_t>(value);
}
SimulatedFlag EthernetPacketErrorEncoding::GetSimulated() const
{
  return static_cast<SimulatedFlag>(mSimulated.get());
}
bool EthernetPacketErrorEncoding::IsSimulatedAvailable() const
{
  return true;
}
void EthernetPacketErrorEncoding::SetBusType(int16_t value)
{
  mBusType.set(value);
}
int16_t EthernetPacketErrorEncoding::GetBusType() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"BusType\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mBusType.get();
}
bool EthernetPacketErrorEncoding::IsBusTypeAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetPacketErrorEncoding::SetHardwareChannel(int64_t value)
{
  mHardwareChannel.set(value);
}
int64_t EthernetPacketErrorEncoding::GetHardwareChannel() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"HardwareChannel\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mHardwareChannel.get();
}
bool EthernetPacketErrorEncoding::IsHardwareChannelAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetPacketErrorEncoding::SetFrameDuration(VTimeNS value)
{
  mFrameDuration.set(value);
}
VTimeNS EthernetPacketErrorEncoding::GetFrameDuration() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"FrameDuration\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mFrameDuration.get();
}
bool EthernetPacketErrorEncoding::IsFrameDurationAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetPacketErrorEncoding::SetErrorCode(int32_t value)
{
  mErrorCode.set(value);
}
int32_t EthernetPacketErrorEncoding::GetErrorCode() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"ErrorCode\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mErrorCode.get();
}
bool EthernetPacketErrorEncoding::IsErrorCodeAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetPacketErrorEncoding::SetEthernetChecksum(int32_t value)
{
  mEthernetChecksum.set(value);
}
int32_t EthernetPacketErrorEncoding::GetEthernetChecksum() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"EthernetChecksum\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mEthernetChecksum.get();
}
bool EthernetPacketErrorEncoding::IsEthernetChecksumAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetPacketErrorEncoding::SetPacketData(const std::vector<uint8_t>& value)
{
  mPacketData.set(value);
}
void EthernetPacketErrorEncoding::SetPacketData(const uint8_t* value, size_t size)
{
	mPacketData.set(value, size);
}
const std::vector<uint8_t>& EthernetPacketErrorEncoding::GetPacketData() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"PacketData\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mPacketData.get();
}
bool EthernetPacketErrorEncoding::IsPacketDataAvailable() const
{
  return (getVersion() >= 1);
}
EthernetPacketErrorForwardedEncoding::EthernetPacketErrorForwardedEncoding() : rti1516ev::HLAfixedRecord(1)
{
  rti1516ev::HLAfixedRecord::appendElementPointer(&mClientIndex, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mDir, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mOriginalTimeStamp, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mSimulated, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mBusType, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mHardwareChannel, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mFrameDuration, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mErrorCode, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mEthernetChecksum, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mPacketData, 1);
}

EthernetPacketErrorForwardedEncoding::EthernetPacketErrorForwardedEncoding(const EthernetPacketErrorForwardedEncoding& ref)
  : rti1516ev::HLAfixedRecord(1)
  , mClientIndex(ref.mClientIndex)
  , mDir(ref.mDir)
  , mOriginalTimeStamp(ref.mOriginalTimeStamp)
  , mSimulated(ref.mSimulated)
  , mBusType(ref.mBusType)
  , mHardwareChannel(ref.mHardwareChannel)
  , mFrameDuration(ref.mFrameDuration)
  , mErrorCode(ref.mErrorCode)
  , mEthernetChecksum(ref.mEthernetChecksum)
  , mPacketData(ref.mPacketData)
{
  rti1516ev::HLAfixedRecord::appendElementPointer(&mClientIndex, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mDir, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mOriginalTimeStamp, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mSimulated, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mBusType, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mHardwareChannel, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mFrameDuration, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mErrorCode, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mEthernetChecksum, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mPacketData, 1);
}

EthernetPacketErrorForwardedEncoding::~EthernetPacketErrorForwardedEncoding()
{
}

EthernetPacketErrorForwardedEncoding& EthernetPacketErrorForwardedEncoding::operator=(const EthernetPacketErrorForwarded& ref)
{
  if (this != &ref)
  {
  SetClientIndex(ref.GetClientIndex());
  SetDir(ref.GetDir());
  SetOriginalTimeStamp(ref.GetOriginalTimeStamp());
  SetSimulated(ref.GetSimulated());
  SetBusType(ref.GetBusType());
  SetHardwareChannel(ref.GetHardwareChannel());
  SetFrameDuration(ref.GetFrameDuration());
  SetErrorCode(ref.GetErrorCode());
  SetEthernetChecksum(ref.GetEthernetChecksum());
  SetPacketData(ref.GetPacketData());
  }
  return *this;
}

uint32_t EthernetPacketErrorForwardedEncoding::getVersion() const { return rti1516ev::HLAfixedRecord::getVersion(); }
void EthernetPacketErrorForwardedEncoding::SetClientIndex(int16_t value)
{
  mClientIndex.set(value);
}
int16_t EthernetPacketErrorForwardedEncoding::GetClientIndex() const
{
  return mClientIndex.get();
}
bool EthernetPacketErrorForwardedEncoding::IsClientIndexAvailable() const
{
  return true;
}
void EthernetPacketErrorForwardedEncoding::SetDir(DirMask value)
{
  // FOMCodeGen.FOMParser+EnumeratedDataType
  mDir = static_cast<uint8_t>(value);
}
DirMask EthernetPacketErrorForwardedEncoding::GetDir() const
{
  return static_cast<DirMask>(mDir.get());
}
bool EthernetPacketErrorForwardedEncoding::IsDirAvailable() const
{
  return true;
}
void EthernetPacketErrorForwardedEncoding::SetOriginalTimeStamp(VTimeNS value)
{
  mOriginalTimeStamp.set(value);
}
VTimeNS EthernetPacketErrorForwardedEncoding::GetOriginalTimeStamp() const
{
  return mOriginalTimeStamp.get();
}
bool EthernetPacketErrorForwardedEncoding::IsOriginalTimeStampAvailable() const
{
  return true;
}
void EthernetPacketErrorForwardedEncoding::SetSimulated(SimulatedFlag value)
{
  // FOMCodeGen.FOMParser+EnumeratedDataType
  mSimulated = static_cast<uint8_t>(value);
}
SimulatedFlag EthernetPacketErrorForwardedEncoding::GetSimulated() const
{
  return static_cast<SimulatedFlag>(mSimulated.get());
}
bool EthernetPacketErrorForwardedEncoding::IsSimulatedAvailable() const
{
  return true;
}
void EthernetPacketErrorForwardedEncoding::SetBusType(int16_t value)
{
  mBusType.set(value);
}
int16_t EthernetPacketErrorForwardedEncoding::GetBusType() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"BusType\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mBusType.get();
}
bool EthernetPacketErrorForwardedEncoding::IsBusTypeAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetPacketErrorForwardedEncoding::SetHardwareChannel(int64_t value)
{
  mHardwareChannel.set(value);
}
int64_t EthernetPacketErrorForwardedEncoding::GetHardwareChannel() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"HardwareChannel\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mHardwareChannel.get();
}
bool EthernetPacketErrorForwardedEncoding::IsHardwareChannelAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetPacketErrorForwardedEncoding::SetFrameDuration(VTimeNS value)
{
  mFrameDuration.set(value);
}
VTimeNS EthernetPacketErrorForwardedEncoding::GetFrameDuration() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"FrameDuration\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mFrameDuration.get();
}
bool EthernetPacketErrorForwardedEncoding::IsFrameDurationAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetPacketErrorForwardedEncoding::SetErrorCode(int32_t value)
{
  mErrorCode.set(value);
}
int32_t EthernetPacketErrorForwardedEncoding::GetErrorCode() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"ErrorCode\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mErrorCode.get();
}
bool EthernetPacketErrorForwardedEncoding::IsErrorCodeAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetPacketErrorForwardedEncoding::SetEthernetChecksum(int32_t value)
{
  mEthernetChecksum.set(value);
}
int32_t EthernetPacketErrorForwardedEncoding::GetEthernetChecksum() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"EthernetChecksum\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mEthernetChecksum.get();
}
bool EthernetPacketErrorForwardedEncoding::IsEthernetChecksumAvailable() const
{
  return (getVersion() >= 1);
}
void EthernetPacketErrorForwardedEncoding::SetPacketData(const std::vector<uint8_t>& value)
{
  mPacketData.set(value);
}
void EthernetPacketErrorForwardedEncoding::SetPacketData(const uint8_t* value, size_t size)
{
	mPacketData.set(value, size);
}
const std::vector<uint8_t>& EthernetPacketErrorForwardedEncoding::GetPacketData() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"PacketData\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mPacketData.get();
}
bool EthernetPacketErrorForwardedEncoding::IsPacketDataAvailable() const
{
  return (getVersion() >= 1);
}
// Payload of FlexRay Frame
FlexRayPayloadEncoding::FlexRayPayloadEncoding() : rti1516ev::HLAfixedRecord(1)
{
  rti1516ev::HLAfixedRecord::appendElementPointer(&mClientIndex, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mDir, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mOriginalTimeStamp, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mSimulated, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mPayloadData, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mPayloadValid, 1);
}

FlexRayPayloadEncoding::FlexRayPayloadEncoding(const FlexRayPayloadEncoding& ref)
  : rti1516ev::HLAfixedRecord(1)
  , mClientIndex(ref.mClientIndex)
  , mDir(ref.mDir)
  , mOriginalTimeStamp(ref.mOriginalTimeStamp)
  , mSimulated(ref.mSimulated)
  , mPayloadData(ref.mPayloadData)
  , mPayloadValid(ref.mPayloadValid)
{
  rti1516ev::HLAfixedRecord::appendElementPointer(&mClientIndex, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mDir, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mOriginalTimeStamp, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mSimulated, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mPayloadData, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mPayloadValid, 1);
}

FlexRayPayloadEncoding::~FlexRayPayloadEncoding()
{
}

FlexRayPayloadEncoding& FlexRayPayloadEncoding::operator=(const FlexRayPayload& ref)
{
  if (this != &ref)
  {
  SetClientIndex(ref.GetClientIndex());
  SetDir(ref.GetDir());
  SetOriginalTimeStamp(ref.GetOriginalTimeStamp());
  SetSimulated(ref.GetSimulated());
  SetPayloadData(ref.GetPayloadData());
  SetPayloadValid(ref.GetPayloadValid());
  }
  return *this;
}

uint32_t FlexRayPayloadEncoding::getVersion() const { return rti1516ev::HLAfixedRecord::getVersion(); }
void FlexRayPayloadEncoding::SetClientIndex(int16_t value)
{
  mClientIndex.set(value);
}
int16_t FlexRayPayloadEncoding::GetClientIndex() const
{
  return mClientIndex.get();
}
bool FlexRayPayloadEncoding::IsClientIndexAvailable() const
{
  return true;
}
void FlexRayPayloadEncoding::SetDir(DirMask value)
{
  // FOMCodeGen.FOMParser+EnumeratedDataType
  mDir = static_cast<uint8_t>(value);
}
DirMask FlexRayPayloadEncoding::GetDir() const
{
  return static_cast<DirMask>(mDir.get());
}
bool FlexRayPayloadEncoding::IsDirAvailable() const
{
  return true;
}
void FlexRayPayloadEncoding::SetOriginalTimeStamp(VTimeNS value)
{
  mOriginalTimeStamp.set(value);
}
VTimeNS FlexRayPayloadEncoding::GetOriginalTimeStamp() const
{
  return mOriginalTimeStamp.get();
}
bool FlexRayPayloadEncoding::IsOriginalTimeStampAvailable() const
{
  return true;
}
void FlexRayPayloadEncoding::SetSimulated(SimulatedFlag value)
{
  // FOMCodeGen.FOMParser+EnumeratedDataType
  mSimulated = static_cast<uint8_t>(value);
}
SimulatedFlag FlexRayPayloadEncoding::GetSimulated() const
{
  return static_cast<SimulatedFlag>(mSimulated.get());
}
bool FlexRayPayloadEncoding::IsSimulatedAvailable() const
{
  return true;
}
void FlexRayPayloadEncoding::SetPayloadData(const std::vector<uint8_t>& value)
{
  mPayloadData.set(value);
}
void FlexRayPayloadEncoding::SetPayloadData(const uint8_t* value, size_t size)
{
	mPayloadData.set(value, size);
}
const std::vector<uint8_t>& FlexRayPayloadEncoding::GetPayloadData() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"PayloadData\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mPayloadData.get();
}
bool FlexRayPayloadEncoding::IsPayloadDataAvailable() const
{
  return (getVersion() >= 1);
}
void FlexRayPayloadEncoding::SetPayloadValid(bool value)
{
  mPayloadValid.set(value);
}
bool FlexRayPayloadEncoding::GetPayloadValid() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"PayloadValid\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mPayloadValid.get();
}
bool FlexRayPayloadEncoding::IsPayloadValidAvailable() const
{
  return (getVersion() >= 1);
}
// Header of FlexRay Frame
FlexRayHeaderEncoding::FlexRayHeaderEncoding() : rti1516ev::HLAfixedRecord(1)
{
  rti1516ev::HLAfixedRecord::appendElementPointer(&mSuFindicator, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mSyFIndicator, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mNFIndicator, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mPPIndicator, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mFrameID, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mpayloadLength, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mHeaderCRC, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mCycle, 1);
}

FlexRayHeaderEncoding::FlexRayHeaderEncoding(const FlexRayHeaderEncoding& ref)
  : rti1516ev::HLAfixedRecord(1)
  , mSuFindicator(ref.mSuFindicator)
  , mSyFIndicator(ref.mSyFIndicator)
  , mNFIndicator(ref.mNFIndicator)
  , mPPIndicator(ref.mPPIndicator)
  , mFrameID(ref.mFrameID)
  , mpayloadLength(ref.mpayloadLength)
  , mHeaderCRC(ref.mHeaderCRC)
  , mCycle(ref.mCycle)
{
  rti1516ev::HLAfixedRecord::appendElementPointer(&mSuFindicator, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mSyFIndicator, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mNFIndicator, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mPPIndicator, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mFrameID, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mpayloadLength, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mHeaderCRC, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mCycle, 1);
}

FlexRayHeaderEncoding::~FlexRayHeaderEncoding()
{
}

FlexRayHeaderEncoding& FlexRayHeaderEncoding::operator=(const FlexRayHeader& ref)
{
  if (this != &ref)
  {
  SetSuFindicator(ref.GetSuFindicator());
  SetSyFIndicator(ref.GetSyFIndicator());
  SetNFIndicator(ref.GetNFIndicator());
  SetPPIndicator(ref.GetPPIndicator());
  SetFrameID(ref.GetFrameID());
  SetpayloadLength(ref.GetpayloadLength());
  SetHeaderCRC(ref.GetHeaderCRC());
  SetCycle(ref.GetCycle());
  }
  return *this;
}

uint32_t FlexRayHeaderEncoding::getVersion() const { return rti1516ev::HLAfixedRecord::getVersion(); }
void FlexRayHeaderEncoding::SetSuFindicator(bool value)
{
  mSuFindicator.set(value);
}
bool FlexRayHeaderEncoding::GetSuFindicator() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"SuFindicator\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mSuFindicator.get();
}
bool FlexRayHeaderEncoding::IsSuFindicatorAvailable() const
{
  return (getVersion() >= 1);
}
void FlexRayHeaderEncoding::SetSyFIndicator(bool value)
{
  mSyFIndicator.set(value);
}
bool FlexRayHeaderEncoding::GetSyFIndicator() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"SyFIndicator\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mSyFIndicator.get();
}
bool FlexRayHeaderEncoding::IsSyFIndicatorAvailable() const
{
  return (getVersion() >= 1);
}
void FlexRayHeaderEncoding::SetNFIndicator(bool value)
{
  mNFIndicator.set(value);
}
bool FlexRayHeaderEncoding::GetNFIndicator() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"NFIndicator\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mNFIndicator.get();
}
bool FlexRayHeaderEncoding::IsNFIndicatorAvailable() const
{
  return (getVersion() >= 1);
}
void FlexRayHeaderEncoding::SetPPIndicator(bool value)
{
  mPPIndicator.set(value);
}
bool FlexRayHeaderEncoding::GetPPIndicator() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"PPIndicator\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mPPIndicator.get();
}
bool FlexRayHeaderEncoding::IsPPIndicatorAvailable() const
{
  return (getVersion() >= 1);
}
void FlexRayHeaderEncoding::SetFrameID(int16_t value)
{
  mFrameID.set(value);
}
int16_t FlexRayHeaderEncoding::GetFrameID() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"FrameID\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mFrameID.get();
}
bool FlexRayHeaderEncoding::IsFrameIDAvailable() const
{
  return (getVersion() >= 1);
}
void FlexRayHeaderEncoding::SetpayloadLength(uint8_t value)
{
  mpayloadLength.set(value);
}
uint8_t FlexRayHeaderEncoding::GetpayloadLength() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"payloadLength\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mpayloadLength.get();
}
bool FlexRayHeaderEncoding::IspayloadLengthAvailable() const
{
  return (getVersion() >= 1);
}
void FlexRayHeaderEncoding::SetHeaderCRC(int16_t value)
{
  mHeaderCRC.set(value);
}
int16_t FlexRayHeaderEncoding::GetHeaderCRC() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"HeaderCRC\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mHeaderCRC.get();
}
bool FlexRayHeaderEncoding::IsHeaderCRCAvailable() const
{
  return (getVersion() >= 1);
}
void FlexRayHeaderEncoding::SetCycle(uint8_t value)
{
  mCycle.set(value);
}
uint8_t FlexRayHeaderEncoding::GetCycle() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"Cycle\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mCycle.get();
}
bool FlexRayHeaderEncoding::IsCycleAvailable() const
{
  return (getVersion() >= 1);
}
// FlexRay Frame
FlexRayFrameEncoding::FlexRayFrameEncoding() : rti1516ev::HLAfixedRecord(1)
{
  rti1516ev::HLAfixedRecord::appendElementPointer(&mClientIndex, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mDir, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mOriginalTimeStamp, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mSimulated, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mPayloadData, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mPayloadValid, 1);
}

FlexRayFrameEncoding::FlexRayFrameEncoding(const FlexRayFrameEncoding& ref)
  : rti1516ev::HLAfixedRecord(1)
  , mClientIndex(ref.mClientIndex)
  , mDir(ref.mDir)
  , mOriginalTimeStamp(ref.mOriginalTimeStamp)
  , mSimulated(ref.mSimulated)
  , mPayloadData(ref.mPayloadData)
  , mPayloadValid(ref.mPayloadValid)
{
  rti1516ev::HLAfixedRecord::appendElementPointer(&mClientIndex, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mDir, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mOriginalTimeStamp, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mSimulated, 0);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mPayloadData, 1);
  rti1516ev::HLAfixedRecord::appendElementPointer(&mPayloadValid, 1);
}

FlexRayFrameEncoding::~FlexRayFrameEncoding()
{
}

FlexRayFrameEncoding& FlexRayFrameEncoding::operator=(const FlexRayFrame& ref)
{
  if (this != &ref)
  {
  SetClientIndex(ref.GetClientIndex());
  SetDir(ref.GetDir());
  SetOriginalTimeStamp(ref.GetOriginalTimeStamp());
  SetSimulated(ref.GetSimulated());
  SetPayloadData(ref.GetPayloadData());
  SetPayloadValid(ref.GetPayloadValid());
  }
  return *this;
}

uint32_t FlexRayFrameEncoding::getVersion() const { return rti1516ev::HLAfixedRecord::getVersion(); }
void FlexRayFrameEncoding::SetClientIndex(int16_t value)
{
  mClientIndex.set(value);
}
int16_t FlexRayFrameEncoding::GetClientIndex() const
{
  return mClientIndex.get();
}
bool FlexRayFrameEncoding::IsClientIndexAvailable() const
{
  return true;
}
void FlexRayFrameEncoding::SetDir(DirMask value)
{
  // FOMCodeGen.FOMParser+EnumeratedDataType
  mDir = static_cast<uint8_t>(value);
}
DirMask FlexRayFrameEncoding::GetDir() const
{
  return static_cast<DirMask>(mDir.get());
}
bool FlexRayFrameEncoding::IsDirAvailable() const
{
  return true;
}
void FlexRayFrameEncoding::SetOriginalTimeStamp(VTimeNS value)
{
  mOriginalTimeStamp.set(value);
}
VTimeNS FlexRayFrameEncoding::GetOriginalTimeStamp() const
{
  return mOriginalTimeStamp.get();
}
bool FlexRayFrameEncoding::IsOriginalTimeStampAvailable() const
{
  return true;
}
void FlexRayFrameEncoding::SetSimulated(SimulatedFlag value)
{
  // FOMCodeGen.FOMParser+EnumeratedDataType
  mSimulated = static_cast<uint8_t>(value);
}
SimulatedFlag FlexRayFrameEncoding::GetSimulated() const
{
  return static_cast<SimulatedFlag>(mSimulated.get());
}
bool FlexRayFrameEncoding::IsSimulatedAvailable() const
{
  return true;
}
void FlexRayFrameEncoding::SetPayloadData(const std::vector<uint8_t>& value)
{
  mPayloadData.set(value);
}
void FlexRayFrameEncoding::SetPayloadData(const uint8_t* value, size_t size)
{
	mPayloadData.set(value, size);
}
const std::vector<uint8_t>& FlexRayFrameEncoding::GetPayloadData() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"PayloadData\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mPayloadData.get();
}
bool FlexRayFrameEncoding::IsPayloadDataAvailable() const
{
  return (getVersion() >= 1);
}
void FlexRayFrameEncoding::SetPayloadValid(bool value)
{
  mPayloadValid.set(value);
}
bool FlexRayFrameEncoding::GetPayloadValid() const
{
  if (getVersion() < 1)
  {
    throw rti1516ev::EncoderException(L"field \"PayloadValid\" is not available in decoded record version " + std::to_wstring(getVersion()));
  }
  return mPayloadValid.get();
}
bool FlexRayFrameEncoding::IsPayloadValidAvailable() const
{
  return (getVersion() >= 1);
}
} // namespace NDistSimIB
} // namespace NRTFederateEncoding

