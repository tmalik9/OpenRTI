
// Code automatically generated by FOMCodeGen version 2.0.1.18 from RTFederate.xml, do not edit

#include <vector>
#include <cassert>
#include "RTFederateObjects.h"

namespace NDistSimIB {
namespace NRTFederateEncoding {

inline std::string to_string(const std::wstring& str)
{
  if (str.empty()) return std::string();
  const std::ctype<wchar_t>& CType = std::use_facet<std::ctype<wchar_t> >(std::locale());
  std::vector<char> stringBuffer(str.length());
  CType.narrow(str.data(), str.data() + str.length(), '_', &stringBuffer[0]);
  return std::string(&stringBuffer[0], stringBuffer.size());
}

HLAobjectRootObjectClass::HLAobjectRootObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry)
{
  mRegistry = registry;
  mRtiAmbassador = rtiAmbassador;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot");
// attribute HLAobjectRoot.HLAprivilegeToDeleteObject : no data type
  SetObjectInstanceCreator([](HLAobjectRootObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador) -> HLAobjectRoot* {
    return new HLAobjectRoot(objectClass, instanceName, rtiAmbassador);
  });
}

HLAobjectRootObjectClass::~HLAobjectRootObjectClass()
{
  //std::lock_guard<std::recursive_mutex> lock(mMutex);
  while (!mObjectInstancesByHandle.empty())
  {
    // careful - hold the reference to the object instance until it has been removed from the maps,
    // otherwise it's mutex will be destroyed while held
    auto objectInstance = mObjectInstancesByHandle.begin()->second;
    objectInstance->Release();
  }
  assert(mObjectInstancesByHandle.empty());
  assert(mObjectInstancesByName.empty());
}

void HLAobjectRootObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void HLAobjectRootObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void HLAobjectRootObjectClass::Subscribe(bool deliverToSelf)
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    if (deliverToSelf) mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void HLAobjectRootObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

rti1516ev::AttributeHandleSet HLAobjectRootObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  return result;
}

void HLAobjectRootObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  assert(mObjectInstancesByName.find(objectInstanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(objectInstanceHandle) == mObjectInstancesByHandle.end());
  std::shared_ptr<HLAobjectRoot> newObject = std::shared_ptr<HLAobjectRoot>(mCreatorFunction(this, objectInstanceName, mRtiAmbassador));
  newObject->mObjectInstanceHandle = objectInstanceHandle;
  newObject->mIsOwner = false;
  InsertObjectInstanceName(newObject, objectInstanceName);
  InsertObjectInstanceHandle(newObject, objectInstanceHandle);
  ExecuteDiscoverObjectInstanceCallbacks(newObject);
}

void HLAobjectRootObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring objectInstanceName = mRtiAmbassador->getObjectInstanceName(objectInstanceHandle);
  auto iter = mObjectInstancesByName.find(objectInstanceName);
  assert(iter != mObjectInstancesByName.end());
  auto objectInstance = std::dynamic_pointer_cast<HLAobjectRoot>(iter->second);
  ExecuteRemoveObjectInstanceCallbacks(objectInstance);
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  EraseObjectInstance(objectInstanceHandle, objectInstanceName);
}

std::shared_ptr<IHLAobjectRoot> HLAobjectRootObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  return nullptr;
}

std::shared_ptr<IHLAobjectRoot> HLAobjectRootObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  return nullptr;
}

std::shared_ptr<IHLAobjectRoot> HLAobjectRootObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"HLAobjectRoot");
  }
  std::shared_ptr<HLAobjectRoot> newObject = std::shared_ptr<HLAobjectRoot>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
    }
  });
  return newObject;
}

std::shared_ptr<IHLAobjectRoot> HLAobjectRootObjectClass::CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"HLAobjectRoot");
  }
  std::shared_ptr<HLAobjectRoot> newObject = std::shared_ptr<HLAobjectRoot>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
      createdCallback(newObject, true);
    }
    else
    {
      createdCallback(newObject, false);
    }
  });
  return newObject;
}

uint32_t HLAobjectRootObjectClass::RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastDiscoverObjectInstanceCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastDiscoverObjectInstanceCallbackToken, callback));
  return mLastDiscoverObjectInstanceCallbackToken;
}

void HLAobjectRootObjectClass::UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mDiscoverCallbacks.erase(callbackToken);
}

void HLAobjectRootObjectClass::ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IHLAobjectRoot> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

uint32_t HLAobjectRootObjectClass::RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastRemoveObjectInstanceCallbackToken++;
  mRemoveObjectInstanceCallbacks.insert(std::make_pair(mLastRemoveObjectInstanceCallbackToken, callback));
  return mLastRemoveObjectInstanceCallbackToken;
}

void HLAobjectRootObjectClass::UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mRemoveObjectInstanceCallbacks.erase(callbackToken);
}

void HLAobjectRootObjectClass::ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IHLAobjectRoot> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mRemoveObjectInstanceCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

void HLAobjectRootObjectClass::InsertObjectInstanceName(std::shared_ptr<IHLAobjectRoot> objectInstance, const std::wstring& objectInstanceName)
{
  // prerequisite: mMutex must be locked
  mObjectInstancesByName.insert(std::make_pair(objectInstanceName, objectInstance));
}

void HLAobjectRootObjectClass::InsertObjectInstanceHandle(std::shared_ptr<IHLAobjectRoot> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByHandle.insert(std::make_pair(objectInstanceHandle, objectInstance));
}

void HLAobjectRootObjectClass::EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByName.erase(objectInstanceName);
  mObjectInstancesByHandle.erase(objectInstanceHandle);
}


// object instances of type 'HLAobjectRoot'
HLAobjectRoot::HLAobjectRoot()
  : mRtiAmbassador()
  , mObjectClass()
  , mObjectInstanceName()
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

HLAobjectRoot::HLAobjectRoot(HLAobjectRootObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mRtiAmbassador(rtiAmbassador)
  , mObjectClass(objectClass)
  , mObjectInstanceName(instanceName)
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

HLAobjectRoot::~HLAobjectRoot()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    try
    {
      mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    }
    catch (const rti1516ev::Exception&)
    {
    }
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

bool HLAobjectRoot::IsValid() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mObjectInstanceHandle.isValid();
}

bool HLAobjectRoot::IsOwner() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mIsOwner;
}

void HLAobjectRoot::Release()
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (mObjectInstanceHandle.isValid())
  {
    if (mIsOwner)
    {
      try
      {
        mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
      }
      catch (const rti1516ev::Exception&)
      {
        // ignore - must execute rest of function
      }
      mIsOwner = false;
    }
    mObjectClass->EraseObjectInstance(mObjectInstanceHandle, mObjectInstanceName);
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  }
}

// attribute HLAobjectRoot.HLAprivilegeToDeleteObject : no data type

rti1516ev::AttributeHandleValueMap HLAobjectRoot::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  return result;
}

rti1516ev::AttributeHandleValueMap HLAobjectRoot::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  return result;
}


// object class type 'SystemVariable'
SystemVariableObjectClass::SystemVariableObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, HLAobjectRootObjectClass* baseClass)
{
  mRegistry = registry;
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.SystemVariable");
  // attribute Value : HLAopaqueData
  mValueAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"Value");
  SetObjectInstanceCreator([](SystemVariableObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador) -> SystemVariable* {
    return new SystemVariable(objectClass, instanceName, rtiAmbassador);
  });
}

SystemVariableObjectClass::~SystemVariableObjectClass()
{
  //std::lock_guard<std::recursive_mutex> lock(mMutex);
  while (!mObjectInstancesByHandle.empty())
  {
    // careful - hold the reference to the object instance until it has been removed from the maps,
    // otherwise it's mutex will be destroyed while held
    auto objectInstance = mObjectInstancesByHandle.begin()->second;
    objectInstance->Release();
  }
  assert(mObjectInstancesByHandle.empty());
  assert(mObjectInstancesByName.empty());
}

void SystemVariableObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void SystemVariableObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void SystemVariableObjectClass::Subscribe(bool deliverToSelf)
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    if (deliverToSelf) mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void SystemVariableObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

rti1516ev::AttributeHandleSet SystemVariableObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetValueAttributeHandle());
  return result;
}

void SystemVariableObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  assert(mObjectInstancesByName.find(objectInstanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(objectInstanceHandle) == mObjectInstancesByHandle.end());
  std::shared_ptr<SystemVariable> newObject = std::shared_ptr<SystemVariable>(mCreatorFunction(this, objectInstanceName, mRtiAmbassador));
  newObject->mObjectInstanceHandle = objectInstanceHandle;
  newObject->mIsOwner = false;
  InsertObjectInstanceName(newObject, objectInstanceName);
  InsertObjectInstanceHandle(newObject, objectInstanceHandle);
  ExecuteDiscoverObjectInstanceCallbacks(newObject);
}

void SystemVariableObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring objectInstanceName = mRtiAmbassador->getObjectInstanceName(objectInstanceHandle);
  auto iter = mObjectInstancesByName.find(objectInstanceName);
  assert(iter != mObjectInstancesByName.end());
  auto objectInstance = std::dynamic_pointer_cast<SystemVariable>(iter->second);
  ExecuteRemoveObjectInstanceCallbacks(objectInstance);
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  EraseObjectInstance(objectInstanceHandle, objectInstanceName);
}

std::shared_ptr<ISystemVariable> SystemVariableObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IHLAobjectRoot> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceName);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<ISystemVariable>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<ISystemVariable> SystemVariableObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IHLAobjectRoot> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceHandle);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<ISystemVariable>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<ISystemVariable> SystemVariableObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"SystemVariable");
  }
  std::shared_ptr<SystemVariable> newObject = std::shared_ptr<SystemVariable>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
    }
  });
  return newObject;
}

std::shared_ptr<ISystemVariable> SystemVariableObjectClass::CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"SystemVariable");
  }
  std::shared_ptr<SystemVariable> newObject = std::shared_ptr<SystemVariable>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
      createdCallback(newObject, true);
    }
    else
    {
      createdCallback(newObject, false);
    }
  });
  return newObject;
}

uint32_t SystemVariableObjectClass::RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastDiscoverObjectInstanceCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastDiscoverObjectInstanceCallbackToken, callback));
  return mLastDiscoverObjectInstanceCallbackToken;
}

void SystemVariableObjectClass::UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mDiscoverCallbacks.erase(callbackToken);
}

void SystemVariableObjectClass::ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<ISystemVariable> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

uint32_t SystemVariableObjectClass::RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastRemoveObjectInstanceCallbackToken++;
  mRemoveObjectInstanceCallbacks.insert(std::make_pair(mLastRemoveObjectInstanceCallbackToken, callback));
  return mLastRemoveObjectInstanceCallbackToken;
}

void SystemVariableObjectClass::UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mRemoveObjectInstanceCallbacks.erase(callbackToken);
}

void SystemVariableObjectClass::ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<ISystemVariable> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mRemoveObjectInstanceCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

void SystemVariableObjectClass::InsertObjectInstanceName(std::shared_ptr<ISystemVariable> objectInstance, const std::wstring& objectInstanceName)
{
  // prerequisite: mMutex must be locked
  mObjectInstancesByName.insert(std::make_pair(objectInstanceName, objectInstance));
  mBaseClass->InsertObjectInstanceName(objectInstance, objectInstanceName);
}

void SystemVariableObjectClass::InsertObjectInstanceHandle(std::shared_ptr<ISystemVariable> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByHandle.insert(std::make_pair(objectInstanceHandle, objectInstance));
  mBaseClass->InsertObjectInstanceHandle(objectInstance, objectInstanceHandle);
}

void SystemVariableObjectClass::EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mBaseClass->EraseObjectInstance(objectInstanceHandle, objectInstanceName);
  mObjectInstancesByName.erase(objectInstanceName);
  mObjectInstancesByHandle.erase(objectInstanceHandle);
}


// object instances of type 'SystemVariable'
SystemVariable::SystemVariable()
  : mRtiAmbassador()
  , mObjectClass()
  , mObjectInstanceName()
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

SystemVariable::SystemVariable(SystemVariableObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mRtiAmbassador(rtiAmbassador)
  , mObjectClass(objectClass)
  , mObjectInstanceName(instanceName)
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

SystemVariable::~SystemVariable()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    try
    {
      mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    }
    catch (const rti1516ev::Exception&)
    {
    }
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

bool SystemVariable::IsValid() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mObjectInstanceHandle.isValid();
}

bool SystemVariable::IsOwner() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mIsOwner;
}

void SystemVariable::Release()
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (mObjectInstanceHandle.isValid())
  {
    if (mIsOwner)
    {
      try
      {
        mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
      }
      catch (const rti1516ev::Exception&)
      {
        // ignore - must execute rest of function
      }
      mIsOwner = false;
    }
    mObjectClass->EraseObjectInstance(mObjectInstanceHandle, mObjectInstanceName);
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  }
}

// attribute SystemVariable.HLAprivilegeToDeleteObject : no data type

// attribute Value : HLAopaqueData
std::vector<uint8_t> SystemVariable::GetValue() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValue.get();
}

void SystemVariable::SetValue(const std::vector<uint8_t>& newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mValue.set(newValue);
  mDirty |= kValueBit;
  mValuesSet |= kValueBit;
}

rti1516ev::AttributeHandleValueMap SystemVariable::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetValueAttributeHandle()] = mValue.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap SystemVariable::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kValueBit)
  {
    result[mObjectClass->GetValueAttributeHandle()] = mValue.encode();
  }
  return result;
}

SystemVariable::AttributeBits SystemVariable::GetReceivedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesReceived;
}

SystemVariable::AttributeBits SystemVariable::GetUpdatedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mLastUpdated;
}

SystemVariable::AttributeBits SystemVariable::GetInitializedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesSet;
}

SystemVariable::AttributeBits SystemVariable::GetModifiedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDirty;
}

void SystemVariable::UpdateAllAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void SystemVariable::UpdateAllAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    try {
      mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
      mDirty = kNone;
    }
    catch (const rti1516ev::InvalidLogicalTime& e)
    {
      throw InvalidLogicalTime(to_string(e.what()));
    }
    catch (const rti1516ev::Exception& e)
    {
      throw std::runtime_error(to_string(e.what()));
    }
  }
}

void SystemVariable::UpdateModifiedAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void SystemVariable::UpdateModifiedAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
        mDirty = kNone;
      }
      catch (const rti1516ev::InvalidLogicalTime& e)
      {
        throw InvalidLogicalTime(to_string(e.what()));
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void SystemVariable::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetValueAttributeHandle())
    {
      mValue.decode(attributeHandleValue.second);
      mLastUpdated |= kValueBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(optional<int64_t>(), optional<OrderType>());
  mLastUpdated = kNone;
} // SystemVariable::ReflectAttributeValues

void SystemVariable::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetValueAttributeHandle())
    {
      mValue.decode(attributeHandleValue.second);
      mLastUpdated |= kValueBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(static_cast<const rti1516ev::HLAinteger64Time&>(theTime).getTime(), orderType);
  mLastUpdated = kNone;
} // SystemVariable::ReflectAttributeValues

// request attributes not being part of the last update
void SystemVariable::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    if ((mLastUpdated & kValueBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetValueAttributeHandle());
    }
  } // scope of lock_guard
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// request all attributes, regardless of current state
void SystemVariable::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetValueAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// provide requested attributes set since last sent update
void SystemVariable::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    for (auto& attributeHandle : attributeHandles)
    {
      if (attributeHandle == mObjectClass->GetValueAttributeHandle() && (mValuesSet & kValueBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mValue.encode()));
        mDirty &= ~kValueBit;
      }
    } // for (auto& attributeHandleValue : attributes)
  } // scope of lock_guard
  if (time)
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(*time));
  else
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // SystemVariable::ReflectAttributeValues

uint32_t SystemVariable::RegisterUpdateCallback(UpdateCallback callback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void SystemVariable::UnregisterUpdateCallback(uint32_t callbackToken)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mUpdateCallbacks.erase(callbackToken);
}

void SystemVariable::ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(std::static_pointer_cast<ISystemVariable>(shared_from_this()), time, orderType);
  }
}


// object class type 'ValueEntity'
ValueEntityObjectClass::ValueEntityObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, HLAobjectRootObjectClass* baseClass)
{
  mRegistry = registry;
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.ValueEntity");
  // attribute Value : HLAopaqueData
  mValueAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"Value");
  SetObjectInstanceCreator([](ValueEntityObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador) -> ValueEntity* {
    return new ValueEntity(objectClass, instanceName, rtiAmbassador);
  });
}

ValueEntityObjectClass::~ValueEntityObjectClass()
{
  //std::lock_guard<std::recursive_mutex> lock(mMutex);
  while (!mObjectInstancesByHandle.empty())
  {
    // careful - hold the reference to the object instance until it has been removed from the maps,
    // otherwise it's mutex will be destroyed while held
    auto objectInstance = mObjectInstancesByHandle.begin()->second;
    objectInstance->Release();
  }
  assert(mObjectInstancesByHandle.empty());
  assert(mObjectInstancesByName.empty());
}

void ValueEntityObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void ValueEntityObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void ValueEntityObjectClass::Subscribe(bool deliverToSelf)
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    if (deliverToSelf) mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void ValueEntityObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

rti1516ev::AttributeHandleSet ValueEntityObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetValueAttributeHandle());
  return result;
}

void ValueEntityObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  assert(mObjectInstancesByName.find(objectInstanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(objectInstanceHandle) == mObjectInstancesByHandle.end());
  std::shared_ptr<ValueEntity> newObject = std::shared_ptr<ValueEntity>(mCreatorFunction(this, objectInstanceName, mRtiAmbassador));
  newObject->mObjectInstanceHandle = objectInstanceHandle;
  newObject->mIsOwner = false;
  InsertObjectInstanceName(newObject, objectInstanceName);
  InsertObjectInstanceHandle(newObject, objectInstanceHandle);
  ExecuteDiscoverObjectInstanceCallbacks(newObject);
}

void ValueEntityObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring objectInstanceName = mRtiAmbassador->getObjectInstanceName(objectInstanceHandle);
  auto iter = mObjectInstancesByName.find(objectInstanceName);
  assert(iter != mObjectInstancesByName.end());
  auto objectInstance = std::dynamic_pointer_cast<ValueEntity>(iter->second);
  ExecuteRemoveObjectInstanceCallbacks(objectInstance);
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  EraseObjectInstance(objectInstanceHandle, objectInstanceName);
}

std::shared_ptr<IValueEntity> ValueEntityObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IHLAobjectRoot> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceName);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IValueEntity>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IValueEntity> ValueEntityObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IHLAobjectRoot> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceHandle);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IValueEntity>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IValueEntity> ValueEntityObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"ValueEntity");
  }
  std::shared_ptr<ValueEntity> newObject = std::shared_ptr<ValueEntity>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
    }
  });
  return newObject;
}

std::shared_ptr<IValueEntity> ValueEntityObjectClass::CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"ValueEntity");
  }
  std::shared_ptr<ValueEntity> newObject = std::shared_ptr<ValueEntity>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
      createdCallback(newObject, true);
    }
    else
    {
      createdCallback(newObject, false);
    }
  });
  return newObject;
}

uint32_t ValueEntityObjectClass::RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastDiscoverObjectInstanceCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastDiscoverObjectInstanceCallbackToken, callback));
  return mLastDiscoverObjectInstanceCallbackToken;
}

void ValueEntityObjectClass::UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mDiscoverCallbacks.erase(callbackToken);
}

void ValueEntityObjectClass::ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IValueEntity> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

uint32_t ValueEntityObjectClass::RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastRemoveObjectInstanceCallbackToken++;
  mRemoveObjectInstanceCallbacks.insert(std::make_pair(mLastRemoveObjectInstanceCallbackToken, callback));
  return mLastRemoveObjectInstanceCallbackToken;
}

void ValueEntityObjectClass::UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mRemoveObjectInstanceCallbacks.erase(callbackToken);
}

void ValueEntityObjectClass::ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IValueEntity> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mRemoveObjectInstanceCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

void ValueEntityObjectClass::InsertObjectInstanceName(std::shared_ptr<IValueEntity> objectInstance, const std::wstring& objectInstanceName)
{
  // prerequisite: mMutex must be locked
  mObjectInstancesByName.insert(std::make_pair(objectInstanceName, objectInstance));
  mBaseClass->InsertObjectInstanceName(objectInstance, objectInstanceName);
}

void ValueEntityObjectClass::InsertObjectInstanceHandle(std::shared_ptr<IValueEntity> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByHandle.insert(std::make_pair(objectInstanceHandle, objectInstance));
  mBaseClass->InsertObjectInstanceHandle(objectInstance, objectInstanceHandle);
}

void ValueEntityObjectClass::EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mBaseClass->EraseObjectInstance(objectInstanceHandle, objectInstanceName);
  mObjectInstancesByName.erase(objectInstanceName);
  mObjectInstancesByHandle.erase(objectInstanceHandle);
}


// object instances of type 'ValueEntity'
ValueEntity::ValueEntity()
  : mRtiAmbassador()
  , mObjectClass()
  , mObjectInstanceName()
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

ValueEntity::ValueEntity(ValueEntityObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mRtiAmbassador(rtiAmbassador)
  , mObjectClass(objectClass)
  , mObjectInstanceName(instanceName)
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

ValueEntity::~ValueEntity()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    try
    {
      mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    }
    catch (const rti1516ev::Exception&)
    {
    }
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

bool ValueEntity::IsValid() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mObjectInstanceHandle.isValid();
}

bool ValueEntity::IsOwner() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mIsOwner;
}

void ValueEntity::Release()
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (mObjectInstanceHandle.isValid())
  {
    if (mIsOwner)
    {
      try
      {
        mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
      }
      catch (const rti1516ev::Exception&)
      {
        // ignore - must execute rest of function
      }
      mIsOwner = false;
    }
    mObjectClass->EraseObjectInstance(mObjectInstanceHandle, mObjectInstanceName);
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  }
}

// attribute ValueEntity.HLAprivilegeToDeleteObject : no data type

// attribute Value : HLAopaqueData
std::vector<uint8_t> ValueEntity::GetValue() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValue.get();
}

void ValueEntity::SetValue(const std::vector<uint8_t>& newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mValue.set(newValue);
  mDirty |= kValueBit;
  mValuesSet |= kValueBit;
}

rti1516ev::AttributeHandleValueMap ValueEntity::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetValueAttributeHandle()] = mValue.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap ValueEntity::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kValueBit)
  {
    result[mObjectClass->GetValueAttributeHandle()] = mValue.encode();
  }
  return result;
}

ValueEntity::AttributeBits ValueEntity::GetReceivedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesReceived;
}

ValueEntity::AttributeBits ValueEntity::GetUpdatedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mLastUpdated;
}

ValueEntity::AttributeBits ValueEntity::GetInitializedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesSet;
}

ValueEntity::AttributeBits ValueEntity::GetModifiedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDirty;
}

void ValueEntity::UpdateAllAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void ValueEntity::UpdateAllAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    try {
      mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
      mDirty = kNone;
    }
    catch (const rti1516ev::InvalidLogicalTime& e)
    {
      throw InvalidLogicalTime(to_string(e.what()));
    }
    catch (const rti1516ev::Exception& e)
    {
      throw std::runtime_error(to_string(e.what()));
    }
  }
}

void ValueEntity::UpdateModifiedAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void ValueEntity::UpdateModifiedAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
        mDirty = kNone;
      }
      catch (const rti1516ev::InvalidLogicalTime& e)
      {
        throw InvalidLogicalTime(to_string(e.what()));
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void ValueEntity::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetValueAttributeHandle())
    {
      mValue.decode(attributeHandleValue.second);
      mLastUpdated |= kValueBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(optional<int64_t>(), optional<OrderType>());
  mLastUpdated = kNone;
} // ValueEntity::ReflectAttributeValues

void ValueEntity::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetValueAttributeHandle())
    {
      mValue.decode(attributeHandleValue.second);
      mLastUpdated |= kValueBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(static_cast<const rti1516ev::HLAinteger64Time&>(theTime).getTime(), orderType);
  mLastUpdated = kNone;
} // ValueEntity::ReflectAttributeValues

// request attributes not being part of the last update
void ValueEntity::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    if ((mLastUpdated & kValueBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetValueAttributeHandle());
    }
  } // scope of lock_guard
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// request all attributes, regardless of current state
void ValueEntity::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetValueAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// provide requested attributes set since last sent update
void ValueEntity::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    for (auto& attributeHandle : attributeHandles)
    {
      if (attributeHandle == mObjectClass->GetValueAttributeHandle() && (mValuesSet & kValueBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mValue.encode()));
        mDirty &= ~kValueBit;
      }
    } // for (auto& attributeHandleValue : attributes)
  } // scope of lock_guard
  if (time)
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(*time));
  else
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // ValueEntity::ReflectAttributeValues

uint32_t ValueEntity::RegisterUpdateCallback(UpdateCallback callback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void ValueEntity::UnregisterUpdateCallback(uint32_t callbackToken)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mUpdateCallbacks.erase(callbackToken);
}

void ValueEntity::ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(std::static_pointer_cast<IValueEntity>(shared_from_this()), time, orderType);
  }
}


// object class type 'DOMemberSource'
DOMemberSourceObjectClass::DOMemberSourceObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, HLAobjectRootObjectClass* baseClass)
{
  mRegistry = registry;
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.DOMemberSource");
  // attribute DOSourceMemberName : HLAASCIIstring
  mDOSourceMemberNameAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"DOSourceMemberName");
  // attribute DOSourceMemberConnectionType : HLAASCIIstring
  mDOSourceMemberConnectionTypeAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"DOSourceMemberConnectionType");
  // attribute DOSourceMemberDataBytes : HLAopaqueData
  mDOSourceMemberDataBytesAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"DOSourceMemberDataBytes");
  SetObjectInstanceCreator([](DOMemberSourceObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador) -> DOMemberSource* {
    return new DOMemberSource(objectClass, instanceName, rtiAmbassador);
  });
}

DOMemberSourceObjectClass::~DOMemberSourceObjectClass()
{
  //std::lock_guard<std::recursive_mutex> lock(mMutex);
  while (!mObjectInstancesByHandle.empty())
  {
    // careful - hold the reference to the object instance until it has been removed from the maps,
    // otherwise it's mutex will be destroyed while held
    auto objectInstance = mObjectInstancesByHandle.begin()->second;
    objectInstance->Release();
  }
  assert(mObjectInstancesByHandle.empty());
  assert(mObjectInstancesByName.empty());
}

void DOMemberSourceObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void DOMemberSourceObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void DOMemberSourceObjectClass::Subscribe(bool deliverToSelf)
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    if (deliverToSelf) mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void DOMemberSourceObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

rti1516ev::AttributeHandleSet DOMemberSourceObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetDOSourceMemberNameAttributeHandle());
  result.insert(GetDOSourceMemberConnectionTypeAttributeHandle());
  result.insert(GetDOSourceMemberDataBytesAttributeHandle());
  return result;
}

void DOMemberSourceObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  assert(mObjectInstancesByName.find(objectInstanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(objectInstanceHandle) == mObjectInstancesByHandle.end());
  std::shared_ptr<DOMemberSource> newObject = std::shared_ptr<DOMemberSource>(mCreatorFunction(this, objectInstanceName, mRtiAmbassador));
  newObject->mObjectInstanceHandle = objectInstanceHandle;
  newObject->mIsOwner = false;
  InsertObjectInstanceName(newObject, objectInstanceName);
  InsertObjectInstanceHandle(newObject, objectInstanceHandle);
  ExecuteDiscoverObjectInstanceCallbacks(newObject);
}

void DOMemberSourceObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring objectInstanceName = mRtiAmbassador->getObjectInstanceName(objectInstanceHandle);
  auto iter = mObjectInstancesByName.find(objectInstanceName);
  assert(iter != mObjectInstancesByName.end());
  auto objectInstance = std::dynamic_pointer_cast<DOMemberSource>(iter->second);
  ExecuteRemoveObjectInstanceCallbacks(objectInstance);
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  EraseObjectInstance(objectInstanceHandle, objectInstanceName);
}

std::shared_ptr<IDOMemberSource> DOMemberSourceObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IHLAobjectRoot> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceName);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IDOMemberSource>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IDOMemberSource> DOMemberSourceObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IHLAobjectRoot> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceHandle);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IDOMemberSource>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IDOMemberSource> DOMemberSourceObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"DOMemberSource");
  }
  std::shared_ptr<DOMemberSource> newObject = std::shared_ptr<DOMemberSource>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
    }
  });
  return newObject;
}

std::shared_ptr<IDOMemberSource> DOMemberSourceObjectClass::CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"DOMemberSource");
  }
  std::shared_ptr<DOMemberSource> newObject = std::shared_ptr<DOMemberSource>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
      createdCallback(newObject, true);
    }
    else
    {
      createdCallback(newObject, false);
    }
  });
  return newObject;
}

uint32_t DOMemberSourceObjectClass::RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastDiscoverObjectInstanceCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastDiscoverObjectInstanceCallbackToken, callback));
  return mLastDiscoverObjectInstanceCallbackToken;
}

void DOMemberSourceObjectClass::UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mDiscoverCallbacks.erase(callbackToken);
}

void DOMemberSourceObjectClass::ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IDOMemberSource> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

uint32_t DOMemberSourceObjectClass::RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastRemoveObjectInstanceCallbackToken++;
  mRemoveObjectInstanceCallbacks.insert(std::make_pair(mLastRemoveObjectInstanceCallbackToken, callback));
  return mLastRemoveObjectInstanceCallbackToken;
}

void DOMemberSourceObjectClass::UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mRemoveObjectInstanceCallbacks.erase(callbackToken);
}

void DOMemberSourceObjectClass::ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IDOMemberSource> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mRemoveObjectInstanceCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

void DOMemberSourceObjectClass::InsertObjectInstanceName(std::shared_ptr<IDOMemberSource> objectInstance, const std::wstring& objectInstanceName)
{
  // prerequisite: mMutex must be locked
  mObjectInstancesByName.insert(std::make_pair(objectInstanceName, objectInstance));
  mBaseClass->InsertObjectInstanceName(objectInstance, objectInstanceName);
}

void DOMemberSourceObjectClass::InsertObjectInstanceHandle(std::shared_ptr<IDOMemberSource> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByHandle.insert(std::make_pair(objectInstanceHandle, objectInstance));
  mBaseClass->InsertObjectInstanceHandle(objectInstance, objectInstanceHandle);
}

void DOMemberSourceObjectClass::EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mBaseClass->EraseObjectInstance(objectInstanceHandle, objectInstanceName);
  mObjectInstancesByName.erase(objectInstanceName);
  mObjectInstancesByHandle.erase(objectInstanceHandle);
}


// object instances of type 'DOMemberSource'
DOMemberSource::DOMemberSource()
  : mRtiAmbassador()
  , mObjectClass()
  , mObjectInstanceName()
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

DOMemberSource::DOMemberSource(DOMemberSourceObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mRtiAmbassador(rtiAmbassador)
  , mObjectClass(objectClass)
  , mObjectInstanceName(instanceName)
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

DOMemberSource::~DOMemberSource()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    try
    {
      mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    }
    catch (const rti1516ev::Exception&)
    {
    }
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

bool DOMemberSource::IsValid() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mObjectInstanceHandle.isValid();
}

bool DOMemberSource::IsOwner() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mIsOwner;
}

void DOMemberSource::Release()
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (mObjectInstanceHandle.isValid())
  {
    if (mIsOwner)
    {
      try
      {
        mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
      }
      catch (const rti1516ev::Exception&)
      {
        // ignore - must execute rest of function
      }
      mIsOwner = false;
    }
    mObjectClass->EraseObjectInstance(mObjectInstanceHandle, mObjectInstanceName);
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  }
}

// attribute DOMemberSource.HLAprivilegeToDeleteObject : no data type

// attribute DOSourceMemberName : HLAASCIIstring
std::string DOMemberSource::GetDOSourceMemberName() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDOSourceMemberName.get();
}

void DOMemberSource::SetDOSourceMemberName(std::string newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mDOSourceMemberName.set(newValue);
  mDirty |= kDOSourceMemberNameBit;
  mValuesSet |= kDOSourceMemberNameBit;
}

// attribute DOSourceMemberConnectionType : HLAASCIIstring
std::string DOMemberSource::GetDOSourceMemberConnectionType() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDOSourceMemberConnectionType.get();
}

void DOMemberSource::SetDOSourceMemberConnectionType(std::string newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mDOSourceMemberConnectionType.set(newValue);
  mDirty |= kDOSourceMemberConnectionTypeBit;
  mValuesSet |= kDOSourceMemberConnectionTypeBit;
}

// attribute DOSourceMemberDataBytes : HLAopaqueData
std::vector<uint8_t> DOMemberSource::GetDOSourceMemberDataBytes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDOSourceMemberDataBytes.get();
}

void DOMemberSource::SetDOSourceMemberDataBytes(const std::vector<uint8_t>& newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mDOSourceMemberDataBytes.set(newValue);
  mDirty |= kDOSourceMemberDataBytesBit;
  mValuesSet |= kDOSourceMemberDataBytesBit;
}

rti1516ev::AttributeHandleValueMap DOMemberSource::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetDOSourceMemberNameAttributeHandle()] = mDOSourceMemberName.encode();
  result[mObjectClass->GetDOSourceMemberConnectionTypeAttributeHandle()] = mDOSourceMemberConnectionType.encode();
  result[mObjectClass->GetDOSourceMemberDataBytesAttributeHandle()] = mDOSourceMemberDataBytes.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap DOMemberSource::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kDOSourceMemberNameBit)
  {
    result[mObjectClass->GetDOSourceMemberNameAttributeHandle()] = mDOSourceMemberName.encode();
  }
  if (mDirty & kDOSourceMemberConnectionTypeBit)
  {
    result[mObjectClass->GetDOSourceMemberConnectionTypeAttributeHandle()] = mDOSourceMemberConnectionType.encode();
  }
  if (mDirty & kDOSourceMemberDataBytesBit)
  {
    result[mObjectClass->GetDOSourceMemberDataBytesAttributeHandle()] = mDOSourceMemberDataBytes.encode();
  }
  return result;
}

DOMemberSource::AttributeBits DOMemberSource::GetReceivedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesReceived;
}

DOMemberSource::AttributeBits DOMemberSource::GetUpdatedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mLastUpdated;
}

DOMemberSource::AttributeBits DOMemberSource::GetInitializedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesSet;
}

DOMemberSource::AttributeBits DOMemberSource::GetModifiedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDirty;
}

void DOMemberSource::UpdateAllAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void DOMemberSource::UpdateAllAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    try {
      mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
      mDirty = kNone;
    }
    catch (const rti1516ev::InvalidLogicalTime& e)
    {
      throw InvalidLogicalTime(to_string(e.what()));
    }
    catch (const rti1516ev::Exception& e)
    {
      throw std::runtime_error(to_string(e.what()));
    }
  }
}

void DOMemberSource::UpdateModifiedAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void DOMemberSource::UpdateModifiedAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
        mDirty = kNone;
      }
      catch (const rti1516ev::InvalidLogicalTime& e)
      {
        throw InvalidLogicalTime(to_string(e.what()));
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void DOMemberSource::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetDOSourceMemberNameAttributeHandle())
    {
      mDOSourceMemberName.decode(attributeHandleValue.second);
      mLastUpdated |= kDOSourceMemberNameBit;
    }
    else if (attributeHandle == mObjectClass->GetDOSourceMemberConnectionTypeAttributeHandle())
    {
      mDOSourceMemberConnectionType.decode(attributeHandleValue.second);
      mLastUpdated |= kDOSourceMemberConnectionTypeBit;
    }
    else if (attributeHandle == mObjectClass->GetDOSourceMemberDataBytesAttributeHandle())
    {
      mDOSourceMemberDataBytes.decode(attributeHandleValue.second);
      mLastUpdated |= kDOSourceMemberDataBytesBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(optional<int64_t>(), optional<OrderType>());
  mLastUpdated = kNone;
} // DOMemberSource::ReflectAttributeValues

void DOMemberSource::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetDOSourceMemberNameAttributeHandle())
    {
      mDOSourceMemberName.decode(attributeHandleValue.second);
      mLastUpdated |= kDOSourceMemberNameBit;
    }
    else if (attributeHandle == mObjectClass->GetDOSourceMemberConnectionTypeAttributeHandle())
    {
      mDOSourceMemberConnectionType.decode(attributeHandleValue.second);
      mLastUpdated |= kDOSourceMemberConnectionTypeBit;
    }
    else if (attributeHandle == mObjectClass->GetDOSourceMemberDataBytesAttributeHandle())
    {
      mDOSourceMemberDataBytes.decode(attributeHandleValue.second);
      mLastUpdated |= kDOSourceMemberDataBytesBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(static_cast<const rti1516ev::HLAinteger64Time&>(theTime).getTime(), orderType);
  mLastUpdated = kNone;
} // DOMemberSource::ReflectAttributeValues

// request attributes not being part of the last update
void DOMemberSource::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    if ((mLastUpdated & kDOSourceMemberNameBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetDOSourceMemberNameAttributeHandle());
    }
    if ((mLastUpdated & kDOSourceMemberConnectionTypeBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetDOSourceMemberConnectionTypeAttributeHandle());
    }
    if ((mLastUpdated & kDOSourceMemberDataBytesBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetDOSourceMemberDataBytesAttributeHandle());
    }
  } // scope of lock_guard
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// request all attributes, regardless of current state
void DOMemberSource::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetDOSourceMemberNameAttributeHandle());
  requestAttributes.insert(mObjectClass->GetDOSourceMemberConnectionTypeAttributeHandle());
  requestAttributes.insert(mObjectClass->GetDOSourceMemberDataBytesAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// provide requested attributes set since last sent update
void DOMemberSource::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    for (auto& attributeHandle : attributeHandles)
    {
      if (attributeHandle == mObjectClass->GetDOSourceMemberNameAttributeHandle() && (mValuesSet & kDOSourceMemberNameBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mDOSourceMemberName.encode()));
        mDirty &= ~kDOSourceMemberNameBit;
      }
      else if (attributeHandle == mObjectClass->GetDOSourceMemberConnectionTypeAttributeHandle() && (mValuesSet & kDOSourceMemberConnectionTypeBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mDOSourceMemberConnectionType.encode()));
        mDirty &= ~kDOSourceMemberConnectionTypeBit;
      }
      else if (attributeHandle == mObjectClass->GetDOSourceMemberDataBytesAttributeHandle() && (mValuesSet & kDOSourceMemberDataBytesBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mDOSourceMemberDataBytes.encode()));
        mDirty &= ~kDOSourceMemberDataBytesBit;
      }
    } // for (auto& attributeHandleValue : attributes)
  } // scope of lock_guard
  if (time)
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(*time));
  else
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // DOMemberSource::ReflectAttributeValues

uint32_t DOMemberSource::RegisterUpdateCallback(UpdateCallback callback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void DOMemberSource::UnregisterUpdateCallback(uint32_t callbackToken)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mUpdateCallbacks.erase(callbackToken);
}

void DOMemberSource::ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(std::static_pointer_cast<IDOMemberSource>(shared_from_this()), time, orderType);
  }
}


// object class type 'DOMemberTarget'
DOMemberTargetObjectClass::DOMemberTargetObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, HLAobjectRootObjectClass* baseClass)
{
  mRegistry = registry;
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.DOMemberTarget");
  // attribute DOTargetMemberName : HLAASCIIstring
  mDOTargetMemberNameAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"DOTargetMemberName");
  // attribute DOTargetMemberConnectionType : HLAASCIIstring
  mDOTargetMemberConnectionTypeAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"DOTargetMemberConnectionType");
  SetObjectInstanceCreator([](DOMemberTargetObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador) -> DOMemberTarget* {
    return new DOMemberTarget(objectClass, instanceName, rtiAmbassador);
  });
}

DOMemberTargetObjectClass::~DOMemberTargetObjectClass()
{
  //std::lock_guard<std::recursive_mutex> lock(mMutex);
  while (!mObjectInstancesByHandle.empty())
  {
    // careful - hold the reference to the object instance until it has been removed from the maps,
    // otherwise it's mutex will be destroyed while held
    auto objectInstance = mObjectInstancesByHandle.begin()->second;
    objectInstance->Release();
  }
  assert(mObjectInstancesByHandle.empty());
  assert(mObjectInstancesByName.empty());
}

void DOMemberTargetObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void DOMemberTargetObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void DOMemberTargetObjectClass::Subscribe(bool deliverToSelf)
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    if (deliverToSelf) mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void DOMemberTargetObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

rti1516ev::AttributeHandleSet DOMemberTargetObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetDOTargetMemberNameAttributeHandle());
  result.insert(GetDOTargetMemberConnectionTypeAttributeHandle());
  return result;
}

void DOMemberTargetObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  assert(mObjectInstancesByName.find(objectInstanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(objectInstanceHandle) == mObjectInstancesByHandle.end());
  std::shared_ptr<DOMemberTarget> newObject = std::shared_ptr<DOMemberTarget>(mCreatorFunction(this, objectInstanceName, mRtiAmbassador));
  newObject->mObjectInstanceHandle = objectInstanceHandle;
  newObject->mIsOwner = false;
  InsertObjectInstanceName(newObject, objectInstanceName);
  InsertObjectInstanceHandle(newObject, objectInstanceHandle);
  ExecuteDiscoverObjectInstanceCallbacks(newObject);
}

void DOMemberTargetObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring objectInstanceName = mRtiAmbassador->getObjectInstanceName(objectInstanceHandle);
  auto iter = mObjectInstancesByName.find(objectInstanceName);
  assert(iter != mObjectInstancesByName.end());
  auto objectInstance = std::dynamic_pointer_cast<DOMemberTarget>(iter->second);
  ExecuteRemoveObjectInstanceCallbacks(objectInstance);
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  EraseObjectInstance(objectInstanceHandle, objectInstanceName);
}

std::shared_ptr<IDOMemberTarget> DOMemberTargetObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IHLAobjectRoot> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceName);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IDOMemberTarget>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IDOMemberTarget> DOMemberTargetObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IHLAobjectRoot> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceHandle);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IDOMemberTarget>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IDOMemberTarget> DOMemberTargetObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"DOMemberTarget");
  }
  std::shared_ptr<DOMemberTarget> newObject = std::shared_ptr<DOMemberTarget>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
    }
  });
  return newObject;
}

std::shared_ptr<IDOMemberTarget> DOMemberTargetObjectClass::CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"DOMemberTarget");
  }
  std::shared_ptr<DOMemberTarget> newObject = std::shared_ptr<DOMemberTarget>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
      createdCallback(newObject, true);
    }
    else
    {
      createdCallback(newObject, false);
    }
  });
  return newObject;
}

uint32_t DOMemberTargetObjectClass::RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastDiscoverObjectInstanceCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastDiscoverObjectInstanceCallbackToken, callback));
  return mLastDiscoverObjectInstanceCallbackToken;
}

void DOMemberTargetObjectClass::UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mDiscoverCallbacks.erase(callbackToken);
}

void DOMemberTargetObjectClass::ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IDOMemberTarget> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

uint32_t DOMemberTargetObjectClass::RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastRemoveObjectInstanceCallbackToken++;
  mRemoveObjectInstanceCallbacks.insert(std::make_pair(mLastRemoveObjectInstanceCallbackToken, callback));
  return mLastRemoveObjectInstanceCallbackToken;
}

void DOMemberTargetObjectClass::UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mRemoveObjectInstanceCallbacks.erase(callbackToken);
}

void DOMemberTargetObjectClass::ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IDOMemberTarget> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mRemoveObjectInstanceCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

void DOMemberTargetObjectClass::InsertObjectInstanceName(std::shared_ptr<IDOMemberTarget> objectInstance, const std::wstring& objectInstanceName)
{
  // prerequisite: mMutex must be locked
  mObjectInstancesByName.insert(std::make_pair(objectInstanceName, objectInstance));
  mBaseClass->InsertObjectInstanceName(objectInstance, objectInstanceName);
}

void DOMemberTargetObjectClass::InsertObjectInstanceHandle(std::shared_ptr<IDOMemberTarget> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByHandle.insert(std::make_pair(objectInstanceHandle, objectInstance));
  mBaseClass->InsertObjectInstanceHandle(objectInstance, objectInstanceHandle);
}

void DOMemberTargetObjectClass::EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mBaseClass->EraseObjectInstance(objectInstanceHandle, objectInstanceName);
  mObjectInstancesByName.erase(objectInstanceName);
  mObjectInstancesByHandle.erase(objectInstanceHandle);
}


// object instances of type 'DOMemberTarget'
DOMemberTarget::DOMemberTarget()
  : mRtiAmbassador()
  , mObjectClass()
  , mObjectInstanceName()
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

DOMemberTarget::DOMemberTarget(DOMemberTargetObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mRtiAmbassador(rtiAmbassador)
  , mObjectClass(objectClass)
  , mObjectInstanceName(instanceName)
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

DOMemberTarget::~DOMemberTarget()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    try
    {
      mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    }
    catch (const rti1516ev::Exception&)
    {
    }
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

bool DOMemberTarget::IsValid() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mObjectInstanceHandle.isValid();
}

bool DOMemberTarget::IsOwner() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mIsOwner;
}

void DOMemberTarget::Release()
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (mObjectInstanceHandle.isValid())
  {
    if (mIsOwner)
    {
      try
      {
        mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
      }
      catch (const rti1516ev::Exception&)
      {
        // ignore - must execute rest of function
      }
      mIsOwner = false;
    }
    mObjectClass->EraseObjectInstance(mObjectInstanceHandle, mObjectInstanceName);
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  }
}

// attribute DOMemberTarget.HLAprivilegeToDeleteObject : no data type

// attribute DOTargetMemberName : HLAASCIIstring
std::string DOMemberTarget::GetDOTargetMemberName() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDOTargetMemberName.get();
}

void DOMemberTarget::SetDOTargetMemberName(std::string newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mDOTargetMemberName.set(newValue);
  mDirty |= kDOTargetMemberNameBit;
  mValuesSet |= kDOTargetMemberNameBit;
}

// attribute DOTargetMemberConnectionType : HLAASCIIstring
std::string DOMemberTarget::GetDOTargetMemberConnectionType() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDOTargetMemberConnectionType.get();
}

void DOMemberTarget::SetDOTargetMemberConnectionType(std::string newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mDOTargetMemberConnectionType.set(newValue);
  mDirty |= kDOTargetMemberConnectionTypeBit;
  mValuesSet |= kDOTargetMemberConnectionTypeBit;
}

rti1516ev::AttributeHandleValueMap DOMemberTarget::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetDOTargetMemberNameAttributeHandle()] = mDOTargetMemberName.encode();
  result[mObjectClass->GetDOTargetMemberConnectionTypeAttributeHandle()] = mDOTargetMemberConnectionType.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap DOMemberTarget::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kDOTargetMemberNameBit)
  {
    result[mObjectClass->GetDOTargetMemberNameAttributeHandle()] = mDOTargetMemberName.encode();
  }
  if (mDirty & kDOTargetMemberConnectionTypeBit)
  {
    result[mObjectClass->GetDOTargetMemberConnectionTypeAttributeHandle()] = mDOTargetMemberConnectionType.encode();
  }
  return result;
}

DOMemberTarget::AttributeBits DOMemberTarget::GetReceivedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesReceived;
}

DOMemberTarget::AttributeBits DOMemberTarget::GetUpdatedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mLastUpdated;
}

DOMemberTarget::AttributeBits DOMemberTarget::GetInitializedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesSet;
}

DOMemberTarget::AttributeBits DOMemberTarget::GetModifiedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDirty;
}

void DOMemberTarget::UpdateAllAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void DOMemberTarget::UpdateAllAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    try {
      mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
      mDirty = kNone;
    }
    catch (const rti1516ev::InvalidLogicalTime& e)
    {
      throw InvalidLogicalTime(to_string(e.what()));
    }
    catch (const rti1516ev::Exception& e)
    {
      throw std::runtime_error(to_string(e.what()));
    }
  }
}

void DOMemberTarget::UpdateModifiedAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void DOMemberTarget::UpdateModifiedAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
        mDirty = kNone;
      }
      catch (const rti1516ev::InvalidLogicalTime& e)
      {
        throw InvalidLogicalTime(to_string(e.what()));
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void DOMemberTarget::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetDOTargetMemberNameAttributeHandle())
    {
      mDOTargetMemberName.decode(attributeHandleValue.second);
      mLastUpdated |= kDOTargetMemberNameBit;
    }
    else if (attributeHandle == mObjectClass->GetDOTargetMemberConnectionTypeAttributeHandle())
    {
      mDOTargetMemberConnectionType.decode(attributeHandleValue.second);
      mLastUpdated |= kDOTargetMemberConnectionTypeBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(optional<int64_t>(), optional<OrderType>());
  mLastUpdated = kNone;
} // DOMemberTarget::ReflectAttributeValues

void DOMemberTarget::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetDOTargetMemberNameAttributeHandle())
    {
      mDOTargetMemberName.decode(attributeHandleValue.second);
      mLastUpdated |= kDOTargetMemberNameBit;
    }
    else if (attributeHandle == mObjectClass->GetDOTargetMemberConnectionTypeAttributeHandle())
    {
      mDOTargetMemberConnectionType.decode(attributeHandleValue.second);
      mLastUpdated |= kDOTargetMemberConnectionTypeBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(static_cast<const rti1516ev::HLAinteger64Time&>(theTime).getTime(), orderType);
  mLastUpdated = kNone;
} // DOMemberTarget::ReflectAttributeValues

// request attributes not being part of the last update
void DOMemberTarget::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    if ((mLastUpdated & kDOTargetMemberNameBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetDOTargetMemberNameAttributeHandle());
    }
    if ((mLastUpdated & kDOTargetMemberConnectionTypeBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetDOTargetMemberConnectionTypeAttributeHandle());
    }
  } // scope of lock_guard
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// request all attributes, regardless of current state
void DOMemberTarget::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetDOTargetMemberNameAttributeHandle());
  requestAttributes.insert(mObjectClass->GetDOTargetMemberConnectionTypeAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// provide requested attributes set since last sent update
void DOMemberTarget::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    for (auto& attributeHandle : attributeHandles)
    {
      if (attributeHandle == mObjectClass->GetDOTargetMemberNameAttributeHandle() && (mValuesSet & kDOTargetMemberNameBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mDOTargetMemberName.encode()));
        mDirty &= ~kDOTargetMemberNameBit;
      }
      else if (attributeHandle == mObjectClass->GetDOTargetMemberConnectionTypeAttributeHandle() && (mValuesSet & kDOTargetMemberConnectionTypeBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mDOTargetMemberConnectionType.encode()));
        mDirty &= ~kDOTargetMemberConnectionTypeBit;
      }
    } // for (auto& attributeHandleValue : attributes)
  } // scope of lock_guard
  if (time)
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(*time));
  else
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // DOMemberTarget::ReflectAttributeValues

uint32_t DOMemberTarget::RegisterUpdateCallback(UpdateCallback callback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void DOMemberTarget::UnregisterUpdateCallback(uint32_t callbackToken)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mUpdateCallbacks.erase(callbackToken);
}

void DOMemberTarget::ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(std::static_pointer_cast<IDOMemberTarget>(shared_from_this()), time, orderType);
  }
}


// object class type 'BusManagement'
BusManagementObjectClass::BusManagementObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, HLAobjectRootObjectClass* baseClass)
{
  mRegistry = registry;
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.BusManagement");
  // attribute NetworkID : HLAASCIIstring
  mNetworkIDAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"NetworkID");
  SetObjectInstanceCreator([](BusManagementObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador) -> BusManagement* {
    return new BusManagement(objectClass, instanceName, rtiAmbassador);
  });
}

BusManagementObjectClass::~BusManagementObjectClass()
{
  //std::lock_guard<std::recursive_mutex> lock(mMutex);
  while (!mObjectInstancesByHandle.empty())
  {
    // careful - hold the reference to the object instance until it has been removed from the maps,
    // otherwise it's mutex will be destroyed while held
    auto objectInstance = mObjectInstancesByHandle.begin()->second;
    objectInstance->Release();
  }
  assert(mObjectInstancesByHandle.empty());
  assert(mObjectInstancesByName.empty());
}

void BusManagementObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void BusManagementObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void BusManagementObjectClass::Subscribe(bool deliverToSelf)
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    if (deliverToSelf) mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void BusManagementObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

rti1516ev::AttributeHandleSet BusManagementObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetNetworkIDAttributeHandle());
  return result;
}

void BusManagementObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  assert(mObjectInstancesByName.find(objectInstanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(objectInstanceHandle) == mObjectInstancesByHandle.end());
  std::shared_ptr<BusManagement> newObject = std::shared_ptr<BusManagement>(mCreatorFunction(this, objectInstanceName, mRtiAmbassador));
  newObject->mObjectInstanceHandle = objectInstanceHandle;
  newObject->mIsOwner = false;
  InsertObjectInstanceName(newObject, objectInstanceName);
  InsertObjectInstanceHandle(newObject, objectInstanceHandle);
  ExecuteDiscoverObjectInstanceCallbacks(newObject);
}

void BusManagementObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring objectInstanceName = mRtiAmbassador->getObjectInstanceName(objectInstanceHandle);
  auto iter = mObjectInstancesByName.find(objectInstanceName);
  assert(iter != mObjectInstancesByName.end());
  auto objectInstance = std::dynamic_pointer_cast<BusManagement>(iter->second);
  ExecuteRemoveObjectInstanceCallbacks(objectInstance);
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  EraseObjectInstance(objectInstanceHandle, objectInstanceName);
}

std::shared_ptr<IBusManagement> BusManagementObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IHLAobjectRoot> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceName);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IBusManagement>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IBusManagement> BusManagementObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IHLAobjectRoot> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceHandle);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IBusManagement>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IBusManagement> BusManagementObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"BusManagement");
  }
  std::shared_ptr<BusManagement> newObject = std::shared_ptr<BusManagement>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
    }
  });
  return newObject;
}

std::shared_ptr<IBusManagement> BusManagementObjectClass::CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"BusManagement");
  }
  std::shared_ptr<BusManagement> newObject = std::shared_ptr<BusManagement>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
      createdCallback(newObject, true);
    }
    else
    {
      createdCallback(newObject, false);
    }
  });
  return newObject;
}

uint32_t BusManagementObjectClass::RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastDiscoverObjectInstanceCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastDiscoverObjectInstanceCallbackToken, callback));
  return mLastDiscoverObjectInstanceCallbackToken;
}

void BusManagementObjectClass::UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mDiscoverCallbacks.erase(callbackToken);
}

void BusManagementObjectClass::ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IBusManagement> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

uint32_t BusManagementObjectClass::RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastRemoveObjectInstanceCallbackToken++;
  mRemoveObjectInstanceCallbacks.insert(std::make_pair(mLastRemoveObjectInstanceCallbackToken, callback));
  return mLastRemoveObjectInstanceCallbackToken;
}

void BusManagementObjectClass::UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mRemoveObjectInstanceCallbacks.erase(callbackToken);
}

void BusManagementObjectClass::ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IBusManagement> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mRemoveObjectInstanceCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

void BusManagementObjectClass::InsertObjectInstanceName(std::shared_ptr<IBusManagement> objectInstance, const std::wstring& objectInstanceName)
{
  // prerequisite: mMutex must be locked
  mObjectInstancesByName.insert(std::make_pair(objectInstanceName, objectInstance));
  mBaseClass->InsertObjectInstanceName(objectInstance, objectInstanceName);
}

void BusManagementObjectClass::InsertObjectInstanceHandle(std::shared_ptr<IBusManagement> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByHandle.insert(std::make_pair(objectInstanceHandle, objectInstance));
  mBaseClass->InsertObjectInstanceHandle(objectInstance, objectInstanceHandle);
}

void BusManagementObjectClass::EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mBaseClass->EraseObjectInstance(objectInstanceHandle, objectInstanceName);
  mObjectInstancesByName.erase(objectInstanceName);
  mObjectInstancesByHandle.erase(objectInstanceHandle);
}


// object instances of type 'BusManagement'
BusManagement::BusManagement()
  : mRtiAmbassador()
  , mObjectClass()
  , mObjectInstanceName()
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

BusManagement::BusManagement(BusManagementObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mRtiAmbassador(rtiAmbassador)
  , mObjectClass(objectClass)
  , mObjectInstanceName(instanceName)
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

BusManagement::~BusManagement()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    try
    {
      mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    }
    catch (const rti1516ev::Exception&)
    {
    }
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

bool BusManagement::IsValid() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mObjectInstanceHandle.isValid();
}

bool BusManagement::IsOwner() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mIsOwner;
}

void BusManagement::Release()
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (mObjectInstanceHandle.isValid())
  {
    if (mIsOwner)
    {
      try
      {
        mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
      }
      catch (const rti1516ev::Exception&)
      {
        // ignore - must execute rest of function
      }
      mIsOwner = false;
    }
    mObjectClass->EraseObjectInstance(mObjectInstanceHandle, mObjectInstanceName);
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  }
}

// attribute BusManagement.HLAprivilegeToDeleteObject : no data type

// attribute NetworkID : HLAASCIIstring
std::string BusManagement::GetNetworkID() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mNetworkID.get();
}

void BusManagement::SetNetworkID(std::string newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mNetworkID.set(newValue);
  mDirty |= kNetworkIDBit;
  mValuesSet |= kNetworkIDBit;
}

rti1516ev::AttributeHandleValueMap BusManagement::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap BusManagement::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kNetworkIDBit)
  {
    result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  }
  return result;
}

BusManagement::AttributeBits BusManagement::GetReceivedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesReceived;
}

BusManagement::AttributeBits BusManagement::GetUpdatedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mLastUpdated;
}

BusManagement::AttributeBits BusManagement::GetInitializedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesSet;
}

BusManagement::AttributeBits BusManagement::GetModifiedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDirty;
}

void BusManagement::UpdateAllAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void BusManagement::UpdateAllAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    try {
      mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
      mDirty = kNone;
    }
    catch (const rti1516ev::InvalidLogicalTime& e)
    {
      throw InvalidLogicalTime(to_string(e.what()));
    }
    catch (const rti1516ev::Exception& e)
    {
      throw std::runtime_error(to_string(e.what()));
    }
  }
}

void BusManagement::UpdateModifiedAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void BusManagement::UpdateModifiedAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
        mDirty = kNone;
      }
      catch (const rti1516ev::InvalidLogicalTime& e)
      {
        throw InvalidLogicalTime(to_string(e.what()));
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void BusManagement::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle())
    {
      mNetworkID.decode(attributeHandleValue.second);
      mLastUpdated |= kNetworkIDBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  mLastUpdated = kNone;
} // BusManagement::ReflectAttributeValues

void BusManagement::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& /* theTime */, OrderType /* orderType */)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle())
    {
      mNetworkID.decode(attributeHandleValue.second);
      mLastUpdated |= kNetworkIDBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  mLastUpdated = kNone;
} // BusManagement::ReflectAttributeValues

// request attributes not being part of the last update
void BusManagement::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    if ((mLastUpdated & kNetworkIDBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetNetworkIDAttributeHandle());
    }
  } // scope of lock_guard
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// request all attributes, regardless of current state
void BusManagement::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetNetworkIDAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// provide requested attributes set since last sent update
void BusManagement::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    for (auto& attributeHandle : attributeHandles)
    {
      if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle() && (mValuesSet & kNetworkIDBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mNetworkID.encode()));
        mDirty &= ~kNetworkIDBit;
      }
    } // for (auto& attributeHandleValue : attributes)
  } // scope of lock_guard
  if (time)
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(*time));
  else
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // BusManagement::ReflectAttributeValues


// object class type 'BusManagementCan'
BusManagementCanObjectClass::BusManagementCanObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, BusManagementObjectClass* baseClass)
{
  mRegistry = registry;
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.BusManagement.BusManagementCan");
  // attribute BusState : CanBusState
  mBusStateAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"BusState");
  // attribute TxErrorCount : HLAinteger32LE
  mTxErrorCountAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"TxErrorCount");
  // attribute RxErrorCount : HLAinteger32LE
  mRxErrorCountAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"RxErrorCount");
  // attribute SendMessagesAsRx : HLAboolean
  mSendMessagesAsRxAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"SendMessagesAsRx");
  SetObjectInstanceCreator([](BusManagementCanObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador) -> BusManagementCan* {
    return new BusManagementCan(objectClass, instanceName, rtiAmbassador);
  });
}

BusManagementCanObjectClass::~BusManagementCanObjectClass()
{
  //std::lock_guard<std::recursive_mutex> lock(mMutex);
  while (!mObjectInstancesByHandle.empty())
  {
    // careful - hold the reference to the object instance until it has been removed from the maps,
    // otherwise it's mutex will be destroyed while held
    auto objectInstance = mObjectInstancesByHandle.begin()->second;
    objectInstance->Release();
  }
  assert(mObjectInstancesByHandle.empty());
  assert(mObjectInstancesByName.empty());
}

void BusManagementCanObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void BusManagementCanObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void BusManagementCanObjectClass::Subscribe(bool deliverToSelf)
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    if (deliverToSelf) mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void BusManagementCanObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

rti1516ev::AttributeHandleSet BusManagementCanObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetNetworkIDAttributeHandle());
  result.insert(GetBusStateAttributeHandle());
  result.insert(GetTxErrorCountAttributeHandle());
  result.insert(GetRxErrorCountAttributeHandle());
  result.insert(GetSendMessagesAsRxAttributeHandle());
  return result;
}

void BusManagementCanObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  assert(mObjectInstancesByName.find(objectInstanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(objectInstanceHandle) == mObjectInstancesByHandle.end());
  std::shared_ptr<BusManagementCan> newObject = std::shared_ptr<BusManagementCan>(mCreatorFunction(this, objectInstanceName, mRtiAmbassador));
  newObject->mObjectInstanceHandle = objectInstanceHandle;
  newObject->mIsOwner = false;
  InsertObjectInstanceName(newObject, objectInstanceName);
  InsertObjectInstanceHandle(newObject, objectInstanceHandle);
  ExecuteDiscoverObjectInstanceCallbacks(newObject);
}

void BusManagementCanObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring objectInstanceName = mRtiAmbassador->getObjectInstanceName(objectInstanceHandle);
  auto iter = mObjectInstancesByName.find(objectInstanceName);
  assert(iter != mObjectInstancesByName.end());
  auto objectInstance = std::dynamic_pointer_cast<BusManagementCan>(iter->second);
  ExecuteRemoveObjectInstanceCallbacks(objectInstance);
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  EraseObjectInstance(objectInstanceHandle, objectInstanceName);
}

std::shared_ptr<IBusManagementCan> BusManagementCanObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IBusManagement> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceName);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IBusManagementCan>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IBusManagementCan> BusManagementCanObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IBusManagement> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceHandle);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IBusManagementCan>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IBusManagementCan> BusManagementCanObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"BusManagementCan");
  }
  std::shared_ptr<BusManagementCan> newObject = std::shared_ptr<BusManagementCan>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
    }
  });
  return newObject;
}

std::shared_ptr<IBusManagementCan> BusManagementCanObjectClass::CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"BusManagementCan");
  }
  std::shared_ptr<BusManagementCan> newObject = std::shared_ptr<BusManagementCan>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
      createdCallback(newObject, true);
    }
    else
    {
      createdCallback(newObject, false);
    }
  });
  return newObject;
}

uint32_t BusManagementCanObjectClass::RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastDiscoverObjectInstanceCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastDiscoverObjectInstanceCallbackToken, callback));
  return mLastDiscoverObjectInstanceCallbackToken;
}

void BusManagementCanObjectClass::UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mDiscoverCallbacks.erase(callbackToken);
}

void BusManagementCanObjectClass::ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IBusManagementCan> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

uint32_t BusManagementCanObjectClass::RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastRemoveObjectInstanceCallbackToken++;
  mRemoveObjectInstanceCallbacks.insert(std::make_pair(mLastRemoveObjectInstanceCallbackToken, callback));
  return mLastRemoveObjectInstanceCallbackToken;
}

void BusManagementCanObjectClass::UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mRemoveObjectInstanceCallbacks.erase(callbackToken);
}

void BusManagementCanObjectClass::ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IBusManagementCan> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mRemoveObjectInstanceCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

void BusManagementCanObjectClass::InsertObjectInstanceName(std::shared_ptr<IBusManagementCan> objectInstance, const std::wstring& objectInstanceName)
{
  // prerequisite: mMutex must be locked
  mObjectInstancesByName.insert(std::make_pair(objectInstanceName, objectInstance));
  mBaseClass->InsertObjectInstanceName(objectInstance, objectInstanceName);
}

void BusManagementCanObjectClass::InsertObjectInstanceHandle(std::shared_ptr<IBusManagementCan> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByHandle.insert(std::make_pair(objectInstanceHandle, objectInstance));
  mBaseClass->InsertObjectInstanceHandle(objectInstance, objectInstanceHandle);
}

void BusManagementCanObjectClass::EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mBaseClass->EraseObjectInstance(objectInstanceHandle, objectInstanceName);
  mObjectInstancesByName.erase(objectInstanceName);
  mObjectInstancesByHandle.erase(objectInstanceHandle);
}


// object instances of type 'BusManagementCan'
BusManagementCan::BusManagementCan()
  : mRtiAmbassador()
  , mObjectClass()
  , mObjectInstanceName()
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

BusManagementCan::BusManagementCan(BusManagementCanObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mRtiAmbassador(rtiAmbassador)
  , mObjectClass(objectClass)
  , mObjectInstanceName(instanceName)
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

BusManagementCan::~BusManagementCan()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    try
    {
      mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    }
    catch (const rti1516ev::Exception&)
    {
    }
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

bool BusManagementCan::IsValid() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mObjectInstanceHandle.isValid();
}

bool BusManagementCan::IsOwner() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mIsOwner;
}

void BusManagementCan::Release()
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (mObjectInstanceHandle.isValid())
  {
    if (mIsOwner)
    {
      try
      {
        mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
      }
      catch (const rti1516ev::Exception&)
      {
        // ignore - must execute rest of function
      }
      mIsOwner = false;
    }
    mObjectClass->EraseObjectInstance(mObjectInstanceHandle, mObjectInstanceName);
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  }
}

// attribute BusManagementCan.HLAprivilegeToDeleteObject : no data type

// attribute NetworkID : HLAASCIIstring
std::string BusManagementCan::GetNetworkID() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mNetworkID.get();
}

void BusManagementCan::SetNetworkID(std::string newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mNetworkID.set(newValue);
  mDirty |= kNetworkIDBit;
  mValuesSet |= kNetworkIDBit;
}

// attribute BusState : CanBusState
CanBusState BusManagementCan::GetBusState() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return static_cast<CanBusState>(mBusState.get());
}

void BusManagementCan::SetBusState(CanBusState newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mBusState.set(static_cast<int32_t>(newValue));
  mDirty |= kBusStateBit;
  mValuesSet |= kBusStateBit;
}

// attribute TxErrorCount : HLAinteger32LE
int32_t BusManagementCan::GetTxErrorCount() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mTxErrorCount.get();
}

void BusManagementCan::SetTxErrorCount(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mTxErrorCount.set(newValue);
  mDirty |= kTxErrorCountBit;
  mValuesSet |= kTxErrorCountBit;
}

// attribute RxErrorCount : HLAinteger32LE
int32_t BusManagementCan::GetRxErrorCount() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mRxErrorCount.get();
}

void BusManagementCan::SetRxErrorCount(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mRxErrorCount.set(newValue);
  mDirty |= kRxErrorCountBit;
  mValuesSet |= kRxErrorCountBit;
}

// attribute SendMessagesAsRx : HLAboolean
bool BusManagementCan::GetSendMessagesAsRx() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mSendMessagesAsRx.get();
}

void BusManagementCan::SetSendMessagesAsRx(bool newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mSendMessagesAsRx.set(newValue);
  mDirty |= kSendMessagesAsRxBit;
  mValuesSet |= kSendMessagesAsRxBit;
}

rti1516ev::AttributeHandleValueMap BusManagementCan::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  result[mObjectClass->GetBusStateAttributeHandle()] = mBusState.encode();
  result[mObjectClass->GetTxErrorCountAttributeHandle()] = mTxErrorCount.encode();
  result[mObjectClass->GetRxErrorCountAttributeHandle()] = mRxErrorCount.encode();
  result[mObjectClass->GetSendMessagesAsRxAttributeHandle()] = mSendMessagesAsRx.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap BusManagementCan::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kNetworkIDBit)
  {
    result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  }
  if (mDirty & kBusStateBit)
  {
    result[mObjectClass->GetBusStateAttributeHandle()] = mBusState.encode();
  }
  if (mDirty & kTxErrorCountBit)
  {
    result[mObjectClass->GetTxErrorCountAttributeHandle()] = mTxErrorCount.encode();
  }
  if (mDirty & kRxErrorCountBit)
  {
    result[mObjectClass->GetRxErrorCountAttributeHandle()] = mRxErrorCount.encode();
  }
  if (mDirty & kSendMessagesAsRxBit)
  {
    result[mObjectClass->GetSendMessagesAsRxAttributeHandle()] = mSendMessagesAsRx.encode();
  }
  return result;
}

BusManagementCan::AttributeBits BusManagementCan::GetReceivedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesReceived;
}

BusManagementCan::AttributeBits BusManagementCan::GetUpdatedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mLastUpdated;
}

BusManagementCan::AttributeBits BusManagementCan::GetInitializedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesSet;
}

BusManagementCan::AttributeBits BusManagementCan::GetModifiedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDirty;
}

void BusManagementCan::UpdateAllAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void BusManagementCan::UpdateAllAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    try {
      mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
      mDirty = kNone;
    }
    catch (const rti1516ev::InvalidLogicalTime& e)
    {
      throw InvalidLogicalTime(to_string(e.what()));
    }
    catch (const rti1516ev::Exception& e)
    {
      throw std::runtime_error(to_string(e.what()));
    }
  }
}

void BusManagementCan::UpdateModifiedAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void BusManagementCan::UpdateModifiedAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
        mDirty = kNone;
      }
      catch (const rti1516ev::InvalidLogicalTime& e)
      {
        throw InvalidLogicalTime(to_string(e.what()));
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void BusManagementCan::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle())
    {
      mNetworkID.decode(attributeHandleValue.second);
      mLastUpdated |= kNetworkIDBit;
    }
    else if (attributeHandle == mObjectClass->GetBusStateAttributeHandle())
    {
      mBusState.decode(attributeHandleValue.second);
      mLastUpdated |= kBusStateBit;
    }
    else if (attributeHandle == mObjectClass->GetTxErrorCountAttributeHandle())
    {
      mTxErrorCount.decode(attributeHandleValue.second);
      mLastUpdated |= kTxErrorCountBit;
    }
    else if (attributeHandle == mObjectClass->GetRxErrorCountAttributeHandle())
    {
      mRxErrorCount.decode(attributeHandleValue.second);
      mLastUpdated |= kRxErrorCountBit;
    }
    else if (attributeHandle == mObjectClass->GetSendMessagesAsRxAttributeHandle())
    {
      mSendMessagesAsRx.decode(attributeHandleValue.second);
      mLastUpdated |= kSendMessagesAsRxBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(optional<int64_t>(), optional<OrderType>());
  mLastUpdated = kNone;
} // BusManagementCan::ReflectAttributeValues

void BusManagementCan::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle())
    {
      mNetworkID.decode(attributeHandleValue.second);
      mLastUpdated |= kNetworkIDBit;
    }
    else if (attributeHandle == mObjectClass->GetBusStateAttributeHandle())
    {
      mBusState.decode(attributeHandleValue.second);
      mLastUpdated |= kBusStateBit;
    }
    else if (attributeHandle == mObjectClass->GetTxErrorCountAttributeHandle())
    {
      mTxErrorCount.decode(attributeHandleValue.second);
      mLastUpdated |= kTxErrorCountBit;
    }
    else if (attributeHandle == mObjectClass->GetRxErrorCountAttributeHandle())
    {
      mRxErrorCount.decode(attributeHandleValue.second);
      mLastUpdated |= kRxErrorCountBit;
    }
    else if (attributeHandle == mObjectClass->GetSendMessagesAsRxAttributeHandle())
    {
      mSendMessagesAsRx.decode(attributeHandleValue.second);
      mLastUpdated |= kSendMessagesAsRxBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(static_cast<const rti1516ev::HLAinteger64Time&>(theTime).getTime(), orderType);
  mLastUpdated = kNone;
} // BusManagementCan::ReflectAttributeValues

// request attributes not being part of the last update
void BusManagementCan::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    if ((mLastUpdated & kNetworkIDBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetNetworkIDAttributeHandle());
    }
    if ((mLastUpdated & kBusStateBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetBusStateAttributeHandle());
    }
    if ((mLastUpdated & kTxErrorCountBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetTxErrorCountAttributeHandle());
    }
    if ((mLastUpdated & kRxErrorCountBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetRxErrorCountAttributeHandle());
    }
    if ((mLastUpdated & kSendMessagesAsRxBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetSendMessagesAsRxAttributeHandle());
    }
  } // scope of lock_guard
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// request all attributes, regardless of current state
void BusManagementCan::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetNetworkIDAttributeHandle());
  requestAttributes.insert(mObjectClass->GetBusStateAttributeHandle());
  requestAttributes.insert(mObjectClass->GetTxErrorCountAttributeHandle());
  requestAttributes.insert(mObjectClass->GetRxErrorCountAttributeHandle());
  requestAttributes.insert(mObjectClass->GetSendMessagesAsRxAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// provide requested attributes set since last sent update
void BusManagementCan::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    for (auto& attributeHandle : attributeHandles)
    {
      if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle() && (mValuesSet & kNetworkIDBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mNetworkID.encode()));
        mDirty &= ~kNetworkIDBit;
      }
      else if (attributeHandle == mObjectClass->GetBusStateAttributeHandle() && (mValuesSet & kBusStateBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mBusState.encode()));
        mDirty &= ~kBusStateBit;
      }
      else if (attributeHandle == mObjectClass->GetTxErrorCountAttributeHandle() && (mValuesSet & kTxErrorCountBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mTxErrorCount.encode()));
        mDirty &= ~kTxErrorCountBit;
      }
      else if (attributeHandle == mObjectClass->GetRxErrorCountAttributeHandle() && (mValuesSet & kRxErrorCountBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mRxErrorCount.encode()));
        mDirty &= ~kRxErrorCountBit;
      }
      else if (attributeHandle == mObjectClass->GetSendMessagesAsRxAttributeHandle() && (mValuesSet & kSendMessagesAsRxBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mSendMessagesAsRx.encode()));
        mDirty &= ~kSendMessagesAsRxBit;
      }
    } // for (auto& attributeHandleValue : attributes)
  } // scope of lock_guard
  if (time)
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(*time));
  else
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // BusManagementCan::ReflectAttributeValues

uint32_t BusManagementCan::RegisterUpdateCallback(UpdateCallback callback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void BusManagementCan::UnregisterUpdateCallback(uint32_t callbackToken)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mUpdateCallbacks.erase(callbackToken);
}

void BusManagementCan::ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(std::static_pointer_cast<IBusManagementCan>(shared_from_this()), time, orderType);
  }
}


// object class type 'BusManagementEthernet'
BusManagementEthernetObjectClass::BusManagementEthernetObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, BusManagementObjectClass* baseClass)
{
  mRegistry = registry;
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.BusManagement.BusManagementEthernet");
  // attribute PortName : HLAASCIIstring
  mPortNameAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"PortName");
  // attribute SendMessagesAsRx : HLAboolean
  mSendMessagesAsRxAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"SendMessagesAsRx");
  SetObjectInstanceCreator([](BusManagementEthernetObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador) -> BusManagementEthernet* {
    return new BusManagementEthernet(objectClass, instanceName, rtiAmbassador);
  });
}

BusManagementEthernetObjectClass::~BusManagementEthernetObjectClass()
{
  //std::lock_guard<std::recursive_mutex> lock(mMutex);
  while (!mObjectInstancesByHandle.empty())
  {
    // careful - hold the reference to the object instance until it has been removed from the maps,
    // otherwise it's mutex will be destroyed while held
    auto objectInstance = mObjectInstancesByHandle.begin()->second;
    objectInstance->Release();
  }
  assert(mObjectInstancesByHandle.empty());
  assert(mObjectInstancesByName.empty());
}

void BusManagementEthernetObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void BusManagementEthernetObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void BusManagementEthernetObjectClass::Subscribe(bool deliverToSelf)
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    if (deliverToSelf) mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void BusManagementEthernetObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

rti1516ev::AttributeHandleSet BusManagementEthernetObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetNetworkIDAttributeHandle());
  result.insert(GetPortNameAttributeHandle());
  result.insert(GetSendMessagesAsRxAttributeHandle());
  return result;
}

void BusManagementEthernetObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  assert(mObjectInstancesByName.find(objectInstanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(objectInstanceHandle) == mObjectInstancesByHandle.end());
  std::shared_ptr<BusManagementEthernet> newObject = std::shared_ptr<BusManagementEthernet>(mCreatorFunction(this, objectInstanceName, mRtiAmbassador));
  newObject->mObjectInstanceHandle = objectInstanceHandle;
  newObject->mIsOwner = false;
  InsertObjectInstanceName(newObject, objectInstanceName);
  InsertObjectInstanceHandle(newObject, objectInstanceHandle);
  ExecuteDiscoverObjectInstanceCallbacks(newObject);
}

void BusManagementEthernetObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring objectInstanceName = mRtiAmbassador->getObjectInstanceName(objectInstanceHandle);
  auto iter = mObjectInstancesByName.find(objectInstanceName);
  assert(iter != mObjectInstancesByName.end());
  auto objectInstance = std::dynamic_pointer_cast<BusManagementEthernet>(iter->second);
  ExecuteRemoveObjectInstanceCallbacks(objectInstance);
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  EraseObjectInstance(objectInstanceHandle, objectInstanceName);
}

std::shared_ptr<IBusManagementEthernet> BusManagementEthernetObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IBusManagement> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceName);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IBusManagementEthernet>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IBusManagementEthernet> BusManagementEthernetObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IBusManagement> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceHandle);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IBusManagementEthernet>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IBusManagementEthernet> BusManagementEthernetObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"BusManagementEthernet");
  }
  std::shared_ptr<BusManagementEthernet> newObject = std::shared_ptr<BusManagementEthernet>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
    }
  });
  return newObject;
}

std::shared_ptr<IBusManagementEthernet> BusManagementEthernetObjectClass::CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"BusManagementEthernet");
  }
  std::shared_ptr<BusManagementEthernet> newObject = std::shared_ptr<BusManagementEthernet>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
      createdCallback(newObject, true);
    }
    else
    {
      createdCallback(newObject, false);
    }
  });
  return newObject;
}

uint32_t BusManagementEthernetObjectClass::RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastDiscoverObjectInstanceCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastDiscoverObjectInstanceCallbackToken, callback));
  return mLastDiscoverObjectInstanceCallbackToken;
}

void BusManagementEthernetObjectClass::UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mDiscoverCallbacks.erase(callbackToken);
}

void BusManagementEthernetObjectClass::ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IBusManagementEthernet> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

uint32_t BusManagementEthernetObjectClass::RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastRemoveObjectInstanceCallbackToken++;
  mRemoveObjectInstanceCallbacks.insert(std::make_pair(mLastRemoveObjectInstanceCallbackToken, callback));
  return mLastRemoveObjectInstanceCallbackToken;
}

void BusManagementEthernetObjectClass::UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mRemoveObjectInstanceCallbacks.erase(callbackToken);
}

void BusManagementEthernetObjectClass::ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IBusManagementEthernet> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mRemoveObjectInstanceCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

void BusManagementEthernetObjectClass::InsertObjectInstanceName(std::shared_ptr<IBusManagementEthernet> objectInstance, const std::wstring& objectInstanceName)
{
  // prerequisite: mMutex must be locked
  mObjectInstancesByName.insert(std::make_pair(objectInstanceName, objectInstance));
  mBaseClass->InsertObjectInstanceName(objectInstance, objectInstanceName);
}

void BusManagementEthernetObjectClass::InsertObjectInstanceHandle(std::shared_ptr<IBusManagementEthernet> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByHandle.insert(std::make_pair(objectInstanceHandle, objectInstance));
  mBaseClass->InsertObjectInstanceHandle(objectInstance, objectInstanceHandle);
}

void BusManagementEthernetObjectClass::EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mBaseClass->EraseObjectInstance(objectInstanceHandle, objectInstanceName);
  mObjectInstancesByName.erase(objectInstanceName);
  mObjectInstancesByHandle.erase(objectInstanceHandle);
}


// object instances of type 'BusManagementEthernet'
BusManagementEthernet::BusManagementEthernet()
  : mRtiAmbassador()
  , mObjectClass()
  , mObjectInstanceName()
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

BusManagementEthernet::BusManagementEthernet(BusManagementEthernetObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mRtiAmbassador(rtiAmbassador)
  , mObjectClass(objectClass)
  , mObjectInstanceName(instanceName)
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

BusManagementEthernet::~BusManagementEthernet()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    try
    {
      mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    }
    catch (const rti1516ev::Exception&)
    {
    }
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

bool BusManagementEthernet::IsValid() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mObjectInstanceHandle.isValid();
}

bool BusManagementEthernet::IsOwner() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mIsOwner;
}

void BusManagementEthernet::Release()
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (mObjectInstanceHandle.isValid())
  {
    if (mIsOwner)
    {
      try
      {
        mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
      }
      catch (const rti1516ev::Exception&)
      {
        // ignore - must execute rest of function
      }
      mIsOwner = false;
    }
    mObjectClass->EraseObjectInstance(mObjectInstanceHandle, mObjectInstanceName);
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  }
}

// attribute BusManagementEthernet.HLAprivilegeToDeleteObject : no data type

// attribute NetworkID : HLAASCIIstring
std::string BusManagementEthernet::GetNetworkID() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mNetworkID.get();
}

void BusManagementEthernet::SetNetworkID(std::string newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mNetworkID.set(newValue);
  mDirty |= kNetworkIDBit;
  mValuesSet |= kNetworkIDBit;
}

// attribute PortName : HLAASCIIstring
std::string BusManagementEthernet::GetPortName() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mPortName.get();
}

void BusManagementEthernet::SetPortName(std::string newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mPortName.set(newValue);
  mDirty |= kPortNameBit;
  mValuesSet |= kPortNameBit;
}

// attribute SendMessagesAsRx : HLAboolean
bool BusManagementEthernet::GetSendMessagesAsRx() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mSendMessagesAsRx.get();
}

void BusManagementEthernet::SetSendMessagesAsRx(bool newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mSendMessagesAsRx.set(newValue);
  mDirty |= kSendMessagesAsRxBit;
  mValuesSet |= kSendMessagesAsRxBit;
}

rti1516ev::AttributeHandleValueMap BusManagementEthernet::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  result[mObjectClass->GetPortNameAttributeHandle()] = mPortName.encode();
  result[mObjectClass->GetSendMessagesAsRxAttributeHandle()] = mSendMessagesAsRx.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap BusManagementEthernet::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kNetworkIDBit)
  {
    result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  }
  if (mDirty & kPortNameBit)
  {
    result[mObjectClass->GetPortNameAttributeHandle()] = mPortName.encode();
  }
  if (mDirty & kSendMessagesAsRxBit)
  {
    result[mObjectClass->GetSendMessagesAsRxAttributeHandle()] = mSendMessagesAsRx.encode();
  }
  return result;
}

BusManagementEthernet::AttributeBits BusManagementEthernet::GetReceivedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesReceived;
}

BusManagementEthernet::AttributeBits BusManagementEthernet::GetUpdatedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mLastUpdated;
}

BusManagementEthernet::AttributeBits BusManagementEthernet::GetInitializedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesSet;
}

BusManagementEthernet::AttributeBits BusManagementEthernet::GetModifiedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDirty;
}

void BusManagementEthernet::UpdateAllAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void BusManagementEthernet::UpdateAllAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    try {
      mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
      mDirty = kNone;
    }
    catch (const rti1516ev::InvalidLogicalTime& e)
    {
      throw InvalidLogicalTime(to_string(e.what()));
    }
    catch (const rti1516ev::Exception& e)
    {
      throw std::runtime_error(to_string(e.what()));
    }
  }
}

void BusManagementEthernet::UpdateModifiedAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void BusManagementEthernet::UpdateModifiedAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
        mDirty = kNone;
      }
      catch (const rti1516ev::InvalidLogicalTime& e)
      {
        throw InvalidLogicalTime(to_string(e.what()));
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void BusManagementEthernet::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle())
    {
      mNetworkID.decode(attributeHandleValue.second);
      mLastUpdated |= kNetworkIDBit;
    }
    else if (attributeHandle == mObjectClass->GetPortNameAttributeHandle())
    {
      mPortName.decode(attributeHandleValue.second);
      mLastUpdated |= kPortNameBit;
    }
    else if (attributeHandle == mObjectClass->GetSendMessagesAsRxAttributeHandle())
    {
      mSendMessagesAsRx.decode(attributeHandleValue.second);
      mLastUpdated |= kSendMessagesAsRxBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(optional<int64_t>(), optional<OrderType>());
  mLastUpdated = kNone;
} // BusManagementEthernet::ReflectAttributeValues

void BusManagementEthernet::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle())
    {
      mNetworkID.decode(attributeHandleValue.second);
      mLastUpdated |= kNetworkIDBit;
    }
    else if (attributeHandle == mObjectClass->GetPortNameAttributeHandle())
    {
      mPortName.decode(attributeHandleValue.second);
      mLastUpdated |= kPortNameBit;
    }
    else if (attributeHandle == mObjectClass->GetSendMessagesAsRxAttributeHandle())
    {
      mSendMessagesAsRx.decode(attributeHandleValue.second);
      mLastUpdated |= kSendMessagesAsRxBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(static_cast<const rti1516ev::HLAinteger64Time&>(theTime).getTime(), orderType);
  mLastUpdated = kNone;
} // BusManagementEthernet::ReflectAttributeValues

// request attributes not being part of the last update
void BusManagementEthernet::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    if ((mLastUpdated & kNetworkIDBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetNetworkIDAttributeHandle());
    }
    if ((mLastUpdated & kPortNameBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetPortNameAttributeHandle());
    }
    if ((mLastUpdated & kSendMessagesAsRxBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetSendMessagesAsRxAttributeHandle());
    }
  } // scope of lock_guard
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// request all attributes, regardless of current state
void BusManagementEthernet::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetNetworkIDAttributeHandle());
  requestAttributes.insert(mObjectClass->GetPortNameAttributeHandle());
  requestAttributes.insert(mObjectClass->GetSendMessagesAsRxAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// provide requested attributes set since last sent update
void BusManagementEthernet::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    for (auto& attributeHandle : attributeHandles)
    {
      if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle() && (mValuesSet & kNetworkIDBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mNetworkID.encode()));
        mDirty &= ~kNetworkIDBit;
      }
      else if (attributeHandle == mObjectClass->GetPortNameAttributeHandle() && (mValuesSet & kPortNameBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mPortName.encode()));
        mDirty &= ~kPortNameBit;
      }
      else if (attributeHandle == mObjectClass->GetSendMessagesAsRxAttributeHandle() && (mValuesSet & kSendMessagesAsRxBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mSendMessagesAsRx.encode()));
        mDirty &= ~kSendMessagesAsRxBit;
      }
    } // for (auto& attributeHandleValue : attributes)
  } // scope of lock_guard
  if (time)
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(*time));
  else
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // BusManagementEthernet::ReflectAttributeValues

uint32_t BusManagementEthernet::RegisterUpdateCallback(UpdateCallback callback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void BusManagementEthernet::UnregisterUpdateCallback(uint32_t callbackToken)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mUpdateCallbacks.erase(callbackToken);
}

void BusManagementEthernet::ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(std::static_pointer_cast<IBusManagementEthernet>(shared_from_this()), time, orderType);
  }
}


// object class type 'FlexRayCluster'
FlexRayClusterObjectClass::FlexRayClusterObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, BusManagementObjectClass* baseClass)
{
  mRegistry = registry;
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.BusManagement.FlexRayCluster");
  // attribute gColdstartAttempts : HLAoctet
  mgColdstartAttemptsAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gColdstartAttempts");
  // attribute gCycleCountMax : HLAoctet
  mgCycleCountMaxAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gCycleCountMax");
  // attribute gdActionPointOffset : HLAinteger32LE
  mgdActionPointOffsetAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gdActionPointOffset");
  // attribute gdDynamicSlotIdlePhase : HLAinteger32LE
  mgdDynamicSlotIdlePhaseAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gdDynamicSlotIdlePhase");
  // attribute gdMiniSlot : HLAinteger32LE
  mgdMiniSlotAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gdMiniSlot");
  // attribute gdMiniSlotActionPointOffset : HLAinteger32LE
  mgdMiniSlotActionPointOffsetAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gdMiniSlotActionPointOffset");
  // attribute gdStaticSlot : HLAinteger32LE
  mgdStaticSlotAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gdStaticSlot");
  // attribute gdSymbolWindow : HLAinteger32LE
  mgdSymbolWindowAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gdSymbolWindow");
  // attribute gdSymbolWindowActionPointOffset : HLAinteger32LE
  mgdSymbolWindowActionPointOffsetAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gdSymbolWindowActionPointOffset");
  // attribute gdTSSTransmitter : HLAinteger32LE
  mgdTSSTransmitterAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gdTSSTransmitter");
  // attribute gdWakeupTxActive : HLAinteger32LE
  mgdWakeupTxActiveAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gdWakeupTxActive");
  // attribute gdWakeupTxIdle : HLAinteger32LE
  mgdWakeupTxIdleAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gdWakeupTxIdle");
  // attribute gListenNoise : HLAoctet
  mgListenNoiseAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gListenNoise");
  // attribute gMacroPerCycle : HLAinteger32LE
  mgMacroPerCycleAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gMacroPerCycle");
  // attribute gMaxWithoutClockCorrectionFatal : HLAoctet
  mgMaxWithoutClockCorrectionFatalAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gMaxWithoutClockCorrectionFatal");
  // attribute gMaxWithoutClockCorrectionPassive : HLAoctet
  mgMaxWithoutClockCorrectionPassiveAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gMaxWithoutClockCorrectionPassive");
  // attribute gNumberOfMiniSlots : HLAinteger32LE
  mgNumberOfMiniSlotsAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gNumberOfMiniSlots");
  // attribute gNumberOfStaticSlots : HLAinteger32LE
  mgNumberOfStaticSlotsAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gNumberOfStaticSlots");
  // attribute gPayloadLengthStatic : HLAinteger32LE
  mgPayloadLengthStaticAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gPayloadLengthStatic");
  // attribute gSyncFrameIDCountMax : HLAoctet
  mgSyncFrameIDCountMaxAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"gSyncFrameIDCountMax");
  SetObjectInstanceCreator([](FlexRayClusterObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador) -> FlexRayCluster* {
    return new FlexRayCluster(objectClass, instanceName, rtiAmbassador);
  });
}

FlexRayClusterObjectClass::~FlexRayClusterObjectClass()
{
  //std::lock_guard<std::recursive_mutex> lock(mMutex);
  while (!mObjectInstancesByHandle.empty())
  {
    // careful - hold the reference to the object instance until it has been removed from the maps,
    // otherwise it's mutex will be destroyed while held
    auto objectInstance = mObjectInstancesByHandle.begin()->second;
    objectInstance->Release();
  }
  assert(mObjectInstancesByHandle.empty());
  assert(mObjectInstancesByName.empty());
}

void FlexRayClusterObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void FlexRayClusterObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void FlexRayClusterObjectClass::Subscribe(bool deliverToSelf)
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    if (deliverToSelf) mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void FlexRayClusterObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

rti1516ev::AttributeHandleSet FlexRayClusterObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetNetworkIDAttributeHandle());
  result.insert(GetgColdstartAttemptsAttributeHandle());
  result.insert(GetgCycleCountMaxAttributeHandle());
  result.insert(GetgdActionPointOffsetAttributeHandle());
  result.insert(GetgdDynamicSlotIdlePhaseAttributeHandle());
  result.insert(GetgdMiniSlotAttributeHandle());
  result.insert(GetgdMiniSlotActionPointOffsetAttributeHandle());
  result.insert(GetgdStaticSlotAttributeHandle());
  result.insert(GetgdSymbolWindowAttributeHandle());
  result.insert(GetgdSymbolWindowActionPointOffsetAttributeHandle());
  result.insert(GetgdTSSTransmitterAttributeHandle());
  result.insert(GetgdWakeupTxActiveAttributeHandle());
  result.insert(GetgdWakeupTxIdleAttributeHandle());
  result.insert(GetgListenNoiseAttributeHandle());
  result.insert(GetgMacroPerCycleAttributeHandle());
  result.insert(GetgMaxWithoutClockCorrectionFatalAttributeHandle());
  result.insert(GetgMaxWithoutClockCorrectionPassiveAttributeHandle());
  result.insert(GetgNumberOfMiniSlotsAttributeHandle());
  result.insert(GetgNumberOfStaticSlotsAttributeHandle());
  result.insert(GetgPayloadLengthStaticAttributeHandle());
  result.insert(GetgSyncFrameIDCountMaxAttributeHandle());
  return result;
}

void FlexRayClusterObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  assert(mObjectInstancesByName.find(objectInstanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(objectInstanceHandle) == mObjectInstancesByHandle.end());
  std::shared_ptr<FlexRayCluster> newObject = std::shared_ptr<FlexRayCluster>(mCreatorFunction(this, objectInstanceName, mRtiAmbassador));
  newObject->mObjectInstanceHandle = objectInstanceHandle;
  newObject->mIsOwner = false;
  InsertObjectInstanceName(newObject, objectInstanceName);
  InsertObjectInstanceHandle(newObject, objectInstanceHandle);
  ExecuteDiscoverObjectInstanceCallbacks(newObject);
}

void FlexRayClusterObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring objectInstanceName = mRtiAmbassador->getObjectInstanceName(objectInstanceHandle);
  auto iter = mObjectInstancesByName.find(objectInstanceName);
  assert(iter != mObjectInstancesByName.end());
  auto objectInstance = std::dynamic_pointer_cast<FlexRayCluster>(iter->second);
  ExecuteRemoveObjectInstanceCallbacks(objectInstance);
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  EraseObjectInstance(objectInstanceHandle, objectInstanceName);
}

std::shared_ptr<IFlexRayCluster> FlexRayClusterObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IBusManagement> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceName);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IFlexRayCluster>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IFlexRayCluster> FlexRayClusterObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IBusManagement> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceHandle);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IFlexRayCluster>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IFlexRayCluster> FlexRayClusterObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"FlexRayCluster");
  }
  std::shared_ptr<FlexRayCluster> newObject = std::shared_ptr<FlexRayCluster>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
    }
  });
  return newObject;
}

std::shared_ptr<IFlexRayCluster> FlexRayClusterObjectClass::CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"FlexRayCluster");
  }
  std::shared_ptr<FlexRayCluster> newObject = std::shared_ptr<FlexRayCluster>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
      createdCallback(newObject, true);
    }
    else
    {
      createdCallback(newObject, false);
    }
  });
  return newObject;
}

uint32_t FlexRayClusterObjectClass::RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastDiscoverObjectInstanceCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastDiscoverObjectInstanceCallbackToken, callback));
  return mLastDiscoverObjectInstanceCallbackToken;
}

void FlexRayClusterObjectClass::UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mDiscoverCallbacks.erase(callbackToken);
}

void FlexRayClusterObjectClass::ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IFlexRayCluster> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

uint32_t FlexRayClusterObjectClass::RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastRemoveObjectInstanceCallbackToken++;
  mRemoveObjectInstanceCallbacks.insert(std::make_pair(mLastRemoveObjectInstanceCallbackToken, callback));
  return mLastRemoveObjectInstanceCallbackToken;
}

void FlexRayClusterObjectClass::UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mRemoveObjectInstanceCallbacks.erase(callbackToken);
}

void FlexRayClusterObjectClass::ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IFlexRayCluster> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mRemoveObjectInstanceCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

void FlexRayClusterObjectClass::InsertObjectInstanceName(std::shared_ptr<IFlexRayCluster> objectInstance, const std::wstring& objectInstanceName)
{
  // prerequisite: mMutex must be locked
  mObjectInstancesByName.insert(std::make_pair(objectInstanceName, objectInstance));
  mBaseClass->InsertObjectInstanceName(objectInstance, objectInstanceName);
}

void FlexRayClusterObjectClass::InsertObjectInstanceHandle(std::shared_ptr<IFlexRayCluster> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByHandle.insert(std::make_pair(objectInstanceHandle, objectInstance));
  mBaseClass->InsertObjectInstanceHandle(objectInstance, objectInstanceHandle);
}

void FlexRayClusterObjectClass::EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mBaseClass->EraseObjectInstance(objectInstanceHandle, objectInstanceName);
  mObjectInstancesByName.erase(objectInstanceName);
  mObjectInstancesByHandle.erase(objectInstanceHandle);
}


// object instances of type 'FlexRayCluster'
FlexRayCluster::FlexRayCluster()
  : mRtiAmbassador()
  , mObjectClass()
  , mObjectInstanceName()
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

FlexRayCluster::FlexRayCluster(FlexRayClusterObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mRtiAmbassador(rtiAmbassador)
  , mObjectClass(objectClass)
  , mObjectInstanceName(instanceName)
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

FlexRayCluster::~FlexRayCluster()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    try
    {
      mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    }
    catch (const rti1516ev::Exception&)
    {
    }
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

bool FlexRayCluster::IsValid() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mObjectInstanceHandle.isValid();
}

bool FlexRayCluster::IsOwner() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mIsOwner;
}

void FlexRayCluster::Release()
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (mObjectInstanceHandle.isValid())
  {
    if (mIsOwner)
    {
      try
      {
        mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
      }
      catch (const rti1516ev::Exception&)
      {
        // ignore - must execute rest of function
      }
      mIsOwner = false;
    }
    mObjectClass->EraseObjectInstance(mObjectInstanceHandle, mObjectInstanceName);
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  }
}

// attribute FlexRayCluster.HLAprivilegeToDeleteObject : no data type

// attribute NetworkID : HLAASCIIstring
std::string FlexRayCluster::GetNetworkID() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mNetworkID.get();
}

void FlexRayCluster::SetNetworkID(std::string newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mNetworkID.set(newValue);
  mDirty |= kNetworkIDBit;
  mValuesSet |= kNetworkIDBit;
}

// attribute gColdstartAttempts : HLAoctet
uint8_t FlexRayCluster::GetgColdstartAttempts() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mgColdstartAttempts.get();
}

void FlexRayCluster::SetgColdstartAttempts(uint8_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mgColdstartAttempts.set(newValue);
  mDirty |= kgColdstartAttemptsBit;
  mValuesSet |= kgColdstartAttemptsBit;
}

// attribute gCycleCountMax : HLAoctet
uint8_t FlexRayCluster::GetgCycleCountMax() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mgCycleCountMax.get();
}

void FlexRayCluster::SetgCycleCountMax(uint8_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mgCycleCountMax.set(newValue);
  mDirty |= kgCycleCountMaxBit;
  mValuesSet |= kgCycleCountMaxBit;
}

// attribute gdActionPointOffset : HLAinteger32LE
int32_t FlexRayCluster::GetgdActionPointOffset() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mgdActionPointOffset.get();
}

void FlexRayCluster::SetgdActionPointOffset(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mgdActionPointOffset.set(newValue);
  mDirty |= kgdActionPointOffsetBit;
  mValuesSet |= kgdActionPointOffsetBit;
}

// attribute gdDynamicSlotIdlePhase : HLAinteger32LE
int32_t FlexRayCluster::GetgdDynamicSlotIdlePhase() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mgdDynamicSlotIdlePhase.get();
}

void FlexRayCluster::SetgdDynamicSlotIdlePhase(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mgdDynamicSlotIdlePhase.set(newValue);
  mDirty |= kgdDynamicSlotIdlePhaseBit;
  mValuesSet |= kgdDynamicSlotIdlePhaseBit;
}

// attribute gdMiniSlot : HLAinteger32LE
int32_t FlexRayCluster::GetgdMiniSlot() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mgdMiniSlot.get();
}

void FlexRayCluster::SetgdMiniSlot(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mgdMiniSlot.set(newValue);
  mDirty |= kgdMiniSlotBit;
  mValuesSet |= kgdMiniSlotBit;
}

// attribute gdMiniSlotActionPointOffset : HLAinteger32LE
int32_t FlexRayCluster::GetgdMiniSlotActionPointOffset() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mgdMiniSlotActionPointOffset.get();
}

void FlexRayCluster::SetgdMiniSlotActionPointOffset(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mgdMiniSlotActionPointOffset.set(newValue);
  mDirty |= kgdMiniSlotActionPointOffsetBit;
  mValuesSet |= kgdMiniSlotActionPointOffsetBit;
}

// attribute gdStaticSlot : HLAinteger32LE
int32_t FlexRayCluster::GetgdStaticSlot() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mgdStaticSlot.get();
}

void FlexRayCluster::SetgdStaticSlot(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mgdStaticSlot.set(newValue);
  mDirty |= kgdStaticSlotBit;
  mValuesSet |= kgdStaticSlotBit;
}

// attribute gdSymbolWindow : HLAinteger32LE
int32_t FlexRayCluster::GetgdSymbolWindow() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mgdSymbolWindow.get();
}

void FlexRayCluster::SetgdSymbolWindow(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mgdSymbolWindow.set(newValue);
  mDirty |= kgdSymbolWindowBit;
  mValuesSet |= kgdSymbolWindowBit;
}

// attribute gdSymbolWindowActionPointOffset : HLAinteger32LE
int32_t FlexRayCluster::GetgdSymbolWindowActionPointOffset() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mgdSymbolWindowActionPointOffset.get();
}

void FlexRayCluster::SetgdSymbolWindowActionPointOffset(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mgdSymbolWindowActionPointOffset.set(newValue);
  mDirty |= kgdSymbolWindowActionPointOffsetBit;
  mValuesSet |= kgdSymbolWindowActionPointOffsetBit;
}

// attribute gdTSSTransmitter : HLAinteger32LE
int32_t FlexRayCluster::GetgdTSSTransmitter() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mgdTSSTransmitter.get();
}

void FlexRayCluster::SetgdTSSTransmitter(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mgdTSSTransmitter.set(newValue);
  mDirty |= kgdTSSTransmitterBit;
  mValuesSet |= kgdTSSTransmitterBit;
}

// attribute gdWakeupTxActive : HLAinteger32LE
int32_t FlexRayCluster::GetgdWakeupTxActive() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mgdWakeupTxActive.get();
}

void FlexRayCluster::SetgdWakeupTxActive(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mgdWakeupTxActive.set(newValue);
  mDirty |= kgdWakeupTxActiveBit;
  mValuesSet |= kgdWakeupTxActiveBit;
}

// attribute gdWakeupTxIdle : HLAinteger32LE
int32_t FlexRayCluster::GetgdWakeupTxIdle() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mgdWakeupTxIdle.get();
}

void FlexRayCluster::SetgdWakeupTxIdle(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mgdWakeupTxIdle.set(newValue);
  mDirty |= kgdWakeupTxIdleBit;
  mValuesSet |= kgdWakeupTxIdleBit;
}

// attribute gListenNoise : HLAoctet
uint8_t FlexRayCluster::GetgListenNoise() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mgListenNoise.get();
}

void FlexRayCluster::SetgListenNoise(uint8_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mgListenNoise.set(newValue);
  mDirty |= kgListenNoiseBit;
  mValuesSet |= kgListenNoiseBit;
}

// attribute gMacroPerCycle : HLAinteger32LE
int32_t FlexRayCluster::GetgMacroPerCycle() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mgMacroPerCycle.get();
}

void FlexRayCluster::SetgMacroPerCycle(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mgMacroPerCycle.set(newValue);
  mDirty |= kgMacroPerCycleBit;
  mValuesSet |= kgMacroPerCycleBit;
}

// attribute gMaxWithoutClockCorrectionFatal : HLAoctet
uint8_t FlexRayCluster::GetgMaxWithoutClockCorrectionFatal() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mgMaxWithoutClockCorrectionFatal.get();
}

void FlexRayCluster::SetgMaxWithoutClockCorrectionFatal(uint8_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mgMaxWithoutClockCorrectionFatal.set(newValue);
  mDirty |= kgMaxWithoutClockCorrectionFatalBit;
  mValuesSet |= kgMaxWithoutClockCorrectionFatalBit;
}

// attribute gMaxWithoutClockCorrectionPassive : HLAoctet
uint8_t FlexRayCluster::GetgMaxWithoutClockCorrectionPassive() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mgMaxWithoutClockCorrectionPassive.get();
}

void FlexRayCluster::SetgMaxWithoutClockCorrectionPassive(uint8_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mgMaxWithoutClockCorrectionPassive.set(newValue);
  mDirty |= kgMaxWithoutClockCorrectionPassiveBit;
  mValuesSet |= kgMaxWithoutClockCorrectionPassiveBit;
}

// attribute gNumberOfMiniSlots : HLAinteger32LE
int32_t FlexRayCluster::GetgNumberOfMiniSlots() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mgNumberOfMiniSlots.get();
}

void FlexRayCluster::SetgNumberOfMiniSlots(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mgNumberOfMiniSlots.set(newValue);
  mDirty |= kgNumberOfMiniSlotsBit;
  mValuesSet |= kgNumberOfMiniSlotsBit;
}

// attribute gNumberOfStaticSlots : HLAinteger32LE
int32_t FlexRayCluster::GetgNumberOfStaticSlots() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mgNumberOfStaticSlots.get();
}

void FlexRayCluster::SetgNumberOfStaticSlots(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mgNumberOfStaticSlots.set(newValue);
  mDirty |= kgNumberOfStaticSlotsBit;
  mValuesSet |= kgNumberOfStaticSlotsBit;
}

// attribute gPayloadLengthStatic : HLAinteger32LE
int32_t FlexRayCluster::GetgPayloadLengthStatic() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mgPayloadLengthStatic.get();
}

void FlexRayCluster::SetgPayloadLengthStatic(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mgPayloadLengthStatic.set(newValue);
  mDirty |= kgPayloadLengthStaticBit;
  mValuesSet |= kgPayloadLengthStaticBit;
}

// attribute gSyncFrameIDCountMax : HLAoctet
uint8_t FlexRayCluster::GetgSyncFrameIDCountMax() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mgSyncFrameIDCountMax.get();
}

void FlexRayCluster::SetgSyncFrameIDCountMax(uint8_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mgSyncFrameIDCountMax.set(newValue);
  mDirty |= kgSyncFrameIDCountMaxBit;
  mValuesSet |= kgSyncFrameIDCountMaxBit;
}

rti1516ev::AttributeHandleValueMap FlexRayCluster::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  result[mObjectClass->GetgColdstartAttemptsAttributeHandle()] = mgColdstartAttempts.encode();
  result[mObjectClass->GetgCycleCountMaxAttributeHandle()] = mgCycleCountMax.encode();
  result[mObjectClass->GetgdActionPointOffsetAttributeHandle()] = mgdActionPointOffset.encode();
  result[mObjectClass->GetgdDynamicSlotIdlePhaseAttributeHandle()] = mgdDynamicSlotIdlePhase.encode();
  result[mObjectClass->GetgdMiniSlotAttributeHandle()] = mgdMiniSlot.encode();
  result[mObjectClass->GetgdMiniSlotActionPointOffsetAttributeHandle()] = mgdMiniSlotActionPointOffset.encode();
  result[mObjectClass->GetgdStaticSlotAttributeHandle()] = mgdStaticSlot.encode();
  result[mObjectClass->GetgdSymbolWindowAttributeHandle()] = mgdSymbolWindow.encode();
  result[mObjectClass->GetgdSymbolWindowActionPointOffsetAttributeHandle()] = mgdSymbolWindowActionPointOffset.encode();
  result[mObjectClass->GetgdTSSTransmitterAttributeHandle()] = mgdTSSTransmitter.encode();
  result[mObjectClass->GetgdWakeupTxActiveAttributeHandle()] = mgdWakeupTxActive.encode();
  result[mObjectClass->GetgdWakeupTxIdleAttributeHandle()] = mgdWakeupTxIdle.encode();
  result[mObjectClass->GetgListenNoiseAttributeHandle()] = mgListenNoise.encode();
  result[mObjectClass->GetgMacroPerCycleAttributeHandle()] = mgMacroPerCycle.encode();
  result[mObjectClass->GetgMaxWithoutClockCorrectionFatalAttributeHandle()] = mgMaxWithoutClockCorrectionFatal.encode();
  result[mObjectClass->GetgMaxWithoutClockCorrectionPassiveAttributeHandle()] = mgMaxWithoutClockCorrectionPassive.encode();
  result[mObjectClass->GetgNumberOfMiniSlotsAttributeHandle()] = mgNumberOfMiniSlots.encode();
  result[mObjectClass->GetgNumberOfStaticSlotsAttributeHandle()] = mgNumberOfStaticSlots.encode();
  result[mObjectClass->GetgPayloadLengthStaticAttributeHandle()] = mgPayloadLengthStatic.encode();
  result[mObjectClass->GetgSyncFrameIDCountMaxAttributeHandle()] = mgSyncFrameIDCountMax.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap FlexRayCluster::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kNetworkIDBit)
  {
    result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  }
  if (mDirty & kgColdstartAttemptsBit)
  {
    result[mObjectClass->GetgColdstartAttemptsAttributeHandle()] = mgColdstartAttempts.encode();
  }
  if (mDirty & kgCycleCountMaxBit)
  {
    result[mObjectClass->GetgCycleCountMaxAttributeHandle()] = mgCycleCountMax.encode();
  }
  if (mDirty & kgdActionPointOffsetBit)
  {
    result[mObjectClass->GetgdActionPointOffsetAttributeHandle()] = mgdActionPointOffset.encode();
  }
  if (mDirty & kgdDynamicSlotIdlePhaseBit)
  {
    result[mObjectClass->GetgdDynamicSlotIdlePhaseAttributeHandle()] = mgdDynamicSlotIdlePhase.encode();
  }
  if (mDirty & kgdMiniSlotBit)
  {
    result[mObjectClass->GetgdMiniSlotAttributeHandle()] = mgdMiniSlot.encode();
  }
  if (mDirty & kgdMiniSlotActionPointOffsetBit)
  {
    result[mObjectClass->GetgdMiniSlotActionPointOffsetAttributeHandle()] = mgdMiniSlotActionPointOffset.encode();
  }
  if (mDirty & kgdStaticSlotBit)
  {
    result[mObjectClass->GetgdStaticSlotAttributeHandle()] = mgdStaticSlot.encode();
  }
  if (mDirty & kgdSymbolWindowBit)
  {
    result[mObjectClass->GetgdSymbolWindowAttributeHandle()] = mgdSymbolWindow.encode();
  }
  if (mDirty & kgdSymbolWindowActionPointOffsetBit)
  {
    result[mObjectClass->GetgdSymbolWindowActionPointOffsetAttributeHandle()] = mgdSymbolWindowActionPointOffset.encode();
  }
  if (mDirty & kgdTSSTransmitterBit)
  {
    result[mObjectClass->GetgdTSSTransmitterAttributeHandle()] = mgdTSSTransmitter.encode();
  }
  if (mDirty & kgdWakeupTxActiveBit)
  {
    result[mObjectClass->GetgdWakeupTxActiveAttributeHandle()] = mgdWakeupTxActive.encode();
  }
  if (mDirty & kgdWakeupTxIdleBit)
  {
    result[mObjectClass->GetgdWakeupTxIdleAttributeHandle()] = mgdWakeupTxIdle.encode();
  }
  if (mDirty & kgListenNoiseBit)
  {
    result[mObjectClass->GetgListenNoiseAttributeHandle()] = mgListenNoise.encode();
  }
  if (mDirty & kgMacroPerCycleBit)
  {
    result[mObjectClass->GetgMacroPerCycleAttributeHandle()] = mgMacroPerCycle.encode();
  }
  if (mDirty & kgMaxWithoutClockCorrectionFatalBit)
  {
    result[mObjectClass->GetgMaxWithoutClockCorrectionFatalAttributeHandle()] = mgMaxWithoutClockCorrectionFatal.encode();
  }
  if (mDirty & kgMaxWithoutClockCorrectionPassiveBit)
  {
    result[mObjectClass->GetgMaxWithoutClockCorrectionPassiveAttributeHandle()] = mgMaxWithoutClockCorrectionPassive.encode();
  }
  if (mDirty & kgNumberOfMiniSlotsBit)
  {
    result[mObjectClass->GetgNumberOfMiniSlotsAttributeHandle()] = mgNumberOfMiniSlots.encode();
  }
  if (mDirty & kgNumberOfStaticSlotsBit)
  {
    result[mObjectClass->GetgNumberOfStaticSlotsAttributeHandle()] = mgNumberOfStaticSlots.encode();
  }
  if (mDirty & kgPayloadLengthStaticBit)
  {
    result[mObjectClass->GetgPayloadLengthStaticAttributeHandle()] = mgPayloadLengthStatic.encode();
  }
  if (mDirty & kgSyncFrameIDCountMaxBit)
  {
    result[mObjectClass->GetgSyncFrameIDCountMaxAttributeHandle()] = mgSyncFrameIDCountMax.encode();
  }
  return result;
}

FlexRayCluster::AttributeBits FlexRayCluster::GetReceivedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesReceived;
}

FlexRayCluster::AttributeBits FlexRayCluster::GetUpdatedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mLastUpdated;
}

FlexRayCluster::AttributeBits FlexRayCluster::GetInitializedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesSet;
}

FlexRayCluster::AttributeBits FlexRayCluster::GetModifiedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDirty;
}

void FlexRayCluster::UpdateAllAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void FlexRayCluster::UpdateAllAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    try {
      mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
      mDirty = kNone;
    }
    catch (const rti1516ev::InvalidLogicalTime& e)
    {
      throw InvalidLogicalTime(to_string(e.what()));
    }
    catch (const rti1516ev::Exception& e)
    {
      throw std::runtime_error(to_string(e.what()));
    }
  }
}

void FlexRayCluster::UpdateModifiedAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void FlexRayCluster::UpdateModifiedAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
        mDirty = kNone;
      }
      catch (const rti1516ev::InvalidLogicalTime& e)
      {
        throw InvalidLogicalTime(to_string(e.what()));
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void FlexRayCluster::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle())
    {
      mNetworkID.decode(attributeHandleValue.second);
      mLastUpdated |= kNetworkIDBit;
    }
    else if (attributeHandle == mObjectClass->GetgColdstartAttemptsAttributeHandle())
    {
      mgColdstartAttempts.decode(attributeHandleValue.second);
      mLastUpdated |= kgColdstartAttemptsBit;
    }
    else if (attributeHandle == mObjectClass->GetgCycleCountMaxAttributeHandle())
    {
      mgCycleCountMax.decode(attributeHandleValue.second);
      mLastUpdated |= kgCycleCountMaxBit;
    }
    else if (attributeHandle == mObjectClass->GetgdActionPointOffsetAttributeHandle())
    {
      mgdActionPointOffset.decode(attributeHandleValue.second);
      mLastUpdated |= kgdActionPointOffsetBit;
    }
    else if (attributeHandle == mObjectClass->GetgdDynamicSlotIdlePhaseAttributeHandle())
    {
      mgdDynamicSlotIdlePhase.decode(attributeHandleValue.second);
      mLastUpdated |= kgdDynamicSlotIdlePhaseBit;
    }
    else if (attributeHandle == mObjectClass->GetgdMiniSlotAttributeHandle())
    {
      mgdMiniSlot.decode(attributeHandleValue.second);
      mLastUpdated |= kgdMiniSlotBit;
    }
    else if (attributeHandle == mObjectClass->GetgdMiniSlotActionPointOffsetAttributeHandle())
    {
      mgdMiniSlotActionPointOffset.decode(attributeHandleValue.second);
      mLastUpdated |= kgdMiniSlotActionPointOffsetBit;
    }
    else if (attributeHandle == mObjectClass->GetgdStaticSlotAttributeHandle())
    {
      mgdStaticSlot.decode(attributeHandleValue.second);
      mLastUpdated |= kgdStaticSlotBit;
    }
    else if (attributeHandle == mObjectClass->GetgdSymbolWindowAttributeHandle())
    {
      mgdSymbolWindow.decode(attributeHandleValue.second);
      mLastUpdated |= kgdSymbolWindowBit;
    }
    else if (attributeHandle == mObjectClass->GetgdSymbolWindowActionPointOffsetAttributeHandle())
    {
      mgdSymbolWindowActionPointOffset.decode(attributeHandleValue.second);
      mLastUpdated |= kgdSymbolWindowActionPointOffsetBit;
    }
    else if (attributeHandle == mObjectClass->GetgdTSSTransmitterAttributeHandle())
    {
      mgdTSSTransmitter.decode(attributeHandleValue.second);
      mLastUpdated |= kgdTSSTransmitterBit;
    }
    else if (attributeHandle == mObjectClass->GetgdWakeupTxActiveAttributeHandle())
    {
      mgdWakeupTxActive.decode(attributeHandleValue.second);
      mLastUpdated |= kgdWakeupTxActiveBit;
    }
    else if (attributeHandle == mObjectClass->GetgdWakeupTxIdleAttributeHandle())
    {
      mgdWakeupTxIdle.decode(attributeHandleValue.second);
      mLastUpdated |= kgdWakeupTxIdleBit;
    }
    else if (attributeHandle == mObjectClass->GetgListenNoiseAttributeHandle())
    {
      mgListenNoise.decode(attributeHandleValue.second);
      mLastUpdated |= kgListenNoiseBit;
    }
    else if (attributeHandle == mObjectClass->GetgMacroPerCycleAttributeHandle())
    {
      mgMacroPerCycle.decode(attributeHandleValue.second);
      mLastUpdated |= kgMacroPerCycleBit;
    }
    else if (attributeHandle == mObjectClass->GetgMaxWithoutClockCorrectionFatalAttributeHandle())
    {
      mgMaxWithoutClockCorrectionFatal.decode(attributeHandleValue.second);
      mLastUpdated |= kgMaxWithoutClockCorrectionFatalBit;
    }
    else if (attributeHandle == mObjectClass->GetgMaxWithoutClockCorrectionPassiveAttributeHandle())
    {
      mgMaxWithoutClockCorrectionPassive.decode(attributeHandleValue.second);
      mLastUpdated |= kgMaxWithoutClockCorrectionPassiveBit;
    }
    else if (attributeHandle == mObjectClass->GetgNumberOfMiniSlotsAttributeHandle())
    {
      mgNumberOfMiniSlots.decode(attributeHandleValue.second);
      mLastUpdated |= kgNumberOfMiniSlotsBit;
    }
    else if (attributeHandle == mObjectClass->GetgNumberOfStaticSlotsAttributeHandle())
    {
      mgNumberOfStaticSlots.decode(attributeHandleValue.second);
      mLastUpdated |= kgNumberOfStaticSlotsBit;
    }
    else if (attributeHandle == mObjectClass->GetgPayloadLengthStaticAttributeHandle())
    {
      mgPayloadLengthStatic.decode(attributeHandleValue.second);
      mLastUpdated |= kgPayloadLengthStaticBit;
    }
    else if (attributeHandle == mObjectClass->GetgSyncFrameIDCountMaxAttributeHandle())
    {
      mgSyncFrameIDCountMax.decode(attributeHandleValue.second);
      mLastUpdated |= kgSyncFrameIDCountMaxBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(optional<int64_t>(), optional<OrderType>());
  mLastUpdated = kNone;
} // FlexRayCluster::ReflectAttributeValues

void FlexRayCluster::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle())
    {
      mNetworkID.decode(attributeHandleValue.second);
      mLastUpdated |= kNetworkIDBit;
    }
    else if (attributeHandle == mObjectClass->GetgColdstartAttemptsAttributeHandle())
    {
      mgColdstartAttempts.decode(attributeHandleValue.second);
      mLastUpdated |= kgColdstartAttemptsBit;
    }
    else if (attributeHandle == mObjectClass->GetgCycleCountMaxAttributeHandle())
    {
      mgCycleCountMax.decode(attributeHandleValue.second);
      mLastUpdated |= kgCycleCountMaxBit;
    }
    else if (attributeHandle == mObjectClass->GetgdActionPointOffsetAttributeHandle())
    {
      mgdActionPointOffset.decode(attributeHandleValue.second);
      mLastUpdated |= kgdActionPointOffsetBit;
    }
    else if (attributeHandle == mObjectClass->GetgdDynamicSlotIdlePhaseAttributeHandle())
    {
      mgdDynamicSlotIdlePhase.decode(attributeHandleValue.second);
      mLastUpdated |= kgdDynamicSlotIdlePhaseBit;
    }
    else if (attributeHandle == mObjectClass->GetgdMiniSlotAttributeHandle())
    {
      mgdMiniSlot.decode(attributeHandleValue.second);
      mLastUpdated |= kgdMiniSlotBit;
    }
    else if (attributeHandle == mObjectClass->GetgdMiniSlotActionPointOffsetAttributeHandle())
    {
      mgdMiniSlotActionPointOffset.decode(attributeHandleValue.second);
      mLastUpdated |= kgdMiniSlotActionPointOffsetBit;
    }
    else if (attributeHandle == mObjectClass->GetgdStaticSlotAttributeHandle())
    {
      mgdStaticSlot.decode(attributeHandleValue.second);
      mLastUpdated |= kgdStaticSlotBit;
    }
    else if (attributeHandle == mObjectClass->GetgdSymbolWindowAttributeHandle())
    {
      mgdSymbolWindow.decode(attributeHandleValue.second);
      mLastUpdated |= kgdSymbolWindowBit;
    }
    else if (attributeHandle == mObjectClass->GetgdSymbolWindowActionPointOffsetAttributeHandle())
    {
      mgdSymbolWindowActionPointOffset.decode(attributeHandleValue.second);
      mLastUpdated |= kgdSymbolWindowActionPointOffsetBit;
    }
    else if (attributeHandle == mObjectClass->GetgdTSSTransmitterAttributeHandle())
    {
      mgdTSSTransmitter.decode(attributeHandleValue.second);
      mLastUpdated |= kgdTSSTransmitterBit;
    }
    else if (attributeHandle == mObjectClass->GetgdWakeupTxActiveAttributeHandle())
    {
      mgdWakeupTxActive.decode(attributeHandleValue.second);
      mLastUpdated |= kgdWakeupTxActiveBit;
    }
    else if (attributeHandle == mObjectClass->GetgdWakeupTxIdleAttributeHandle())
    {
      mgdWakeupTxIdle.decode(attributeHandleValue.second);
      mLastUpdated |= kgdWakeupTxIdleBit;
    }
    else if (attributeHandle == mObjectClass->GetgListenNoiseAttributeHandle())
    {
      mgListenNoise.decode(attributeHandleValue.second);
      mLastUpdated |= kgListenNoiseBit;
    }
    else if (attributeHandle == mObjectClass->GetgMacroPerCycleAttributeHandle())
    {
      mgMacroPerCycle.decode(attributeHandleValue.second);
      mLastUpdated |= kgMacroPerCycleBit;
    }
    else if (attributeHandle == mObjectClass->GetgMaxWithoutClockCorrectionFatalAttributeHandle())
    {
      mgMaxWithoutClockCorrectionFatal.decode(attributeHandleValue.second);
      mLastUpdated |= kgMaxWithoutClockCorrectionFatalBit;
    }
    else if (attributeHandle == mObjectClass->GetgMaxWithoutClockCorrectionPassiveAttributeHandle())
    {
      mgMaxWithoutClockCorrectionPassive.decode(attributeHandleValue.second);
      mLastUpdated |= kgMaxWithoutClockCorrectionPassiveBit;
    }
    else if (attributeHandle == mObjectClass->GetgNumberOfMiniSlotsAttributeHandle())
    {
      mgNumberOfMiniSlots.decode(attributeHandleValue.second);
      mLastUpdated |= kgNumberOfMiniSlotsBit;
    }
    else if (attributeHandle == mObjectClass->GetgNumberOfStaticSlotsAttributeHandle())
    {
      mgNumberOfStaticSlots.decode(attributeHandleValue.second);
      mLastUpdated |= kgNumberOfStaticSlotsBit;
    }
    else if (attributeHandle == mObjectClass->GetgPayloadLengthStaticAttributeHandle())
    {
      mgPayloadLengthStatic.decode(attributeHandleValue.second);
      mLastUpdated |= kgPayloadLengthStaticBit;
    }
    else if (attributeHandle == mObjectClass->GetgSyncFrameIDCountMaxAttributeHandle())
    {
      mgSyncFrameIDCountMax.decode(attributeHandleValue.second);
      mLastUpdated |= kgSyncFrameIDCountMaxBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(static_cast<const rti1516ev::HLAinteger64Time&>(theTime).getTime(), orderType);
  mLastUpdated = kNone;
} // FlexRayCluster::ReflectAttributeValues

// request attributes not being part of the last update
void FlexRayCluster::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    if ((mLastUpdated & kNetworkIDBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetNetworkIDAttributeHandle());
    }
    if ((mLastUpdated & kgColdstartAttemptsBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetgColdstartAttemptsAttributeHandle());
    }
    if ((mLastUpdated & kgCycleCountMaxBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetgCycleCountMaxAttributeHandle());
    }
    if ((mLastUpdated & kgdActionPointOffsetBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetgdActionPointOffsetAttributeHandle());
    }
    if ((mLastUpdated & kgdDynamicSlotIdlePhaseBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetgdDynamicSlotIdlePhaseAttributeHandle());
    }
    if ((mLastUpdated & kgdMiniSlotBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetgdMiniSlotAttributeHandle());
    }
    if ((mLastUpdated & kgdMiniSlotActionPointOffsetBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetgdMiniSlotActionPointOffsetAttributeHandle());
    }
    if ((mLastUpdated & kgdStaticSlotBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetgdStaticSlotAttributeHandle());
    }
    if ((mLastUpdated & kgdSymbolWindowBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetgdSymbolWindowAttributeHandle());
    }
    if ((mLastUpdated & kgdSymbolWindowActionPointOffsetBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetgdSymbolWindowActionPointOffsetAttributeHandle());
    }
    if ((mLastUpdated & kgdTSSTransmitterBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetgdTSSTransmitterAttributeHandle());
    }
    if ((mLastUpdated & kgdWakeupTxActiveBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetgdWakeupTxActiveAttributeHandle());
    }
    if ((mLastUpdated & kgdWakeupTxIdleBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetgdWakeupTxIdleAttributeHandle());
    }
    if ((mLastUpdated & kgListenNoiseBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetgListenNoiseAttributeHandle());
    }
    if ((mLastUpdated & kgMacroPerCycleBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetgMacroPerCycleAttributeHandle());
    }
    if ((mLastUpdated & kgMaxWithoutClockCorrectionFatalBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetgMaxWithoutClockCorrectionFatalAttributeHandle());
    }
    if ((mLastUpdated & kgMaxWithoutClockCorrectionPassiveBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetgMaxWithoutClockCorrectionPassiveAttributeHandle());
    }
    if ((mLastUpdated & kgNumberOfMiniSlotsBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetgNumberOfMiniSlotsAttributeHandle());
    }
    if ((mLastUpdated & kgNumberOfStaticSlotsBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetgNumberOfStaticSlotsAttributeHandle());
    }
    if ((mLastUpdated & kgPayloadLengthStaticBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetgPayloadLengthStaticAttributeHandle());
    }
    if ((mLastUpdated & kgSyncFrameIDCountMaxBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetgSyncFrameIDCountMaxAttributeHandle());
    }
  } // scope of lock_guard
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// request all attributes, regardless of current state
void FlexRayCluster::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetNetworkIDAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgColdstartAttemptsAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgCycleCountMaxAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgdActionPointOffsetAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgdDynamicSlotIdlePhaseAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgdMiniSlotAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgdMiniSlotActionPointOffsetAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgdStaticSlotAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgdSymbolWindowAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgdSymbolWindowActionPointOffsetAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgdTSSTransmitterAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgdWakeupTxActiveAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgdWakeupTxIdleAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgListenNoiseAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgMacroPerCycleAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgMaxWithoutClockCorrectionFatalAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgMaxWithoutClockCorrectionPassiveAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgNumberOfMiniSlotsAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgNumberOfStaticSlotsAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgPayloadLengthStaticAttributeHandle());
  requestAttributes.insert(mObjectClass->GetgSyncFrameIDCountMaxAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// provide requested attributes set since last sent update
void FlexRayCluster::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    for (auto& attributeHandle : attributeHandles)
    {
      if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle() && (mValuesSet & kNetworkIDBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mNetworkID.encode()));
        mDirty &= ~kNetworkIDBit;
      }
      else if (attributeHandle == mObjectClass->GetgColdstartAttemptsAttributeHandle() && (mValuesSet & kgColdstartAttemptsBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mgColdstartAttempts.encode()));
        mDirty &= ~kgColdstartAttemptsBit;
      }
      else if (attributeHandle == mObjectClass->GetgCycleCountMaxAttributeHandle() && (mValuesSet & kgCycleCountMaxBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mgCycleCountMax.encode()));
        mDirty &= ~kgCycleCountMaxBit;
      }
      else if (attributeHandle == mObjectClass->GetgdActionPointOffsetAttributeHandle() && (mValuesSet & kgdActionPointOffsetBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mgdActionPointOffset.encode()));
        mDirty &= ~kgdActionPointOffsetBit;
      }
      else if (attributeHandle == mObjectClass->GetgdDynamicSlotIdlePhaseAttributeHandle() && (mValuesSet & kgdDynamicSlotIdlePhaseBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mgdDynamicSlotIdlePhase.encode()));
        mDirty &= ~kgdDynamicSlotIdlePhaseBit;
      }
      else if (attributeHandle == mObjectClass->GetgdMiniSlotAttributeHandle() && (mValuesSet & kgdMiniSlotBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mgdMiniSlot.encode()));
        mDirty &= ~kgdMiniSlotBit;
      }
      else if (attributeHandle == mObjectClass->GetgdMiniSlotActionPointOffsetAttributeHandle() && (mValuesSet & kgdMiniSlotActionPointOffsetBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mgdMiniSlotActionPointOffset.encode()));
        mDirty &= ~kgdMiniSlotActionPointOffsetBit;
      }
      else if (attributeHandle == mObjectClass->GetgdStaticSlotAttributeHandle() && (mValuesSet & kgdStaticSlotBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mgdStaticSlot.encode()));
        mDirty &= ~kgdStaticSlotBit;
      }
      else if (attributeHandle == mObjectClass->GetgdSymbolWindowAttributeHandle() && (mValuesSet & kgdSymbolWindowBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mgdSymbolWindow.encode()));
        mDirty &= ~kgdSymbolWindowBit;
      }
      else if (attributeHandle == mObjectClass->GetgdSymbolWindowActionPointOffsetAttributeHandle() && (mValuesSet & kgdSymbolWindowActionPointOffsetBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mgdSymbolWindowActionPointOffset.encode()));
        mDirty &= ~kgdSymbolWindowActionPointOffsetBit;
      }
      else if (attributeHandle == mObjectClass->GetgdTSSTransmitterAttributeHandle() && (mValuesSet & kgdTSSTransmitterBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mgdTSSTransmitter.encode()));
        mDirty &= ~kgdTSSTransmitterBit;
      }
      else if (attributeHandle == mObjectClass->GetgdWakeupTxActiveAttributeHandle() && (mValuesSet & kgdWakeupTxActiveBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mgdWakeupTxActive.encode()));
        mDirty &= ~kgdWakeupTxActiveBit;
      }
      else if (attributeHandle == mObjectClass->GetgdWakeupTxIdleAttributeHandle() && (mValuesSet & kgdWakeupTxIdleBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mgdWakeupTxIdle.encode()));
        mDirty &= ~kgdWakeupTxIdleBit;
      }
      else if (attributeHandle == mObjectClass->GetgListenNoiseAttributeHandle() && (mValuesSet & kgListenNoiseBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mgListenNoise.encode()));
        mDirty &= ~kgListenNoiseBit;
      }
      else if (attributeHandle == mObjectClass->GetgMacroPerCycleAttributeHandle() && (mValuesSet & kgMacroPerCycleBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mgMacroPerCycle.encode()));
        mDirty &= ~kgMacroPerCycleBit;
      }
      else if (attributeHandle == mObjectClass->GetgMaxWithoutClockCorrectionFatalAttributeHandle() && (mValuesSet & kgMaxWithoutClockCorrectionFatalBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mgMaxWithoutClockCorrectionFatal.encode()));
        mDirty &= ~kgMaxWithoutClockCorrectionFatalBit;
      }
      else if (attributeHandle == mObjectClass->GetgMaxWithoutClockCorrectionPassiveAttributeHandle() && (mValuesSet & kgMaxWithoutClockCorrectionPassiveBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mgMaxWithoutClockCorrectionPassive.encode()));
        mDirty &= ~kgMaxWithoutClockCorrectionPassiveBit;
      }
      else if (attributeHandle == mObjectClass->GetgNumberOfMiniSlotsAttributeHandle() && (mValuesSet & kgNumberOfMiniSlotsBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mgNumberOfMiniSlots.encode()));
        mDirty &= ~kgNumberOfMiniSlotsBit;
      }
      else if (attributeHandle == mObjectClass->GetgNumberOfStaticSlotsAttributeHandle() && (mValuesSet & kgNumberOfStaticSlotsBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mgNumberOfStaticSlots.encode()));
        mDirty &= ~kgNumberOfStaticSlotsBit;
      }
      else if (attributeHandle == mObjectClass->GetgPayloadLengthStaticAttributeHandle() && (mValuesSet & kgPayloadLengthStaticBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mgPayloadLengthStatic.encode()));
        mDirty &= ~kgPayloadLengthStaticBit;
      }
      else if (attributeHandle == mObjectClass->GetgSyncFrameIDCountMaxAttributeHandle() && (mValuesSet & kgSyncFrameIDCountMaxBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mgSyncFrameIDCountMax.encode()));
        mDirty &= ~kgSyncFrameIDCountMaxBit;
      }
    } // for (auto& attributeHandleValue : attributes)
  } // scope of lock_guard
  if (time)
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(*time));
  else
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // FlexRayCluster::ReflectAttributeValues

uint32_t FlexRayCluster::RegisterUpdateCallback(UpdateCallback callback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void FlexRayCluster::UnregisterUpdateCallback(uint32_t callbackToken)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mUpdateCallbacks.erase(callbackToken);
}

void FlexRayCluster::ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(std::static_pointer_cast<IFlexRayCluster>(shared_from_this()), time, orderType);
  }
}


// object class type 'BusController'
BusControllerObjectClass::BusControllerObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, HLAobjectRootObjectClass* baseClass)
{
  mRegistry = registry;
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.BusController");
  // attribute NetworkID : HLAASCIIstring
  mNetworkIDAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"NetworkID");
  // attribute DeviceID : HLAASCIIstring
  mDeviceIDAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"DeviceID");
  SetObjectInstanceCreator([](BusControllerObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador) -> BusController* {
    return new BusController(objectClass, instanceName, rtiAmbassador);
  });
}

BusControllerObjectClass::~BusControllerObjectClass()
{
  //std::lock_guard<std::recursive_mutex> lock(mMutex);
  while (!mObjectInstancesByHandle.empty())
  {
    // careful - hold the reference to the object instance until it has been removed from the maps,
    // otherwise it's mutex will be destroyed while held
    auto objectInstance = mObjectInstancesByHandle.begin()->second;
    objectInstance->Release();
  }
  assert(mObjectInstancesByHandle.empty());
  assert(mObjectInstancesByName.empty());
}

void BusControllerObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void BusControllerObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void BusControllerObjectClass::Subscribe(bool deliverToSelf)
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    if (deliverToSelf) mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void BusControllerObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

rti1516ev::AttributeHandleSet BusControllerObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetNetworkIDAttributeHandle());
  result.insert(GetDeviceIDAttributeHandle());
  return result;
}

void BusControllerObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  assert(mObjectInstancesByName.find(objectInstanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(objectInstanceHandle) == mObjectInstancesByHandle.end());
  std::shared_ptr<BusController> newObject = std::shared_ptr<BusController>(mCreatorFunction(this, objectInstanceName, mRtiAmbassador));
  newObject->mObjectInstanceHandle = objectInstanceHandle;
  newObject->mIsOwner = false;
  InsertObjectInstanceName(newObject, objectInstanceName);
  InsertObjectInstanceHandle(newObject, objectInstanceHandle);
  ExecuteDiscoverObjectInstanceCallbacks(newObject);
}

void BusControllerObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring objectInstanceName = mRtiAmbassador->getObjectInstanceName(objectInstanceHandle);
  auto iter = mObjectInstancesByName.find(objectInstanceName);
  assert(iter != mObjectInstancesByName.end());
  auto objectInstance = std::dynamic_pointer_cast<BusController>(iter->second);
  ExecuteRemoveObjectInstanceCallbacks(objectInstance);
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  EraseObjectInstance(objectInstanceHandle, objectInstanceName);
}

std::shared_ptr<IBusController> BusControllerObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IHLAobjectRoot> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceName);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IBusController>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IBusController> BusControllerObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IHLAobjectRoot> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceHandle);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IBusController>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IBusController> BusControllerObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"BusController");
  }
  std::shared_ptr<BusController> newObject = std::shared_ptr<BusController>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
    }
  });
  return newObject;
}

std::shared_ptr<IBusController> BusControllerObjectClass::CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"BusController");
  }
  std::shared_ptr<BusController> newObject = std::shared_ptr<BusController>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
      createdCallback(newObject, true);
    }
    else
    {
      createdCallback(newObject, false);
    }
  });
  return newObject;
}

uint32_t BusControllerObjectClass::RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastDiscoverObjectInstanceCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastDiscoverObjectInstanceCallbackToken, callback));
  return mLastDiscoverObjectInstanceCallbackToken;
}

void BusControllerObjectClass::UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mDiscoverCallbacks.erase(callbackToken);
}

void BusControllerObjectClass::ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IBusController> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

uint32_t BusControllerObjectClass::RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastRemoveObjectInstanceCallbackToken++;
  mRemoveObjectInstanceCallbacks.insert(std::make_pair(mLastRemoveObjectInstanceCallbackToken, callback));
  return mLastRemoveObjectInstanceCallbackToken;
}

void BusControllerObjectClass::UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mRemoveObjectInstanceCallbacks.erase(callbackToken);
}

void BusControllerObjectClass::ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IBusController> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mRemoveObjectInstanceCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

void BusControllerObjectClass::InsertObjectInstanceName(std::shared_ptr<IBusController> objectInstance, const std::wstring& objectInstanceName)
{
  // prerequisite: mMutex must be locked
  mObjectInstancesByName.insert(std::make_pair(objectInstanceName, objectInstance));
  mBaseClass->InsertObjectInstanceName(objectInstance, objectInstanceName);
}

void BusControllerObjectClass::InsertObjectInstanceHandle(std::shared_ptr<IBusController> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByHandle.insert(std::make_pair(objectInstanceHandle, objectInstance));
  mBaseClass->InsertObjectInstanceHandle(objectInstance, objectInstanceHandle);
}

void BusControllerObjectClass::EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mBaseClass->EraseObjectInstance(objectInstanceHandle, objectInstanceName);
  mObjectInstancesByName.erase(objectInstanceName);
  mObjectInstancesByHandle.erase(objectInstanceHandle);
}


// object instances of type 'BusController'
BusController::BusController()
  : mRtiAmbassador()
  , mObjectClass()
  , mObjectInstanceName()
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

BusController::BusController(BusControllerObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mRtiAmbassador(rtiAmbassador)
  , mObjectClass(objectClass)
  , mObjectInstanceName(instanceName)
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

BusController::~BusController()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    try
    {
      mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    }
    catch (const rti1516ev::Exception&)
    {
    }
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

bool BusController::IsValid() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mObjectInstanceHandle.isValid();
}

bool BusController::IsOwner() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mIsOwner;
}

void BusController::Release()
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (mObjectInstanceHandle.isValid())
  {
    if (mIsOwner)
    {
      try
      {
        mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
      }
      catch (const rti1516ev::Exception&)
      {
        // ignore - must execute rest of function
      }
      mIsOwner = false;
    }
    mObjectClass->EraseObjectInstance(mObjectInstanceHandle, mObjectInstanceName);
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  }
}

// attribute BusController.HLAprivilegeToDeleteObject : no data type

// attribute NetworkID : HLAASCIIstring
std::string BusController::GetNetworkID() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mNetworkID.get();
}

void BusController::SetNetworkID(std::string newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mNetworkID.set(newValue);
  mDirty |= kNetworkIDBit;
  mValuesSet |= kNetworkIDBit;
}

// attribute DeviceID : HLAASCIIstring
std::string BusController::GetDeviceID() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDeviceID.get();
}

void BusController::SetDeviceID(std::string newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mDeviceID.set(newValue);
  mDirty |= kDeviceIDBit;
  mValuesSet |= kDeviceIDBit;
}

rti1516ev::AttributeHandleValueMap BusController::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  result[mObjectClass->GetDeviceIDAttributeHandle()] = mDeviceID.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap BusController::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kNetworkIDBit)
  {
    result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  }
  if (mDirty & kDeviceIDBit)
  {
    result[mObjectClass->GetDeviceIDAttributeHandle()] = mDeviceID.encode();
  }
  return result;
}

BusController::AttributeBits BusController::GetReceivedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesReceived;
}

BusController::AttributeBits BusController::GetUpdatedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mLastUpdated;
}

BusController::AttributeBits BusController::GetInitializedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesSet;
}

BusController::AttributeBits BusController::GetModifiedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDirty;
}

void BusController::UpdateAllAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void BusController::UpdateAllAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    try {
      mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
      mDirty = kNone;
    }
    catch (const rti1516ev::InvalidLogicalTime& e)
    {
      throw InvalidLogicalTime(to_string(e.what()));
    }
    catch (const rti1516ev::Exception& e)
    {
      throw std::runtime_error(to_string(e.what()));
    }
  }
}

void BusController::UpdateModifiedAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void BusController::UpdateModifiedAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
        mDirty = kNone;
      }
      catch (const rti1516ev::InvalidLogicalTime& e)
      {
        throw InvalidLogicalTime(to_string(e.what()));
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void BusController::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle())
    {
      mNetworkID.decode(attributeHandleValue.second);
      mLastUpdated |= kNetworkIDBit;
    }
    else if (attributeHandle == mObjectClass->GetDeviceIDAttributeHandle())
    {
      mDeviceID.decode(attributeHandleValue.second);
      mLastUpdated |= kDeviceIDBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  mLastUpdated = kNone;
} // BusController::ReflectAttributeValues

void BusController::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& /* theTime */, OrderType /* orderType */)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle())
    {
      mNetworkID.decode(attributeHandleValue.second);
      mLastUpdated |= kNetworkIDBit;
    }
    else if (attributeHandle == mObjectClass->GetDeviceIDAttributeHandle())
    {
      mDeviceID.decode(attributeHandleValue.second);
      mLastUpdated |= kDeviceIDBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  mLastUpdated = kNone;
} // BusController::ReflectAttributeValues

// request attributes not being part of the last update
void BusController::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    if ((mLastUpdated & kNetworkIDBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetNetworkIDAttributeHandle());
    }
    if ((mLastUpdated & kDeviceIDBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetDeviceIDAttributeHandle());
    }
  } // scope of lock_guard
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// request all attributes, regardless of current state
void BusController::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetNetworkIDAttributeHandle());
  requestAttributes.insert(mObjectClass->GetDeviceIDAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// provide requested attributes set since last sent update
void BusController::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    for (auto& attributeHandle : attributeHandles)
    {
      if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle() && (mValuesSet & kNetworkIDBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mNetworkID.encode()));
        mDirty &= ~kNetworkIDBit;
      }
      else if (attributeHandle == mObjectClass->GetDeviceIDAttributeHandle() && (mValuesSet & kDeviceIDBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mDeviceID.encode()));
        mDirty &= ~kDeviceIDBit;
      }
    } // for (auto& attributeHandleValue : attributes)
  } // scope of lock_guard
  if (time)
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(*time));
  else
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // BusController::ReflectAttributeValues


// object class type 'BusControllerCan'
BusControllerCanObjectClass::BusControllerCanObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, BusControllerObjectClass* baseClass)
{
  mRegistry = registry;
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.BusController.BusControllerCan");
  // attribute BaudRate : HLAinteger32LE
  mBaudRateAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"BaudRate");
  // attribute DataBaudRate : HLAinteger32LE
  mDataBaudRateAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"DataBaudRate");
  // attribute PreScaler : HLAinteger32LE
  mPreScalerAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"PreScaler");
  // attribute OperationMode : CanOperationMode
  mOperationModeAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"OperationMode");
  // attribute Sync_Seg : HLAinteger32LE
  mSync_SegAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"Sync_Seg");
  // attribute Prop_Seg : HLAinteger32LE
  mProp_SegAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"Prop_Seg");
  // attribute Phase_Seg1 : HLAinteger32LE
  mPhase_Seg1AttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"Phase_Seg1");
  // attribute Phase_Seg2 : HLAinteger32LE
  mPhase_Seg2AttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"Phase_Seg2");
  // attribute SamplingMode : CanSamplingMode
  mSamplingModeAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"SamplingMode");
  SetObjectInstanceCreator([](BusControllerCanObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador) -> BusControllerCan* {
    return new BusControllerCan(objectClass, instanceName, rtiAmbassador);
  });
}

BusControllerCanObjectClass::~BusControllerCanObjectClass()
{
  //std::lock_guard<std::recursive_mutex> lock(mMutex);
  while (!mObjectInstancesByHandle.empty())
  {
    // careful - hold the reference to the object instance until it has been removed from the maps,
    // otherwise it's mutex will be destroyed while held
    auto objectInstance = mObjectInstancesByHandle.begin()->second;
    objectInstance->Release();
  }
  assert(mObjectInstancesByHandle.empty());
  assert(mObjectInstancesByName.empty());
}

void BusControllerCanObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void BusControllerCanObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void BusControllerCanObjectClass::Subscribe(bool deliverToSelf)
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    if (deliverToSelf) mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void BusControllerCanObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

rti1516ev::AttributeHandleSet BusControllerCanObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetNetworkIDAttributeHandle());
  result.insert(GetDeviceIDAttributeHandle());
  result.insert(GetBaudRateAttributeHandle());
  result.insert(GetDataBaudRateAttributeHandle());
  result.insert(GetPreScalerAttributeHandle());
  result.insert(GetOperationModeAttributeHandle());
  result.insert(GetSync_SegAttributeHandle());
  result.insert(GetProp_SegAttributeHandle());
  result.insert(GetPhase_Seg1AttributeHandle());
  result.insert(GetPhase_Seg2AttributeHandle());
  result.insert(GetSamplingModeAttributeHandle());
  return result;
}

void BusControllerCanObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  assert(mObjectInstancesByName.find(objectInstanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(objectInstanceHandle) == mObjectInstancesByHandle.end());
  std::shared_ptr<BusControllerCan> newObject = std::shared_ptr<BusControllerCan>(mCreatorFunction(this, objectInstanceName, mRtiAmbassador));
  newObject->mObjectInstanceHandle = objectInstanceHandle;
  newObject->mIsOwner = false;
  InsertObjectInstanceName(newObject, objectInstanceName);
  InsertObjectInstanceHandle(newObject, objectInstanceHandle);
  ExecuteDiscoverObjectInstanceCallbacks(newObject);
}

void BusControllerCanObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring objectInstanceName = mRtiAmbassador->getObjectInstanceName(objectInstanceHandle);
  auto iter = mObjectInstancesByName.find(objectInstanceName);
  assert(iter != mObjectInstancesByName.end());
  auto objectInstance = std::dynamic_pointer_cast<BusControllerCan>(iter->second);
  ExecuteRemoveObjectInstanceCallbacks(objectInstance);
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  EraseObjectInstance(objectInstanceHandle, objectInstanceName);
}

std::shared_ptr<IBusControllerCan> BusControllerCanObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IBusController> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceName);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IBusControllerCan>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IBusControllerCan> BusControllerCanObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IBusController> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceHandle);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IBusControllerCan>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IBusControllerCan> BusControllerCanObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"BusControllerCan");
  }
  std::shared_ptr<BusControllerCan> newObject = std::shared_ptr<BusControllerCan>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
    }
  });
  return newObject;
}

std::shared_ptr<IBusControllerCan> BusControllerCanObjectClass::CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"BusControllerCan");
  }
  std::shared_ptr<BusControllerCan> newObject = std::shared_ptr<BusControllerCan>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
      createdCallback(newObject, true);
    }
    else
    {
      createdCallback(newObject, false);
    }
  });
  return newObject;
}

uint32_t BusControllerCanObjectClass::RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastDiscoverObjectInstanceCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastDiscoverObjectInstanceCallbackToken, callback));
  return mLastDiscoverObjectInstanceCallbackToken;
}

void BusControllerCanObjectClass::UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mDiscoverCallbacks.erase(callbackToken);
}

void BusControllerCanObjectClass::ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IBusControllerCan> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

uint32_t BusControllerCanObjectClass::RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastRemoveObjectInstanceCallbackToken++;
  mRemoveObjectInstanceCallbacks.insert(std::make_pair(mLastRemoveObjectInstanceCallbackToken, callback));
  return mLastRemoveObjectInstanceCallbackToken;
}

void BusControllerCanObjectClass::UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mRemoveObjectInstanceCallbacks.erase(callbackToken);
}

void BusControllerCanObjectClass::ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IBusControllerCan> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mRemoveObjectInstanceCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

void BusControllerCanObjectClass::InsertObjectInstanceName(std::shared_ptr<IBusControllerCan> objectInstance, const std::wstring& objectInstanceName)
{
  // prerequisite: mMutex must be locked
  mObjectInstancesByName.insert(std::make_pair(objectInstanceName, objectInstance));
  mBaseClass->InsertObjectInstanceName(objectInstance, objectInstanceName);
}

void BusControllerCanObjectClass::InsertObjectInstanceHandle(std::shared_ptr<IBusControllerCan> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByHandle.insert(std::make_pair(objectInstanceHandle, objectInstance));
  mBaseClass->InsertObjectInstanceHandle(objectInstance, objectInstanceHandle);
}

void BusControllerCanObjectClass::EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mBaseClass->EraseObjectInstance(objectInstanceHandle, objectInstanceName);
  mObjectInstancesByName.erase(objectInstanceName);
  mObjectInstancesByHandle.erase(objectInstanceHandle);
}


// object instances of type 'BusControllerCan'
BusControllerCan::BusControllerCan()
  : mRtiAmbassador()
  , mObjectClass()
  , mObjectInstanceName()
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

BusControllerCan::BusControllerCan(BusControllerCanObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mRtiAmbassador(rtiAmbassador)
  , mObjectClass(objectClass)
  , mObjectInstanceName(instanceName)
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

BusControllerCan::~BusControllerCan()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    try
    {
      mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    }
    catch (const rti1516ev::Exception&)
    {
    }
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

bool BusControllerCan::IsValid() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mObjectInstanceHandle.isValid();
}

bool BusControllerCan::IsOwner() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mIsOwner;
}

void BusControllerCan::Release()
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (mObjectInstanceHandle.isValid())
  {
    if (mIsOwner)
    {
      try
      {
        mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
      }
      catch (const rti1516ev::Exception&)
      {
        // ignore - must execute rest of function
      }
      mIsOwner = false;
    }
    mObjectClass->EraseObjectInstance(mObjectInstanceHandle, mObjectInstanceName);
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  }
}

// attribute BusControllerCan.HLAprivilegeToDeleteObject : no data type

// attribute NetworkID : HLAASCIIstring
std::string BusControllerCan::GetNetworkID() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mNetworkID.get();
}

void BusControllerCan::SetNetworkID(std::string newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mNetworkID.set(newValue);
  mDirty |= kNetworkIDBit;
  mValuesSet |= kNetworkIDBit;
}

// attribute DeviceID : HLAASCIIstring
std::string BusControllerCan::GetDeviceID() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDeviceID.get();
}

void BusControllerCan::SetDeviceID(std::string newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mDeviceID.set(newValue);
  mDirty |= kDeviceIDBit;
  mValuesSet |= kDeviceIDBit;
}

// attribute BaudRate : HLAinteger32LE
int32_t BusControllerCan::GetBaudRate() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mBaudRate.get();
}

void BusControllerCan::SetBaudRate(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mBaudRate.set(newValue);
  mDirty |= kBaudRateBit;
  mValuesSet |= kBaudRateBit;
}

// attribute DataBaudRate : HLAinteger32LE
int32_t BusControllerCan::GetDataBaudRate() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDataBaudRate.get();
}

void BusControllerCan::SetDataBaudRate(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mDataBaudRate.set(newValue);
  mDirty |= kDataBaudRateBit;
  mValuesSet |= kDataBaudRateBit;
}

// attribute PreScaler : HLAinteger32LE
int32_t BusControllerCan::GetPreScaler() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mPreScaler.get();
}

void BusControllerCan::SetPreScaler(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mPreScaler.set(newValue);
  mDirty |= kPreScalerBit;
  mValuesSet |= kPreScalerBit;
}

// attribute OperationMode : CanOperationMode
CanOperationMode BusControllerCan::GetOperationMode() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return static_cast<CanOperationMode>(mOperationMode.get());
}

void BusControllerCan::SetOperationMode(CanOperationMode newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mOperationMode.set(static_cast<int32_t>(newValue));
  mDirty |= kOperationModeBit;
  mValuesSet |= kOperationModeBit;
}

// attribute Sync_Seg : HLAinteger32LE
int32_t BusControllerCan::GetSync_Seg() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mSync_Seg.get();
}

void BusControllerCan::SetSync_Seg(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mSync_Seg.set(newValue);
  mDirty |= kSync_SegBit;
  mValuesSet |= kSync_SegBit;
}

// attribute Prop_Seg : HLAinteger32LE
int32_t BusControllerCan::GetProp_Seg() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mProp_Seg.get();
}

void BusControllerCan::SetProp_Seg(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mProp_Seg.set(newValue);
  mDirty |= kProp_SegBit;
  mValuesSet |= kProp_SegBit;
}

// attribute Phase_Seg1 : HLAinteger32LE
int32_t BusControllerCan::GetPhase_Seg1() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mPhase_Seg1.get();
}

void BusControllerCan::SetPhase_Seg1(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mPhase_Seg1.set(newValue);
  mDirty |= kPhase_Seg1Bit;
  mValuesSet |= kPhase_Seg1Bit;
}

// attribute Phase_Seg2 : HLAinteger32LE
int32_t BusControllerCan::GetPhase_Seg2() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mPhase_Seg2.get();
}

void BusControllerCan::SetPhase_Seg2(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mPhase_Seg2.set(newValue);
  mDirty |= kPhase_Seg2Bit;
  mValuesSet |= kPhase_Seg2Bit;
}

// attribute SamplingMode : CanSamplingMode
CanSamplingMode BusControllerCan::GetSamplingMode() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return static_cast<CanSamplingMode>(mSamplingMode.get());
}

void BusControllerCan::SetSamplingMode(CanSamplingMode newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mSamplingMode.set(static_cast<int32_t>(newValue));
  mDirty |= kSamplingModeBit;
  mValuesSet |= kSamplingModeBit;
}

rti1516ev::AttributeHandleValueMap BusControllerCan::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  result[mObjectClass->GetDeviceIDAttributeHandle()] = mDeviceID.encode();
  result[mObjectClass->GetBaudRateAttributeHandle()] = mBaudRate.encode();
  result[mObjectClass->GetDataBaudRateAttributeHandle()] = mDataBaudRate.encode();
  result[mObjectClass->GetPreScalerAttributeHandle()] = mPreScaler.encode();
  result[mObjectClass->GetOperationModeAttributeHandle()] = mOperationMode.encode();
  result[mObjectClass->GetSync_SegAttributeHandle()] = mSync_Seg.encode();
  result[mObjectClass->GetProp_SegAttributeHandle()] = mProp_Seg.encode();
  result[mObjectClass->GetPhase_Seg1AttributeHandle()] = mPhase_Seg1.encode();
  result[mObjectClass->GetPhase_Seg2AttributeHandle()] = mPhase_Seg2.encode();
  result[mObjectClass->GetSamplingModeAttributeHandle()] = mSamplingMode.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap BusControllerCan::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kNetworkIDBit)
  {
    result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  }
  if (mDirty & kDeviceIDBit)
  {
    result[mObjectClass->GetDeviceIDAttributeHandle()] = mDeviceID.encode();
  }
  if (mDirty & kBaudRateBit)
  {
    result[mObjectClass->GetBaudRateAttributeHandle()] = mBaudRate.encode();
  }
  if (mDirty & kDataBaudRateBit)
  {
    result[mObjectClass->GetDataBaudRateAttributeHandle()] = mDataBaudRate.encode();
  }
  if (mDirty & kPreScalerBit)
  {
    result[mObjectClass->GetPreScalerAttributeHandle()] = mPreScaler.encode();
  }
  if (mDirty & kOperationModeBit)
  {
    result[mObjectClass->GetOperationModeAttributeHandle()] = mOperationMode.encode();
  }
  if (mDirty & kSync_SegBit)
  {
    result[mObjectClass->GetSync_SegAttributeHandle()] = mSync_Seg.encode();
  }
  if (mDirty & kProp_SegBit)
  {
    result[mObjectClass->GetProp_SegAttributeHandle()] = mProp_Seg.encode();
  }
  if (mDirty & kPhase_Seg1Bit)
  {
    result[mObjectClass->GetPhase_Seg1AttributeHandle()] = mPhase_Seg1.encode();
  }
  if (mDirty & kPhase_Seg2Bit)
  {
    result[mObjectClass->GetPhase_Seg2AttributeHandle()] = mPhase_Seg2.encode();
  }
  if (mDirty & kSamplingModeBit)
  {
    result[mObjectClass->GetSamplingModeAttributeHandle()] = mSamplingMode.encode();
  }
  return result;
}

BusControllerCan::AttributeBits BusControllerCan::GetReceivedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesReceived;
}

BusControllerCan::AttributeBits BusControllerCan::GetUpdatedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mLastUpdated;
}

BusControllerCan::AttributeBits BusControllerCan::GetInitializedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesSet;
}

BusControllerCan::AttributeBits BusControllerCan::GetModifiedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDirty;
}

void BusControllerCan::UpdateAllAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void BusControllerCan::UpdateAllAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    try {
      mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
      mDirty = kNone;
    }
    catch (const rti1516ev::InvalidLogicalTime& e)
    {
      throw InvalidLogicalTime(to_string(e.what()));
    }
    catch (const rti1516ev::Exception& e)
    {
      throw std::runtime_error(to_string(e.what()));
    }
  }
}

void BusControllerCan::UpdateModifiedAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void BusControllerCan::UpdateModifiedAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
        mDirty = kNone;
      }
      catch (const rti1516ev::InvalidLogicalTime& e)
      {
        throw InvalidLogicalTime(to_string(e.what()));
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void BusControllerCan::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle())
    {
      mNetworkID.decode(attributeHandleValue.second);
      mLastUpdated |= kNetworkIDBit;
    }
    else if (attributeHandle == mObjectClass->GetDeviceIDAttributeHandle())
    {
      mDeviceID.decode(attributeHandleValue.second);
      mLastUpdated |= kDeviceIDBit;
    }
    else if (attributeHandle == mObjectClass->GetBaudRateAttributeHandle())
    {
      mBaudRate.decode(attributeHandleValue.second);
      mLastUpdated |= kBaudRateBit;
    }
    else if (attributeHandle == mObjectClass->GetDataBaudRateAttributeHandle())
    {
      mDataBaudRate.decode(attributeHandleValue.second);
      mLastUpdated |= kDataBaudRateBit;
    }
    else if (attributeHandle == mObjectClass->GetPreScalerAttributeHandle())
    {
      mPreScaler.decode(attributeHandleValue.second);
      mLastUpdated |= kPreScalerBit;
    }
    else if (attributeHandle == mObjectClass->GetOperationModeAttributeHandle())
    {
      mOperationMode.decode(attributeHandleValue.second);
      mLastUpdated |= kOperationModeBit;
    }
    else if (attributeHandle == mObjectClass->GetSync_SegAttributeHandle())
    {
      mSync_Seg.decode(attributeHandleValue.second);
      mLastUpdated |= kSync_SegBit;
    }
    else if (attributeHandle == mObjectClass->GetProp_SegAttributeHandle())
    {
      mProp_Seg.decode(attributeHandleValue.second);
      mLastUpdated |= kProp_SegBit;
    }
    else if (attributeHandle == mObjectClass->GetPhase_Seg1AttributeHandle())
    {
      mPhase_Seg1.decode(attributeHandleValue.second);
      mLastUpdated |= kPhase_Seg1Bit;
    }
    else if (attributeHandle == mObjectClass->GetPhase_Seg2AttributeHandle())
    {
      mPhase_Seg2.decode(attributeHandleValue.second);
      mLastUpdated |= kPhase_Seg2Bit;
    }
    else if (attributeHandle == mObjectClass->GetSamplingModeAttributeHandle())
    {
      mSamplingMode.decode(attributeHandleValue.second);
      mLastUpdated |= kSamplingModeBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(optional<int64_t>(), optional<OrderType>());
  mLastUpdated = kNone;
} // BusControllerCan::ReflectAttributeValues

void BusControllerCan::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle())
    {
      mNetworkID.decode(attributeHandleValue.second);
      mLastUpdated |= kNetworkIDBit;
    }
    else if (attributeHandle == mObjectClass->GetDeviceIDAttributeHandle())
    {
      mDeviceID.decode(attributeHandleValue.second);
      mLastUpdated |= kDeviceIDBit;
    }
    else if (attributeHandle == mObjectClass->GetBaudRateAttributeHandle())
    {
      mBaudRate.decode(attributeHandleValue.second);
      mLastUpdated |= kBaudRateBit;
    }
    else if (attributeHandle == mObjectClass->GetDataBaudRateAttributeHandle())
    {
      mDataBaudRate.decode(attributeHandleValue.second);
      mLastUpdated |= kDataBaudRateBit;
    }
    else if (attributeHandle == mObjectClass->GetPreScalerAttributeHandle())
    {
      mPreScaler.decode(attributeHandleValue.second);
      mLastUpdated |= kPreScalerBit;
    }
    else if (attributeHandle == mObjectClass->GetOperationModeAttributeHandle())
    {
      mOperationMode.decode(attributeHandleValue.second);
      mLastUpdated |= kOperationModeBit;
    }
    else if (attributeHandle == mObjectClass->GetSync_SegAttributeHandle())
    {
      mSync_Seg.decode(attributeHandleValue.second);
      mLastUpdated |= kSync_SegBit;
    }
    else if (attributeHandle == mObjectClass->GetProp_SegAttributeHandle())
    {
      mProp_Seg.decode(attributeHandleValue.second);
      mLastUpdated |= kProp_SegBit;
    }
    else if (attributeHandle == mObjectClass->GetPhase_Seg1AttributeHandle())
    {
      mPhase_Seg1.decode(attributeHandleValue.second);
      mLastUpdated |= kPhase_Seg1Bit;
    }
    else if (attributeHandle == mObjectClass->GetPhase_Seg2AttributeHandle())
    {
      mPhase_Seg2.decode(attributeHandleValue.second);
      mLastUpdated |= kPhase_Seg2Bit;
    }
    else if (attributeHandle == mObjectClass->GetSamplingModeAttributeHandle())
    {
      mSamplingMode.decode(attributeHandleValue.second);
      mLastUpdated |= kSamplingModeBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(static_cast<const rti1516ev::HLAinteger64Time&>(theTime).getTime(), orderType);
  mLastUpdated = kNone;
} // BusControllerCan::ReflectAttributeValues

// request attributes not being part of the last update
void BusControllerCan::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    if ((mLastUpdated & kNetworkIDBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetNetworkIDAttributeHandle());
    }
    if ((mLastUpdated & kDeviceIDBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetDeviceIDAttributeHandle());
    }
    if ((mLastUpdated & kBaudRateBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetBaudRateAttributeHandle());
    }
    if ((mLastUpdated & kDataBaudRateBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetDataBaudRateAttributeHandle());
    }
    if ((mLastUpdated & kPreScalerBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetPreScalerAttributeHandle());
    }
    if ((mLastUpdated & kOperationModeBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetOperationModeAttributeHandle());
    }
    if ((mLastUpdated & kSync_SegBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetSync_SegAttributeHandle());
    }
    if ((mLastUpdated & kProp_SegBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetProp_SegAttributeHandle());
    }
    if ((mLastUpdated & kPhase_Seg1Bit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetPhase_Seg1AttributeHandle());
    }
    if ((mLastUpdated & kPhase_Seg2Bit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetPhase_Seg2AttributeHandle());
    }
    if ((mLastUpdated & kSamplingModeBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetSamplingModeAttributeHandle());
    }
  } // scope of lock_guard
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// request all attributes, regardless of current state
void BusControllerCan::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetNetworkIDAttributeHandle());
  requestAttributes.insert(mObjectClass->GetDeviceIDAttributeHandle());
  requestAttributes.insert(mObjectClass->GetBaudRateAttributeHandle());
  requestAttributes.insert(mObjectClass->GetDataBaudRateAttributeHandle());
  requestAttributes.insert(mObjectClass->GetPreScalerAttributeHandle());
  requestAttributes.insert(mObjectClass->GetOperationModeAttributeHandle());
  requestAttributes.insert(mObjectClass->GetSync_SegAttributeHandle());
  requestAttributes.insert(mObjectClass->GetProp_SegAttributeHandle());
  requestAttributes.insert(mObjectClass->GetPhase_Seg1AttributeHandle());
  requestAttributes.insert(mObjectClass->GetPhase_Seg2AttributeHandle());
  requestAttributes.insert(mObjectClass->GetSamplingModeAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// provide requested attributes set since last sent update
void BusControllerCan::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    for (auto& attributeHandle : attributeHandles)
    {
      if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle() && (mValuesSet & kNetworkIDBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mNetworkID.encode()));
        mDirty &= ~kNetworkIDBit;
      }
      else if (attributeHandle == mObjectClass->GetDeviceIDAttributeHandle() && (mValuesSet & kDeviceIDBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mDeviceID.encode()));
        mDirty &= ~kDeviceIDBit;
      }
      else if (attributeHandle == mObjectClass->GetBaudRateAttributeHandle() && (mValuesSet & kBaudRateBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mBaudRate.encode()));
        mDirty &= ~kBaudRateBit;
      }
      else if (attributeHandle == mObjectClass->GetDataBaudRateAttributeHandle() && (mValuesSet & kDataBaudRateBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mDataBaudRate.encode()));
        mDirty &= ~kDataBaudRateBit;
      }
      else if (attributeHandle == mObjectClass->GetPreScalerAttributeHandle() && (mValuesSet & kPreScalerBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mPreScaler.encode()));
        mDirty &= ~kPreScalerBit;
      }
      else if (attributeHandle == mObjectClass->GetOperationModeAttributeHandle() && (mValuesSet & kOperationModeBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mOperationMode.encode()));
        mDirty &= ~kOperationModeBit;
      }
      else if (attributeHandle == mObjectClass->GetSync_SegAttributeHandle() && (mValuesSet & kSync_SegBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mSync_Seg.encode()));
        mDirty &= ~kSync_SegBit;
      }
      else if (attributeHandle == mObjectClass->GetProp_SegAttributeHandle() && (mValuesSet & kProp_SegBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mProp_Seg.encode()));
        mDirty &= ~kProp_SegBit;
      }
      else if (attributeHandle == mObjectClass->GetPhase_Seg1AttributeHandle() && (mValuesSet & kPhase_Seg1Bit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mPhase_Seg1.encode()));
        mDirty &= ~kPhase_Seg1Bit;
      }
      else if (attributeHandle == mObjectClass->GetPhase_Seg2AttributeHandle() && (mValuesSet & kPhase_Seg2Bit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mPhase_Seg2.encode()));
        mDirty &= ~kPhase_Seg2Bit;
      }
      else if (attributeHandle == mObjectClass->GetSamplingModeAttributeHandle() && (mValuesSet & kSamplingModeBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mSamplingMode.encode()));
        mDirty &= ~kSamplingModeBit;
      }
    } // for (auto& attributeHandleValue : attributes)
  } // scope of lock_guard
  if (time)
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(*time));
  else
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // BusControllerCan::ReflectAttributeValues

uint32_t BusControllerCan::RegisterUpdateCallback(UpdateCallback callback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void BusControllerCan::UnregisterUpdateCallback(uint32_t callbackToken)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mUpdateCallbacks.erase(callbackToken);
}

void BusControllerCan::ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(std::static_pointer_cast<IBusControllerCan>(shared_from_this()), time, orderType);
  }
}


// object class type 'BusControllerEthernet'
BusControllerEthernetObjectClass::BusControllerEthernetObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, BusControllerObjectClass* baseClass)
{
  mRegistry = registry;
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.BusController.BusControllerEthernet");
  // attribute PortName : HLAASCIIstring
  mPortNameAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"PortName");
  SetObjectInstanceCreator([](BusControllerEthernetObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador) -> BusControllerEthernet* {
    return new BusControllerEthernet(objectClass, instanceName, rtiAmbassador);
  });
}

BusControllerEthernetObjectClass::~BusControllerEthernetObjectClass()
{
  //std::lock_guard<std::recursive_mutex> lock(mMutex);
  while (!mObjectInstancesByHandle.empty())
  {
    // careful - hold the reference to the object instance until it has been removed from the maps,
    // otherwise it's mutex will be destroyed while held
    auto objectInstance = mObjectInstancesByHandle.begin()->second;
    objectInstance->Release();
  }
  assert(mObjectInstancesByHandle.empty());
  assert(mObjectInstancesByName.empty());
}

void BusControllerEthernetObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void BusControllerEthernetObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void BusControllerEthernetObjectClass::Subscribe(bool deliverToSelf)
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    if (deliverToSelf) mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void BusControllerEthernetObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

rti1516ev::AttributeHandleSet BusControllerEthernetObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetNetworkIDAttributeHandle());
  result.insert(GetDeviceIDAttributeHandle());
  result.insert(GetPortNameAttributeHandle());
  return result;
}

void BusControllerEthernetObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  assert(mObjectInstancesByName.find(objectInstanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(objectInstanceHandle) == mObjectInstancesByHandle.end());
  std::shared_ptr<BusControllerEthernet> newObject = std::shared_ptr<BusControllerEthernet>(mCreatorFunction(this, objectInstanceName, mRtiAmbassador));
  newObject->mObjectInstanceHandle = objectInstanceHandle;
  newObject->mIsOwner = false;
  InsertObjectInstanceName(newObject, objectInstanceName);
  InsertObjectInstanceHandle(newObject, objectInstanceHandle);
  ExecuteDiscoverObjectInstanceCallbacks(newObject);
}

void BusControllerEthernetObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring objectInstanceName = mRtiAmbassador->getObjectInstanceName(objectInstanceHandle);
  auto iter = mObjectInstancesByName.find(objectInstanceName);
  assert(iter != mObjectInstancesByName.end());
  auto objectInstance = std::dynamic_pointer_cast<BusControllerEthernet>(iter->second);
  ExecuteRemoveObjectInstanceCallbacks(objectInstance);
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  EraseObjectInstance(objectInstanceHandle, objectInstanceName);
}

std::shared_ptr<IBusControllerEthernet> BusControllerEthernetObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IBusController> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceName);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IBusControllerEthernet>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IBusControllerEthernet> BusControllerEthernetObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IBusController> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceHandle);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IBusControllerEthernet>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IBusControllerEthernet> BusControllerEthernetObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"BusControllerEthernet");
  }
  std::shared_ptr<BusControllerEthernet> newObject = std::shared_ptr<BusControllerEthernet>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
    }
  });
  return newObject;
}

std::shared_ptr<IBusControllerEthernet> BusControllerEthernetObjectClass::CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"BusControllerEthernet");
  }
  std::shared_ptr<BusControllerEthernet> newObject = std::shared_ptr<BusControllerEthernet>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
      createdCallback(newObject, true);
    }
    else
    {
      createdCallback(newObject, false);
    }
  });
  return newObject;
}

uint32_t BusControllerEthernetObjectClass::RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastDiscoverObjectInstanceCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastDiscoverObjectInstanceCallbackToken, callback));
  return mLastDiscoverObjectInstanceCallbackToken;
}

void BusControllerEthernetObjectClass::UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mDiscoverCallbacks.erase(callbackToken);
}

void BusControllerEthernetObjectClass::ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IBusControllerEthernet> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

uint32_t BusControllerEthernetObjectClass::RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastRemoveObjectInstanceCallbackToken++;
  mRemoveObjectInstanceCallbacks.insert(std::make_pair(mLastRemoveObjectInstanceCallbackToken, callback));
  return mLastRemoveObjectInstanceCallbackToken;
}

void BusControllerEthernetObjectClass::UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mRemoveObjectInstanceCallbacks.erase(callbackToken);
}

void BusControllerEthernetObjectClass::ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IBusControllerEthernet> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mRemoveObjectInstanceCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

void BusControllerEthernetObjectClass::InsertObjectInstanceName(std::shared_ptr<IBusControllerEthernet> objectInstance, const std::wstring& objectInstanceName)
{
  // prerequisite: mMutex must be locked
  mObjectInstancesByName.insert(std::make_pair(objectInstanceName, objectInstance));
  mBaseClass->InsertObjectInstanceName(objectInstance, objectInstanceName);
}

void BusControllerEthernetObjectClass::InsertObjectInstanceHandle(std::shared_ptr<IBusControllerEthernet> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByHandle.insert(std::make_pair(objectInstanceHandle, objectInstance));
  mBaseClass->InsertObjectInstanceHandle(objectInstance, objectInstanceHandle);
}

void BusControllerEthernetObjectClass::EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mBaseClass->EraseObjectInstance(objectInstanceHandle, objectInstanceName);
  mObjectInstancesByName.erase(objectInstanceName);
  mObjectInstancesByHandle.erase(objectInstanceHandle);
}


// object instances of type 'BusControllerEthernet'
BusControllerEthernet::BusControllerEthernet()
  : mRtiAmbassador()
  , mObjectClass()
  , mObjectInstanceName()
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

BusControllerEthernet::BusControllerEthernet(BusControllerEthernetObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mRtiAmbassador(rtiAmbassador)
  , mObjectClass(objectClass)
  , mObjectInstanceName(instanceName)
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

BusControllerEthernet::~BusControllerEthernet()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    try
    {
      mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    }
    catch (const rti1516ev::Exception&)
    {
    }
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

bool BusControllerEthernet::IsValid() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mObjectInstanceHandle.isValid();
}

bool BusControllerEthernet::IsOwner() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mIsOwner;
}

void BusControllerEthernet::Release()
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (mObjectInstanceHandle.isValid())
  {
    if (mIsOwner)
    {
      try
      {
        mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
      }
      catch (const rti1516ev::Exception&)
      {
        // ignore - must execute rest of function
      }
      mIsOwner = false;
    }
    mObjectClass->EraseObjectInstance(mObjectInstanceHandle, mObjectInstanceName);
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  }
}

// attribute BusControllerEthernet.HLAprivilegeToDeleteObject : no data type

// attribute NetworkID : HLAASCIIstring
std::string BusControllerEthernet::GetNetworkID() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mNetworkID.get();
}

void BusControllerEthernet::SetNetworkID(std::string newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mNetworkID.set(newValue);
  mDirty |= kNetworkIDBit;
  mValuesSet |= kNetworkIDBit;
}

// attribute DeviceID : HLAASCIIstring
std::string BusControllerEthernet::GetDeviceID() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDeviceID.get();
}

void BusControllerEthernet::SetDeviceID(std::string newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mDeviceID.set(newValue);
  mDirty |= kDeviceIDBit;
  mValuesSet |= kDeviceIDBit;
}

// attribute PortName : HLAASCIIstring
std::string BusControllerEthernet::GetPortName() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mPortName.get();
}

void BusControllerEthernet::SetPortName(std::string newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mPortName.set(newValue);
  mDirty |= kPortNameBit;
  mValuesSet |= kPortNameBit;
}

rti1516ev::AttributeHandleValueMap BusControllerEthernet::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  result[mObjectClass->GetDeviceIDAttributeHandle()] = mDeviceID.encode();
  result[mObjectClass->GetPortNameAttributeHandle()] = mPortName.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap BusControllerEthernet::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kNetworkIDBit)
  {
    result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  }
  if (mDirty & kDeviceIDBit)
  {
    result[mObjectClass->GetDeviceIDAttributeHandle()] = mDeviceID.encode();
  }
  if (mDirty & kPortNameBit)
  {
    result[mObjectClass->GetPortNameAttributeHandle()] = mPortName.encode();
  }
  return result;
}

BusControllerEthernet::AttributeBits BusControllerEthernet::GetReceivedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesReceived;
}

BusControllerEthernet::AttributeBits BusControllerEthernet::GetUpdatedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mLastUpdated;
}

BusControllerEthernet::AttributeBits BusControllerEthernet::GetInitializedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesSet;
}

BusControllerEthernet::AttributeBits BusControllerEthernet::GetModifiedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDirty;
}

void BusControllerEthernet::UpdateAllAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void BusControllerEthernet::UpdateAllAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    try {
      mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
      mDirty = kNone;
    }
    catch (const rti1516ev::InvalidLogicalTime& e)
    {
      throw InvalidLogicalTime(to_string(e.what()));
    }
    catch (const rti1516ev::Exception& e)
    {
      throw std::runtime_error(to_string(e.what()));
    }
  }
}

void BusControllerEthernet::UpdateModifiedAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void BusControllerEthernet::UpdateModifiedAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
        mDirty = kNone;
      }
      catch (const rti1516ev::InvalidLogicalTime& e)
      {
        throw InvalidLogicalTime(to_string(e.what()));
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void BusControllerEthernet::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle())
    {
      mNetworkID.decode(attributeHandleValue.second);
      mLastUpdated |= kNetworkIDBit;
    }
    else if (attributeHandle == mObjectClass->GetDeviceIDAttributeHandle())
    {
      mDeviceID.decode(attributeHandleValue.second);
      mLastUpdated |= kDeviceIDBit;
    }
    else if (attributeHandle == mObjectClass->GetPortNameAttributeHandle())
    {
      mPortName.decode(attributeHandleValue.second);
      mLastUpdated |= kPortNameBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(optional<int64_t>(), optional<OrderType>());
  mLastUpdated = kNone;
} // BusControllerEthernet::ReflectAttributeValues

void BusControllerEthernet::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle())
    {
      mNetworkID.decode(attributeHandleValue.second);
      mLastUpdated |= kNetworkIDBit;
    }
    else if (attributeHandle == mObjectClass->GetDeviceIDAttributeHandle())
    {
      mDeviceID.decode(attributeHandleValue.second);
      mLastUpdated |= kDeviceIDBit;
    }
    else if (attributeHandle == mObjectClass->GetPortNameAttributeHandle())
    {
      mPortName.decode(attributeHandleValue.second);
      mLastUpdated |= kPortNameBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(static_cast<const rti1516ev::HLAinteger64Time&>(theTime).getTime(), orderType);
  mLastUpdated = kNone;
} // BusControllerEthernet::ReflectAttributeValues

// request attributes not being part of the last update
void BusControllerEthernet::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    if ((mLastUpdated & kNetworkIDBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetNetworkIDAttributeHandle());
    }
    if ((mLastUpdated & kDeviceIDBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetDeviceIDAttributeHandle());
    }
    if ((mLastUpdated & kPortNameBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetPortNameAttributeHandle());
    }
  } // scope of lock_guard
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// request all attributes, regardless of current state
void BusControllerEthernet::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetNetworkIDAttributeHandle());
  requestAttributes.insert(mObjectClass->GetDeviceIDAttributeHandle());
  requestAttributes.insert(mObjectClass->GetPortNameAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// provide requested attributes set since last sent update
void BusControllerEthernet::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    for (auto& attributeHandle : attributeHandles)
    {
      if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle() && (mValuesSet & kNetworkIDBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mNetworkID.encode()));
        mDirty &= ~kNetworkIDBit;
      }
      else if (attributeHandle == mObjectClass->GetDeviceIDAttributeHandle() && (mValuesSet & kDeviceIDBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mDeviceID.encode()));
        mDirty &= ~kDeviceIDBit;
      }
      else if (attributeHandle == mObjectClass->GetPortNameAttributeHandle() && (mValuesSet & kPortNameBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mPortName.encode()));
        mDirty &= ~kPortNameBit;
      }
    } // for (auto& attributeHandleValue : attributes)
  } // scope of lock_guard
  if (time)
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(*time));
  else
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // BusControllerEthernet::ReflectAttributeValues

uint32_t BusControllerEthernet::RegisterUpdateCallback(UpdateCallback callback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void BusControllerEthernet::UnregisterUpdateCallback(uint32_t callbackToken)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mUpdateCallbacks.erase(callbackToken);
}

void BusControllerEthernet::ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(std::static_pointer_cast<IBusControllerEthernet>(shared_from_this()), time, orderType);
  }
}


// object class type 'FlexRayControllerStatus'
FlexRayControllerStatusObjectClass::FlexRayControllerStatusObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, BusControllerObjectClass* baseClass)
{
  mRegistry = registry;
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.BusController.FlexRayControllerStatus");
  // attribute PocState : FlexRayPocState
  mPocStateAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"PocState");
  // attribute chiHaltRequest : HLAboolean
  mchiHaltRequestAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"chiHaltRequest");
  // attribute coldstartNoise : HLAboolean
  mcoldstartNoiseAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"coldstartNoise");
  // attribute freeze : HLAboolean
  mfreezeAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"freeze");
  // attribute chiReadyRequest : HLAboolean
  mchiReadyRequestAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"chiReadyRequest");
  // attribute errorMode : FlexRayErrorModeType
  merrorModeAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"errorMode");
  // attribute slotMode : FlexRaySlotModeType
  mslotModeAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"slotMode");
  // attribute startupState : FlexRayStartupStateType
  mstartupStateAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"startupState");
  // attribute wakeupStatus : FlexRayWakeupStatusType
  mwakeupStatusAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"wakeupStatus");
  SetObjectInstanceCreator([](FlexRayControllerStatusObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador) -> FlexRayControllerStatus* {
    return new FlexRayControllerStatus(objectClass, instanceName, rtiAmbassador);
  });
}

FlexRayControllerStatusObjectClass::~FlexRayControllerStatusObjectClass()
{
  //std::lock_guard<std::recursive_mutex> lock(mMutex);
  while (!mObjectInstancesByHandle.empty())
  {
    // careful - hold the reference to the object instance until it has been removed from the maps,
    // otherwise it's mutex will be destroyed while held
    auto objectInstance = mObjectInstancesByHandle.begin()->second;
    objectInstance->Release();
  }
  assert(mObjectInstancesByHandle.empty());
  assert(mObjectInstancesByName.empty());
}

void FlexRayControllerStatusObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void FlexRayControllerStatusObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void FlexRayControllerStatusObjectClass::Subscribe(bool deliverToSelf)
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    if (deliverToSelf) mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void FlexRayControllerStatusObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

rti1516ev::AttributeHandleSet FlexRayControllerStatusObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetNetworkIDAttributeHandle());
  result.insert(GetDeviceIDAttributeHandle());
  result.insert(GetPocStateAttributeHandle());
  result.insert(GetchiHaltRequestAttributeHandle());
  result.insert(GetcoldstartNoiseAttributeHandle());
  result.insert(GetfreezeAttributeHandle());
  result.insert(GetchiReadyRequestAttributeHandle());
  result.insert(GeterrorModeAttributeHandle());
  result.insert(GetslotModeAttributeHandle());
  result.insert(GetstartupStateAttributeHandle());
  result.insert(GetwakeupStatusAttributeHandle());
  return result;
}

void FlexRayControllerStatusObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  assert(mObjectInstancesByName.find(objectInstanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(objectInstanceHandle) == mObjectInstancesByHandle.end());
  std::shared_ptr<FlexRayControllerStatus> newObject = std::shared_ptr<FlexRayControllerStatus>(mCreatorFunction(this, objectInstanceName, mRtiAmbassador));
  newObject->mObjectInstanceHandle = objectInstanceHandle;
  newObject->mIsOwner = false;
  InsertObjectInstanceName(newObject, objectInstanceName);
  InsertObjectInstanceHandle(newObject, objectInstanceHandle);
  ExecuteDiscoverObjectInstanceCallbacks(newObject);
}

void FlexRayControllerStatusObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring objectInstanceName = mRtiAmbassador->getObjectInstanceName(objectInstanceHandle);
  auto iter = mObjectInstancesByName.find(objectInstanceName);
  assert(iter != mObjectInstancesByName.end());
  auto objectInstance = std::dynamic_pointer_cast<FlexRayControllerStatus>(iter->second);
  ExecuteRemoveObjectInstanceCallbacks(objectInstance);
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  EraseObjectInstance(objectInstanceHandle, objectInstanceName);
}

std::shared_ptr<IFlexRayControllerStatus> FlexRayControllerStatusObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IBusController> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceName);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IFlexRayControllerStatus>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IFlexRayControllerStatus> FlexRayControllerStatusObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IBusController> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceHandle);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IFlexRayControllerStatus>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IFlexRayControllerStatus> FlexRayControllerStatusObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"FlexRayControllerStatus");
  }
  std::shared_ptr<FlexRayControllerStatus> newObject = std::shared_ptr<FlexRayControllerStatus>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
    }
  });
  return newObject;
}

std::shared_ptr<IFlexRayControllerStatus> FlexRayControllerStatusObjectClass::CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"FlexRayControllerStatus");
  }
  std::shared_ptr<FlexRayControllerStatus> newObject = std::shared_ptr<FlexRayControllerStatus>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
      createdCallback(newObject, true);
    }
    else
    {
      createdCallback(newObject, false);
    }
  });
  return newObject;
}

uint32_t FlexRayControllerStatusObjectClass::RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastDiscoverObjectInstanceCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastDiscoverObjectInstanceCallbackToken, callback));
  return mLastDiscoverObjectInstanceCallbackToken;
}

void FlexRayControllerStatusObjectClass::UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mDiscoverCallbacks.erase(callbackToken);
}

void FlexRayControllerStatusObjectClass::ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IFlexRayControllerStatus> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

uint32_t FlexRayControllerStatusObjectClass::RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastRemoveObjectInstanceCallbackToken++;
  mRemoveObjectInstanceCallbacks.insert(std::make_pair(mLastRemoveObjectInstanceCallbackToken, callback));
  return mLastRemoveObjectInstanceCallbackToken;
}

void FlexRayControllerStatusObjectClass::UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mRemoveObjectInstanceCallbacks.erase(callbackToken);
}

void FlexRayControllerStatusObjectClass::ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IFlexRayControllerStatus> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mRemoveObjectInstanceCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

void FlexRayControllerStatusObjectClass::InsertObjectInstanceName(std::shared_ptr<IFlexRayControllerStatus> objectInstance, const std::wstring& objectInstanceName)
{
  // prerequisite: mMutex must be locked
  mObjectInstancesByName.insert(std::make_pair(objectInstanceName, objectInstance));
  mBaseClass->InsertObjectInstanceName(objectInstance, objectInstanceName);
}

void FlexRayControllerStatusObjectClass::InsertObjectInstanceHandle(std::shared_ptr<IFlexRayControllerStatus> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByHandle.insert(std::make_pair(objectInstanceHandle, objectInstance));
  mBaseClass->InsertObjectInstanceHandle(objectInstance, objectInstanceHandle);
}

void FlexRayControllerStatusObjectClass::EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mBaseClass->EraseObjectInstance(objectInstanceHandle, objectInstanceName);
  mObjectInstancesByName.erase(objectInstanceName);
  mObjectInstancesByHandle.erase(objectInstanceHandle);
}


// object instances of type 'FlexRayControllerStatus'
FlexRayControllerStatus::FlexRayControllerStatus()
  : mRtiAmbassador()
  , mObjectClass()
  , mObjectInstanceName()
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

FlexRayControllerStatus::FlexRayControllerStatus(FlexRayControllerStatusObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mRtiAmbassador(rtiAmbassador)
  , mObjectClass(objectClass)
  , mObjectInstanceName(instanceName)
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

FlexRayControllerStatus::~FlexRayControllerStatus()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    try
    {
      mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    }
    catch (const rti1516ev::Exception&)
    {
    }
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

bool FlexRayControllerStatus::IsValid() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mObjectInstanceHandle.isValid();
}

bool FlexRayControllerStatus::IsOwner() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mIsOwner;
}

void FlexRayControllerStatus::Release()
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (mObjectInstanceHandle.isValid())
  {
    if (mIsOwner)
    {
      try
      {
        mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
      }
      catch (const rti1516ev::Exception&)
      {
        // ignore - must execute rest of function
      }
      mIsOwner = false;
    }
    mObjectClass->EraseObjectInstance(mObjectInstanceHandle, mObjectInstanceName);
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  }
}

// attribute FlexRayControllerStatus.HLAprivilegeToDeleteObject : no data type

// attribute NetworkID : HLAASCIIstring
std::string FlexRayControllerStatus::GetNetworkID() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mNetworkID.get();
}

void FlexRayControllerStatus::SetNetworkID(std::string newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mNetworkID.set(newValue);
  mDirty |= kNetworkIDBit;
  mValuesSet |= kNetworkIDBit;
}

// attribute DeviceID : HLAASCIIstring
std::string FlexRayControllerStatus::GetDeviceID() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDeviceID.get();
}

void FlexRayControllerStatus::SetDeviceID(std::string newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mDeviceID.set(newValue);
  mDirty |= kDeviceIDBit;
  mValuesSet |= kDeviceIDBit;
}

// attribute PocState : FlexRayPocState
FlexRayPocState FlexRayControllerStatus::GetPocState() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return static_cast<FlexRayPocState>(mPocState.get());
}

void FlexRayControllerStatus::SetPocState(FlexRayPocState newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mPocState.set(static_cast<uint8_t>(newValue));
  mDirty |= kPocStateBit;
  mValuesSet |= kPocStateBit;
}

// attribute chiHaltRequest : HLAboolean
bool FlexRayControllerStatus::GetchiHaltRequest() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mchiHaltRequest.get();
}

void FlexRayControllerStatus::SetchiHaltRequest(bool newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mchiHaltRequest.set(newValue);
  mDirty |= kchiHaltRequestBit;
  mValuesSet |= kchiHaltRequestBit;
}

// attribute coldstartNoise : HLAboolean
bool FlexRayControllerStatus::GetcoldstartNoise() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mcoldstartNoise.get();
}

void FlexRayControllerStatus::SetcoldstartNoise(bool newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mcoldstartNoise.set(newValue);
  mDirty |= kcoldstartNoiseBit;
  mValuesSet |= kcoldstartNoiseBit;
}

// attribute freeze : HLAboolean
bool FlexRayControllerStatus::Getfreeze() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mfreeze.get();
}

void FlexRayControllerStatus::Setfreeze(bool newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mfreeze.set(newValue);
  mDirty |= kfreezeBit;
  mValuesSet |= kfreezeBit;
}

// attribute chiReadyRequest : HLAboolean
bool FlexRayControllerStatus::GetchiReadyRequest() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mchiReadyRequest.get();
}

void FlexRayControllerStatus::SetchiReadyRequest(bool newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mchiReadyRequest.set(newValue);
  mDirty |= kchiReadyRequestBit;
  mValuesSet |= kchiReadyRequestBit;
}

// attribute errorMode : FlexRayErrorModeType
FlexRayErrorModeType FlexRayControllerStatus::GeterrorMode() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return static_cast<FlexRayErrorModeType>(merrorMode.get());
}

void FlexRayControllerStatus::SeterrorMode(FlexRayErrorModeType newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  merrorMode.set(static_cast<uint8_t>(newValue));
  mDirty |= kerrorModeBit;
  mValuesSet |= kerrorModeBit;
}

// attribute slotMode : FlexRaySlotModeType
FlexRaySlotModeType FlexRayControllerStatus::GetslotMode() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return static_cast<FlexRaySlotModeType>(mslotMode.get());
}

void FlexRayControllerStatus::SetslotMode(FlexRaySlotModeType newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mslotMode.set(static_cast<uint8_t>(newValue));
  mDirty |= kslotModeBit;
  mValuesSet |= kslotModeBit;
}

// attribute startupState : FlexRayStartupStateType
FlexRayStartupStateType FlexRayControllerStatus::GetstartupState() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return static_cast<FlexRayStartupStateType>(mstartupState.get());
}

void FlexRayControllerStatus::SetstartupState(FlexRayStartupStateType newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mstartupState.set(static_cast<uint8_t>(newValue));
  mDirty |= kstartupStateBit;
  mValuesSet |= kstartupStateBit;
}

// attribute wakeupStatus : FlexRayWakeupStatusType
FlexRayWakeupStatusType FlexRayControllerStatus::GetwakeupStatus() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return static_cast<FlexRayWakeupStatusType>(mwakeupStatus.get());
}

void FlexRayControllerStatus::SetwakeupStatus(FlexRayWakeupStatusType newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mwakeupStatus.set(static_cast<uint8_t>(newValue));
  mDirty |= kwakeupStatusBit;
  mValuesSet |= kwakeupStatusBit;
}

rti1516ev::AttributeHandleValueMap FlexRayControllerStatus::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  result[mObjectClass->GetDeviceIDAttributeHandle()] = mDeviceID.encode();
  result[mObjectClass->GetPocStateAttributeHandle()] = mPocState.encode();
  result[mObjectClass->GetchiHaltRequestAttributeHandle()] = mchiHaltRequest.encode();
  result[mObjectClass->GetcoldstartNoiseAttributeHandle()] = mcoldstartNoise.encode();
  result[mObjectClass->GetfreezeAttributeHandle()] = mfreeze.encode();
  result[mObjectClass->GetchiReadyRequestAttributeHandle()] = mchiReadyRequest.encode();
  result[mObjectClass->GeterrorModeAttributeHandle()] = merrorMode.encode();
  result[mObjectClass->GetslotModeAttributeHandle()] = mslotMode.encode();
  result[mObjectClass->GetstartupStateAttributeHandle()] = mstartupState.encode();
  result[mObjectClass->GetwakeupStatusAttributeHandle()] = mwakeupStatus.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap FlexRayControllerStatus::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kNetworkIDBit)
  {
    result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  }
  if (mDirty & kDeviceIDBit)
  {
    result[mObjectClass->GetDeviceIDAttributeHandle()] = mDeviceID.encode();
  }
  if (mDirty & kPocStateBit)
  {
    result[mObjectClass->GetPocStateAttributeHandle()] = mPocState.encode();
  }
  if (mDirty & kchiHaltRequestBit)
  {
    result[mObjectClass->GetchiHaltRequestAttributeHandle()] = mchiHaltRequest.encode();
  }
  if (mDirty & kcoldstartNoiseBit)
  {
    result[mObjectClass->GetcoldstartNoiseAttributeHandle()] = mcoldstartNoise.encode();
  }
  if (mDirty & kfreezeBit)
  {
    result[mObjectClass->GetfreezeAttributeHandle()] = mfreeze.encode();
  }
  if (mDirty & kchiReadyRequestBit)
  {
    result[mObjectClass->GetchiReadyRequestAttributeHandle()] = mchiReadyRequest.encode();
  }
  if (mDirty & kerrorModeBit)
  {
    result[mObjectClass->GeterrorModeAttributeHandle()] = merrorMode.encode();
  }
  if (mDirty & kslotModeBit)
  {
    result[mObjectClass->GetslotModeAttributeHandle()] = mslotMode.encode();
  }
  if (mDirty & kstartupStateBit)
  {
    result[mObjectClass->GetstartupStateAttributeHandle()] = mstartupState.encode();
  }
  if (mDirty & kwakeupStatusBit)
  {
    result[mObjectClass->GetwakeupStatusAttributeHandle()] = mwakeupStatus.encode();
  }
  return result;
}

FlexRayControllerStatus::AttributeBits FlexRayControllerStatus::GetReceivedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesReceived;
}

FlexRayControllerStatus::AttributeBits FlexRayControllerStatus::GetUpdatedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mLastUpdated;
}

FlexRayControllerStatus::AttributeBits FlexRayControllerStatus::GetInitializedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesSet;
}

FlexRayControllerStatus::AttributeBits FlexRayControllerStatus::GetModifiedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDirty;
}

void FlexRayControllerStatus::UpdateAllAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void FlexRayControllerStatus::UpdateAllAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    try {
      mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
      mDirty = kNone;
    }
    catch (const rti1516ev::InvalidLogicalTime& e)
    {
      throw InvalidLogicalTime(to_string(e.what()));
    }
    catch (const rti1516ev::Exception& e)
    {
      throw std::runtime_error(to_string(e.what()));
    }
  }
}

void FlexRayControllerStatus::UpdateModifiedAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void FlexRayControllerStatus::UpdateModifiedAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
        mDirty = kNone;
      }
      catch (const rti1516ev::InvalidLogicalTime& e)
      {
        throw InvalidLogicalTime(to_string(e.what()));
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void FlexRayControllerStatus::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle())
    {
      mNetworkID.decode(attributeHandleValue.second);
      mLastUpdated |= kNetworkIDBit;
    }
    else if (attributeHandle == mObjectClass->GetDeviceIDAttributeHandle())
    {
      mDeviceID.decode(attributeHandleValue.second);
      mLastUpdated |= kDeviceIDBit;
    }
    else if (attributeHandle == mObjectClass->GetPocStateAttributeHandle())
    {
      mPocState.decode(attributeHandleValue.second);
      mLastUpdated |= kPocStateBit;
    }
    else if (attributeHandle == mObjectClass->GetchiHaltRequestAttributeHandle())
    {
      mchiHaltRequest.decode(attributeHandleValue.second);
      mLastUpdated |= kchiHaltRequestBit;
    }
    else if (attributeHandle == mObjectClass->GetcoldstartNoiseAttributeHandle())
    {
      mcoldstartNoise.decode(attributeHandleValue.second);
      mLastUpdated |= kcoldstartNoiseBit;
    }
    else if (attributeHandle == mObjectClass->GetfreezeAttributeHandle())
    {
      mfreeze.decode(attributeHandleValue.second);
      mLastUpdated |= kfreezeBit;
    }
    else if (attributeHandle == mObjectClass->GetchiReadyRequestAttributeHandle())
    {
      mchiReadyRequest.decode(attributeHandleValue.second);
      mLastUpdated |= kchiReadyRequestBit;
    }
    else if (attributeHandle == mObjectClass->GeterrorModeAttributeHandle())
    {
      merrorMode.decode(attributeHandleValue.second);
      mLastUpdated |= kerrorModeBit;
    }
    else if (attributeHandle == mObjectClass->GetslotModeAttributeHandle())
    {
      mslotMode.decode(attributeHandleValue.second);
      mLastUpdated |= kslotModeBit;
    }
    else if (attributeHandle == mObjectClass->GetstartupStateAttributeHandle())
    {
      mstartupState.decode(attributeHandleValue.second);
      mLastUpdated |= kstartupStateBit;
    }
    else if (attributeHandle == mObjectClass->GetwakeupStatusAttributeHandle())
    {
      mwakeupStatus.decode(attributeHandleValue.second);
      mLastUpdated |= kwakeupStatusBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(optional<int64_t>(), optional<OrderType>());
  mLastUpdated = kNone;
} // FlexRayControllerStatus::ReflectAttributeValues

void FlexRayControllerStatus::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle())
    {
      mNetworkID.decode(attributeHandleValue.second);
      mLastUpdated |= kNetworkIDBit;
    }
    else if (attributeHandle == mObjectClass->GetDeviceIDAttributeHandle())
    {
      mDeviceID.decode(attributeHandleValue.second);
      mLastUpdated |= kDeviceIDBit;
    }
    else if (attributeHandle == mObjectClass->GetPocStateAttributeHandle())
    {
      mPocState.decode(attributeHandleValue.second);
      mLastUpdated |= kPocStateBit;
    }
    else if (attributeHandle == mObjectClass->GetchiHaltRequestAttributeHandle())
    {
      mchiHaltRequest.decode(attributeHandleValue.second);
      mLastUpdated |= kchiHaltRequestBit;
    }
    else if (attributeHandle == mObjectClass->GetcoldstartNoiseAttributeHandle())
    {
      mcoldstartNoise.decode(attributeHandleValue.second);
      mLastUpdated |= kcoldstartNoiseBit;
    }
    else if (attributeHandle == mObjectClass->GetfreezeAttributeHandle())
    {
      mfreeze.decode(attributeHandleValue.second);
      mLastUpdated |= kfreezeBit;
    }
    else if (attributeHandle == mObjectClass->GetchiReadyRequestAttributeHandle())
    {
      mchiReadyRequest.decode(attributeHandleValue.second);
      mLastUpdated |= kchiReadyRequestBit;
    }
    else if (attributeHandle == mObjectClass->GeterrorModeAttributeHandle())
    {
      merrorMode.decode(attributeHandleValue.second);
      mLastUpdated |= kerrorModeBit;
    }
    else if (attributeHandle == mObjectClass->GetslotModeAttributeHandle())
    {
      mslotMode.decode(attributeHandleValue.second);
      mLastUpdated |= kslotModeBit;
    }
    else if (attributeHandle == mObjectClass->GetstartupStateAttributeHandle())
    {
      mstartupState.decode(attributeHandleValue.second);
      mLastUpdated |= kstartupStateBit;
    }
    else if (attributeHandle == mObjectClass->GetwakeupStatusAttributeHandle())
    {
      mwakeupStatus.decode(attributeHandleValue.second);
      mLastUpdated |= kwakeupStatusBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(static_cast<const rti1516ev::HLAinteger64Time&>(theTime).getTime(), orderType);
  mLastUpdated = kNone;
} // FlexRayControllerStatus::ReflectAttributeValues

// request attributes not being part of the last update
void FlexRayControllerStatus::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    if ((mLastUpdated & kNetworkIDBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetNetworkIDAttributeHandle());
    }
    if ((mLastUpdated & kDeviceIDBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetDeviceIDAttributeHandle());
    }
    if ((mLastUpdated & kPocStateBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetPocStateAttributeHandle());
    }
    if ((mLastUpdated & kchiHaltRequestBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetchiHaltRequestAttributeHandle());
    }
    if ((mLastUpdated & kcoldstartNoiseBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetcoldstartNoiseAttributeHandle());
    }
    if ((mLastUpdated & kfreezeBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetfreezeAttributeHandle());
    }
    if ((mLastUpdated & kchiReadyRequestBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetchiReadyRequestAttributeHandle());
    }
    if ((mLastUpdated & kerrorModeBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GeterrorModeAttributeHandle());
    }
    if ((mLastUpdated & kslotModeBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetslotModeAttributeHandle());
    }
    if ((mLastUpdated & kstartupStateBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetstartupStateAttributeHandle());
    }
    if ((mLastUpdated & kwakeupStatusBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetwakeupStatusAttributeHandle());
    }
  } // scope of lock_guard
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// request all attributes, regardless of current state
void FlexRayControllerStatus::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetNetworkIDAttributeHandle());
  requestAttributes.insert(mObjectClass->GetDeviceIDAttributeHandle());
  requestAttributes.insert(mObjectClass->GetPocStateAttributeHandle());
  requestAttributes.insert(mObjectClass->GetchiHaltRequestAttributeHandle());
  requestAttributes.insert(mObjectClass->GetcoldstartNoiseAttributeHandle());
  requestAttributes.insert(mObjectClass->GetfreezeAttributeHandle());
  requestAttributes.insert(mObjectClass->GetchiReadyRequestAttributeHandle());
  requestAttributes.insert(mObjectClass->GeterrorModeAttributeHandle());
  requestAttributes.insert(mObjectClass->GetslotModeAttributeHandle());
  requestAttributes.insert(mObjectClass->GetstartupStateAttributeHandle());
  requestAttributes.insert(mObjectClass->GetwakeupStatusAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// provide requested attributes set since last sent update
void FlexRayControllerStatus::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    for (auto& attributeHandle : attributeHandles)
    {
      if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle() && (mValuesSet & kNetworkIDBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mNetworkID.encode()));
        mDirty &= ~kNetworkIDBit;
      }
      else if (attributeHandle == mObjectClass->GetDeviceIDAttributeHandle() && (mValuesSet & kDeviceIDBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mDeviceID.encode()));
        mDirty &= ~kDeviceIDBit;
      }
      else if (attributeHandle == mObjectClass->GetPocStateAttributeHandle() && (mValuesSet & kPocStateBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mPocState.encode()));
        mDirty &= ~kPocStateBit;
      }
      else if (attributeHandle == mObjectClass->GetchiHaltRequestAttributeHandle() && (mValuesSet & kchiHaltRequestBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mchiHaltRequest.encode()));
        mDirty &= ~kchiHaltRequestBit;
      }
      else if (attributeHandle == mObjectClass->GetcoldstartNoiseAttributeHandle() && (mValuesSet & kcoldstartNoiseBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mcoldstartNoise.encode()));
        mDirty &= ~kcoldstartNoiseBit;
      }
      else if (attributeHandle == mObjectClass->GetfreezeAttributeHandle() && (mValuesSet & kfreezeBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mfreeze.encode()));
        mDirty &= ~kfreezeBit;
      }
      else if (attributeHandle == mObjectClass->GetchiReadyRequestAttributeHandle() && (mValuesSet & kchiReadyRequestBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mchiReadyRequest.encode()));
        mDirty &= ~kchiReadyRequestBit;
      }
      else if (attributeHandle == mObjectClass->GeterrorModeAttributeHandle() && (mValuesSet & kerrorModeBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, merrorMode.encode()));
        mDirty &= ~kerrorModeBit;
      }
      else if (attributeHandle == mObjectClass->GetslotModeAttributeHandle() && (mValuesSet & kslotModeBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mslotMode.encode()));
        mDirty &= ~kslotModeBit;
      }
      else if (attributeHandle == mObjectClass->GetstartupStateAttributeHandle() && (mValuesSet & kstartupStateBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mstartupState.encode()));
        mDirty &= ~kstartupStateBit;
      }
      else if (attributeHandle == mObjectClass->GetwakeupStatusAttributeHandle() && (mValuesSet & kwakeupStatusBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mwakeupStatus.encode()));
        mDirty &= ~kwakeupStatusBit;
      }
    } // for (auto& attributeHandleValue : attributes)
  } // scope of lock_guard
  if (time)
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(*time));
  else
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // FlexRayControllerStatus::ReflectAttributeValues

uint32_t FlexRayControllerStatus::RegisterUpdateCallback(UpdateCallback callback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void FlexRayControllerStatus::UnregisterUpdateCallback(uint32_t callbackToken)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mUpdateCallbacks.erase(callbackToken);
}

void FlexRayControllerStatus::ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(std::static_pointer_cast<IFlexRayControllerStatus>(shared_from_this()), time, orderType);
  }
}


// object class type 'FlexRayController'
FlexRayControllerObjectClass::FlexRayControllerObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, BusControllerObjectClass* baseClass)
{
  mRegistry = registry;
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.BusController.FlexRayController");
  // attribute PocRequest : FlexRayPocState
  mPocRequestAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"PocRequest");
  // attribute ChiCommand : FlexRayChiCommand
  mChiCommandAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"ChiCommand");
  // attribute pAllowHaltDueToClock : HLAoctet
  mpAllowHaltDueToClockAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pAllowHaltDueToClock");
  // attribute pAllowPassiveToActive : HLAoctet
  mpAllowPassiveToActiveAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pAllowPassiveToActive");
  // attribute pChannels : FlexRayChannel
  mpChannelsAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pChannels");
  // attribute pClusterDriftDamping : HLAoctet
  mpClusterDriftDampingAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pClusterDriftDamping");
  // attribute pdAcceptedStartupRange : HLAinteger32LE
  mpdAcceptedStartupRangeAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pdAcceptedStartupRange");
  // attribute pdListenTimeout : HLAinteger32LE
  mpdListenTimeoutAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pdListenTimeout");
  // attribute pKeySlotId : HLAinteger16LE
  mpKeySlotIdAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pKeySlotId");
  // attribute pKeySlotOnlyEnabled : HLAoctet
  mpKeySlotOnlyEnabledAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pKeySlotOnlyEnabled");
  // attribute pKeySlotUsedForStartup : HLAoctet
  mpKeySlotUsedForStartupAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pKeySlotUsedForStartup");
  // attribute pKeySlotUsedForSync : HLAoctet
  mpKeySlotUsedForSyncAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pKeySlotUsedForSync");
  // attribute pLatestTx : HLAinteger16LE
  mpLatestTxAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pLatestTx");
  // attribute pMacroInitialOffsetA : HLAoctet
  mpMacroInitialOffsetAAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pMacroInitialOffsetA");
  // attribute pMacroInitialOffsetB : HLAoctet
  mpMacroInitialOffsetBAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pMacroInitialOffsetB");
  // attribute pMicroInitialOffsetA : HLAinteger32LE
  mpMicroInitialOffsetAAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pMicroInitialOffsetA");
  // attribute pMicroInitialOffsetB : HLAinteger32LE
  mpMicroInitialOffsetBAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pMicroInitialOffsetB");
  // attribute pMicroPerCycle : HLAinteger32LE
  mpMicroPerCycleAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pMicroPerCycle");
  // attribute pOffsetCorrectionOut : HLAinteger32LE
  mpOffsetCorrectionOutAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pOffsetCorrectionOut");
  // attribute pOffsetCorrectionStart : HLAinteger16LE
  mpOffsetCorrectionStartAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pOffsetCorrectionStart");
  // attribute pRateCorrectionOut : HLAinteger32LE
  mpRateCorrectionOutAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pRateCorrectionOut");
  // attribute pWakeupChannel : FlexRayChannel
  mpWakeupChannelAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pWakeupChannel");
  // attribute pWakeupPattern : HLAoctet
  mpWakeupPatternAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pWakeupPattern");
  // attribute pdMicrotick : FlexRayClockPeriod
  mpdMicrotickAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pdMicrotick");
  // attribute pSamplesPerMicrotick : HLAoctet
  mpSamplesPerMicrotickAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"pSamplesPerMicrotick");
  SetObjectInstanceCreator([](FlexRayControllerObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador) -> FlexRayController* {
    return new FlexRayController(objectClass, instanceName, rtiAmbassador);
  });
}

FlexRayControllerObjectClass::~FlexRayControllerObjectClass()
{
  //std::lock_guard<std::recursive_mutex> lock(mMutex);
  while (!mObjectInstancesByHandle.empty())
  {
    // careful - hold the reference to the object instance until it has been removed from the maps,
    // otherwise it's mutex will be destroyed while held
    auto objectInstance = mObjectInstancesByHandle.begin()->second;
    objectInstance->Release();
  }
  assert(mObjectInstancesByHandle.empty());
  assert(mObjectInstancesByName.empty());
}

void FlexRayControllerObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void FlexRayControllerObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void FlexRayControllerObjectClass::Subscribe(bool deliverToSelf)
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    if (deliverToSelf) mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void FlexRayControllerObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

rti1516ev::AttributeHandleSet FlexRayControllerObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetNetworkIDAttributeHandle());
  result.insert(GetDeviceIDAttributeHandle());
  result.insert(GetPocRequestAttributeHandle());
  result.insert(GetChiCommandAttributeHandle());
  result.insert(GetpAllowHaltDueToClockAttributeHandle());
  result.insert(GetpAllowPassiveToActiveAttributeHandle());
  result.insert(GetpChannelsAttributeHandle());
  result.insert(GetpClusterDriftDampingAttributeHandle());
  result.insert(GetpdAcceptedStartupRangeAttributeHandle());
  result.insert(GetpdListenTimeoutAttributeHandle());
  result.insert(GetpKeySlotIdAttributeHandle());
  result.insert(GetpKeySlotOnlyEnabledAttributeHandle());
  result.insert(GetpKeySlotUsedForStartupAttributeHandle());
  result.insert(GetpKeySlotUsedForSyncAttributeHandle());
  result.insert(GetpLatestTxAttributeHandle());
  result.insert(GetpMacroInitialOffsetAAttributeHandle());
  result.insert(GetpMacroInitialOffsetBAttributeHandle());
  result.insert(GetpMicroInitialOffsetAAttributeHandle());
  result.insert(GetpMicroInitialOffsetBAttributeHandle());
  result.insert(GetpMicroPerCycleAttributeHandle());
  result.insert(GetpOffsetCorrectionOutAttributeHandle());
  result.insert(GetpOffsetCorrectionStartAttributeHandle());
  result.insert(GetpRateCorrectionOutAttributeHandle());
  result.insert(GetpWakeupChannelAttributeHandle());
  result.insert(GetpWakeupPatternAttributeHandle());
  result.insert(GetpdMicrotickAttributeHandle());
  result.insert(GetpSamplesPerMicrotickAttributeHandle());
  return result;
}

void FlexRayControllerObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  assert(mObjectInstancesByName.find(objectInstanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(objectInstanceHandle) == mObjectInstancesByHandle.end());
  std::shared_ptr<FlexRayController> newObject = std::shared_ptr<FlexRayController>(mCreatorFunction(this, objectInstanceName, mRtiAmbassador));
  newObject->mObjectInstanceHandle = objectInstanceHandle;
  newObject->mIsOwner = false;
  InsertObjectInstanceName(newObject, objectInstanceName);
  InsertObjectInstanceHandle(newObject, objectInstanceHandle);
  ExecuteDiscoverObjectInstanceCallbacks(newObject);
}

void FlexRayControllerObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring objectInstanceName = mRtiAmbassador->getObjectInstanceName(objectInstanceHandle);
  auto iter = mObjectInstancesByName.find(objectInstanceName);
  assert(iter != mObjectInstancesByName.end());
  auto objectInstance = std::dynamic_pointer_cast<FlexRayController>(iter->second);
  ExecuteRemoveObjectInstanceCallbacks(objectInstance);
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  EraseObjectInstance(objectInstanceHandle, objectInstanceName);
}

std::shared_ptr<IFlexRayController> FlexRayControllerObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IBusController> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceName);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IFlexRayController>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IFlexRayController> FlexRayControllerObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IBusController> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceHandle);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IFlexRayController>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IFlexRayController> FlexRayControllerObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"FlexRayController");
  }
  std::shared_ptr<FlexRayController> newObject = std::shared_ptr<FlexRayController>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
    }
  });
  return newObject;
}

std::shared_ptr<IFlexRayController> FlexRayControllerObjectClass::CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"FlexRayController");
  }
  std::shared_ptr<FlexRayController> newObject = std::shared_ptr<FlexRayController>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
      createdCallback(newObject, true);
    }
    else
    {
      createdCallback(newObject, false);
    }
  });
  return newObject;
}

uint32_t FlexRayControllerObjectClass::RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastDiscoverObjectInstanceCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastDiscoverObjectInstanceCallbackToken, callback));
  return mLastDiscoverObjectInstanceCallbackToken;
}

void FlexRayControllerObjectClass::UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mDiscoverCallbacks.erase(callbackToken);
}

void FlexRayControllerObjectClass::ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IFlexRayController> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

uint32_t FlexRayControllerObjectClass::RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastRemoveObjectInstanceCallbackToken++;
  mRemoveObjectInstanceCallbacks.insert(std::make_pair(mLastRemoveObjectInstanceCallbackToken, callback));
  return mLastRemoveObjectInstanceCallbackToken;
}

void FlexRayControllerObjectClass::UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mRemoveObjectInstanceCallbacks.erase(callbackToken);
}

void FlexRayControllerObjectClass::ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IFlexRayController> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mRemoveObjectInstanceCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

void FlexRayControllerObjectClass::InsertObjectInstanceName(std::shared_ptr<IFlexRayController> objectInstance, const std::wstring& objectInstanceName)
{
  // prerequisite: mMutex must be locked
  mObjectInstancesByName.insert(std::make_pair(objectInstanceName, objectInstance));
  mBaseClass->InsertObjectInstanceName(objectInstance, objectInstanceName);
}

void FlexRayControllerObjectClass::InsertObjectInstanceHandle(std::shared_ptr<IFlexRayController> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByHandle.insert(std::make_pair(objectInstanceHandle, objectInstance));
  mBaseClass->InsertObjectInstanceHandle(objectInstance, objectInstanceHandle);
}

void FlexRayControllerObjectClass::EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mBaseClass->EraseObjectInstance(objectInstanceHandle, objectInstanceName);
  mObjectInstancesByName.erase(objectInstanceName);
  mObjectInstancesByHandle.erase(objectInstanceHandle);
}


// object instances of type 'FlexRayController'
FlexRayController::FlexRayController()
  : mRtiAmbassador()
  , mObjectClass()
  , mObjectInstanceName()
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

FlexRayController::FlexRayController(FlexRayControllerObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mRtiAmbassador(rtiAmbassador)
  , mObjectClass(objectClass)
  , mObjectInstanceName(instanceName)
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

FlexRayController::~FlexRayController()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    try
    {
      mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    }
    catch (const rti1516ev::Exception&)
    {
    }
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

bool FlexRayController::IsValid() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mObjectInstanceHandle.isValid();
}

bool FlexRayController::IsOwner() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mIsOwner;
}

void FlexRayController::Release()
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (mObjectInstanceHandle.isValid())
  {
    if (mIsOwner)
    {
      try
      {
        mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
      }
      catch (const rti1516ev::Exception&)
      {
        // ignore - must execute rest of function
      }
      mIsOwner = false;
    }
    mObjectClass->EraseObjectInstance(mObjectInstanceHandle, mObjectInstanceName);
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  }
}

// attribute FlexRayController.HLAprivilegeToDeleteObject : no data type

// attribute NetworkID : HLAASCIIstring
std::string FlexRayController::GetNetworkID() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mNetworkID.get();
}

void FlexRayController::SetNetworkID(std::string newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mNetworkID.set(newValue);
  mDirty |= kNetworkIDBit;
  mValuesSet |= kNetworkIDBit;
}

// attribute DeviceID : HLAASCIIstring
std::string FlexRayController::GetDeviceID() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDeviceID.get();
}

void FlexRayController::SetDeviceID(std::string newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mDeviceID.set(newValue);
  mDirty |= kDeviceIDBit;
  mValuesSet |= kDeviceIDBit;
}

// attribute PocRequest : FlexRayPocState
FlexRayPocState FlexRayController::GetPocRequest() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return static_cast<FlexRayPocState>(mPocRequest.get());
}

void FlexRayController::SetPocRequest(FlexRayPocState newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mPocRequest.set(static_cast<uint8_t>(newValue));
  mDirty |= kPocRequestBit;
  mValuesSet |= kPocRequestBit;
}

// attribute ChiCommand : FlexRayChiCommand
FlexRayChiCommand FlexRayController::GetChiCommand() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return static_cast<FlexRayChiCommand>(mChiCommand.get());
}

void FlexRayController::SetChiCommand(FlexRayChiCommand newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mChiCommand.set(static_cast<uint8_t>(newValue));
  mDirty |= kChiCommandBit;
  mValuesSet |= kChiCommandBit;
}

// attribute pAllowHaltDueToClock : HLAoctet
uint8_t FlexRayController::GetpAllowHaltDueToClock() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mpAllowHaltDueToClock.get();
}

void FlexRayController::SetpAllowHaltDueToClock(uint8_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mpAllowHaltDueToClock.set(newValue);
  mDirty |= kpAllowHaltDueToClockBit;
  mValuesSet |= kpAllowHaltDueToClockBit;
}

// attribute pAllowPassiveToActive : HLAoctet
uint8_t FlexRayController::GetpAllowPassiveToActive() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mpAllowPassiveToActive.get();
}

void FlexRayController::SetpAllowPassiveToActive(uint8_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mpAllowPassiveToActive.set(newValue);
  mDirty |= kpAllowPassiveToActiveBit;
  mValuesSet |= kpAllowPassiveToActiveBit;
}

// attribute pChannels : FlexRayChannel
FlexRayChannel FlexRayController::GetpChannels() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return static_cast<FlexRayChannel>(mpChannels.get());
}

void FlexRayController::SetpChannels(FlexRayChannel newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mpChannels.set(static_cast<uint8_t>(newValue));
  mDirty |= kpChannelsBit;
  mValuesSet |= kpChannelsBit;
}

// attribute pClusterDriftDamping : HLAoctet
uint8_t FlexRayController::GetpClusterDriftDamping() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mpClusterDriftDamping.get();
}

void FlexRayController::SetpClusterDriftDamping(uint8_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mpClusterDriftDamping.set(newValue);
  mDirty |= kpClusterDriftDampingBit;
  mValuesSet |= kpClusterDriftDampingBit;
}

// attribute pdAcceptedStartupRange : HLAinteger32LE
int32_t FlexRayController::GetpdAcceptedStartupRange() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mpdAcceptedStartupRange.get();
}

void FlexRayController::SetpdAcceptedStartupRange(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mpdAcceptedStartupRange.set(newValue);
  mDirty |= kpdAcceptedStartupRangeBit;
  mValuesSet |= kpdAcceptedStartupRangeBit;
}

// attribute pdListenTimeout : HLAinteger32LE
int32_t FlexRayController::GetpdListenTimeout() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mpdListenTimeout.get();
}

void FlexRayController::SetpdListenTimeout(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mpdListenTimeout.set(newValue);
  mDirty |= kpdListenTimeoutBit;
  mValuesSet |= kpdListenTimeoutBit;
}

// attribute pKeySlotId : HLAinteger16LE
int16_t FlexRayController::GetpKeySlotId() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mpKeySlotId.get();
}

void FlexRayController::SetpKeySlotId(int16_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mpKeySlotId.set(newValue);
  mDirty |= kpKeySlotIdBit;
  mValuesSet |= kpKeySlotIdBit;
}

// attribute pKeySlotOnlyEnabled : HLAoctet
uint8_t FlexRayController::GetpKeySlotOnlyEnabled() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mpKeySlotOnlyEnabled.get();
}

void FlexRayController::SetpKeySlotOnlyEnabled(uint8_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mpKeySlotOnlyEnabled.set(newValue);
  mDirty |= kpKeySlotOnlyEnabledBit;
  mValuesSet |= kpKeySlotOnlyEnabledBit;
}

// attribute pKeySlotUsedForStartup : HLAoctet
uint8_t FlexRayController::GetpKeySlotUsedForStartup() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mpKeySlotUsedForStartup.get();
}

void FlexRayController::SetpKeySlotUsedForStartup(uint8_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mpKeySlotUsedForStartup.set(newValue);
  mDirty |= kpKeySlotUsedForStartupBit;
  mValuesSet |= kpKeySlotUsedForStartupBit;
}

// attribute pKeySlotUsedForSync : HLAoctet
uint8_t FlexRayController::GetpKeySlotUsedForSync() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mpKeySlotUsedForSync.get();
}

void FlexRayController::SetpKeySlotUsedForSync(uint8_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mpKeySlotUsedForSync.set(newValue);
  mDirty |= kpKeySlotUsedForSyncBit;
  mValuesSet |= kpKeySlotUsedForSyncBit;
}

// attribute pLatestTx : HLAinteger16LE
int16_t FlexRayController::GetpLatestTx() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mpLatestTx.get();
}

void FlexRayController::SetpLatestTx(int16_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mpLatestTx.set(newValue);
  mDirty |= kpLatestTxBit;
  mValuesSet |= kpLatestTxBit;
}

// attribute pMacroInitialOffsetA : HLAoctet
uint8_t FlexRayController::GetpMacroInitialOffsetA() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mpMacroInitialOffsetA.get();
}

void FlexRayController::SetpMacroInitialOffsetA(uint8_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mpMacroInitialOffsetA.set(newValue);
  mDirty |= kpMacroInitialOffsetABit;
  mValuesSet |= kpMacroInitialOffsetABit;
}

// attribute pMacroInitialOffsetB : HLAoctet
uint8_t FlexRayController::GetpMacroInitialOffsetB() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mpMacroInitialOffsetB.get();
}

void FlexRayController::SetpMacroInitialOffsetB(uint8_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mpMacroInitialOffsetB.set(newValue);
  mDirty |= kpMacroInitialOffsetBBit;
  mValuesSet |= kpMacroInitialOffsetBBit;
}

// attribute pMicroInitialOffsetA : HLAinteger32LE
int32_t FlexRayController::GetpMicroInitialOffsetA() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mpMicroInitialOffsetA.get();
}

void FlexRayController::SetpMicroInitialOffsetA(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mpMicroInitialOffsetA.set(newValue);
  mDirty |= kpMicroInitialOffsetABit;
  mValuesSet |= kpMicroInitialOffsetABit;
}

// attribute pMicroInitialOffsetB : HLAinteger32LE
int32_t FlexRayController::GetpMicroInitialOffsetB() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mpMicroInitialOffsetB.get();
}

void FlexRayController::SetpMicroInitialOffsetB(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mpMicroInitialOffsetB.set(newValue);
  mDirty |= kpMicroInitialOffsetBBit;
  mValuesSet |= kpMicroInitialOffsetBBit;
}

// attribute pMicroPerCycle : HLAinteger32LE
int32_t FlexRayController::GetpMicroPerCycle() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mpMicroPerCycle.get();
}

void FlexRayController::SetpMicroPerCycle(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mpMicroPerCycle.set(newValue);
  mDirty |= kpMicroPerCycleBit;
  mValuesSet |= kpMicroPerCycleBit;
}

// attribute pOffsetCorrectionOut : HLAinteger32LE
int32_t FlexRayController::GetpOffsetCorrectionOut() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mpOffsetCorrectionOut.get();
}

void FlexRayController::SetpOffsetCorrectionOut(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mpOffsetCorrectionOut.set(newValue);
  mDirty |= kpOffsetCorrectionOutBit;
  mValuesSet |= kpOffsetCorrectionOutBit;
}

// attribute pOffsetCorrectionStart : HLAinteger16LE
int16_t FlexRayController::GetpOffsetCorrectionStart() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mpOffsetCorrectionStart.get();
}

void FlexRayController::SetpOffsetCorrectionStart(int16_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mpOffsetCorrectionStart.set(newValue);
  mDirty |= kpOffsetCorrectionStartBit;
  mValuesSet |= kpOffsetCorrectionStartBit;
}

// attribute pRateCorrectionOut : HLAinteger32LE
int32_t FlexRayController::GetpRateCorrectionOut() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mpRateCorrectionOut.get();
}

void FlexRayController::SetpRateCorrectionOut(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mpRateCorrectionOut.set(newValue);
  mDirty |= kpRateCorrectionOutBit;
  mValuesSet |= kpRateCorrectionOutBit;
}

// attribute pWakeupChannel : FlexRayChannel
FlexRayChannel FlexRayController::GetpWakeupChannel() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return static_cast<FlexRayChannel>(mpWakeupChannel.get());
}

void FlexRayController::SetpWakeupChannel(FlexRayChannel newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mpWakeupChannel.set(static_cast<uint8_t>(newValue));
  mDirty |= kpWakeupChannelBit;
  mValuesSet |= kpWakeupChannelBit;
}

// attribute pWakeupPattern : HLAoctet
uint8_t FlexRayController::GetpWakeupPattern() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mpWakeupPattern.get();
}

void FlexRayController::SetpWakeupPattern(uint8_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mpWakeupPattern.set(newValue);
  mDirty |= kpWakeupPatternBit;
  mValuesSet |= kpWakeupPatternBit;
}

// attribute pdMicrotick : FlexRayClockPeriod
FlexRayClockPeriod FlexRayController::GetpdMicrotick() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return static_cast<FlexRayClockPeriod>(mpdMicrotick.get());
}

void FlexRayController::SetpdMicrotick(FlexRayClockPeriod newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mpdMicrotick.set(static_cast<uint8_t>(newValue));
  mDirty |= kpdMicrotickBit;
  mValuesSet |= kpdMicrotickBit;
}

// attribute pSamplesPerMicrotick : HLAoctet
uint8_t FlexRayController::GetpSamplesPerMicrotick() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mpSamplesPerMicrotick.get();
}

void FlexRayController::SetpSamplesPerMicrotick(uint8_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mpSamplesPerMicrotick.set(newValue);
  mDirty |= kpSamplesPerMicrotickBit;
  mValuesSet |= kpSamplesPerMicrotickBit;
}

rti1516ev::AttributeHandleValueMap FlexRayController::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  result[mObjectClass->GetDeviceIDAttributeHandle()] = mDeviceID.encode();
  result[mObjectClass->GetPocRequestAttributeHandle()] = mPocRequest.encode();
  result[mObjectClass->GetChiCommandAttributeHandle()] = mChiCommand.encode();
  result[mObjectClass->GetpAllowHaltDueToClockAttributeHandle()] = mpAllowHaltDueToClock.encode();
  result[mObjectClass->GetpAllowPassiveToActiveAttributeHandle()] = mpAllowPassiveToActive.encode();
  result[mObjectClass->GetpChannelsAttributeHandle()] = mpChannels.encode();
  result[mObjectClass->GetpClusterDriftDampingAttributeHandle()] = mpClusterDriftDamping.encode();
  result[mObjectClass->GetpdAcceptedStartupRangeAttributeHandle()] = mpdAcceptedStartupRange.encode();
  result[mObjectClass->GetpdListenTimeoutAttributeHandle()] = mpdListenTimeout.encode();
  result[mObjectClass->GetpKeySlotIdAttributeHandle()] = mpKeySlotId.encode();
  result[mObjectClass->GetpKeySlotOnlyEnabledAttributeHandle()] = mpKeySlotOnlyEnabled.encode();
  result[mObjectClass->GetpKeySlotUsedForStartupAttributeHandle()] = mpKeySlotUsedForStartup.encode();
  result[mObjectClass->GetpKeySlotUsedForSyncAttributeHandle()] = mpKeySlotUsedForSync.encode();
  result[mObjectClass->GetpLatestTxAttributeHandle()] = mpLatestTx.encode();
  result[mObjectClass->GetpMacroInitialOffsetAAttributeHandle()] = mpMacroInitialOffsetA.encode();
  result[mObjectClass->GetpMacroInitialOffsetBAttributeHandle()] = mpMacroInitialOffsetB.encode();
  result[mObjectClass->GetpMicroInitialOffsetAAttributeHandle()] = mpMicroInitialOffsetA.encode();
  result[mObjectClass->GetpMicroInitialOffsetBAttributeHandle()] = mpMicroInitialOffsetB.encode();
  result[mObjectClass->GetpMicroPerCycleAttributeHandle()] = mpMicroPerCycle.encode();
  result[mObjectClass->GetpOffsetCorrectionOutAttributeHandle()] = mpOffsetCorrectionOut.encode();
  result[mObjectClass->GetpOffsetCorrectionStartAttributeHandle()] = mpOffsetCorrectionStart.encode();
  result[mObjectClass->GetpRateCorrectionOutAttributeHandle()] = mpRateCorrectionOut.encode();
  result[mObjectClass->GetpWakeupChannelAttributeHandle()] = mpWakeupChannel.encode();
  result[mObjectClass->GetpWakeupPatternAttributeHandle()] = mpWakeupPattern.encode();
  result[mObjectClass->GetpdMicrotickAttributeHandle()] = mpdMicrotick.encode();
  result[mObjectClass->GetpSamplesPerMicrotickAttributeHandle()] = mpSamplesPerMicrotick.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap FlexRayController::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kNetworkIDBit)
  {
    result[mObjectClass->GetNetworkIDAttributeHandle()] = mNetworkID.encode();
  }
  if (mDirty & kDeviceIDBit)
  {
    result[mObjectClass->GetDeviceIDAttributeHandle()] = mDeviceID.encode();
  }
  if (mDirty & kPocRequestBit)
  {
    result[mObjectClass->GetPocRequestAttributeHandle()] = mPocRequest.encode();
  }
  if (mDirty & kChiCommandBit)
  {
    result[mObjectClass->GetChiCommandAttributeHandle()] = mChiCommand.encode();
  }
  if (mDirty & kpAllowHaltDueToClockBit)
  {
    result[mObjectClass->GetpAllowHaltDueToClockAttributeHandle()] = mpAllowHaltDueToClock.encode();
  }
  if (mDirty & kpAllowPassiveToActiveBit)
  {
    result[mObjectClass->GetpAllowPassiveToActiveAttributeHandle()] = mpAllowPassiveToActive.encode();
  }
  if (mDirty & kpChannelsBit)
  {
    result[mObjectClass->GetpChannelsAttributeHandle()] = mpChannels.encode();
  }
  if (mDirty & kpClusterDriftDampingBit)
  {
    result[mObjectClass->GetpClusterDriftDampingAttributeHandle()] = mpClusterDriftDamping.encode();
  }
  if (mDirty & kpdAcceptedStartupRangeBit)
  {
    result[mObjectClass->GetpdAcceptedStartupRangeAttributeHandle()] = mpdAcceptedStartupRange.encode();
  }
  if (mDirty & kpdListenTimeoutBit)
  {
    result[mObjectClass->GetpdListenTimeoutAttributeHandle()] = mpdListenTimeout.encode();
  }
  if (mDirty & kpKeySlotIdBit)
  {
    result[mObjectClass->GetpKeySlotIdAttributeHandle()] = mpKeySlotId.encode();
  }
  if (mDirty & kpKeySlotOnlyEnabledBit)
  {
    result[mObjectClass->GetpKeySlotOnlyEnabledAttributeHandle()] = mpKeySlotOnlyEnabled.encode();
  }
  if (mDirty & kpKeySlotUsedForStartupBit)
  {
    result[mObjectClass->GetpKeySlotUsedForStartupAttributeHandle()] = mpKeySlotUsedForStartup.encode();
  }
  if (mDirty & kpKeySlotUsedForSyncBit)
  {
    result[mObjectClass->GetpKeySlotUsedForSyncAttributeHandle()] = mpKeySlotUsedForSync.encode();
  }
  if (mDirty & kpLatestTxBit)
  {
    result[mObjectClass->GetpLatestTxAttributeHandle()] = mpLatestTx.encode();
  }
  if (mDirty & kpMacroInitialOffsetABit)
  {
    result[mObjectClass->GetpMacroInitialOffsetAAttributeHandle()] = mpMacroInitialOffsetA.encode();
  }
  if (mDirty & kpMacroInitialOffsetBBit)
  {
    result[mObjectClass->GetpMacroInitialOffsetBAttributeHandle()] = mpMacroInitialOffsetB.encode();
  }
  if (mDirty & kpMicroInitialOffsetABit)
  {
    result[mObjectClass->GetpMicroInitialOffsetAAttributeHandle()] = mpMicroInitialOffsetA.encode();
  }
  if (mDirty & kpMicroInitialOffsetBBit)
  {
    result[mObjectClass->GetpMicroInitialOffsetBAttributeHandle()] = mpMicroInitialOffsetB.encode();
  }
  if (mDirty & kpMicroPerCycleBit)
  {
    result[mObjectClass->GetpMicroPerCycleAttributeHandle()] = mpMicroPerCycle.encode();
  }
  if (mDirty & kpOffsetCorrectionOutBit)
  {
    result[mObjectClass->GetpOffsetCorrectionOutAttributeHandle()] = mpOffsetCorrectionOut.encode();
  }
  if (mDirty & kpOffsetCorrectionStartBit)
  {
    result[mObjectClass->GetpOffsetCorrectionStartAttributeHandle()] = mpOffsetCorrectionStart.encode();
  }
  if (mDirty & kpRateCorrectionOutBit)
  {
    result[mObjectClass->GetpRateCorrectionOutAttributeHandle()] = mpRateCorrectionOut.encode();
  }
  if (mDirty & kpWakeupChannelBit)
  {
    result[mObjectClass->GetpWakeupChannelAttributeHandle()] = mpWakeupChannel.encode();
  }
  if (mDirty & kpWakeupPatternBit)
  {
    result[mObjectClass->GetpWakeupPatternAttributeHandle()] = mpWakeupPattern.encode();
  }
  if (mDirty & kpdMicrotickBit)
  {
    result[mObjectClass->GetpdMicrotickAttributeHandle()] = mpdMicrotick.encode();
  }
  if (mDirty & kpSamplesPerMicrotickBit)
  {
    result[mObjectClass->GetpSamplesPerMicrotickAttributeHandle()] = mpSamplesPerMicrotick.encode();
  }
  return result;
}

FlexRayController::AttributeBits FlexRayController::GetReceivedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesReceived;
}

FlexRayController::AttributeBits FlexRayController::GetUpdatedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mLastUpdated;
}

FlexRayController::AttributeBits FlexRayController::GetInitializedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesSet;
}

FlexRayController::AttributeBits FlexRayController::GetModifiedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDirty;
}

void FlexRayController::UpdateAllAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void FlexRayController::UpdateAllAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    try {
      mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
      mDirty = kNone;
    }
    catch (const rti1516ev::InvalidLogicalTime& e)
    {
      throw InvalidLogicalTime(to_string(e.what()));
    }
    catch (const rti1516ev::Exception& e)
    {
      throw std::runtime_error(to_string(e.what()));
    }
  }
}

void FlexRayController::UpdateModifiedAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void FlexRayController::UpdateModifiedAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
        mDirty = kNone;
      }
      catch (const rti1516ev::InvalidLogicalTime& e)
      {
        throw InvalidLogicalTime(to_string(e.what()));
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void FlexRayController::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle())
    {
      mNetworkID.decode(attributeHandleValue.second);
      mLastUpdated |= kNetworkIDBit;
    }
    else if (attributeHandle == mObjectClass->GetDeviceIDAttributeHandle())
    {
      mDeviceID.decode(attributeHandleValue.second);
      mLastUpdated |= kDeviceIDBit;
    }
    else if (attributeHandle == mObjectClass->GetPocRequestAttributeHandle())
    {
      mPocRequest.decode(attributeHandleValue.second);
      mLastUpdated |= kPocRequestBit;
    }
    else if (attributeHandle == mObjectClass->GetChiCommandAttributeHandle())
    {
      mChiCommand.decode(attributeHandleValue.second);
      mLastUpdated |= kChiCommandBit;
    }
    else if (attributeHandle == mObjectClass->GetpAllowHaltDueToClockAttributeHandle())
    {
      mpAllowHaltDueToClock.decode(attributeHandleValue.second);
      mLastUpdated |= kpAllowHaltDueToClockBit;
    }
    else if (attributeHandle == mObjectClass->GetpAllowPassiveToActiveAttributeHandle())
    {
      mpAllowPassiveToActive.decode(attributeHandleValue.second);
      mLastUpdated |= kpAllowPassiveToActiveBit;
    }
    else if (attributeHandle == mObjectClass->GetpChannelsAttributeHandle())
    {
      mpChannels.decode(attributeHandleValue.second);
      mLastUpdated |= kpChannelsBit;
    }
    else if (attributeHandle == mObjectClass->GetpClusterDriftDampingAttributeHandle())
    {
      mpClusterDriftDamping.decode(attributeHandleValue.second);
      mLastUpdated |= kpClusterDriftDampingBit;
    }
    else if (attributeHandle == mObjectClass->GetpdAcceptedStartupRangeAttributeHandle())
    {
      mpdAcceptedStartupRange.decode(attributeHandleValue.second);
      mLastUpdated |= kpdAcceptedStartupRangeBit;
    }
    else if (attributeHandle == mObjectClass->GetpdListenTimeoutAttributeHandle())
    {
      mpdListenTimeout.decode(attributeHandleValue.second);
      mLastUpdated |= kpdListenTimeoutBit;
    }
    else if (attributeHandle == mObjectClass->GetpKeySlotIdAttributeHandle())
    {
      mpKeySlotId.decode(attributeHandleValue.second);
      mLastUpdated |= kpKeySlotIdBit;
    }
    else if (attributeHandle == mObjectClass->GetpKeySlotOnlyEnabledAttributeHandle())
    {
      mpKeySlotOnlyEnabled.decode(attributeHandleValue.second);
      mLastUpdated |= kpKeySlotOnlyEnabledBit;
    }
    else if (attributeHandle == mObjectClass->GetpKeySlotUsedForStartupAttributeHandle())
    {
      mpKeySlotUsedForStartup.decode(attributeHandleValue.second);
      mLastUpdated |= kpKeySlotUsedForStartupBit;
    }
    else if (attributeHandle == mObjectClass->GetpKeySlotUsedForSyncAttributeHandle())
    {
      mpKeySlotUsedForSync.decode(attributeHandleValue.second);
      mLastUpdated |= kpKeySlotUsedForSyncBit;
    }
    else if (attributeHandle == mObjectClass->GetpLatestTxAttributeHandle())
    {
      mpLatestTx.decode(attributeHandleValue.second);
      mLastUpdated |= kpLatestTxBit;
    }
    else if (attributeHandle == mObjectClass->GetpMacroInitialOffsetAAttributeHandle())
    {
      mpMacroInitialOffsetA.decode(attributeHandleValue.second);
      mLastUpdated |= kpMacroInitialOffsetABit;
    }
    else if (attributeHandle == mObjectClass->GetpMacroInitialOffsetBAttributeHandle())
    {
      mpMacroInitialOffsetB.decode(attributeHandleValue.second);
      mLastUpdated |= kpMacroInitialOffsetBBit;
    }
    else if (attributeHandle == mObjectClass->GetpMicroInitialOffsetAAttributeHandle())
    {
      mpMicroInitialOffsetA.decode(attributeHandleValue.second);
      mLastUpdated |= kpMicroInitialOffsetABit;
    }
    else if (attributeHandle == mObjectClass->GetpMicroInitialOffsetBAttributeHandle())
    {
      mpMicroInitialOffsetB.decode(attributeHandleValue.second);
      mLastUpdated |= kpMicroInitialOffsetBBit;
    }
    else if (attributeHandle == mObjectClass->GetpMicroPerCycleAttributeHandle())
    {
      mpMicroPerCycle.decode(attributeHandleValue.second);
      mLastUpdated |= kpMicroPerCycleBit;
    }
    else if (attributeHandle == mObjectClass->GetpOffsetCorrectionOutAttributeHandle())
    {
      mpOffsetCorrectionOut.decode(attributeHandleValue.second);
      mLastUpdated |= kpOffsetCorrectionOutBit;
    }
    else if (attributeHandle == mObjectClass->GetpOffsetCorrectionStartAttributeHandle())
    {
      mpOffsetCorrectionStart.decode(attributeHandleValue.second);
      mLastUpdated |= kpOffsetCorrectionStartBit;
    }
    else if (attributeHandle == mObjectClass->GetpRateCorrectionOutAttributeHandle())
    {
      mpRateCorrectionOut.decode(attributeHandleValue.second);
      mLastUpdated |= kpRateCorrectionOutBit;
    }
    else if (attributeHandle == mObjectClass->GetpWakeupChannelAttributeHandle())
    {
      mpWakeupChannel.decode(attributeHandleValue.second);
      mLastUpdated |= kpWakeupChannelBit;
    }
    else if (attributeHandle == mObjectClass->GetpWakeupPatternAttributeHandle())
    {
      mpWakeupPattern.decode(attributeHandleValue.second);
      mLastUpdated |= kpWakeupPatternBit;
    }
    else if (attributeHandle == mObjectClass->GetpdMicrotickAttributeHandle())
    {
      mpdMicrotick.decode(attributeHandleValue.second);
      mLastUpdated |= kpdMicrotickBit;
    }
    else if (attributeHandle == mObjectClass->GetpSamplesPerMicrotickAttributeHandle())
    {
      mpSamplesPerMicrotick.decode(attributeHandleValue.second);
      mLastUpdated |= kpSamplesPerMicrotickBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(optional<int64_t>(), optional<OrderType>());
  mLastUpdated = kNone;
} // FlexRayController::ReflectAttributeValues

void FlexRayController::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle())
    {
      mNetworkID.decode(attributeHandleValue.second);
      mLastUpdated |= kNetworkIDBit;
    }
    else if (attributeHandle == mObjectClass->GetDeviceIDAttributeHandle())
    {
      mDeviceID.decode(attributeHandleValue.second);
      mLastUpdated |= kDeviceIDBit;
    }
    else if (attributeHandle == mObjectClass->GetPocRequestAttributeHandle())
    {
      mPocRequest.decode(attributeHandleValue.second);
      mLastUpdated |= kPocRequestBit;
    }
    else if (attributeHandle == mObjectClass->GetChiCommandAttributeHandle())
    {
      mChiCommand.decode(attributeHandleValue.second);
      mLastUpdated |= kChiCommandBit;
    }
    else if (attributeHandle == mObjectClass->GetpAllowHaltDueToClockAttributeHandle())
    {
      mpAllowHaltDueToClock.decode(attributeHandleValue.second);
      mLastUpdated |= kpAllowHaltDueToClockBit;
    }
    else if (attributeHandle == mObjectClass->GetpAllowPassiveToActiveAttributeHandle())
    {
      mpAllowPassiveToActive.decode(attributeHandleValue.second);
      mLastUpdated |= kpAllowPassiveToActiveBit;
    }
    else if (attributeHandle == mObjectClass->GetpChannelsAttributeHandle())
    {
      mpChannels.decode(attributeHandleValue.second);
      mLastUpdated |= kpChannelsBit;
    }
    else if (attributeHandle == mObjectClass->GetpClusterDriftDampingAttributeHandle())
    {
      mpClusterDriftDamping.decode(attributeHandleValue.second);
      mLastUpdated |= kpClusterDriftDampingBit;
    }
    else if (attributeHandle == mObjectClass->GetpdAcceptedStartupRangeAttributeHandle())
    {
      mpdAcceptedStartupRange.decode(attributeHandleValue.second);
      mLastUpdated |= kpdAcceptedStartupRangeBit;
    }
    else if (attributeHandle == mObjectClass->GetpdListenTimeoutAttributeHandle())
    {
      mpdListenTimeout.decode(attributeHandleValue.second);
      mLastUpdated |= kpdListenTimeoutBit;
    }
    else if (attributeHandle == mObjectClass->GetpKeySlotIdAttributeHandle())
    {
      mpKeySlotId.decode(attributeHandleValue.second);
      mLastUpdated |= kpKeySlotIdBit;
    }
    else if (attributeHandle == mObjectClass->GetpKeySlotOnlyEnabledAttributeHandle())
    {
      mpKeySlotOnlyEnabled.decode(attributeHandleValue.second);
      mLastUpdated |= kpKeySlotOnlyEnabledBit;
    }
    else if (attributeHandle == mObjectClass->GetpKeySlotUsedForStartupAttributeHandle())
    {
      mpKeySlotUsedForStartup.decode(attributeHandleValue.second);
      mLastUpdated |= kpKeySlotUsedForStartupBit;
    }
    else if (attributeHandle == mObjectClass->GetpKeySlotUsedForSyncAttributeHandle())
    {
      mpKeySlotUsedForSync.decode(attributeHandleValue.second);
      mLastUpdated |= kpKeySlotUsedForSyncBit;
    }
    else if (attributeHandle == mObjectClass->GetpLatestTxAttributeHandle())
    {
      mpLatestTx.decode(attributeHandleValue.second);
      mLastUpdated |= kpLatestTxBit;
    }
    else if (attributeHandle == mObjectClass->GetpMacroInitialOffsetAAttributeHandle())
    {
      mpMacroInitialOffsetA.decode(attributeHandleValue.second);
      mLastUpdated |= kpMacroInitialOffsetABit;
    }
    else if (attributeHandle == mObjectClass->GetpMacroInitialOffsetBAttributeHandle())
    {
      mpMacroInitialOffsetB.decode(attributeHandleValue.second);
      mLastUpdated |= kpMacroInitialOffsetBBit;
    }
    else if (attributeHandle == mObjectClass->GetpMicroInitialOffsetAAttributeHandle())
    {
      mpMicroInitialOffsetA.decode(attributeHandleValue.second);
      mLastUpdated |= kpMicroInitialOffsetABit;
    }
    else if (attributeHandle == mObjectClass->GetpMicroInitialOffsetBAttributeHandle())
    {
      mpMicroInitialOffsetB.decode(attributeHandleValue.second);
      mLastUpdated |= kpMicroInitialOffsetBBit;
    }
    else if (attributeHandle == mObjectClass->GetpMicroPerCycleAttributeHandle())
    {
      mpMicroPerCycle.decode(attributeHandleValue.second);
      mLastUpdated |= kpMicroPerCycleBit;
    }
    else if (attributeHandle == mObjectClass->GetpOffsetCorrectionOutAttributeHandle())
    {
      mpOffsetCorrectionOut.decode(attributeHandleValue.second);
      mLastUpdated |= kpOffsetCorrectionOutBit;
    }
    else if (attributeHandle == mObjectClass->GetpOffsetCorrectionStartAttributeHandle())
    {
      mpOffsetCorrectionStart.decode(attributeHandleValue.second);
      mLastUpdated |= kpOffsetCorrectionStartBit;
    }
    else if (attributeHandle == mObjectClass->GetpRateCorrectionOutAttributeHandle())
    {
      mpRateCorrectionOut.decode(attributeHandleValue.second);
      mLastUpdated |= kpRateCorrectionOutBit;
    }
    else if (attributeHandle == mObjectClass->GetpWakeupChannelAttributeHandle())
    {
      mpWakeupChannel.decode(attributeHandleValue.second);
      mLastUpdated |= kpWakeupChannelBit;
    }
    else if (attributeHandle == mObjectClass->GetpWakeupPatternAttributeHandle())
    {
      mpWakeupPattern.decode(attributeHandleValue.second);
      mLastUpdated |= kpWakeupPatternBit;
    }
    else if (attributeHandle == mObjectClass->GetpdMicrotickAttributeHandle())
    {
      mpdMicrotick.decode(attributeHandleValue.second);
      mLastUpdated |= kpdMicrotickBit;
    }
    else if (attributeHandle == mObjectClass->GetpSamplesPerMicrotickAttributeHandle())
    {
      mpSamplesPerMicrotick.decode(attributeHandleValue.second);
      mLastUpdated |= kpSamplesPerMicrotickBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(static_cast<const rti1516ev::HLAinteger64Time&>(theTime).getTime(), orderType);
  mLastUpdated = kNone;
} // FlexRayController::ReflectAttributeValues

// request attributes not being part of the last update
void FlexRayController::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    if ((mLastUpdated & kNetworkIDBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetNetworkIDAttributeHandle());
    }
    if ((mLastUpdated & kDeviceIDBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetDeviceIDAttributeHandle());
    }
    if ((mLastUpdated & kPocRequestBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetPocRequestAttributeHandle());
    }
    if ((mLastUpdated & kChiCommandBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetChiCommandAttributeHandle());
    }
    if ((mLastUpdated & kpAllowHaltDueToClockBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetpAllowHaltDueToClockAttributeHandle());
    }
    if ((mLastUpdated & kpAllowPassiveToActiveBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetpAllowPassiveToActiveAttributeHandle());
    }
    if ((mLastUpdated & kpChannelsBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetpChannelsAttributeHandle());
    }
    if ((mLastUpdated & kpClusterDriftDampingBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetpClusterDriftDampingAttributeHandle());
    }
    if ((mLastUpdated & kpdAcceptedStartupRangeBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetpdAcceptedStartupRangeAttributeHandle());
    }
    if ((mLastUpdated & kpdListenTimeoutBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetpdListenTimeoutAttributeHandle());
    }
    if ((mLastUpdated & kpKeySlotIdBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetpKeySlotIdAttributeHandle());
    }
    if ((mLastUpdated & kpKeySlotOnlyEnabledBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetpKeySlotOnlyEnabledAttributeHandle());
    }
    if ((mLastUpdated & kpKeySlotUsedForStartupBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetpKeySlotUsedForStartupAttributeHandle());
    }
    if ((mLastUpdated & kpKeySlotUsedForSyncBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetpKeySlotUsedForSyncAttributeHandle());
    }
    if ((mLastUpdated & kpLatestTxBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetpLatestTxAttributeHandle());
    }
    if ((mLastUpdated & kpMacroInitialOffsetABit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetpMacroInitialOffsetAAttributeHandle());
    }
    if ((mLastUpdated & kpMacroInitialOffsetBBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetpMacroInitialOffsetBAttributeHandle());
    }
    if ((mLastUpdated & kpMicroInitialOffsetABit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetpMicroInitialOffsetAAttributeHandle());
    }
    if ((mLastUpdated & kpMicroInitialOffsetBBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetpMicroInitialOffsetBAttributeHandle());
    }
    if ((mLastUpdated & kpMicroPerCycleBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetpMicroPerCycleAttributeHandle());
    }
    if ((mLastUpdated & kpOffsetCorrectionOutBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetpOffsetCorrectionOutAttributeHandle());
    }
    if ((mLastUpdated & kpOffsetCorrectionStartBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetpOffsetCorrectionStartAttributeHandle());
    }
    if ((mLastUpdated & kpRateCorrectionOutBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetpRateCorrectionOutAttributeHandle());
    }
    if ((mLastUpdated & kpWakeupChannelBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetpWakeupChannelAttributeHandle());
    }
    if ((mLastUpdated & kpWakeupPatternBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetpWakeupPatternAttributeHandle());
    }
    if ((mLastUpdated & kpdMicrotickBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetpdMicrotickAttributeHandle());
    }
    if ((mLastUpdated & kpSamplesPerMicrotickBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetpSamplesPerMicrotickAttributeHandle());
    }
  } // scope of lock_guard
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// request all attributes, regardless of current state
void FlexRayController::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetNetworkIDAttributeHandle());
  requestAttributes.insert(mObjectClass->GetDeviceIDAttributeHandle());
  requestAttributes.insert(mObjectClass->GetPocRequestAttributeHandle());
  requestAttributes.insert(mObjectClass->GetChiCommandAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpAllowHaltDueToClockAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpAllowPassiveToActiveAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpChannelsAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpClusterDriftDampingAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpdAcceptedStartupRangeAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpdListenTimeoutAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpKeySlotIdAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpKeySlotOnlyEnabledAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpKeySlotUsedForStartupAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpKeySlotUsedForSyncAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpLatestTxAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpMacroInitialOffsetAAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpMacroInitialOffsetBAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpMicroInitialOffsetAAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpMicroInitialOffsetBAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpMicroPerCycleAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpOffsetCorrectionOutAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpOffsetCorrectionStartAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpRateCorrectionOutAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpWakeupChannelAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpWakeupPatternAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpdMicrotickAttributeHandle());
  requestAttributes.insert(mObjectClass->GetpSamplesPerMicrotickAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// provide requested attributes set since last sent update
void FlexRayController::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    for (auto& attributeHandle : attributeHandles)
    {
      if (attributeHandle == mObjectClass->GetNetworkIDAttributeHandle() && (mValuesSet & kNetworkIDBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mNetworkID.encode()));
        mDirty &= ~kNetworkIDBit;
      }
      else if (attributeHandle == mObjectClass->GetDeviceIDAttributeHandle() && (mValuesSet & kDeviceIDBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mDeviceID.encode()));
        mDirty &= ~kDeviceIDBit;
      }
      else if (attributeHandle == mObjectClass->GetPocRequestAttributeHandle() && (mValuesSet & kPocRequestBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mPocRequest.encode()));
        mDirty &= ~kPocRequestBit;
      }
      else if (attributeHandle == mObjectClass->GetChiCommandAttributeHandle() && (mValuesSet & kChiCommandBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mChiCommand.encode()));
        mDirty &= ~kChiCommandBit;
      }
      else if (attributeHandle == mObjectClass->GetpAllowHaltDueToClockAttributeHandle() && (mValuesSet & kpAllowHaltDueToClockBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mpAllowHaltDueToClock.encode()));
        mDirty &= ~kpAllowHaltDueToClockBit;
      }
      else if (attributeHandle == mObjectClass->GetpAllowPassiveToActiveAttributeHandle() && (mValuesSet & kpAllowPassiveToActiveBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mpAllowPassiveToActive.encode()));
        mDirty &= ~kpAllowPassiveToActiveBit;
      }
      else if (attributeHandle == mObjectClass->GetpChannelsAttributeHandle() && (mValuesSet & kpChannelsBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mpChannels.encode()));
        mDirty &= ~kpChannelsBit;
      }
      else if (attributeHandle == mObjectClass->GetpClusterDriftDampingAttributeHandle() && (mValuesSet & kpClusterDriftDampingBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mpClusterDriftDamping.encode()));
        mDirty &= ~kpClusterDriftDampingBit;
      }
      else if (attributeHandle == mObjectClass->GetpdAcceptedStartupRangeAttributeHandle() && (mValuesSet & kpdAcceptedStartupRangeBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mpdAcceptedStartupRange.encode()));
        mDirty &= ~kpdAcceptedStartupRangeBit;
      }
      else if (attributeHandle == mObjectClass->GetpdListenTimeoutAttributeHandle() && (mValuesSet & kpdListenTimeoutBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mpdListenTimeout.encode()));
        mDirty &= ~kpdListenTimeoutBit;
      }
      else if (attributeHandle == mObjectClass->GetpKeySlotIdAttributeHandle() && (mValuesSet & kpKeySlotIdBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mpKeySlotId.encode()));
        mDirty &= ~kpKeySlotIdBit;
      }
      else if (attributeHandle == mObjectClass->GetpKeySlotOnlyEnabledAttributeHandle() && (mValuesSet & kpKeySlotOnlyEnabledBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mpKeySlotOnlyEnabled.encode()));
        mDirty &= ~kpKeySlotOnlyEnabledBit;
      }
      else if (attributeHandle == mObjectClass->GetpKeySlotUsedForStartupAttributeHandle() && (mValuesSet & kpKeySlotUsedForStartupBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mpKeySlotUsedForStartup.encode()));
        mDirty &= ~kpKeySlotUsedForStartupBit;
      }
      else if (attributeHandle == mObjectClass->GetpKeySlotUsedForSyncAttributeHandle() && (mValuesSet & kpKeySlotUsedForSyncBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mpKeySlotUsedForSync.encode()));
        mDirty &= ~kpKeySlotUsedForSyncBit;
      }
      else if (attributeHandle == mObjectClass->GetpLatestTxAttributeHandle() && (mValuesSet & kpLatestTxBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mpLatestTx.encode()));
        mDirty &= ~kpLatestTxBit;
      }
      else if (attributeHandle == mObjectClass->GetpMacroInitialOffsetAAttributeHandle() && (mValuesSet & kpMacroInitialOffsetABit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mpMacroInitialOffsetA.encode()));
        mDirty &= ~kpMacroInitialOffsetABit;
      }
      else if (attributeHandle == mObjectClass->GetpMacroInitialOffsetBAttributeHandle() && (mValuesSet & kpMacroInitialOffsetBBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mpMacroInitialOffsetB.encode()));
        mDirty &= ~kpMacroInitialOffsetBBit;
      }
      else if (attributeHandle == mObjectClass->GetpMicroInitialOffsetAAttributeHandle() && (mValuesSet & kpMicroInitialOffsetABit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mpMicroInitialOffsetA.encode()));
        mDirty &= ~kpMicroInitialOffsetABit;
      }
      else if (attributeHandle == mObjectClass->GetpMicroInitialOffsetBAttributeHandle() && (mValuesSet & kpMicroInitialOffsetBBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mpMicroInitialOffsetB.encode()));
        mDirty &= ~kpMicroInitialOffsetBBit;
      }
      else if (attributeHandle == mObjectClass->GetpMicroPerCycleAttributeHandle() && (mValuesSet & kpMicroPerCycleBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mpMicroPerCycle.encode()));
        mDirty &= ~kpMicroPerCycleBit;
      }
      else if (attributeHandle == mObjectClass->GetpOffsetCorrectionOutAttributeHandle() && (mValuesSet & kpOffsetCorrectionOutBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mpOffsetCorrectionOut.encode()));
        mDirty &= ~kpOffsetCorrectionOutBit;
      }
      else if (attributeHandle == mObjectClass->GetpOffsetCorrectionStartAttributeHandle() && (mValuesSet & kpOffsetCorrectionStartBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mpOffsetCorrectionStart.encode()));
        mDirty &= ~kpOffsetCorrectionStartBit;
      }
      else if (attributeHandle == mObjectClass->GetpRateCorrectionOutAttributeHandle() && (mValuesSet & kpRateCorrectionOutBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mpRateCorrectionOut.encode()));
        mDirty &= ~kpRateCorrectionOutBit;
      }
      else if (attributeHandle == mObjectClass->GetpWakeupChannelAttributeHandle() && (mValuesSet & kpWakeupChannelBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mpWakeupChannel.encode()));
        mDirty &= ~kpWakeupChannelBit;
      }
      else if (attributeHandle == mObjectClass->GetpWakeupPatternAttributeHandle() && (mValuesSet & kpWakeupPatternBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mpWakeupPattern.encode()));
        mDirty &= ~kpWakeupPatternBit;
      }
      else if (attributeHandle == mObjectClass->GetpdMicrotickAttributeHandle() && (mValuesSet & kpdMicrotickBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mpdMicrotick.encode()));
        mDirty &= ~kpdMicrotickBit;
      }
      else if (attributeHandle == mObjectClass->GetpSamplesPerMicrotickAttributeHandle() && (mValuesSet & kpSamplesPerMicrotickBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mpSamplesPerMicrotick.encode()));
        mDirty &= ~kpSamplesPerMicrotickBit;
      }
    } // for (auto& attributeHandleValue : attributes)
  } // scope of lock_guard
  if (time)
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(*time));
  else
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // FlexRayController::ReflectAttributeValues

uint32_t FlexRayController::RegisterUpdateCallback(UpdateCallback callback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void FlexRayController::UnregisterUpdateCallback(uint32_t callbackToken)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mUpdateCallbacks.erase(callbackToken);
}

void FlexRayController::ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(std::static_pointer_cast<IFlexRayController>(shared_from_this()), time, orderType);
  }
}


// object class type 'FlexRaySendBuffer'
FlexRaySendBufferObjectClass::FlexRaySendBufferObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, HLAobjectRootObjectClass* baseClass)
{
  mRegistry = registry;
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.FlexRaySendBuffer");
  // attribute Sender : HLAobjectInstanceHandle.FlexRayController
  mSenderAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"Sender");
  // attribute TransmissionMode : FlexRayTransmissionMode
  mTransmissionModeAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"TransmissionMode");
  // attribute Payload : FlexRayPayload
  mPayloadAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"Payload");
  // attribute CycleOffset : HLAoctet
  mCycleOffsetAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"CycleOffset");
  // attribute CycleRepetition : HLAoctet
  mCycleRepetitionAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"CycleRepetition");
  // attribute SlotId : HLAinteger16LE
  mSlotIdAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"SlotId");
  // attribute Channel : FlexRayChannel
  mChannelAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"Channel");
  // attribute PPIndicator : HLAboolean
  mPPIndicatorAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"PPIndicator");
  // attribute HeaderCRC : HLAinteger16LE
  mHeaderCRCAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HeaderCRC");
  SetObjectInstanceCreator([](FlexRaySendBufferObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador) -> FlexRaySendBuffer* {
    return new FlexRaySendBuffer(objectClass, instanceName, rtiAmbassador);
  });
}

FlexRaySendBufferObjectClass::~FlexRaySendBufferObjectClass()
{
  //std::lock_guard<std::recursive_mutex> lock(mMutex);
  while (!mObjectInstancesByHandle.empty())
  {
    // careful - hold the reference to the object instance until it has been removed from the maps,
    // otherwise it's mutex will be destroyed while held
    auto objectInstance = mObjectInstancesByHandle.begin()->second;
    objectInstance->Release();
  }
  assert(mObjectInstancesByHandle.empty());
  assert(mObjectInstancesByName.empty());
}

void FlexRaySendBufferObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void FlexRaySendBufferObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void FlexRaySendBufferObjectClass::Subscribe(bool deliverToSelf)
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    if (deliverToSelf) mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void FlexRaySendBufferObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

rti1516ev::AttributeHandleSet FlexRaySendBufferObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetSenderAttributeHandle());
  result.insert(GetTransmissionModeAttributeHandle());
  result.insert(GetPayloadAttributeHandle());
  result.insert(GetCycleOffsetAttributeHandle());
  result.insert(GetCycleRepetitionAttributeHandle());
  result.insert(GetSlotIdAttributeHandle());
  result.insert(GetChannelAttributeHandle());
  result.insert(GetPPIndicatorAttributeHandle());
  result.insert(GetHeaderCRCAttributeHandle());
  return result;
}

void FlexRaySendBufferObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  assert(mObjectInstancesByName.find(objectInstanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(objectInstanceHandle) == mObjectInstancesByHandle.end());
  std::shared_ptr<FlexRaySendBuffer> newObject = std::shared_ptr<FlexRaySendBuffer>(mCreatorFunction(this, objectInstanceName, mRtiAmbassador));
  newObject->mObjectInstanceHandle = objectInstanceHandle;
  newObject->mIsOwner = false;
  InsertObjectInstanceName(newObject, objectInstanceName);
  InsertObjectInstanceHandle(newObject, objectInstanceHandle);
  ExecuteDiscoverObjectInstanceCallbacks(newObject);
}

void FlexRaySendBufferObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring objectInstanceName = mRtiAmbassador->getObjectInstanceName(objectInstanceHandle);
  auto iter = mObjectInstancesByName.find(objectInstanceName);
  assert(iter != mObjectInstancesByName.end());
  auto objectInstance = std::dynamic_pointer_cast<FlexRaySendBuffer>(iter->second);
  ExecuteRemoveObjectInstanceCallbacks(objectInstance);
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  EraseObjectInstance(objectInstanceHandle, objectInstanceName);
}

std::shared_ptr<IFlexRaySendBuffer> FlexRaySendBufferObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IHLAobjectRoot> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceName);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IFlexRaySendBuffer>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IFlexRaySendBuffer> FlexRaySendBufferObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IHLAobjectRoot> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceHandle);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IFlexRaySendBuffer>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IFlexRaySendBuffer> FlexRaySendBufferObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"FlexRaySendBuffer");
  }
  std::shared_ptr<FlexRaySendBuffer> newObject = std::shared_ptr<FlexRaySendBuffer>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
    }
  });
  return newObject;
}

std::shared_ptr<IFlexRaySendBuffer> FlexRaySendBufferObjectClass::CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"FlexRaySendBuffer");
  }
  std::shared_ptr<FlexRaySendBuffer> newObject = std::shared_ptr<FlexRaySendBuffer>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
      createdCallback(newObject, true);
    }
    else
    {
      createdCallback(newObject, false);
    }
  });
  return newObject;
}

uint32_t FlexRaySendBufferObjectClass::RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastDiscoverObjectInstanceCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastDiscoverObjectInstanceCallbackToken, callback));
  return mLastDiscoverObjectInstanceCallbackToken;
}

void FlexRaySendBufferObjectClass::UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mDiscoverCallbacks.erase(callbackToken);
}

void FlexRaySendBufferObjectClass::ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IFlexRaySendBuffer> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

uint32_t FlexRaySendBufferObjectClass::RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastRemoveObjectInstanceCallbackToken++;
  mRemoveObjectInstanceCallbacks.insert(std::make_pair(mLastRemoveObjectInstanceCallbackToken, callback));
  return mLastRemoveObjectInstanceCallbackToken;
}

void FlexRaySendBufferObjectClass::UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mRemoveObjectInstanceCallbacks.erase(callbackToken);
}

void FlexRaySendBufferObjectClass::ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IFlexRaySendBuffer> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mRemoveObjectInstanceCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

void FlexRaySendBufferObjectClass::InsertObjectInstanceName(std::shared_ptr<IFlexRaySendBuffer> objectInstance, const std::wstring& objectInstanceName)
{
  // prerequisite: mMutex must be locked
  mObjectInstancesByName.insert(std::make_pair(objectInstanceName, objectInstance));
  mBaseClass->InsertObjectInstanceName(objectInstance, objectInstanceName);
}

void FlexRaySendBufferObjectClass::InsertObjectInstanceHandle(std::shared_ptr<IFlexRaySendBuffer> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByHandle.insert(std::make_pair(objectInstanceHandle, objectInstance));
  mBaseClass->InsertObjectInstanceHandle(objectInstance, objectInstanceHandle);
}

void FlexRaySendBufferObjectClass::EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mBaseClass->EraseObjectInstance(objectInstanceHandle, objectInstanceName);
  mObjectInstancesByName.erase(objectInstanceName);
  mObjectInstancesByHandle.erase(objectInstanceHandle);
}


// object instances of type 'FlexRaySendBuffer'
FlexRaySendBuffer::FlexRaySendBuffer()
  : mRtiAmbassador()
  , mObjectClass()
  , mObjectInstanceName()
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

FlexRaySendBuffer::FlexRaySendBuffer(FlexRaySendBufferObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mRtiAmbassador(rtiAmbassador)
  , mObjectClass(objectClass)
  , mObjectInstanceName(instanceName)
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

FlexRaySendBuffer::~FlexRaySendBuffer()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    try
    {
      mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    }
    catch (const rti1516ev::Exception&)
    {
    }
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

bool FlexRaySendBuffer::IsValid() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mObjectInstanceHandle.isValid();
}

bool FlexRaySendBuffer::IsOwner() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mIsOwner;
}

void FlexRaySendBuffer::Release()
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (mObjectInstanceHandle.isValid())
  {
    if (mIsOwner)
    {
      try
      {
        mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
      }
      catch (const rti1516ev::Exception&)
      {
        // ignore - must execute rest of function
      }
      mIsOwner = false;
    }
    mObjectClass->EraseObjectInstance(mObjectInstanceHandle, mObjectInstanceName);
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  }
}

// attribute FlexRaySendBuffer.HLAprivilegeToDeleteObject : no data type

// attribute Sender : HLAobjectInstanceHandle.FlexRayController
IFlexRayController* FlexRaySendBuffer::GetSender() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return static_cast<FlexRayControllerObjectClass*>(GetObjectClassRegistry()->GetFlexRayControllerObjectClass())->GetObjectInstance(mSender.get()).get();
}

void FlexRaySendBuffer::SetSender(IFlexRayController* newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mSender.set(static_cast<FlexRayController*>(newValue)->GetObjectInstanceHandle());
  mDirty |= kSenderBit;
  mValuesSet |= kSenderBit;
}

// attribute TransmissionMode : FlexRayTransmissionMode
FlexRayTransmissionMode FlexRaySendBuffer::GetTransmissionMode() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return static_cast<FlexRayTransmissionMode>(mTransmissionMode.get());
}

void FlexRaySendBuffer::SetTransmissionMode(FlexRayTransmissionMode newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mTransmissionMode.set(static_cast<uint8_t>(newValue));
  mDirty |= kTransmissionModeBit;
  mValuesSet |= kTransmissionModeBit;
}

// attribute Payload : FlexRayPayload
const FlexRayPayload& FlexRaySendBuffer::GetPayload() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mPayload;
}

FlexRayPayload& FlexRaySendBuffer::GetPayload()
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mDirty |= kPayloadBit;
  mValuesSet |= kPayloadBit;
  return mPayload;
}

void FlexRaySendBuffer::SetPayload(const FlexRayPayload& newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mPayload = newValue;
  mDirty |= kPayloadBit;
  mValuesSet |= kPayloadBit;
}

// attribute CycleOffset : HLAoctet
uint8_t FlexRaySendBuffer::GetCycleOffset() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mCycleOffset.get();
}

void FlexRaySendBuffer::SetCycleOffset(uint8_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mCycleOffset.set(newValue);
  mDirty |= kCycleOffsetBit;
  mValuesSet |= kCycleOffsetBit;
}

// attribute CycleRepetition : HLAoctet
uint8_t FlexRaySendBuffer::GetCycleRepetition() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mCycleRepetition.get();
}

void FlexRaySendBuffer::SetCycleRepetition(uint8_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mCycleRepetition.set(newValue);
  mDirty |= kCycleRepetitionBit;
  mValuesSet |= kCycleRepetitionBit;
}

// attribute SlotId : HLAinteger16LE
int16_t FlexRaySendBuffer::GetSlotId() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mSlotId.get();
}

void FlexRaySendBuffer::SetSlotId(int16_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mSlotId.set(newValue);
  mDirty |= kSlotIdBit;
  mValuesSet |= kSlotIdBit;
}

// attribute Channel : FlexRayChannel
FlexRayChannel FlexRaySendBuffer::GetChannel() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return static_cast<FlexRayChannel>(mChannel.get());
}

void FlexRaySendBuffer::SetChannel(FlexRayChannel newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mChannel.set(static_cast<uint8_t>(newValue));
  mDirty |= kChannelBit;
  mValuesSet |= kChannelBit;
}

// attribute PPIndicator : HLAboolean
bool FlexRaySendBuffer::GetPPIndicator() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mPPIndicator.get();
}

void FlexRaySendBuffer::SetPPIndicator(bool newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mPPIndicator.set(newValue);
  mDirty |= kPPIndicatorBit;
  mValuesSet |= kPPIndicatorBit;
}

// attribute HeaderCRC : HLAinteger16LE
int16_t FlexRaySendBuffer::GetHeaderCRC() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHeaderCRC.get();
}

void FlexRaySendBuffer::SetHeaderCRC(int16_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHeaderCRC.set(newValue);
  mDirty |= kHeaderCRCBit;
  mValuesSet |= kHeaderCRCBit;
}

rti1516ev::AttributeHandleValueMap FlexRaySendBuffer::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetSenderAttributeHandle()] = mSender.encode();
  result[mObjectClass->GetTransmissionModeAttributeHandle()] = mTransmissionMode.encode();
  result[mObjectClass->GetPayloadAttributeHandle()] = mPayload.encode();
  result[mObjectClass->GetCycleOffsetAttributeHandle()] = mCycleOffset.encode();
  result[mObjectClass->GetCycleRepetitionAttributeHandle()] = mCycleRepetition.encode();
  result[mObjectClass->GetSlotIdAttributeHandle()] = mSlotId.encode();
  result[mObjectClass->GetChannelAttributeHandle()] = mChannel.encode();
  result[mObjectClass->GetPPIndicatorAttributeHandle()] = mPPIndicator.encode();
  result[mObjectClass->GetHeaderCRCAttributeHandle()] = mHeaderCRC.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap FlexRaySendBuffer::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kSenderBit)
  {
    result[mObjectClass->GetSenderAttributeHandle()] = mSender.encode();
  }
  if (mDirty & kTransmissionModeBit)
  {
    result[mObjectClass->GetTransmissionModeAttributeHandle()] = mTransmissionMode.encode();
  }
  if (mDirty & kPayloadBit)
  {
    result[mObjectClass->GetPayloadAttributeHandle()] = mPayload.encode();
  }
  if (mDirty & kCycleOffsetBit)
  {
    result[mObjectClass->GetCycleOffsetAttributeHandle()] = mCycleOffset.encode();
  }
  if (mDirty & kCycleRepetitionBit)
  {
    result[mObjectClass->GetCycleRepetitionAttributeHandle()] = mCycleRepetition.encode();
  }
  if (mDirty & kSlotIdBit)
  {
    result[mObjectClass->GetSlotIdAttributeHandle()] = mSlotId.encode();
  }
  if (mDirty & kChannelBit)
  {
    result[mObjectClass->GetChannelAttributeHandle()] = mChannel.encode();
  }
  if (mDirty & kPPIndicatorBit)
  {
    result[mObjectClass->GetPPIndicatorAttributeHandle()] = mPPIndicator.encode();
  }
  if (mDirty & kHeaderCRCBit)
  {
    result[mObjectClass->GetHeaderCRCAttributeHandle()] = mHeaderCRC.encode();
  }
  return result;
}

FlexRaySendBuffer::AttributeBits FlexRaySendBuffer::GetReceivedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesReceived;
}

FlexRaySendBuffer::AttributeBits FlexRaySendBuffer::GetUpdatedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mLastUpdated;
}

FlexRaySendBuffer::AttributeBits FlexRaySendBuffer::GetInitializedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesSet;
}

FlexRaySendBuffer::AttributeBits FlexRaySendBuffer::GetModifiedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDirty;
}

void FlexRaySendBuffer::UpdateAllAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void FlexRaySendBuffer::UpdateAllAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    try {
      mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
      mDirty = kNone;
    }
    catch (const rti1516ev::InvalidLogicalTime& e)
    {
      throw InvalidLogicalTime(to_string(e.what()));
    }
    catch (const rti1516ev::Exception& e)
    {
      throw std::runtime_error(to_string(e.what()));
    }
  }
}

void FlexRaySendBuffer::UpdateModifiedAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void FlexRaySendBuffer::UpdateModifiedAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
        mDirty = kNone;
      }
      catch (const rti1516ev::InvalidLogicalTime& e)
      {
        throw InvalidLogicalTime(to_string(e.what()));
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void FlexRaySendBuffer::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetSenderAttributeHandle())
    {
      mSender.decode(attributeHandleValue.second);
      mLastUpdated |= kSenderBit;
    }
    else if (attributeHandle == mObjectClass->GetTransmissionModeAttributeHandle())
    {
      mTransmissionMode.decode(attributeHandleValue.second);
      mLastUpdated |= kTransmissionModeBit;
    }
    else if (attributeHandle == mObjectClass->GetPayloadAttributeHandle())
    {
      mPayload.decode(attributeHandleValue.second);
      mLastUpdated |= kPayloadBit;
    }
    else if (attributeHandle == mObjectClass->GetCycleOffsetAttributeHandle())
    {
      mCycleOffset.decode(attributeHandleValue.second);
      mLastUpdated |= kCycleOffsetBit;
    }
    else if (attributeHandle == mObjectClass->GetCycleRepetitionAttributeHandle())
    {
      mCycleRepetition.decode(attributeHandleValue.second);
      mLastUpdated |= kCycleRepetitionBit;
    }
    else if (attributeHandle == mObjectClass->GetSlotIdAttributeHandle())
    {
      mSlotId.decode(attributeHandleValue.second);
      mLastUpdated |= kSlotIdBit;
    }
    else if (attributeHandle == mObjectClass->GetChannelAttributeHandle())
    {
      mChannel.decode(attributeHandleValue.second);
      mLastUpdated |= kChannelBit;
    }
    else if (attributeHandle == mObjectClass->GetPPIndicatorAttributeHandle())
    {
      mPPIndicator.decode(attributeHandleValue.second);
      mLastUpdated |= kPPIndicatorBit;
    }
    else if (attributeHandle == mObjectClass->GetHeaderCRCAttributeHandle())
    {
      mHeaderCRC.decode(attributeHandleValue.second);
      mLastUpdated |= kHeaderCRCBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(optional<int64_t>(), optional<OrderType>());
  mLastUpdated = kNone;
} // FlexRaySendBuffer::ReflectAttributeValues

void FlexRaySendBuffer::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetSenderAttributeHandle())
    {
      mSender.decode(attributeHandleValue.second);
      mLastUpdated |= kSenderBit;
    }
    else if (attributeHandle == mObjectClass->GetTransmissionModeAttributeHandle())
    {
      mTransmissionMode.decode(attributeHandleValue.second);
      mLastUpdated |= kTransmissionModeBit;
    }
    else if (attributeHandle == mObjectClass->GetPayloadAttributeHandle())
    {
      mPayload.decode(attributeHandleValue.second);
      mLastUpdated |= kPayloadBit;
    }
    else if (attributeHandle == mObjectClass->GetCycleOffsetAttributeHandle())
    {
      mCycleOffset.decode(attributeHandleValue.second);
      mLastUpdated |= kCycleOffsetBit;
    }
    else if (attributeHandle == mObjectClass->GetCycleRepetitionAttributeHandle())
    {
      mCycleRepetition.decode(attributeHandleValue.second);
      mLastUpdated |= kCycleRepetitionBit;
    }
    else if (attributeHandle == mObjectClass->GetSlotIdAttributeHandle())
    {
      mSlotId.decode(attributeHandleValue.second);
      mLastUpdated |= kSlotIdBit;
    }
    else if (attributeHandle == mObjectClass->GetChannelAttributeHandle())
    {
      mChannel.decode(attributeHandleValue.second);
      mLastUpdated |= kChannelBit;
    }
    else if (attributeHandle == mObjectClass->GetPPIndicatorAttributeHandle())
    {
      mPPIndicator.decode(attributeHandleValue.second);
      mLastUpdated |= kPPIndicatorBit;
    }
    else if (attributeHandle == mObjectClass->GetHeaderCRCAttributeHandle())
    {
      mHeaderCRC.decode(attributeHandleValue.second);
      mLastUpdated |= kHeaderCRCBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(static_cast<const rti1516ev::HLAinteger64Time&>(theTime).getTime(), orderType);
  mLastUpdated = kNone;
} // FlexRaySendBuffer::ReflectAttributeValues

// request attributes not being part of the last update
void FlexRaySendBuffer::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    if ((mLastUpdated & kSenderBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetSenderAttributeHandle());
    }
    if ((mLastUpdated & kTransmissionModeBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetTransmissionModeAttributeHandle());
    }
    if ((mLastUpdated & kPayloadBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetPayloadAttributeHandle());
    }
    if ((mLastUpdated & kCycleOffsetBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetCycleOffsetAttributeHandle());
    }
    if ((mLastUpdated & kCycleRepetitionBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetCycleRepetitionAttributeHandle());
    }
    if ((mLastUpdated & kSlotIdBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetSlotIdAttributeHandle());
    }
    if ((mLastUpdated & kChannelBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetChannelAttributeHandle());
    }
    if ((mLastUpdated & kPPIndicatorBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetPPIndicatorAttributeHandle());
    }
    if ((mLastUpdated & kHeaderCRCBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHeaderCRCAttributeHandle());
    }
  } // scope of lock_guard
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// request all attributes, regardless of current state
void FlexRaySendBuffer::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetSenderAttributeHandle());
  requestAttributes.insert(mObjectClass->GetTransmissionModeAttributeHandle());
  requestAttributes.insert(mObjectClass->GetPayloadAttributeHandle());
  requestAttributes.insert(mObjectClass->GetCycleOffsetAttributeHandle());
  requestAttributes.insert(mObjectClass->GetCycleRepetitionAttributeHandle());
  requestAttributes.insert(mObjectClass->GetSlotIdAttributeHandle());
  requestAttributes.insert(mObjectClass->GetChannelAttributeHandle());
  requestAttributes.insert(mObjectClass->GetPPIndicatorAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHeaderCRCAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// provide requested attributes set since last sent update
void FlexRaySendBuffer::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    for (auto& attributeHandle : attributeHandles)
    {
      if (attributeHandle == mObjectClass->GetSenderAttributeHandle() && (mValuesSet & kSenderBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mSender.encode()));
        mDirty &= ~kSenderBit;
      }
      else if (attributeHandle == mObjectClass->GetTransmissionModeAttributeHandle() && (mValuesSet & kTransmissionModeBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mTransmissionMode.encode()));
        mDirty &= ~kTransmissionModeBit;
      }
      else if (attributeHandle == mObjectClass->GetPayloadAttributeHandle() && (mValuesSet & kPayloadBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mPayload.encode()));
        mDirty &= ~kPayloadBit;
      }
      else if (attributeHandle == mObjectClass->GetCycleOffsetAttributeHandle() && (mValuesSet & kCycleOffsetBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mCycleOffset.encode()));
        mDirty &= ~kCycleOffsetBit;
      }
      else if (attributeHandle == mObjectClass->GetCycleRepetitionAttributeHandle() && (mValuesSet & kCycleRepetitionBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mCycleRepetition.encode()));
        mDirty &= ~kCycleRepetitionBit;
      }
      else if (attributeHandle == mObjectClass->GetSlotIdAttributeHandle() && (mValuesSet & kSlotIdBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mSlotId.encode()));
        mDirty &= ~kSlotIdBit;
      }
      else if (attributeHandle == mObjectClass->GetChannelAttributeHandle() && (mValuesSet & kChannelBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mChannel.encode()));
        mDirty &= ~kChannelBit;
      }
      else if (attributeHandle == mObjectClass->GetPPIndicatorAttributeHandle() && (mValuesSet & kPPIndicatorBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mPPIndicator.encode()));
        mDirty &= ~kPPIndicatorBit;
      }
      else if (attributeHandle == mObjectClass->GetHeaderCRCAttributeHandle() && (mValuesSet & kHeaderCRCBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHeaderCRC.encode()));
        mDirty &= ~kHeaderCRCBit;
      }
    } // for (auto& attributeHandleValue : attributes)
  } // scope of lock_guard
  if (time)
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(*time));
  else
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // FlexRaySendBuffer::ReflectAttributeValues

uint32_t FlexRaySendBuffer::RegisterUpdateCallback(UpdateCallback callback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void FlexRaySendBuffer::UnregisterUpdateCallback(uint32_t callbackToken)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mUpdateCallbacks.erase(callbackToken);
}

void FlexRaySendBuffer::ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(std::static_pointer_cast<IFlexRaySendBuffer>(shared_from_this()), time, orderType);
  }
}


 

ObjectClassRegistry::ObjectClassRegistry()
  : mRtiAmbassador(nullptr)
{
}

ObjectClassRegistry::~ObjectClassRegistry()
{
}

void ObjectClassRegistry::Initialize(rti1516ev::RTIambassador* rtiAmbassador)
{
  mRtiAmbassador = rtiAmbassador;
  try
  {
    mHLAobjectRootObjectClass = std::unique_ptr<HLAobjectRootObjectClass>(new HLAobjectRootObjectClass(mRtiAmbassador, this));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mHLAobjectRootObjectClass.get() != nullptr);
    mSystemVariableObjectClass = std::unique_ptr<SystemVariableObjectClass>(new SystemVariableObjectClass(mRtiAmbassador, this, mHLAobjectRootObjectClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mHLAobjectRootObjectClass.get() != nullptr);
    mValueEntityObjectClass = std::unique_ptr<ValueEntityObjectClass>(new ValueEntityObjectClass(mRtiAmbassador, this, mHLAobjectRootObjectClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mHLAobjectRootObjectClass.get() != nullptr);
    mDOMemberSourceObjectClass = std::unique_ptr<DOMemberSourceObjectClass>(new DOMemberSourceObjectClass(mRtiAmbassador, this, mHLAobjectRootObjectClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mHLAobjectRootObjectClass.get() != nullptr);
    mDOMemberTargetObjectClass = std::unique_ptr<DOMemberTargetObjectClass>(new DOMemberTargetObjectClass(mRtiAmbassador, this, mHLAobjectRootObjectClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mHLAobjectRootObjectClass.get() != nullptr);
    mBusManagementObjectClass = std::unique_ptr<BusManagementObjectClass>(new BusManagementObjectClass(mRtiAmbassador, this, mHLAobjectRootObjectClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mBusManagementObjectClass.get() != nullptr);
    mBusManagementCanObjectClass = std::unique_ptr<BusManagementCanObjectClass>(new BusManagementCanObjectClass(mRtiAmbassador, this, mBusManagementObjectClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mBusManagementObjectClass.get() != nullptr);
    mBusManagementEthernetObjectClass = std::unique_ptr<BusManagementEthernetObjectClass>(new BusManagementEthernetObjectClass(mRtiAmbassador, this, mBusManagementObjectClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mBusManagementObjectClass.get() != nullptr);
    mFlexRayClusterObjectClass = std::unique_ptr<FlexRayClusterObjectClass>(new FlexRayClusterObjectClass(mRtiAmbassador, this, mBusManagementObjectClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mHLAobjectRootObjectClass.get() != nullptr);
    mBusControllerObjectClass = std::unique_ptr<BusControllerObjectClass>(new BusControllerObjectClass(mRtiAmbassador, this, mHLAobjectRootObjectClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mBusControllerObjectClass.get() != nullptr);
    mBusControllerCanObjectClass = std::unique_ptr<BusControllerCanObjectClass>(new BusControllerCanObjectClass(mRtiAmbassador, this, mBusControllerObjectClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mBusControllerObjectClass.get() != nullptr);
    mBusControllerEthernetObjectClass = std::unique_ptr<BusControllerEthernetObjectClass>(new BusControllerEthernetObjectClass(mRtiAmbassador, this, mBusControllerObjectClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mBusControllerObjectClass.get() != nullptr);
    mFlexRayControllerStatusObjectClass = std::unique_ptr<FlexRayControllerStatusObjectClass>(new FlexRayControllerStatusObjectClass(mRtiAmbassador, this, mBusControllerObjectClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mBusControllerObjectClass.get() != nullptr);
    mFlexRayControllerObjectClass = std::unique_ptr<FlexRayControllerObjectClass>(new FlexRayControllerObjectClass(mRtiAmbassador, this, mBusControllerObjectClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mHLAobjectRootObjectClass.get() != nullptr);
    mFlexRaySendBufferObjectClass = std::unique_ptr<FlexRaySendBufferObjectClass>(new FlexRaySendBufferObjectClass(mRtiAmbassador, this, mHLAobjectRootObjectClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
} // Initialize

void ObjectClassRegistry::Finalize()
{
  mFlexRaySendBufferObjectClass.reset();
  mFlexRayControllerObjectClass.reset();
  mFlexRayControllerStatusObjectClass.reset();
  mBusControllerEthernetObjectClass.reset();
  mBusControllerCanObjectClass.reset();
  mBusControllerObjectClass.reset();
  mFlexRayClusterObjectClass.reset();
  mBusManagementEthernetObjectClass.reset();
  mBusManagementCanObjectClass.reset();
  mBusManagementObjectClass.reset();
  mDOMemberTargetObjectClass.reset();
  mDOMemberSourceObjectClass.reset();
  mValueEntityObjectClass.reset();
  mSystemVariableObjectClass.reset();
  mHLAobjectRootObjectClass.reset();
  mRtiAmbassador = nullptr;
} // Initialize

void ObjectClassRegistry::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  rti1516ev::ObjectClassHandle theObjectClass = mRtiAmbassador->getKnownObjectClassHandle(theObject);
  if (mHLAobjectRootObjectClass != nullptr && theObjectClass == mHLAobjectRootObjectClass->GetObjectClassHandle())
  {
    mHLAobjectRootObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (mSystemVariableObjectClass != nullptr && theObjectClass == mSystemVariableObjectClass->GetObjectClassHandle())
  {
    mSystemVariableObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (mValueEntityObjectClass != nullptr && theObjectClass == mValueEntityObjectClass->GetObjectClassHandle())
  {
    mValueEntityObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (mDOMemberSourceObjectClass != nullptr && theObjectClass == mDOMemberSourceObjectClass->GetObjectClassHandle())
  {
    mDOMemberSourceObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (mDOMemberTargetObjectClass != nullptr && theObjectClass == mDOMemberTargetObjectClass->GetObjectClassHandle())
  {
    mDOMemberTargetObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (mBusManagementObjectClass != nullptr && theObjectClass == mBusManagementObjectClass->GetObjectClassHandle())
  {
    mBusManagementObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (mBusManagementCanObjectClass != nullptr && theObjectClass == mBusManagementCanObjectClass->GetObjectClassHandle())
  {
    mBusManagementCanObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (mBusManagementEthernetObjectClass != nullptr && theObjectClass == mBusManagementEthernetObjectClass->GetObjectClassHandle())
  {
    mBusManagementEthernetObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (mFlexRayClusterObjectClass != nullptr && theObjectClass == mFlexRayClusterObjectClass->GetObjectClassHandle())
  {
    mFlexRayClusterObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (mBusControllerObjectClass != nullptr && theObjectClass == mBusControllerObjectClass->GetObjectClassHandle())
  {
    mBusControllerObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (mBusControllerCanObjectClass != nullptr && theObjectClass == mBusControllerCanObjectClass->GetObjectClassHandle())
  {
    mBusControllerCanObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (mBusControllerEthernetObjectClass != nullptr && theObjectClass == mBusControllerEthernetObjectClass->GetObjectClassHandle())
  {
    mBusControllerEthernetObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (mFlexRayControllerStatusObjectClass != nullptr && theObjectClass == mFlexRayControllerStatusObjectClass->GetObjectClassHandle())
  {
    mFlexRayControllerStatusObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (mFlexRayControllerObjectClass != nullptr && theObjectClass == mFlexRayControllerObjectClass->GetObjectClassHandle())
  {
    mFlexRayControllerObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
  else if (mFlexRaySendBufferObjectClass != nullptr && theObjectClass == mFlexRaySendBufferObjectClass->GetObjectClassHandle())
  {
    mFlexRaySendBufferObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
}

void ObjectClassRegistry::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  rti1516ev::ObjectClassHandle theObjectClass = mRtiAmbassador->getKnownObjectClassHandle(theObject);
  if (mHLAobjectRootObjectClass != nullptr && theObjectClass == mHLAobjectRootObjectClass->GetObjectClassHandle())
  {
    mHLAobjectRootObjectClass->RemoveObjectInstance(theObject);
  }
  else if (mSystemVariableObjectClass != nullptr && theObjectClass == mSystemVariableObjectClass->GetObjectClassHandle())
  {
    mSystemVariableObjectClass->RemoveObjectInstance(theObject);
  }
  else if (mValueEntityObjectClass != nullptr && theObjectClass == mValueEntityObjectClass->GetObjectClassHandle())
  {
    mValueEntityObjectClass->RemoveObjectInstance(theObject);
  }
  else if (mDOMemberSourceObjectClass != nullptr && theObjectClass == mDOMemberSourceObjectClass->GetObjectClassHandle())
  {
    mDOMemberSourceObjectClass->RemoveObjectInstance(theObject);
  }
  else if (mDOMemberTargetObjectClass != nullptr && theObjectClass == mDOMemberTargetObjectClass->GetObjectClassHandle())
  {
    mDOMemberTargetObjectClass->RemoveObjectInstance(theObject);
  }
  else if (mBusManagementObjectClass != nullptr && theObjectClass == mBusManagementObjectClass->GetObjectClassHandle())
  {
    mBusManagementObjectClass->RemoveObjectInstance(theObject);
  }
  else if (mBusManagementCanObjectClass != nullptr && theObjectClass == mBusManagementCanObjectClass->GetObjectClassHandle())
  {
    mBusManagementCanObjectClass->RemoveObjectInstance(theObject);
  }
  else if (mBusManagementEthernetObjectClass != nullptr && theObjectClass == mBusManagementEthernetObjectClass->GetObjectClassHandle())
  {
    mBusManagementEthernetObjectClass->RemoveObjectInstance(theObject);
  }
  else if (mFlexRayClusterObjectClass != nullptr && theObjectClass == mFlexRayClusterObjectClass->GetObjectClassHandle())
  {
    mFlexRayClusterObjectClass->RemoveObjectInstance(theObject);
  }
  else if (mBusControllerObjectClass != nullptr && theObjectClass == mBusControllerObjectClass->GetObjectClassHandle())
  {
    mBusControllerObjectClass->RemoveObjectInstance(theObject);
  }
  else if (mBusControllerCanObjectClass != nullptr && theObjectClass == mBusControllerCanObjectClass->GetObjectClassHandle())
  {
    mBusControllerCanObjectClass->RemoveObjectInstance(theObject);
  }
  else if (mBusControllerEthernetObjectClass != nullptr && theObjectClass == mBusControllerEthernetObjectClass->GetObjectClassHandle())
  {
    mBusControllerEthernetObjectClass->RemoveObjectInstance(theObject);
  }
  else if (mFlexRayControllerStatusObjectClass != nullptr && theObjectClass == mFlexRayControllerStatusObjectClass->GetObjectClassHandle())
  {
    mFlexRayControllerStatusObjectClass->RemoveObjectInstance(theObject);
  }
  else if (mFlexRayControllerObjectClass != nullptr && theObjectClass == mFlexRayControllerObjectClass->GetObjectClassHandle())
  {
    mFlexRayControllerObjectClass->RemoveObjectInstance(theObject);
  }
  else if (mFlexRaySendBufferObjectClass != nullptr && theObjectClass == mFlexRaySendBufferObjectClass->GetObjectClassHandle())
  {
    mFlexRaySendBufferObjectClass->RemoveObjectInstance(theObject);
  }
}

void ObjectClassRegistry::ReflectAttributeValues(rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  rti1516ev::ObjectClassHandle theObjectClass = mRtiAmbassador->getKnownObjectClassHandle(theObject);
  if (mSystemVariableObjectClass != nullptr && theObjectClass == mSystemVariableObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<SystemVariable>(mSystemVariableObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (mValueEntityObjectClass != nullptr && theObjectClass == mValueEntityObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<ValueEntity>(mValueEntityObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (mDOMemberSourceObjectClass != nullptr && theObjectClass == mDOMemberSourceObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<DOMemberSource>(mDOMemberSourceObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (mDOMemberTargetObjectClass != nullptr && theObjectClass == mDOMemberTargetObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<DOMemberTarget>(mDOMemberTargetObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (mBusManagementObjectClass != nullptr && theObjectClass == mBusManagementObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<BusManagement>(mBusManagementObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (mBusManagementCanObjectClass != nullptr && theObjectClass == mBusManagementCanObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<BusManagementCan>(mBusManagementCanObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (mBusManagementEthernetObjectClass != nullptr && theObjectClass == mBusManagementEthernetObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<BusManagementEthernet>(mBusManagementEthernetObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (mFlexRayClusterObjectClass != nullptr && theObjectClass == mFlexRayClusterObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<FlexRayCluster>(mFlexRayClusterObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (mBusControllerObjectClass != nullptr && theObjectClass == mBusControllerObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<BusController>(mBusControllerObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (mBusControllerCanObjectClass != nullptr && theObjectClass == mBusControllerCanObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<BusControllerCan>(mBusControllerCanObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (mBusControllerEthernetObjectClass != nullptr && theObjectClass == mBusControllerEthernetObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<BusControllerEthernet>(mBusControllerEthernetObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (mFlexRayControllerStatusObjectClass != nullptr && theObjectClass == mFlexRayControllerStatusObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<FlexRayControllerStatus>(mFlexRayControllerStatusObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (mFlexRayControllerObjectClass != nullptr && theObjectClass == mFlexRayControllerObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<FlexRayController>(mFlexRayControllerObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
  else if (mFlexRaySendBufferObjectClass != nullptr && theObjectClass == mFlexRaySendBufferObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<FlexRaySendBuffer>(mFlexRaySendBufferObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
}

void ObjectClassRegistry::ReflectAttributeValues(rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  rti1516ev::ObjectClassHandle theObjectClass = mRtiAmbassador->getKnownObjectClassHandle(theObject);
  if (mSystemVariableObjectClass != nullptr && theObjectClass == mSystemVariableObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<SystemVariable>(mSystemVariableObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes, theTime, orderType);
  }
  else if (mValueEntityObjectClass != nullptr && theObjectClass == mValueEntityObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<ValueEntity>(mValueEntityObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes, theTime, orderType);
  }
  else if (mDOMemberSourceObjectClass != nullptr && theObjectClass == mDOMemberSourceObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<DOMemberSource>(mDOMemberSourceObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes, theTime, orderType);
  }
  else if (mDOMemberTargetObjectClass != nullptr && theObjectClass == mDOMemberTargetObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<DOMemberTarget>(mDOMemberTargetObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes, theTime, orderType);
  }
  else if (mBusManagementObjectClass != nullptr && theObjectClass == mBusManagementObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<BusManagement>(mBusManagementObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes, theTime, orderType);
  }
  else if (mBusManagementCanObjectClass != nullptr && theObjectClass == mBusManagementCanObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<BusManagementCan>(mBusManagementCanObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes, theTime, orderType);
  }
  else if (mBusManagementEthernetObjectClass != nullptr && theObjectClass == mBusManagementEthernetObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<BusManagementEthernet>(mBusManagementEthernetObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes, theTime, orderType);
  }
  else if (mFlexRayClusterObjectClass != nullptr && theObjectClass == mFlexRayClusterObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<FlexRayCluster>(mFlexRayClusterObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes, theTime, orderType);
  }
  else if (mBusControllerObjectClass != nullptr && theObjectClass == mBusControllerObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<BusController>(mBusControllerObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes, theTime, orderType);
  }
  else if (mBusControllerCanObjectClass != nullptr && theObjectClass == mBusControllerCanObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<BusControllerCan>(mBusControllerCanObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes, theTime, orderType);
  }
  else if (mBusControllerEthernetObjectClass != nullptr && theObjectClass == mBusControllerEthernetObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<BusControllerEthernet>(mBusControllerEthernetObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes, theTime, orderType);
  }
  else if (mFlexRayControllerStatusObjectClass != nullptr && theObjectClass == mFlexRayControllerStatusObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<FlexRayControllerStatus>(mFlexRayControllerStatusObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes, theTime, orderType);
  }
  else if (mFlexRayControllerObjectClass != nullptr && theObjectClass == mFlexRayControllerObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<FlexRayController>(mFlexRayControllerObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes, theTime, orderType);
  }
  else if (mFlexRaySendBufferObjectClass != nullptr && theObjectClass == mFlexRaySendBufferObjectClass->GetObjectClassHandle())
  {
    std::static_pointer_cast<FlexRaySendBuffer>(mFlexRaySendBufferObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes, theTime, orderType);
  }
}

void ObjectClassRegistry::ProvideAttributeValues(rti1516ev::ObjectClassHandle theObjectClass, rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  if (mSystemVariableObjectClass != nullptr && theObjectClass == mSystemVariableObjectClass->GetObjectClassHandle())
  {
    auto objectInstance = std::static_pointer_cast<SystemVariable>(mSystemVariableObjectClass->GetObjectInstance(theObject));
    if (objectInstance != nullptr)
    {
      objectInstance->ProvideAttributeValues(attributeHandles, time);
    }
  }
  else if (mValueEntityObjectClass != nullptr && theObjectClass == mValueEntityObjectClass->GetObjectClassHandle())
  {
    auto objectInstance = std::static_pointer_cast<ValueEntity>(mValueEntityObjectClass->GetObjectInstance(theObject));
    if (objectInstance != nullptr)
    {
      objectInstance->ProvideAttributeValues(attributeHandles, time);
    }
  }
  else if (mDOMemberSourceObjectClass != nullptr && theObjectClass == mDOMemberSourceObjectClass->GetObjectClassHandle())
  {
    auto objectInstance = std::static_pointer_cast<DOMemberSource>(mDOMemberSourceObjectClass->GetObjectInstance(theObject));
    if (objectInstance != nullptr)
    {
      objectInstance->ProvideAttributeValues(attributeHandles, time);
    }
  }
  else if (mDOMemberTargetObjectClass != nullptr && theObjectClass == mDOMemberTargetObjectClass->GetObjectClassHandle())
  {
    auto objectInstance = std::static_pointer_cast<DOMemberTarget>(mDOMemberTargetObjectClass->GetObjectInstance(theObject));
    if (objectInstance != nullptr)
    {
      objectInstance->ProvideAttributeValues(attributeHandles, time);
    }
  }
  else if (mBusManagementObjectClass != nullptr && theObjectClass == mBusManagementObjectClass->GetObjectClassHandle())
  {
    auto objectInstance = std::static_pointer_cast<BusManagement>(mBusManagementObjectClass->GetObjectInstance(theObject));
    if (objectInstance != nullptr)
    {
      objectInstance->ProvideAttributeValues(attributeHandles, time);
    }
  }
  else if (mBusManagementCanObjectClass != nullptr && theObjectClass == mBusManagementCanObjectClass->GetObjectClassHandle())
  {
    auto objectInstance = std::static_pointer_cast<BusManagementCan>(mBusManagementCanObjectClass->GetObjectInstance(theObject));
    if (objectInstance != nullptr)
    {
      objectInstance->ProvideAttributeValues(attributeHandles, time);
    }
  }
  else if (mBusManagementEthernetObjectClass != nullptr && theObjectClass == mBusManagementEthernetObjectClass->GetObjectClassHandle())
  {
    auto objectInstance = std::static_pointer_cast<BusManagementEthernet>(mBusManagementEthernetObjectClass->GetObjectInstance(theObject));
    if (objectInstance != nullptr)
    {
      objectInstance->ProvideAttributeValues(attributeHandles, time);
    }
  }
  else if (mFlexRayClusterObjectClass != nullptr && theObjectClass == mFlexRayClusterObjectClass->GetObjectClassHandle())
  {
    auto objectInstance = std::static_pointer_cast<FlexRayCluster>(mFlexRayClusterObjectClass->GetObjectInstance(theObject));
    if (objectInstance != nullptr)
    {
      objectInstance->ProvideAttributeValues(attributeHandles, time);
    }
  }
  else if (mBusControllerObjectClass != nullptr && theObjectClass == mBusControllerObjectClass->GetObjectClassHandle())
  {
    auto objectInstance = std::static_pointer_cast<BusController>(mBusControllerObjectClass->GetObjectInstance(theObject));
    if (objectInstance != nullptr)
    {
      objectInstance->ProvideAttributeValues(attributeHandles, time);
    }
  }
  else if (mBusControllerCanObjectClass != nullptr && theObjectClass == mBusControllerCanObjectClass->GetObjectClassHandle())
  {
    auto objectInstance = std::static_pointer_cast<BusControllerCan>(mBusControllerCanObjectClass->GetObjectInstance(theObject));
    if (objectInstance != nullptr)
    {
      objectInstance->ProvideAttributeValues(attributeHandles, time);
    }
  }
  else if (mBusControllerEthernetObjectClass != nullptr && theObjectClass == mBusControllerEthernetObjectClass->GetObjectClassHandle())
  {
    auto objectInstance = std::static_pointer_cast<BusControllerEthernet>(mBusControllerEthernetObjectClass->GetObjectInstance(theObject));
    if (objectInstance != nullptr)
    {
      objectInstance->ProvideAttributeValues(attributeHandles, time);
    }
  }
  else if (mFlexRayControllerStatusObjectClass != nullptr && theObjectClass == mFlexRayControllerStatusObjectClass->GetObjectClassHandle())
  {
    auto objectInstance = std::static_pointer_cast<FlexRayControllerStatus>(mFlexRayControllerStatusObjectClass->GetObjectInstance(theObject));
    if (objectInstance != nullptr)
    {
      objectInstance->ProvideAttributeValues(attributeHandles, time);
    }
  }
  else if (mFlexRayControllerObjectClass != nullptr && theObjectClass == mFlexRayControllerObjectClass->GetObjectClassHandle())
  {
    auto objectInstance = std::static_pointer_cast<FlexRayController>(mFlexRayControllerObjectClass->GetObjectInstance(theObject));
    if (objectInstance != nullptr)
    {
      objectInstance->ProvideAttributeValues(attributeHandles, time);
    }
  }
  else if (mFlexRaySendBufferObjectClass != nullptr && theObjectClass == mFlexRaySendBufferObjectClass->GetObjectClassHandle())
  {
    auto objectInstance = std::static_pointer_cast<FlexRaySendBuffer>(mFlexRaySendBufferObjectClass->GetObjectInstance(theObject));
    if (objectInstance != nullptr)
    {
      objectInstance->ProvideAttributeValues(attributeHandles, time);
    }
  }
}

void ObjectClassRegistry::RegisterObjectInstanceName(const std::wstring& theObjectInstanceName, std::function<void(bool)> completionCallback)
{
  mObjectInstanceNameReservationCallbacks.insert(std::make_pair(theObjectInstanceName, completionCallback));
  mRtiAmbassador->reserveObjectInstanceName(theObjectInstanceName);
}

void ObjectClassRegistry::ObjectInstanceNameReservationSucceeded(const std::wstring& theObjectInstanceName)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  auto iter = mObjectInstanceNameReservationCallbacks.find(theObjectInstanceName);
  if (iter != mObjectInstanceNameReservationCallbacks.end())
  {
    iter->second(true);
    mObjectInstanceNameReservationCallbacks.erase(iter);
  }
}

void ObjectClassRegistry::ObjectInstanceNameReservationFailed(const std::wstring& theObjectInstanceName)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  auto iter = mObjectInstanceNameReservationCallbacks.find(theObjectInstanceName);
  if (iter != mObjectInstanceNameReservationCallbacks.end())
  {
    iter->second(false);
    mObjectInstanceNameReservationCallbacks.erase(iter);
  }
}

} // namespace NDistSimIB
} // namespace NRTFederateEncoding
