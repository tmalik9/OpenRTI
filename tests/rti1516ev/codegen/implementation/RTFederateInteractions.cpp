
// Code automatically generated by FOMCodeGen version 2.0.4.0 from RTFederate.xml, do not edit

#include <vector>
#include <cassert>

#include "RTI/time/HLAinteger64Time.h"

#include "RTFederateInteractions.h"
#include "RTFederateObjects.h"

namespace NDistSimIB {
namespace NRTFederateEncoding {

inline std::string to_string(const std::wstring& str)
{
  if (str.empty()) return std::string();
  const std::ctype<wchar_t>& CType = std::use_facet<std::ctype<wchar_t> >(std::locale());
  std::vector<char> stringBuffer(str.length());
  CType.narrow(str.data(), str.data() + str.length(), '_', &stringBuffer[0]);
  return std::string(&stringBuffer[0], stringBuffer.size());
}

HLAinteractionRootInteractionClass::HLAinteractionRootInteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry)
{
  mInteractionClassRegistry = interactionClassRegistry;
  mRtiAmbassador = rtiAmbassador;

  mInteractionClassHandle = rtiAmbassador->getInteractionClassHandle(L"HLAinteractionRoot");
}

// get the corresponding *object* class registry, for access to objects sent as parameters
ObjectClassRegistry* HLAinteractionRootInteractionClass::GetObjectClassRegistry()
{
  return mInteractionClassRegistry->GetObjectClassRegistry();
}

void HLAinteractionRootInteractionClass::Publish()
{
  if (!mPublished)
  {
    mRtiAmbassador->publishInteractionClass(mInteractionClassHandle);
    mPublished = true;
  }
}

void HLAinteractionRootInteractionClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishInteractionClass(mInteractionClassHandle);
    mPublished = false;
  }
}

void HLAinteractionRootInteractionClass::Subscribe(bool deliverToSelf)
{
  mRtiAmbassador->subscribeInteractionClass(mInteractionClassHandle);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  mSubscribed = true;
}


void HLAinteractionRootInteractionClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeInteractionClass(mInteractionClassHandle);
    mSubscribed = false;
  }
}

void HLAinteractionRootInteractionClass::send()
{
  rti1516ev::ParameterHandleValueMap parameters;
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData());
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void HLAinteractionRootInteractionClass::sendWithTime(int64_t time)
{
  rti1516ev::ParameterHandleValueMap parameters;
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
  }
  catch (const rti1516ev::InvalidLogicalTime& e)
  {
    throw InvalidLogicalTime(to_string(e.what()));
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void HLAinteractionRootInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap&)
{
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(optional<int64_t>(), optional<OrderType>());
  }
}

void HLAinteractionRootInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap&, const rti1516ev::LogicalTime& time, OrderType orderType)
{

  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  }
}

uint32_t HLAinteractionRootInteractionClass::RegisterReceiveCallback(ReceiveCallback callback)
{
  uint32_t key = mReceiveCallbacksNextKey++;
  mReceiveCallbacks.insert(std::make_pair(key, callback));
  return key;
}

rti1516ev::ParameterHandleSet HLAinteractionRootInteractionClass::GetAllParameterHandles()
{
  rti1516ev::ParameterHandleSet result;
  return result;
}

// object class type 'MeasurementInit'
MeasurementInitInteractionClass::MeasurementInitInteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry, HLAinteractionRootInteractionClass* baseClass)
{
  mInteractionClassRegistry = interactionClassRegistry;
  mRtiAmbassador = rtiAmbassador;

  mBaseClass = baseClass;
  mInteractionClassHandle = rtiAmbassador->getInteractionClassHandle(L"HLAinteractionRoot.MeasurementInit");
  // parameter MeasurementInit.Dummy : no data type
  mDummyParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Dummy");
}

// get the corresponding *object* class registry, for access to objects sent as parameters
ObjectClassRegistry* MeasurementInitInteractionClass::GetObjectClassRegistry()
{
  return mInteractionClassRegistry->GetObjectClassRegistry();
}

void MeasurementInitInteractionClass::Publish()
{
  if (!mPublished)
  {
    mRtiAmbassador->publishInteractionClass(mInteractionClassHandle);
    mPublished = true;
  }
}

void MeasurementInitInteractionClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishInteractionClass(mInteractionClassHandle);
    mPublished = false;
  }
}

void MeasurementInitInteractionClass::Subscribe(bool deliverToSelf)
{
  mRtiAmbassador->subscribeInteractionClass(mInteractionClassHandle);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  mSubscribed = true;
}


void MeasurementInitInteractionClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeInteractionClass(mInteractionClassHandle);
    mSubscribed = false;
  }
}

void MeasurementInitInteractionClass::send()
{
  rti1516ev::ParameterHandleValueMap parameters;
  parameters.insert(std::make_pair(GetDummyParameterHandle(), rti1516ev::VariableLengthData()));
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData());
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void MeasurementInitInteractionClass::sendWithTime(int64_t time)
{
  rti1516ev::ParameterHandleValueMap parameters;
  parameters.insert(std::make_pair(GetDummyParameterHandle(), rti1516ev::VariableLengthData()));
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
  }
  catch (const rti1516ev::InvalidLogicalTime& e)
  {
    throw InvalidLogicalTime(to_string(e.what()));
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void MeasurementInitInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap&)
{
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(optional<int64_t>(), optional<OrderType>());
  }
}

void MeasurementInitInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap&, const rti1516ev::LogicalTime& time, OrderType orderType)
{

  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  }
}

uint32_t MeasurementInitInteractionClass::RegisterReceiveCallback(ReceiveCallback callback)
{
  uint32_t key = mReceiveCallbacksNextKey++;
  mReceiveCallbacks.insert(std::make_pair(key, callback));
  return key;
}

rti1516ev::ParameterHandleSet MeasurementInitInteractionClass::GetAllParameterHandles()
{
  rti1516ev::ParameterHandleSet result;
  result.insert(GetDummyParameterHandle());
  return result;
}

// object class type 'MeasurementStop'
MeasurementStopInteractionClass::MeasurementStopInteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry, HLAinteractionRootInteractionClass* baseClass)
{
  mInteractionClassRegistry = interactionClassRegistry;
  mRtiAmbassador = rtiAmbassador;

  mBaseClass = baseClass;
  mInteractionClassHandle = rtiAmbassador->getInteractionClassHandle(L"HLAinteractionRoot.MeasurementStop");
  // parameter NextFederationSuffix : HLAunicodeString
  mNextFederationSuffixParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"NextFederationSuffix");
}

// get the corresponding *object* class registry, for access to objects sent as parameters
ObjectClassRegistry* MeasurementStopInteractionClass::GetObjectClassRegistry()
{
  return mInteractionClassRegistry->GetObjectClassRegistry();
}

void MeasurementStopInteractionClass::Publish()
{
  if (!mPublished)
  {
    mRtiAmbassador->publishInteractionClass(mInteractionClassHandle);
    mPublished = true;
  }
}

void MeasurementStopInteractionClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishInteractionClass(mInteractionClassHandle);
    mPublished = false;
  }
}

void MeasurementStopInteractionClass::Subscribe(bool deliverToSelf)
{
  mRtiAmbassador->subscribeInteractionClass(mInteractionClassHandle);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  mSubscribed = true;
}

void MeasurementStopInteractionClass::Subscribe(optional<std::wstring> NextFederationSuffix, bool deliverToSelf)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (NextFederationSuffix)
  {
    rti1516ev::HLAunicodeString NextFederationSuffixEncoder(*NextFederationSuffix);
    parameters.insert(std::make_pair(GetNextFederationSuffixParameterHandle(), NextFederationSuffixEncoder.encode()));
  }
  mRtiAmbassador->subscribeInteractionClassWithFilter(mInteractionClassHandle, parameters);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  // we must always set mSubscribed, otherwise we can't unsubscribe
  mSubscribed = true;
}

void MeasurementStopInteractionClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeInteractionClass(mInteractionClassHandle);
    mSubscribed = false;
  }
}

void MeasurementStopInteractionClass::send(optional<std::wstring> NextFederationSuffix)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (NextFederationSuffix)
  {
    rti1516ev::HLAunicodeString NextFederationSuffixEncoder(*NextFederationSuffix);
    parameters.insert(std::make_pair(GetNextFederationSuffixParameterHandle(), NextFederationSuffixEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData());
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void MeasurementStopInteractionClass::sendWithTime(optional<std::wstring> NextFederationSuffix, int64_t time)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (NextFederationSuffix)
  {
    rti1516ev::HLAunicodeString NextFederationSuffixEncoder(*NextFederationSuffix);
    parameters.insert(std::make_pair(GetNextFederationSuffixParameterHandle(), NextFederationSuffixEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
  }
  catch (const rti1516ev::InvalidLogicalTime& e)
  {
    throw InvalidLogicalTime(to_string(e.what()));
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void MeasurementStopInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters )
{
  optional<std::wstring> NextFederationSuffix;
  rti1516ev::HLAunicodeString NextFederationSuffixDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator NextFederationSuffixIter = parameters.find(GetNextFederationSuffixParameterHandle());
  if (NextFederationSuffixIter != parameters.end())
  {
    NextFederationSuffixDecoder.decode(NextFederationSuffixIter->second);
    NextFederationSuffix = NextFederationSuffixDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(NextFederationSuffix, optional<int64_t>(), optional<OrderType>());
  }
}

void MeasurementStopInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters , const rti1516ev::LogicalTime& time, OrderType orderType)
{
  optional<std::wstring> NextFederationSuffix;

  rti1516ev::HLAunicodeString NextFederationSuffixDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator NextFederationSuffixIter = parameters.find(GetNextFederationSuffixParameterHandle());
  if (NextFederationSuffixIter != parameters.end())
  {
    NextFederationSuffixDecoder.decode(NextFederationSuffixIter->second);
    NextFederationSuffix = NextFederationSuffixDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(NextFederationSuffix, static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  }
}

uint32_t MeasurementStopInteractionClass::RegisterReceiveCallback(ReceiveCallback callback)
{
  uint32_t key = mReceiveCallbacksNextKey++;
  mReceiveCallbacks.insert(std::make_pair(key, callback));
  return key;
}

rti1516ev::ParameterHandleSet MeasurementStopInteractionClass::GetAllParameterHandles()
{
  rti1516ev::ParameterHandleSet result;
  result.insert(GetNextFederationSuffixParameterHandle());
  return result;
}

// object class type 'KeyEvent'
KeyEventInteractionClass::KeyEventInteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry, HLAinteractionRootInteractionClass* baseClass)
{
  mInteractionClassRegistry = interactionClassRegistry;
  mRtiAmbassador = rtiAmbassador;

  mBaseClass = baseClass;
  mInteractionClassHandle = rtiAmbassador->getInteractionClassHandle(L"HLAinteractionRoot.KeyEvent");
  // parameter KeyCode : HLAinteger32LE
  mKeyCodeParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"KeyCode");
}

// get the corresponding *object* class registry, for access to objects sent as parameters
ObjectClassRegistry* KeyEventInteractionClass::GetObjectClassRegistry()
{
  return mInteractionClassRegistry->GetObjectClassRegistry();
}

void KeyEventInteractionClass::Publish()
{
  if (!mPublished)
  {
    mRtiAmbassador->publishInteractionClass(mInteractionClassHandle);
    mPublished = true;
  }
}

void KeyEventInteractionClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishInteractionClass(mInteractionClassHandle);
    mPublished = false;
  }
}

void KeyEventInteractionClass::Subscribe(bool deliverToSelf)
{
  mRtiAmbassador->subscribeInteractionClass(mInteractionClassHandle);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  mSubscribed = true;
}

void KeyEventInteractionClass::Subscribe(optional<int32_t> KeyCode, bool deliverToSelf)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (KeyCode)
  {
    rti1516ev::HLAinteger32LE KeyCodeEncoder(*KeyCode);
    parameters.insert(std::make_pair(GetKeyCodeParameterHandle(), KeyCodeEncoder.encode()));
  }
  mRtiAmbassador->subscribeInteractionClassWithFilter(mInteractionClassHandle, parameters);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  // we must always set mSubscribed, otherwise we can't unsubscribe
  mSubscribed = true;
}

void KeyEventInteractionClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeInteractionClass(mInteractionClassHandle);
    mSubscribed = false;
  }
}

void KeyEventInteractionClass::send(optional<int32_t> KeyCode)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (KeyCode)
  {
    rti1516ev::HLAinteger32LE KeyCodeEncoder(*KeyCode);
    parameters.insert(std::make_pair(GetKeyCodeParameterHandle(), KeyCodeEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData());
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void KeyEventInteractionClass::sendWithTime(optional<int32_t> KeyCode, int64_t time)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (KeyCode)
  {
    rti1516ev::HLAinteger32LE KeyCodeEncoder(*KeyCode);
    parameters.insert(std::make_pair(GetKeyCodeParameterHandle(), KeyCodeEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
  }
  catch (const rti1516ev::InvalidLogicalTime& e)
  {
    throw InvalidLogicalTime(to_string(e.what()));
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void KeyEventInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters )
{
  optional<int32_t> KeyCode;
  rti1516ev::HLAinteger32LE KeyCodeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator KeyCodeIter = parameters.find(GetKeyCodeParameterHandle());
  if (KeyCodeIter != parameters.end())
  {
    KeyCodeDecoder.decode(KeyCodeIter->second);
    KeyCode = KeyCodeDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(KeyCode, optional<int64_t>(), optional<OrderType>());
  }
}

void KeyEventInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters , const rti1516ev::LogicalTime& time, OrderType orderType)
{
  optional<int32_t> KeyCode;

  rti1516ev::HLAinteger32LE KeyCodeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator KeyCodeIter = parameters.find(GetKeyCodeParameterHandle());
  if (KeyCodeIter != parameters.end())
  {
    KeyCodeDecoder.decode(KeyCodeIter->second);
    KeyCode = KeyCodeDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(KeyCode, static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  }
}

uint32_t KeyEventInteractionClass::RegisterReceiveCallback(ReceiveCallback callback)
{
  uint32_t key = mReceiveCallbacksNextKey++;
  mReceiveCallbacks.insert(std::make_pair(key, callback));
  return key;
}

rti1516ev::ParameterHandleSet KeyEventInteractionClass::GetAllParameterHandles()
{
  rti1516ev::ParameterHandleSet result;
  result.insert(GetKeyCodeParameterHandle());
  return result;
}

// object class type 'TextLog'
TextLogInteractionClass::TextLogInteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry, HLAinteractionRootInteractionClass* baseClass)
{
  mInteractionClassRegistry = interactionClassRegistry;
  mRtiAmbassador = rtiAmbassador;

  mBaseClass = baseClass;
  mInteractionClassHandle = rtiAmbassador->getInteractionClassHandle(L"HLAinteractionRoot.TextLog");
  // parameter Sender : HLAunicodeString
  mSenderParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Sender");
  // parameter Text : HLAunicodeString
  mTextParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Text");
}

// get the corresponding *object* class registry, for access to objects sent as parameters
ObjectClassRegistry* TextLogInteractionClass::GetObjectClassRegistry()
{
  return mInteractionClassRegistry->GetObjectClassRegistry();
}

void TextLogInteractionClass::Publish()
{
  if (!mPublished)
  {
    mRtiAmbassador->publishInteractionClass(mInteractionClassHandle);
    mPublished = true;
  }
}

void TextLogInteractionClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishInteractionClass(mInteractionClassHandle);
    mPublished = false;
  }
}

void TextLogInteractionClass::Subscribe(bool deliverToSelf)
{
  mRtiAmbassador->subscribeInteractionClass(mInteractionClassHandle);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  mSubscribed = true;
}

void TextLogInteractionClass::Subscribe(optional<std::wstring> Sender, optional<std::wstring> Text, bool deliverToSelf)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (Sender)
  {
    rti1516ev::HLAunicodeString SenderEncoder(*Sender);
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Text)
  {
    rti1516ev::HLAunicodeString TextEncoder(*Text);
    parameters.insert(std::make_pair(GetTextParameterHandle(), TextEncoder.encode()));
  }
  mRtiAmbassador->subscribeInteractionClassWithFilter(mInteractionClassHandle, parameters);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  // we must always set mSubscribed, otherwise we can't unsubscribe
  mSubscribed = true;
}

void TextLogInteractionClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeInteractionClass(mInteractionClassHandle);
    mSubscribed = false;
  }
}

void TextLogInteractionClass::send(optional<std::wstring> Sender, optional<std::wstring> Text)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (Sender)
  {
    rti1516ev::HLAunicodeString SenderEncoder(*Sender);
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Text)
  {
    rti1516ev::HLAunicodeString TextEncoder(*Text);
    parameters.insert(std::make_pair(GetTextParameterHandle(), TextEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData());
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void TextLogInteractionClass::sendWithTime(optional<std::wstring> Sender, optional<std::wstring> Text, int64_t time)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (Sender)
  {
    rti1516ev::HLAunicodeString SenderEncoder(*Sender);
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Text)
  {
    rti1516ev::HLAunicodeString TextEncoder(*Text);
    parameters.insert(std::make_pair(GetTextParameterHandle(), TextEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
  }
  catch (const rti1516ev::InvalidLogicalTime& e)
  {
    throw InvalidLogicalTime(to_string(e.what()));
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void TextLogInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters )
{
  optional<std::wstring> Sender;
  optional<std::wstring> Text;
  rti1516ev::HLAunicodeString SenderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SenderIter = parameters.find(GetSenderParameterHandle());
  if (SenderIter != parameters.end())
  {
    SenderDecoder.decode(SenderIter->second);
    Sender = SenderDecoder.get();
  }
  rti1516ev::HLAunicodeString TextDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator TextIter = parameters.find(GetTextParameterHandle());
  if (TextIter != parameters.end())
  {
    TextDecoder.decode(TextIter->second);
    Text = TextDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(Sender, Text, optional<int64_t>(), optional<OrderType>());
  }
}

void TextLogInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters , const rti1516ev::LogicalTime& time, OrderType orderType)
{
  optional<std::wstring> Sender;
  optional<std::wstring> Text;

  rti1516ev::HLAunicodeString SenderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SenderIter = parameters.find(GetSenderParameterHandle());
  if (SenderIter != parameters.end())
  {
    SenderDecoder.decode(SenderIter->second);
    Sender = SenderDecoder.get();
  }
  rti1516ev::HLAunicodeString TextDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator TextIter = parameters.find(GetTextParameterHandle());
  if (TextIter != parameters.end())
  {
    TextDecoder.decode(TextIter->second);
    Text = TextDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(Sender, Text, static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  }
}

uint32_t TextLogInteractionClass::RegisterReceiveCallback(ReceiveCallback callback)
{
  uint32_t key = mReceiveCallbacksNextKey++;
  mReceiveCallbacks.insert(std::make_pair(key, callback));
  return key;
}

rti1516ev::ParameterHandleSet TextLogInteractionClass::GetAllParameterHandles()
{
  rti1516ev::ParameterHandleSet result;
  result.insert(GetSenderParameterHandle());
  result.insert(GetTextParameterHandle());
  return result;
}

// object class type 'SystemVariableUpdate'
SystemVariableUpdateInteractionClass::SystemVariableUpdateInteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry, HLAinteractionRootInteractionClass* baseClass)
{
  mInteractionClassRegistry = interactionClassRegistry;
  mRtiAmbassador = rtiAmbassador;

  mBaseClass = baseClass;
  mInteractionClassHandle = rtiAmbassador->getInteractionClassHandle(L"HLAinteractionRoot.SystemVariableUpdate");
  // parameter Id : HLAASCIIstring
  mIdParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Id");
  // parameter Value : HLAopaqueData
  mValueParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Value");
  // parameter Client : HLAinteger32LE
  mClientParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Client");
  // parameter HasChanged : HLAboolean
  mHasChangedParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"HasChanged");
}

// get the corresponding *object* class registry, for access to objects sent as parameters
ObjectClassRegistry* SystemVariableUpdateInteractionClass::GetObjectClassRegistry()
{
  return mInteractionClassRegistry->GetObjectClassRegistry();
}

void SystemVariableUpdateInteractionClass::Publish()
{
  if (!mPublished)
  {
    mRtiAmbassador->publishInteractionClass(mInteractionClassHandle);
    mPublished = true;
  }
}

void SystemVariableUpdateInteractionClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishInteractionClass(mInteractionClassHandle);
    mPublished = false;
  }
}

void SystemVariableUpdateInteractionClass::Subscribe(bool deliverToSelf)
{
  mRtiAmbassador->subscribeInteractionClass(mInteractionClassHandle);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  mSubscribed = true;
}

void SystemVariableUpdateInteractionClass::Subscribe(optional<std::string> Id, optional<const std::vector<uint8_t>&> Value, optional<int32_t> Client, optional<bool> HasChanged, bool deliverToSelf)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (Id)
  {
    rti1516ev::HLAASCIIstring IdEncoder(*Id);
    parameters.insert(std::make_pair(GetIdParameterHandle(), IdEncoder.encode()));
  }
  if (Value)
  {
    rti1516ev::HLAopaqueData ValueEncoder(*Value);
    parameters.insert(std::make_pair(GetValueParameterHandle(), ValueEncoder.encode()));
  }
  if (Client)
  {
    rti1516ev::HLAinteger32LE ClientEncoder(*Client);
    parameters.insert(std::make_pair(GetClientParameterHandle(), ClientEncoder.encode()));
  }
  if (HasChanged)
  {
    rti1516ev::HLAboolean HasChangedEncoder(*HasChanged);
    parameters.insert(std::make_pair(GetHasChangedParameterHandle(), HasChangedEncoder.encode()));
  }
  mRtiAmbassador->subscribeInteractionClassWithFilter(mInteractionClassHandle, parameters);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  // we must always set mSubscribed, otherwise we can't unsubscribe
  mSubscribed = true;
}

void SystemVariableUpdateInteractionClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeInteractionClass(mInteractionClassHandle);
    mSubscribed = false;
  }
}

void SystemVariableUpdateInteractionClass::send(optional<std::string> Id, optional<const std::vector<uint8_t>&> Value, optional<int32_t> Client, optional<bool> HasChanged)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (Id)
  {
    rti1516ev::HLAASCIIstring IdEncoder(*Id);
    parameters.insert(std::make_pair(GetIdParameterHandle(), IdEncoder.encode()));
  }
  if (Value)
  {
    rti1516ev::HLAopaqueData ValueEncoder(*Value);
    parameters.insert(std::make_pair(GetValueParameterHandle(), ValueEncoder.encode()));
  }
  if (Client)
  {
    rti1516ev::HLAinteger32LE ClientEncoder(*Client);
    parameters.insert(std::make_pair(GetClientParameterHandle(), ClientEncoder.encode()));
  }
  if (HasChanged)
  {
    rti1516ev::HLAboolean HasChangedEncoder(*HasChanged);
    parameters.insert(std::make_pair(GetHasChangedParameterHandle(), HasChangedEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData());
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void SystemVariableUpdateInteractionClass::sendWithTime(optional<std::string> Id, optional<const std::vector<uint8_t>&> Value, optional<int32_t> Client, optional<bool> HasChanged, int64_t time)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (Id)
  {
    rti1516ev::HLAASCIIstring IdEncoder(*Id);
    parameters.insert(std::make_pair(GetIdParameterHandle(), IdEncoder.encode()));
  }
  if (Value)
  {
    rti1516ev::HLAopaqueData ValueEncoder(*Value);
    parameters.insert(std::make_pair(GetValueParameterHandle(), ValueEncoder.encode()));
  }
  if (Client)
  {
    rti1516ev::HLAinteger32LE ClientEncoder(*Client);
    parameters.insert(std::make_pair(GetClientParameterHandle(), ClientEncoder.encode()));
  }
  if (HasChanged)
  {
    rti1516ev::HLAboolean HasChangedEncoder(*HasChanged);
    parameters.insert(std::make_pair(GetHasChangedParameterHandle(), HasChangedEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
  }
  catch (const rti1516ev::InvalidLogicalTime& e)
  {
    throw InvalidLogicalTime(to_string(e.what()));
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void SystemVariableUpdateInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters )
{
  optional<std::string> Id;
  optional<const std::vector<uint8_t>&> Value;
  optional<int32_t> Client;
  optional<bool> HasChanged;
  rti1516ev::HLAASCIIstring IdDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IdIter = parameters.find(GetIdParameterHandle());
  if (IdIter != parameters.end())
  {
    IdDecoder.decode(IdIter->second);
    Id = IdDecoder.get();
  }
  rti1516ev::HLAopaqueData ValueDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ValueIter = parameters.find(GetValueParameterHandle());
  if (ValueIter != parameters.end())
  {
    ValueDecoder.decode(ValueIter->second);
    Value = ValueDecoder.get();
  }
  rti1516ev::HLAinteger32LE ClientDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ClientIter = parameters.find(GetClientParameterHandle());
  if (ClientIter != parameters.end())
  {
    ClientDecoder.decode(ClientIter->second);
    Client = ClientDecoder.get();
  }
  rti1516ev::HLAboolean HasChangedDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator HasChangedIter = parameters.find(GetHasChangedParameterHandle());
  if (HasChangedIter != parameters.end())
  {
    HasChangedDecoder.decode(HasChangedIter->second);
    HasChanged = HasChangedDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(Id, Value, Client, HasChanged, optional<int64_t>(), optional<OrderType>());
  }
}

void SystemVariableUpdateInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters , const rti1516ev::LogicalTime& time, OrderType orderType)
{
  optional<std::string> Id;
  optional<const std::vector<uint8_t>&> Value;
  optional<int32_t> Client;
  optional<bool> HasChanged;

  rti1516ev::HLAASCIIstring IdDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IdIter = parameters.find(GetIdParameterHandle());
  if (IdIter != parameters.end())
  {
    IdDecoder.decode(IdIter->second);
    Id = IdDecoder.get();
  }
  rti1516ev::HLAopaqueData ValueDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ValueIter = parameters.find(GetValueParameterHandle());
  if (ValueIter != parameters.end())
  {
    ValueDecoder.decode(ValueIter->second);
    Value = ValueDecoder.get();
  }
  rti1516ev::HLAinteger32LE ClientDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ClientIter = parameters.find(GetClientParameterHandle());
  if (ClientIter != parameters.end())
  {
    ClientDecoder.decode(ClientIter->second);
    Client = ClientDecoder.get();
  }
  rti1516ev::HLAboolean HasChangedDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator HasChangedIter = parameters.find(GetHasChangedParameterHandle());
  if (HasChangedIter != parameters.end())
  {
    HasChangedDecoder.decode(HasChangedIter->second);
    HasChanged = HasChangedDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(Id, Value, Client, HasChanged, static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  }
}

uint32_t SystemVariableUpdateInteractionClass::RegisterReceiveCallback(ReceiveCallback callback)
{
  uint32_t key = mReceiveCallbacksNextKey++;
  mReceiveCallbacks.insert(std::make_pair(key, callback));
  return key;
}

rti1516ev::ParameterHandleSet SystemVariableUpdateInteractionClass::GetAllParameterHandles()
{
  rti1516ev::ParameterHandleSet result;
  result.insert(GetIdParameterHandle());
  result.insert(GetValueParameterHandle());
  result.insert(GetClientParameterHandle());
  result.insert(GetHasChangedParameterHandle());
  return result;
}

// object class type 'SystemVariableModification'
SystemVariableModificationInteractionClass::SystemVariableModificationInteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry, HLAinteractionRootInteractionClass* baseClass)
{
  mInteractionClassRegistry = interactionClassRegistry;
  mRtiAmbassador = rtiAmbassador;

  mBaseClass = baseClass;
  mInteractionClassHandle = rtiAmbassador->getInteractionClassHandle(L"HLAinteractionRoot.SystemVariableModification");
  // parameter Value : HLAopaqueData
  mValueParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Value");
}

// get the corresponding *object* class registry, for access to objects sent as parameters
ObjectClassRegistry* SystemVariableModificationInteractionClass::GetObjectClassRegistry()
{
  return mInteractionClassRegistry->GetObjectClassRegistry();
}

void SystemVariableModificationInteractionClass::Publish()
{
  if (!mPublished)
  {
    mRtiAmbassador->publishInteractionClass(mInteractionClassHandle);
    mPublished = true;
  }
}

void SystemVariableModificationInteractionClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishInteractionClass(mInteractionClassHandle);
    mPublished = false;
  }
}

void SystemVariableModificationInteractionClass::Subscribe(bool deliverToSelf)
{
  mRtiAmbassador->subscribeInteractionClass(mInteractionClassHandle);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  mSubscribed = true;
}

void SystemVariableModificationInteractionClass::Subscribe(optional<const std::vector<uint8_t>&> Value, bool deliverToSelf)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (Value)
  {
    rti1516ev::HLAopaqueData ValueEncoder(*Value);
    parameters.insert(std::make_pair(GetValueParameterHandle(), ValueEncoder.encode()));
  }
  mRtiAmbassador->subscribeInteractionClassWithFilter(mInteractionClassHandle, parameters);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  // we must always set mSubscribed, otherwise we can't unsubscribe
  mSubscribed = true;
}

void SystemVariableModificationInteractionClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeInteractionClass(mInteractionClassHandle);
    mSubscribed = false;
  }
}

void SystemVariableModificationInteractionClass::send(optional<const std::vector<uint8_t>&> Value)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (Value)
  {
    rti1516ev::HLAopaqueData ValueEncoder(*Value);
    parameters.insert(std::make_pair(GetValueParameterHandle(), ValueEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData());
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void SystemVariableModificationInteractionClass::sendWithTime(optional<const std::vector<uint8_t>&> Value, int64_t time)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (Value)
  {
    rti1516ev::HLAopaqueData ValueEncoder(*Value);
    parameters.insert(std::make_pair(GetValueParameterHandle(), ValueEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
  }
  catch (const rti1516ev::InvalidLogicalTime& e)
  {
    throw InvalidLogicalTime(to_string(e.what()));
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void SystemVariableModificationInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters )
{
  optional<const std::vector<uint8_t>&> Value;
  rti1516ev::HLAopaqueData ValueDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ValueIter = parameters.find(GetValueParameterHandle());
  if (ValueIter != parameters.end())
  {
    ValueDecoder.decode(ValueIter->second);
    Value = ValueDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(Value, optional<int64_t>(), optional<OrderType>());
  }
}

void SystemVariableModificationInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters , const rti1516ev::LogicalTime& time, OrderType orderType)
{
  optional<const std::vector<uint8_t>&> Value;

  rti1516ev::HLAopaqueData ValueDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ValueIter = parameters.find(GetValueParameterHandle());
  if (ValueIter != parameters.end())
  {
    ValueDecoder.decode(ValueIter->second);
    Value = ValueDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(Value, static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  }
}

uint32_t SystemVariableModificationInteractionClass::RegisterReceiveCallback(ReceiveCallback callback)
{
  uint32_t key = mReceiveCallbacksNextKey++;
  mReceiveCallbacks.insert(std::make_pair(key, callback));
  return key;
}

rti1516ev::ParameterHandleSet SystemVariableModificationInteractionClass::GetAllParameterHandles()
{
  rti1516ev::ParameterHandleSet result;
  result.insert(GetValueParameterHandle());
  return result;
}

// object class type 'ValueEntityUpdate'
ValueEntityUpdateInteractionClass::ValueEntityUpdateInteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry, HLAinteractionRootInteractionClass* baseClass)
{
  mInteractionClassRegistry = interactionClassRegistry;
  mRtiAmbassador = rtiAmbassador;

  mBaseClass = baseClass;
  mInteractionClassHandle = rtiAmbassador->getInteractionClassHandle(L"HLAinteractionRoot.ValueEntityUpdate");
  // parameter Id : HLAopaqueData
  mIdParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Id");
  // parameter Value : HLAopaqueData
  mValueParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Value");
}

// get the corresponding *object* class registry, for access to objects sent as parameters
ObjectClassRegistry* ValueEntityUpdateInteractionClass::GetObjectClassRegistry()
{
  return mInteractionClassRegistry->GetObjectClassRegistry();
}

void ValueEntityUpdateInteractionClass::Publish()
{
  if (!mPublished)
  {
    mRtiAmbassador->publishInteractionClass(mInteractionClassHandle);
    mPublished = true;
  }
}

void ValueEntityUpdateInteractionClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishInteractionClass(mInteractionClassHandle);
    mPublished = false;
  }
}

void ValueEntityUpdateInteractionClass::Subscribe(bool deliverToSelf)
{
  mRtiAmbassador->subscribeInteractionClass(mInteractionClassHandle);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  mSubscribed = true;
}

void ValueEntityUpdateInteractionClass::Subscribe(optional<const std::vector<uint8_t>&> Id, optional<const std::vector<uint8_t>&> Value, bool deliverToSelf)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (Id)
  {
    rti1516ev::HLAopaqueData IdEncoder(*Id);
    parameters.insert(std::make_pair(GetIdParameterHandle(), IdEncoder.encode()));
  }
  if (Value)
  {
    rti1516ev::HLAopaqueData ValueEncoder(*Value);
    parameters.insert(std::make_pair(GetValueParameterHandle(), ValueEncoder.encode()));
  }
  mRtiAmbassador->subscribeInteractionClassWithFilter(mInteractionClassHandle, parameters);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  // we must always set mSubscribed, otherwise we can't unsubscribe
  mSubscribed = true;
}

void ValueEntityUpdateInteractionClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeInteractionClass(mInteractionClassHandle);
    mSubscribed = false;
  }
}

void ValueEntityUpdateInteractionClass::send(optional<const std::vector<uint8_t>&> Id, optional<const std::vector<uint8_t>&> Value)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (Id)
  {
    rti1516ev::HLAopaqueData IdEncoder(*Id);
    parameters.insert(std::make_pair(GetIdParameterHandle(), IdEncoder.encode()));
  }
  if (Value)
  {
    rti1516ev::HLAopaqueData ValueEncoder(*Value);
    parameters.insert(std::make_pair(GetValueParameterHandle(), ValueEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData());
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void ValueEntityUpdateInteractionClass::sendWithTime(optional<const std::vector<uint8_t>&> Id, optional<const std::vector<uint8_t>&> Value, int64_t time)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (Id)
  {
    rti1516ev::HLAopaqueData IdEncoder(*Id);
    parameters.insert(std::make_pair(GetIdParameterHandle(), IdEncoder.encode()));
  }
  if (Value)
  {
    rti1516ev::HLAopaqueData ValueEncoder(*Value);
    parameters.insert(std::make_pair(GetValueParameterHandle(), ValueEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
  }
  catch (const rti1516ev::InvalidLogicalTime& e)
  {
    throw InvalidLogicalTime(to_string(e.what()));
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void ValueEntityUpdateInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters )
{
  optional<const std::vector<uint8_t>&> Id;
  optional<const std::vector<uint8_t>&> Value;
  rti1516ev::HLAopaqueData IdDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IdIter = parameters.find(GetIdParameterHandle());
  if (IdIter != parameters.end())
  {
    IdDecoder.decode(IdIter->second);
    Id = IdDecoder.get();
  }
  rti1516ev::HLAopaqueData ValueDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ValueIter = parameters.find(GetValueParameterHandle());
  if (ValueIter != parameters.end())
  {
    ValueDecoder.decode(ValueIter->second);
    Value = ValueDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(Id, Value, optional<int64_t>(), optional<OrderType>());
  }
}

void ValueEntityUpdateInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters , const rti1516ev::LogicalTime& time, OrderType orderType)
{
  optional<const std::vector<uint8_t>&> Id;
  optional<const std::vector<uint8_t>&> Value;

  rti1516ev::HLAopaqueData IdDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IdIter = parameters.find(GetIdParameterHandle());
  if (IdIter != parameters.end())
  {
    IdDecoder.decode(IdIter->second);
    Id = IdDecoder.get();
  }
  rti1516ev::HLAopaqueData ValueDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ValueIter = parameters.find(GetValueParameterHandle());
  if (ValueIter != parameters.end())
  {
    ValueDecoder.decode(ValueIter->second);
    Value = ValueDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(Id, Value, static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  }
}

uint32_t ValueEntityUpdateInteractionClass::RegisterReceiveCallback(ReceiveCallback callback)
{
  uint32_t key = mReceiveCallbacksNextKey++;
  mReceiveCallbacks.insert(std::make_pair(key, callback));
  return key;
}

rti1516ev::ParameterHandleSet ValueEntityUpdateInteractionClass::GetAllParameterHandles()
{
  rti1516ev::ParameterHandleSet result;
  result.insert(GetIdParameterHandle());
  result.insert(GetValueParameterHandle());
  return result;
}

// object class type 'BusMessage'
BusMessageInteractionClass::BusMessageInteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry, HLAinteractionRootInteractionClass* baseClass)
{
  mInteractionClassRegistry = interactionClassRegistry;
  mRtiAmbassador = rtiAmbassador;

  mBaseClass = baseClass;
  mInteractionClassHandle = rtiAmbassador->getInteractionClassHandle(L"HLAinteractionRoot.BusMessage");
  // parameter IsRequest : HLAboolean
  mIsRequestParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"IsRequest");
  // parameter ChannelName : HLAASCIIstring
  mChannelNameParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"ChannelName");
  // parameter BusType : BusType
  mBusTypeParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"BusType");
  // parameter RequestingFederate : HLAobjectInstanceHandle.BusController
  mRequestingFederateParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"RequestingFederate");
  // parameter Sender : HLAobjectInstanceHandle.BusController
  mSenderParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Sender");
  // parameter Receiver : HLAobjectInstanceHandle.BusController
  mReceiverParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Receiver");
}

// get the corresponding *object* class registry, for access to objects sent as parameters
ObjectClassRegistry* BusMessageInteractionClass::GetObjectClassRegistry()
{
  return mInteractionClassRegistry->GetObjectClassRegistry();
}

void BusMessageInteractionClass::Publish()
{
  if (!mPublished)
  {
    mRtiAmbassador->publishInteractionClass(mInteractionClassHandle);
    mPublished = true;
  }
}

void BusMessageInteractionClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishInteractionClass(mInteractionClassHandle);
    mPublished = false;
  }
}

void BusMessageInteractionClass::Subscribe(bool deliverToSelf)
{
  mRtiAmbassador->subscribeInteractionClass(mInteractionClassHandle);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  mSubscribed = true;
}

void BusMessageInteractionClass::Subscribe(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, bool deliverToSelf)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  mRtiAmbassador->subscribeInteractionClassWithFilter(mInteractionClassHandle, parameters);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  // we must always set mSubscribed, otherwise we can't unsubscribe
  mSubscribed = true;
}

void BusMessageInteractionClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeInteractionClass(mInteractionClassHandle);
    mSubscribed = false;
  }
}

void BusMessageInteractionClass::send(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData());
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void BusMessageInteractionClass::sendWithTime(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, int64_t time)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
  }
  catch (const rti1516ev::InvalidLogicalTime& e)
  {
    throw InvalidLogicalTime(to_string(e.what()));
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void BusMessageInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters )
{
  optional<bool> IsRequest;
  optional<std::string> ChannelName;
  optional<BusType> BusTypeP;
  optional<IBusController*> RequestingFederate;
  optional<IBusController*> Sender;
  optional<IBusController*> Receiver;
  rti1516ev::HLAboolean IsRequestDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IsRequestIter = parameters.find(GetIsRequestParameterHandle());
  if (IsRequestIter != parameters.end())
  {
    IsRequestDecoder.decode(IsRequestIter->second);
    IsRequest = IsRequestDecoder.get();
  }
  rti1516ev::HLAASCIIstring ChannelNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ChannelNameIter = parameters.find(GetChannelNameParameterHandle());
  if (ChannelNameIter != parameters.end())
  {
    ChannelNameDecoder.decode(ChannelNameIter->second);
    ChannelName = ChannelNameDecoder.get();
  }
  rti1516ev::HLAinteger32LE BusTypeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator BusTypeIter = parameters.find(GetBusTypeParameterHandle());
  if (BusTypeIter != parameters.end())
  {
    BusTypeDecoder.decode(BusTypeIter->second);
    BusTypeP = static_cast<BusType>(BusTypeDecoder.get());
  }
  rti1516ev::HLAobjectInstanceHandle RequestingFederateDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator RequestingFederateIter = parameters.find(GetRequestingFederateParameterHandle());
  if (RequestingFederateIter != parameters.end())
  {
    RequestingFederateDecoder.decode(RequestingFederateIter->second);
    RequestingFederate = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(RequestingFederateDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle SenderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SenderIter = parameters.find(GetSenderParameterHandle());
  if (SenderIter != parameters.end())
  {
    SenderDecoder.decode(SenderIter->second);
    Sender = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(SenderDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle ReceiverDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ReceiverIter = parameters.find(GetReceiverParameterHandle());
  if (ReceiverIter != parameters.end())
  {
    ReceiverDecoder.decode(ReceiverIter->second);
    Receiver = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(ReceiverDecoder.get()).get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(IsRequest, ChannelName, BusTypeP, RequestingFederate, Sender, Receiver, optional<int64_t>(), optional<OrderType>());
  }
}

void BusMessageInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters , const rti1516ev::LogicalTime& time, OrderType orderType)
{
  optional<bool> IsRequest;
  optional<std::string> ChannelName;
  optional<BusType> BusTypeP;
  optional<IBusController*> RequestingFederate;
  optional<IBusController*> Sender;
  optional<IBusController*> Receiver;

  rti1516ev::HLAboolean IsRequestDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IsRequestIter = parameters.find(GetIsRequestParameterHandle());
  if (IsRequestIter != parameters.end())
  {
    IsRequestDecoder.decode(IsRequestIter->second);
    IsRequest = IsRequestDecoder.get();
  }
  rti1516ev::HLAASCIIstring ChannelNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ChannelNameIter = parameters.find(GetChannelNameParameterHandle());
  if (ChannelNameIter != parameters.end())
  {
    ChannelNameDecoder.decode(ChannelNameIter->second);
    ChannelName = ChannelNameDecoder.get();
  }
  rti1516ev::HLAinteger32LE BusTypeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator BusTypeIter = parameters.find(GetBusTypeParameterHandle());
  if (BusTypeIter != parameters.end())
  {
    BusTypeDecoder.decode(BusTypeIter->second);
    BusTypeP = static_cast<BusType>(BusTypeDecoder.get());
  }
  rti1516ev::HLAobjectInstanceHandle RequestingFederateDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator RequestingFederateIter = parameters.find(GetRequestingFederateParameterHandle());
  if (RequestingFederateIter != parameters.end())
  {
    RequestingFederateDecoder.decode(RequestingFederateIter->second);
    RequestingFederate = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(RequestingFederateDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle SenderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SenderIter = parameters.find(GetSenderParameterHandle());
  if (SenderIter != parameters.end())
  {
    SenderDecoder.decode(SenderIter->second);
    Sender = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(SenderDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle ReceiverDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ReceiverIter = parameters.find(GetReceiverParameterHandle());
  if (ReceiverIter != parameters.end())
  {
    ReceiverDecoder.decode(ReceiverIter->second);
    Receiver = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(ReceiverDecoder.get()).get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(IsRequest, ChannelName, BusTypeP, RequestingFederate, Sender, Receiver, static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  }
}

uint32_t BusMessageInteractionClass::RegisterReceiveCallback(ReceiveCallback callback)
{
  uint32_t key = mReceiveCallbacksNextKey++;
  mReceiveCallbacks.insert(std::make_pair(key, callback));
  return key;
}

rti1516ev::ParameterHandleSet BusMessageInteractionClass::GetAllParameterHandles()
{
  rti1516ev::ParameterHandleSet result;
  result.insert(GetIsRequestParameterHandle());
  result.insert(GetChannelNameParameterHandle());
  result.insert(GetBusTypeParameterHandle());
  result.insert(GetRequestingFederateParameterHandle());
  result.insert(GetSenderParameterHandle());
  result.insert(GetReceiverParameterHandle());
  return result;
}

// object class type 'EthPacket'
EthPacketInteractionClass::EthPacketInteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry, BusMessageInteractionClass* baseClass)
{
  mInteractionClassRegistry = interactionClassRegistry;
  mRtiAmbassador = rtiAmbassador;

  mBaseClass = baseClass;
  mInteractionClassHandle = rtiAmbassador->getInteractionClassHandle(L"HLAinteractionRoot.BusMessage.EthPacket");
  // parameter Frame : EthernetPacket
  mFrameParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Frame");
  // parameter PortName : HLAASCIIstring
  mPortNameParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"PortName");
}

// get the corresponding *object* class registry, for access to objects sent as parameters
ObjectClassRegistry* EthPacketInteractionClass::GetObjectClassRegistry()
{
  return mInteractionClassRegistry->GetObjectClassRegistry();
}

void EthPacketInteractionClass::Publish()
{
  if (!mPublished)
  {
    mRtiAmbassador->publishInteractionClass(mInteractionClassHandle);
    mPublished = true;
  }
}

void EthPacketInteractionClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishInteractionClass(mInteractionClassHandle);
    mPublished = false;
  }
}

void EthPacketInteractionClass::Subscribe(bool deliverToSelf)
{
  mRtiAmbassador->subscribeInteractionClass(mInteractionClassHandle);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  mSubscribed = true;
}

void EthPacketInteractionClass::Subscribe(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacket&> Frame, optional<std::string> PortName, bool deliverToSelf)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (Frame)
  {
    const EthernetPacketEncoding& FrameEncoder = static_cast<const EthernetPacketEncoding&>(*Frame);
    parameters.insert(std::make_pair(GetFrameParameterHandle(), FrameEncoder.encode()));
  }
  if (PortName)
  {
    rti1516ev::HLAASCIIstring PortNameEncoder(*PortName);
    parameters.insert(std::make_pair(GetPortNameParameterHandle(), PortNameEncoder.encode()));
  }
  mRtiAmbassador->subscribeInteractionClassWithFilter(mInteractionClassHandle, parameters);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  // we must always set mSubscribed, otherwise we can't unsubscribe
  mSubscribed = true;
}

void EthPacketInteractionClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeInteractionClass(mInteractionClassHandle);
    mSubscribed = false;
  }
}

void EthPacketInteractionClass::send(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacket&> Frame, optional<std::string> PortName)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (Frame)
  {
    const EthernetPacketEncoding& FrameEncoder = static_cast<const EthernetPacketEncoding&>(*Frame);
    parameters.insert(std::make_pair(GetFrameParameterHandle(), FrameEncoder.encode()));
  }
  if (PortName)
  {
    rti1516ev::HLAASCIIstring PortNameEncoder(*PortName);
    parameters.insert(std::make_pair(GetPortNameParameterHandle(), PortNameEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData());
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void EthPacketInteractionClass::sendWithTime(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacket&> Frame, optional<std::string> PortName, int64_t time)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (Frame)
  {
    const EthernetPacketEncoding& FrameEncoder = static_cast<const EthernetPacketEncoding&>(*Frame);
    parameters.insert(std::make_pair(GetFrameParameterHandle(), FrameEncoder.encode()));
  }
  if (PortName)
  {
    rti1516ev::HLAASCIIstring PortNameEncoder(*PortName);
    parameters.insert(std::make_pair(GetPortNameParameterHandle(), PortNameEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
  }
  catch (const rti1516ev::InvalidLogicalTime& e)
  {
    throw InvalidLogicalTime(to_string(e.what()));
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void EthPacketInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters )
{
  optional<bool> IsRequest;
  optional<std::string> ChannelName;
  optional<BusType> BusTypeP;
  optional<IBusController*> RequestingFederate;
  optional<IBusController*> Sender;
  optional<IBusController*> Receiver;
  optional<const EthernetPacket&> Frame;
  optional<std::string> PortName;
  rti1516ev::HLAboolean IsRequestDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IsRequestIter = parameters.find(GetIsRequestParameterHandle());
  if (IsRequestIter != parameters.end())
  {
    IsRequestDecoder.decode(IsRequestIter->second);
    IsRequest = IsRequestDecoder.get();
  }
  rti1516ev::HLAASCIIstring ChannelNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ChannelNameIter = parameters.find(GetChannelNameParameterHandle());
  if (ChannelNameIter != parameters.end())
  {
    ChannelNameDecoder.decode(ChannelNameIter->second);
    ChannelName = ChannelNameDecoder.get();
  }
  rti1516ev::HLAinteger32LE BusTypeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator BusTypeIter = parameters.find(GetBusTypeParameterHandle());
  if (BusTypeIter != parameters.end())
  {
    BusTypeDecoder.decode(BusTypeIter->second);
    BusTypeP = static_cast<BusType>(BusTypeDecoder.get());
  }
  rti1516ev::HLAobjectInstanceHandle RequestingFederateDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator RequestingFederateIter = parameters.find(GetRequestingFederateParameterHandle());
  if (RequestingFederateIter != parameters.end())
  {
    RequestingFederateDecoder.decode(RequestingFederateIter->second);
    RequestingFederate = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(RequestingFederateDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle SenderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SenderIter = parameters.find(GetSenderParameterHandle());
  if (SenderIter != parameters.end())
  {
    SenderDecoder.decode(SenderIter->second);
    Sender = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(SenderDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle ReceiverDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ReceiverIter = parameters.find(GetReceiverParameterHandle());
  if (ReceiverIter != parameters.end())
  {
    ReceiverDecoder.decode(ReceiverIter->second);
    Receiver = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(ReceiverDecoder.get()).get();
  }
  EthernetPacketEncoding FrameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator FrameIter = parameters.find(GetFrameParameterHandle());
  if (FrameIter != parameters.end())
  {
    FrameDecoder.decode(FrameIter->second);
    Frame = FrameDecoder;
  }
  rti1516ev::HLAASCIIstring PortNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator PortNameIter = parameters.find(GetPortNameParameterHandle());
  if (PortNameIter != parameters.end())
  {
    PortNameDecoder.decode(PortNameIter->second);
    PortName = PortNameDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(IsRequest, ChannelName, BusTypeP, RequestingFederate, Sender, Receiver, Frame, PortName, optional<int64_t>(), optional<OrderType>());
  }
}

void EthPacketInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters , const rti1516ev::LogicalTime& time, OrderType orderType)
{
  optional<bool> IsRequest;
  optional<std::string> ChannelName;
  optional<BusType> BusTypeP;
  optional<IBusController*> RequestingFederate;
  optional<IBusController*> Sender;
  optional<IBusController*> Receiver;
  optional<const EthernetPacket&> Frame;
  optional<std::string> PortName;

  rti1516ev::HLAboolean IsRequestDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IsRequestIter = parameters.find(GetIsRequestParameterHandle());
  if (IsRequestIter != parameters.end())
  {
    IsRequestDecoder.decode(IsRequestIter->second);
    IsRequest = IsRequestDecoder.get();
  }
  rti1516ev::HLAASCIIstring ChannelNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ChannelNameIter = parameters.find(GetChannelNameParameterHandle());
  if (ChannelNameIter != parameters.end())
  {
    ChannelNameDecoder.decode(ChannelNameIter->second);
    ChannelName = ChannelNameDecoder.get();
  }
  rti1516ev::HLAinteger32LE BusTypeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator BusTypeIter = parameters.find(GetBusTypeParameterHandle());
  if (BusTypeIter != parameters.end())
  {
    BusTypeDecoder.decode(BusTypeIter->second);
    BusTypeP = static_cast<BusType>(BusTypeDecoder.get());
  }
  rti1516ev::HLAobjectInstanceHandle RequestingFederateDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator RequestingFederateIter = parameters.find(GetRequestingFederateParameterHandle());
  if (RequestingFederateIter != parameters.end())
  {
    RequestingFederateDecoder.decode(RequestingFederateIter->second);
    RequestingFederate = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(RequestingFederateDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle SenderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SenderIter = parameters.find(GetSenderParameterHandle());
  if (SenderIter != parameters.end())
  {
    SenderDecoder.decode(SenderIter->second);
    Sender = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(SenderDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle ReceiverDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ReceiverIter = parameters.find(GetReceiverParameterHandle());
  if (ReceiverIter != parameters.end())
  {
    ReceiverDecoder.decode(ReceiverIter->second);
    Receiver = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(ReceiverDecoder.get()).get();
  }
  EthernetPacketEncoding FrameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator FrameIter = parameters.find(GetFrameParameterHandle());
  if (FrameIter != parameters.end())
  {
    FrameDecoder.decode(FrameIter->second);
    Frame = FrameDecoder;
  }
  rti1516ev::HLAASCIIstring PortNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator PortNameIter = parameters.find(GetPortNameParameterHandle());
  if (PortNameIter != parameters.end())
  {
    PortNameDecoder.decode(PortNameIter->second);
    PortName = PortNameDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(IsRequest, ChannelName, BusTypeP, RequestingFederate, Sender, Receiver, Frame, PortName, static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  }
}

uint32_t EthPacketInteractionClass::RegisterReceiveCallback(ReceiveCallback callback)
{
  uint32_t key = mReceiveCallbacksNextKey++;
  mReceiveCallbacks.insert(std::make_pair(key, callback));
  return key;
}

rti1516ev::ParameterHandleSet EthPacketInteractionClass::GetAllParameterHandles()
{
  rti1516ev::ParameterHandleSet result;
  result.insert(GetIsRequestParameterHandle());
  result.insert(GetChannelNameParameterHandle());
  result.insert(GetBusTypeParameterHandle());
  result.insert(GetRequestingFederateParameterHandle());
  result.insert(GetSenderParameterHandle());
  result.insert(GetReceiverParameterHandle());
  result.insert(GetFrameParameterHandle());
  result.insert(GetPortNameParameterHandle());
  return result;
}

// object class type 'EthPacketError'
EthPacketErrorInteractionClass::EthPacketErrorInteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry, BusMessageInteractionClass* baseClass)
{
  mInteractionClassRegistry = interactionClassRegistry;
  mRtiAmbassador = rtiAmbassador;

  mBaseClass = baseClass;
  mInteractionClassHandle = rtiAmbassador->getInteractionClassHandle(L"HLAinteractionRoot.BusMessage.EthPacketError");
  // parameter Frame : EthernetPacketError
  mFrameParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Frame");
}

// get the corresponding *object* class registry, for access to objects sent as parameters
ObjectClassRegistry* EthPacketErrorInteractionClass::GetObjectClassRegistry()
{
  return mInteractionClassRegistry->GetObjectClassRegistry();
}

void EthPacketErrorInteractionClass::Publish()
{
  if (!mPublished)
  {
    mRtiAmbassador->publishInteractionClass(mInteractionClassHandle);
    mPublished = true;
  }
}

void EthPacketErrorInteractionClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishInteractionClass(mInteractionClassHandle);
    mPublished = false;
  }
}

void EthPacketErrorInteractionClass::Subscribe(bool deliverToSelf)
{
  mRtiAmbassador->subscribeInteractionClass(mInteractionClassHandle);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  mSubscribed = true;
}

void EthPacketErrorInteractionClass::Subscribe(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacketError&> Frame, bool deliverToSelf)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (Frame)
  {
    const EthernetPacketErrorEncoding& FrameEncoder = static_cast<const EthernetPacketErrorEncoding&>(*Frame);
    parameters.insert(std::make_pair(GetFrameParameterHandle(), FrameEncoder.encode()));
  }
  mRtiAmbassador->subscribeInteractionClassWithFilter(mInteractionClassHandle, parameters);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  // we must always set mSubscribed, otherwise we can't unsubscribe
  mSubscribed = true;
}

void EthPacketErrorInteractionClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeInteractionClass(mInteractionClassHandle);
    mSubscribed = false;
  }
}

void EthPacketErrorInteractionClass::send(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacketError&> Frame)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (Frame)
  {
    const EthernetPacketErrorEncoding& FrameEncoder = static_cast<const EthernetPacketErrorEncoding&>(*Frame);
    parameters.insert(std::make_pair(GetFrameParameterHandle(), FrameEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData());
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void EthPacketErrorInteractionClass::sendWithTime(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacketError&> Frame, int64_t time)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (Frame)
  {
    const EthernetPacketErrorEncoding& FrameEncoder = static_cast<const EthernetPacketErrorEncoding&>(*Frame);
    parameters.insert(std::make_pair(GetFrameParameterHandle(), FrameEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
  }
  catch (const rti1516ev::InvalidLogicalTime& e)
  {
    throw InvalidLogicalTime(to_string(e.what()));
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void EthPacketErrorInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters )
{
  optional<bool> IsRequest;
  optional<std::string> ChannelName;
  optional<BusType> BusTypeP;
  optional<IBusController*> RequestingFederate;
  optional<IBusController*> Sender;
  optional<IBusController*> Receiver;
  optional<const EthernetPacketError&> Frame;
  rti1516ev::HLAboolean IsRequestDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IsRequestIter = parameters.find(GetIsRequestParameterHandle());
  if (IsRequestIter != parameters.end())
  {
    IsRequestDecoder.decode(IsRequestIter->second);
    IsRequest = IsRequestDecoder.get();
  }
  rti1516ev::HLAASCIIstring ChannelNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ChannelNameIter = parameters.find(GetChannelNameParameterHandle());
  if (ChannelNameIter != parameters.end())
  {
    ChannelNameDecoder.decode(ChannelNameIter->second);
    ChannelName = ChannelNameDecoder.get();
  }
  rti1516ev::HLAinteger32LE BusTypeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator BusTypeIter = parameters.find(GetBusTypeParameterHandle());
  if (BusTypeIter != parameters.end())
  {
    BusTypeDecoder.decode(BusTypeIter->second);
    BusTypeP = static_cast<BusType>(BusTypeDecoder.get());
  }
  rti1516ev::HLAobjectInstanceHandle RequestingFederateDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator RequestingFederateIter = parameters.find(GetRequestingFederateParameterHandle());
  if (RequestingFederateIter != parameters.end())
  {
    RequestingFederateDecoder.decode(RequestingFederateIter->second);
    RequestingFederate = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(RequestingFederateDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle SenderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SenderIter = parameters.find(GetSenderParameterHandle());
  if (SenderIter != parameters.end())
  {
    SenderDecoder.decode(SenderIter->second);
    Sender = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(SenderDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle ReceiverDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ReceiverIter = parameters.find(GetReceiverParameterHandle());
  if (ReceiverIter != parameters.end())
  {
    ReceiverDecoder.decode(ReceiverIter->second);
    Receiver = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(ReceiverDecoder.get()).get();
  }
  EthernetPacketErrorEncoding FrameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator FrameIter = parameters.find(GetFrameParameterHandle());
  if (FrameIter != parameters.end())
  {
    FrameDecoder.decode(FrameIter->second);
    Frame = FrameDecoder;
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(IsRequest, ChannelName, BusTypeP, RequestingFederate, Sender, Receiver, Frame, optional<int64_t>(), optional<OrderType>());
  }
}

void EthPacketErrorInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters , const rti1516ev::LogicalTime& time, OrderType orderType)
{
  optional<bool> IsRequest;
  optional<std::string> ChannelName;
  optional<BusType> BusTypeP;
  optional<IBusController*> RequestingFederate;
  optional<IBusController*> Sender;
  optional<IBusController*> Receiver;
  optional<const EthernetPacketError&> Frame;

  rti1516ev::HLAboolean IsRequestDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IsRequestIter = parameters.find(GetIsRequestParameterHandle());
  if (IsRequestIter != parameters.end())
  {
    IsRequestDecoder.decode(IsRequestIter->second);
    IsRequest = IsRequestDecoder.get();
  }
  rti1516ev::HLAASCIIstring ChannelNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ChannelNameIter = parameters.find(GetChannelNameParameterHandle());
  if (ChannelNameIter != parameters.end())
  {
    ChannelNameDecoder.decode(ChannelNameIter->second);
    ChannelName = ChannelNameDecoder.get();
  }
  rti1516ev::HLAinteger32LE BusTypeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator BusTypeIter = parameters.find(GetBusTypeParameterHandle());
  if (BusTypeIter != parameters.end())
  {
    BusTypeDecoder.decode(BusTypeIter->second);
    BusTypeP = static_cast<BusType>(BusTypeDecoder.get());
  }
  rti1516ev::HLAobjectInstanceHandle RequestingFederateDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator RequestingFederateIter = parameters.find(GetRequestingFederateParameterHandle());
  if (RequestingFederateIter != parameters.end())
  {
    RequestingFederateDecoder.decode(RequestingFederateIter->second);
    RequestingFederate = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(RequestingFederateDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle SenderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SenderIter = parameters.find(GetSenderParameterHandle());
  if (SenderIter != parameters.end())
  {
    SenderDecoder.decode(SenderIter->second);
    Sender = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(SenderDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle ReceiverDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ReceiverIter = parameters.find(GetReceiverParameterHandle());
  if (ReceiverIter != parameters.end())
  {
    ReceiverDecoder.decode(ReceiverIter->second);
    Receiver = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(ReceiverDecoder.get()).get();
  }
  EthernetPacketErrorEncoding FrameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator FrameIter = parameters.find(GetFrameParameterHandle());
  if (FrameIter != parameters.end())
  {
    FrameDecoder.decode(FrameIter->second);
    Frame = FrameDecoder;
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(IsRequest, ChannelName, BusTypeP, RequestingFederate, Sender, Receiver, Frame, static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  }
}

uint32_t EthPacketErrorInteractionClass::RegisterReceiveCallback(ReceiveCallback callback)
{
  uint32_t key = mReceiveCallbacksNextKey++;
  mReceiveCallbacks.insert(std::make_pair(key, callback));
  return key;
}

rti1516ev::ParameterHandleSet EthPacketErrorInteractionClass::GetAllParameterHandles()
{
  rti1516ev::ParameterHandleSet result;
  result.insert(GetIsRequestParameterHandle());
  result.insert(GetChannelNameParameterHandle());
  result.insert(GetBusTypeParameterHandle());
  result.insert(GetRequestingFederateParameterHandle());
  result.insert(GetSenderParameterHandle());
  result.insert(GetReceiverParameterHandle());
  result.insert(GetFrameParameterHandle());
  return result;
}

// object class type 'EthPacketErrorForwarded'
EthPacketErrorForwardedInteractionClass::EthPacketErrorForwardedInteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry, BusMessageInteractionClass* baseClass)
{
  mInteractionClassRegistry = interactionClassRegistry;
  mRtiAmbassador = rtiAmbassador;

  mBaseClass = baseClass;
  mInteractionClassHandle = rtiAmbassador->getInteractionClassHandle(L"HLAinteractionRoot.BusMessage.EthPacketErrorForwarded");
  // parameter Frame : EthernetPacketErrorForwarded
  mFrameParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Frame");
}

// get the corresponding *object* class registry, for access to objects sent as parameters
ObjectClassRegistry* EthPacketErrorForwardedInteractionClass::GetObjectClassRegistry()
{
  return mInteractionClassRegistry->GetObjectClassRegistry();
}

void EthPacketErrorForwardedInteractionClass::Publish()
{
  if (!mPublished)
  {
    mRtiAmbassador->publishInteractionClass(mInteractionClassHandle);
    mPublished = true;
  }
}

void EthPacketErrorForwardedInteractionClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishInteractionClass(mInteractionClassHandle);
    mPublished = false;
  }
}

void EthPacketErrorForwardedInteractionClass::Subscribe(bool deliverToSelf)
{
  mRtiAmbassador->subscribeInteractionClass(mInteractionClassHandle);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  mSubscribed = true;
}

void EthPacketErrorForwardedInteractionClass::Subscribe(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacketErrorForwarded&> Frame, bool deliverToSelf)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (Frame)
  {
    const EthernetPacketErrorForwardedEncoding& FrameEncoder = static_cast<const EthernetPacketErrorForwardedEncoding&>(*Frame);
    parameters.insert(std::make_pair(GetFrameParameterHandle(), FrameEncoder.encode()));
  }
  mRtiAmbassador->subscribeInteractionClassWithFilter(mInteractionClassHandle, parameters);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  // we must always set mSubscribed, otherwise we can't unsubscribe
  mSubscribed = true;
}

void EthPacketErrorForwardedInteractionClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeInteractionClass(mInteractionClassHandle);
    mSubscribed = false;
  }
}

void EthPacketErrorForwardedInteractionClass::send(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacketErrorForwarded&> Frame)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (Frame)
  {
    const EthernetPacketErrorForwardedEncoding& FrameEncoder = static_cast<const EthernetPacketErrorForwardedEncoding&>(*Frame);
    parameters.insert(std::make_pair(GetFrameParameterHandle(), FrameEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData());
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void EthPacketErrorForwardedInteractionClass::sendWithTime(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacketErrorForwarded&> Frame, int64_t time)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (Frame)
  {
    const EthernetPacketErrorForwardedEncoding& FrameEncoder = static_cast<const EthernetPacketErrorForwardedEncoding&>(*Frame);
    parameters.insert(std::make_pair(GetFrameParameterHandle(), FrameEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
  }
  catch (const rti1516ev::InvalidLogicalTime& e)
  {
    throw InvalidLogicalTime(to_string(e.what()));
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void EthPacketErrorForwardedInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters )
{
  optional<bool> IsRequest;
  optional<std::string> ChannelName;
  optional<BusType> BusTypeP;
  optional<IBusController*> RequestingFederate;
  optional<IBusController*> Sender;
  optional<IBusController*> Receiver;
  optional<const EthernetPacketErrorForwarded&> Frame;
  rti1516ev::HLAboolean IsRequestDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IsRequestIter = parameters.find(GetIsRequestParameterHandle());
  if (IsRequestIter != parameters.end())
  {
    IsRequestDecoder.decode(IsRequestIter->second);
    IsRequest = IsRequestDecoder.get();
  }
  rti1516ev::HLAASCIIstring ChannelNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ChannelNameIter = parameters.find(GetChannelNameParameterHandle());
  if (ChannelNameIter != parameters.end())
  {
    ChannelNameDecoder.decode(ChannelNameIter->second);
    ChannelName = ChannelNameDecoder.get();
  }
  rti1516ev::HLAinteger32LE BusTypeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator BusTypeIter = parameters.find(GetBusTypeParameterHandle());
  if (BusTypeIter != parameters.end())
  {
    BusTypeDecoder.decode(BusTypeIter->second);
    BusTypeP = static_cast<BusType>(BusTypeDecoder.get());
  }
  rti1516ev::HLAobjectInstanceHandle RequestingFederateDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator RequestingFederateIter = parameters.find(GetRequestingFederateParameterHandle());
  if (RequestingFederateIter != parameters.end())
  {
    RequestingFederateDecoder.decode(RequestingFederateIter->second);
    RequestingFederate = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(RequestingFederateDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle SenderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SenderIter = parameters.find(GetSenderParameterHandle());
  if (SenderIter != parameters.end())
  {
    SenderDecoder.decode(SenderIter->second);
    Sender = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(SenderDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle ReceiverDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ReceiverIter = parameters.find(GetReceiverParameterHandle());
  if (ReceiverIter != parameters.end())
  {
    ReceiverDecoder.decode(ReceiverIter->second);
    Receiver = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(ReceiverDecoder.get()).get();
  }
  EthernetPacketErrorForwardedEncoding FrameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator FrameIter = parameters.find(GetFrameParameterHandle());
  if (FrameIter != parameters.end())
  {
    FrameDecoder.decode(FrameIter->second);
    Frame = FrameDecoder;
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(IsRequest, ChannelName, BusTypeP, RequestingFederate, Sender, Receiver, Frame, optional<int64_t>(), optional<OrderType>());
  }
}

void EthPacketErrorForwardedInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters , const rti1516ev::LogicalTime& time, OrderType orderType)
{
  optional<bool> IsRequest;
  optional<std::string> ChannelName;
  optional<BusType> BusTypeP;
  optional<IBusController*> RequestingFederate;
  optional<IBusController*> Sender;
  optional<IBusController*> Receiver;
  optional<const EthernetPacketErrorForwarded&> Frame;

  rti1516ev::HLAboolean IsRequestDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IsRequestIter = parameters.find(GetIsRequestParameterHandle());
  if (IsRequestIter != parameters.end())
  {
    IsRequestDecoder.decode(IsRequestIter->second);
    IsRequest = IsRequestDecoder.get();
  }
  rti1516ev::HLAASCIIstring ChannelNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ChannelNameIter = parameters.find(GetChannelNameParameterHandle());
  if (ChannelNameIter != parameters.end())
  {
    ChannelNameDecoder.decode(ChannelNameIter->second);
    ChannelName = ChannelNameDecoder.get();
  }
  rti1516ev::HLAinteger32LE BusTypeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator BusTypeIter = parameters.find(GetBusTypeParameterHandle());
  if (BusTypeIter != parameters.end())
  {
    BusTypeDecoder.decode(BusTypeIter->second);
    BusTypeP = static_cast<BusType>(BusTypeDecoder.get());
  }
  rti1516ev::HLAobjectInstanceHandle RequestingFederateDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator RequestingFederateIter = parameters.find(GetRequestingFederateParameterHandle());
  if (RequestingFederateIter != parameters.end())
  {
    RequestingFederateDecoder.decode(RequestingFederateIter->second);
    RequestingFederate = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(RequestingFederateDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle SenderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SenderIter = parameters.find(GetSenderParameterHandle());
  if (SenderIter != parameters.end())
  {
    SenderDecoder.decode(SenderIter->second);
    Sender = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(SenderDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle ReceiverDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ReceiverIter = parameters.find(GetReceiverParameterHandle());
  if (ReceiverIter != parameters.end())
  {
    ReceiverDecoder.decode(ReceiverIter->second);
    Receiver = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(ReceiverDecoder.get()).get();
  }
  EthernetPacketErrorForwardedEncoding FrameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator FrameIter = parameters.find(GetFrameParameterHandle());
  if (FrameIter != parameters.end())
  {
    FrameDecoder.decode(FrameIter->second);
    Frame = FrameDecoder;
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(IsRequest, ChannelName, BusTypeP, RequestingFederate, Sender, Receiver, Frame, static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  }
}

uint32_t EthPacketErrorForwardedInteractionClass::RegisterReceiveCallback(ReceiveCallback callback)
{
  uint32_t key = mReceiveCallbacksNextKey++;
  mReceiveCallbacks.insert(std::make_pair(key, callback));
  return key;
}

rti1516ev::ParameterHandleSet EthPacketErrorForwardedInteractionClass::GetAllParameterHandles()
{
  rti1516ev::ParameterHandleSet result;
  result.insert(GetIsRequestParameterHandle());
  result.insert(GetChannelNameParameterHandle());
  result.insert(GetBusTypeParameterHandle());
  result.insert(GetRequestingFederateParameterHandle());
  result.insert(GetSenderParameterHandle());
  result.insert(GetReceiverParameterHandle());
  result.insert(GetFrameParameterHandle());
  return result;
}

// object class type 'EthForwardedPacket'
EthForwardedPacketInteractionClass::EthForwardedPacketInteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry, BusMessageInteractionClass* baseClass)
{
  mInteractionClassRegistry = interactionClassRegistry;
  mRtiAmbassador = rtiAmbassador;

  mBaseClass = baseClass;
  mInteractionClassHandle = rtiAmbassador->getInteractionClassHandle(L"HLAinteractionRoot.BusMessage.EthForwardedPacket");
  // parameter Frame : EthernetPacketForwarded
  mFrameParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Frame");
  // parameter PortName : HLAASCIIstring
  mPortNameParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"PortName");
}

// get the corresponding *object* class registry, for access to objects sent as parameters
ObjectClassRegistry* EthForwardedPacketInteractionClass::GetObjectClassRegistry()
{
  return mInteractionClassRegistry->GetObjectClassRegistry();
}

void EthForwardedPacketInteractionClass::Publish()
{
  if (!mPublished)
  {
    mRtiAmbassador->publishInteractionClass(mInteractionClassHandle);
    mPublished = true;
  }
}

void EthForwardedPacketInteractionClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishInteractionClass(mInteractionClassHandle);
    mPublished = false;
  }
}

void EthForwardedPacketInteractionClass::Subscribe(bool deliverToSelf)
{
  mRtiAmbassador->subscribeInteractionClass(mInteractionClassHandle);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  mSubscribed = true;
}

void EthForwardedPacketInteractionClass::Subscribe(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacketForwarded&> Frame, optional<std::string> PortName, bool deliverToSelf)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (Frame)
  {
    const EthernetPacketForwardedEncoding& FrameEncoder = static_cast<const EthernetPacketForwardedEncoding&>(*Frame);
    parameters.insert(std::make_pair(GetFrameParameterHandle(), FrameEncoder.encode()));
  }
  if (PortName)
  {
    rti1516ev::HLAASCIIstring PortNameEncoder(*PortName);
    parameters.insert(std::make_pair(GetPortNameParameterHandle(), PortNameEncoder.encode()));
  }
  mRtiAmbassador->subscribeInteractionClassWithFilter(mInteractionClassHandle, parameters);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  // we must always set mSubscribed, otherwise we can't unsubscribe
  mSubscribed = true;
}

void EthForwardedPacketInteractionClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeInteractionClass(mInteractionClassHandle);
    mSubscribed = false;
  }
}

void EthForwardedPacketInteractionClass::send(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacketForwarded&> Frame, optional<std::string> PortName)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (Frame)
  {
    const EthernetPacketForwardedEncoding& FrameEncoder = static_cast<const EthernetPacketForwardedEncoding&>(*Frame);
    parameters.insert(std::make_pair(GetFrameParameterHandle(), FrameEncoder.encode()));
  }
  if (PortName)
  {
    rti1516ev::HLAASCIIstring PortNameEncoder(*PortName);
    parameters.insert(std::make_pair(GetPortNameParameterHandle(), PortNameEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData());
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void EthForwardedPacketInteractionClass::sendWithTime(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacketForwarded&> Frame, optional<std::string> PortName, int64_t time)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (Frame)
  {
    const EthernetPacketForwardedEncoding& FrameEncoder = static_cast<const EthernetPacketForwardedEncoding&>(*Frame);
    parameters.insert(std::make_pair(GetFrameParameterHandle(), FrameEncoder.encode()));
  }
  if (PortName)
  {
    rti1516ev::HLAASCIIstring PortNameEncoder(*PortName);
    parameters.insert(std::make_pair(GetPortNameParameterHandle(), PortNameEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
  }
  catch (const rti1516ev::InvalidLogicalTime& e)
  {
    throw InvalidLogicalTime(to_string(e.what()));
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void EthForwardedPacketInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters )
{
  optional<bool> IsRequest;
  optional<std::string> ChannelName;
  optional<BusType> BusTypeP;
  optional<IBusController*> RequestingFederate;
  optional<IBusController*> Sender;
  optional<IBusController*> Receiver;
  optional<const EthernetPacketForwarded&> Frame;
  optional<std::string> PortName;
  rti1516ev::HLAboolean IsRequestDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IsRequestIter = parameters.find(GetIsRequestParameterHandle());
  if (IsRequestIter != parameters.end())
  {
    IsRequestDecoder.decode(IsRequestIter->second);
    IsRequest = IsRequestDecoder.get();
  }
  rti1516ev::HLAASCIIstring ChannelNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ChannelNameIter = parameters.find(GetChannelNameParameterHandle());
  if (ChannelNameIter != parameters.end())
  {
    ChannelNameDecoder.decode(ChannelNameIter->second);
    ChannelName = ChannelNameDecoder.get();
  }
  rti1516ev::HLAinteger32LE BusTypeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator BusTypeIter = parameters.find(GetBusTypeParameterHandle());
  if (BusTypeIter != parameters.end())
  {
    BusTypeDecoder.decode(BusTypeIter->second);
    BusTypeP = static_cast<BusType>(BusTypeDecoder.get());
  }
  rti1516ev::HLAobjectInstanceHandle RequestingFederateDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator RequestingFederateIter = parameters.find(GetRequestingFederateParameterHandle());
  if (RequestingFederateIter != parameters.end())
  {
    RequestingFederateDecoder.decode(RequestingFederateIter->second);
    RequestingFederate = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(RequestingFederateDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle SenderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SenderIter = parameters.find(GetSenderParameterHandle());
  if (SenderIter != parameters.end())
  {
    SenderDecoder.decode(SenderIter->second);
    Sender = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(SenderDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle ReceiverDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ReceiverIter = parameters.find(GetReceiverParameterHandle());
  if (ReceiverIter != parameters.end())
  {
    ReceiverDecoder.decode(ReceiverIter->second);
    Receiver = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(ReceiverDecoder.get()).get();
  }
  EthernetPacketForwardedEncoding FrameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator FrameIter = parameters.find(GetFrameParameterHandle());
  if (FrameIter != parameters.end())
  {
    FrameDecoder.decode(FrameIter->second);
    Frame = FrameDecoder;
  }
  rti1516ev::HLAASCIIstring PortNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator PortNameIter = parameters.find(GetPortNameParameterHandle());
  if (PortNameIter != parameters.end())
  {
    PortNameDecoder.decode(PortNameIter->second);
    PortName = PortNameDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(IsRequest, ChannelName, BusTypeP, RequestingFederate, Sender, Receiver, Frame, PortName, optional<int64_t>(), optional<OrderType>());
  }
}

void EthForwardedPacketInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters , const rti1516ev::LogicalTime& time, OrderType orderType)
{
  optional<bool> IsRequest;
  optional<std::string> ChannelName;
  optional<BusType> BusTypeP;
  optional<IBusController*> RequestingFederate;
  optional<IBusController*> Sender;
  optional<IBusController*> Receiver;
  optional<const EthernetPacketForwarded&> Frame;
  optional<std::string> PortName;

  rti1516ev::HLAboolean IsRequestDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IsRequestIter = parameters.find(GetIsRequestParameterHandle());
  if (IsRequestIter != parameters.end())
  {
    IsRequestDecoder.decode(IsRequestIter->second);
    IsRequest = IsRequestDecoder.get();
  }
  rti1516ev::HLAASCIIstring ChannelNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ChannelNameIter = parameters.find(GetChannelNameParameterHandle());
  if (ChannelNameIter != parameters.end())
  {
    ChannelNameDecoder.decode(ChannelNameIter->second);
    ChannelName = ChannelNameDecoder.get();
  }
  rti1516ev::HLAinteger32LE BusTypeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator BusTypeIter = parameters.find(GetBusTypeParameterHandle());
  if (BusTypeIter != parameters.end())
  {
    BusTypeDecoder.decode(BusTypeIter->second);
    BusTypeP = static_cast<BusType>(BusTypeDecoder.get());
  }
  rti1516ev::HLAobjectInstanceHandle RequestingFederateDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator RequestingFederateIter = parameters.find(GetRequestingFederateParameterHandle());
  if (RequestingFederateIter != parameters.end())
  {
    RequestingFederateDecoder.decode(RequestingFederateIter->second);
    RequestingFederate = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(RequestingFederateDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle SenderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SenderIter = parameters.find(GetSenderParameterHandle());
  if (SenderIter != parameters.end())
  {
    SenderDecoder.decode(SenderIter->second);
    Sender = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(SenderDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle ReceiverDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ReceiverIter = parameters.find(GetReceiverParameterHandle());
  if (ReceiverIter != parameters.end())
  {
    ReceiverDecoder.decode(ReceiverIter->second);
    Receiver = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(ReceiverDecoder.get()).get();
  }
  EthernetPacketForwardedEncoding FrameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator FrameIter = parameters.find(GetFrameParameterHandle());
  if (FrameIter != parameters.end())
  {
    FrameDecoder.decode(FrameIter->second);
    Frame = FrameDecoder;
  }
  rti1516ev::HLAASCIIstring PortNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator PortNameIter = parameters.find(GetPortNameParameterHandle());
  if (PortNameIter != parameters.end())
  {
    PortNameDecoder.decode(PortNameIter->second);
    PortName = PortNameDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(IsRequest, ChannelName, BusTypeP, RequestingFederate, Sender, Receiver, Frame, PortName, static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  }
}

uint32_t EthForwardedPacketInteractionClass::RegisterReceiveCallback(ReceiveCallback callback)
{
  uint32_t key = mReceiveCallbacksNextKey++;
  mReceiveCallbacks.insert(std::make_pair(key, callback));
  return key;
}

rti1516ev::ParameterHandleSet EthForwardedPacketInteractionClass::GetAllParameterHandles()
{
  rti1516ev::ParameterHandleSet result;
  result.insert(GetIsRequestParameterHandle());
  result.insert(GetChannelNameParameterHandle());
  result.insert(GetBusTypeParameterHandle());
  result.insert(GetRequestingFederateParameterHandle());
  result.insert(GetSenderParameterHandle());
  result.insert(GetReceiverParameterHandle());
  result.insert(GetFrameParameterHandle());
  result.insert(GetPortNameParameterHandle());
  return result;
}

// object class type 'EthStatus'
EthStatusInteractionClass::EthStatusInteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry, BusMessageInteractionClass* baseClass)
{
  mInteractionClassRegistry = interactionClassRegistry;
  mRtiAmbassador = rtiAmbassador;

  mBaseClass = baseClass;
  mInteractionClassHandle = rtiAmbassador->getInteractionClassHandle(L"HLAinteractionRoot.BusMessage.EthStatus");
  // parameter Frame : EthernetStatus
  mFrameParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Frame");
  // parameter PortName : HLAASCIIstring
  mPortNameParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"PortName");
}

// get the corresponding *object* class registry, for access to objects sent as parameters
ObjectClassRegistry* EthStatusInteractionClass::GetObjectClassRegistry()
{
  return mInteractionClassRegistry->GetObjectClassRegistry();
}

void EthStatusInteractionClass::Publish()
{
  if (!mPublished)
  {
    mRtiAmbassador->publishInteractionClass(mInteractionClassHandle);
    mPublished = true;
  }
}

void EthStatusInteractionClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishInteractionClass(mInteractionClassHandle);
    mPublished = false;
  }
}

void EthStatusInteractionClass::Subscribe(bool deliverToSelf)
{
  mRtiAmbassador->subscribeInteractionClass(mInteractionClassHandle);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  mSubscribed = true;
}

void EthStatusInteractionClass::Subscribe(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetStatus&> Frame, optional<std::string> PortName, bool deliverToSelf)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (Frame)
  {
    const EthernetStatusEncoding& FrameEncoder = static_cast<const EthernetStatusEncoding&>(*Frame);
    parameters.insert(std::make_pair(GetFrameParameterHandle(), FrameEncoder.encode()));
  }
  if (PortName)
  {
    rti1516ev::HLAASCIIstring PortNameEncoder(*PortName);
    parameters.insert(std::make_pair(GetPortNameParameterHandle(), PortNameEncoder.encode()));
  }
  mRtiAmbassador->subscribeInteractionClassWithFilter(mInteractionClassHandle, parameters);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  // we must always set mSubscribed, otherwise we can't unsubscribe
  mSubscribed = true;
}

void EthStatusInteractionClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeInteractionClass(mInteractionClassHandle);
    mSubscribed = false;
  }
}

void EthStatusInteractionClass::send(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetStatus&> Frame, optional<std::string> PortName)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (Frame)
  {
    const EthernetStatusEncoding& FrameEncoder = static_cast<const EthernetStatusEncoding&>(*Frame);
    parameters.insert(std::make_pair(GetFrameParameterHandle(), FrameEncoder.encode()));
  }
  if (PortName)
  {
    rti1516ev::HLAASCIIstring PortNameEncoder(*PortName);
    parameters.insert(std::make_pair(GetPortNameParameterHandle(), PortNameEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData());
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void EthStatusInteractionClass::sendWithTime(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetStatus&> Frame, optional<std::string> PortName, int64_t time)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (Frame)
  {
    const EthernetStatusEncoding& FrameEncoder = static_cast<const EthernetStatusEncoding&>(*Frame);
    parameters.insert(std::make_pair(GetFrameParameterHandle(), FrameEncoder.encode()));
  }
  if (PortName)
  {
    rti1516ev::HLAASCIIstring PortNameEncoder(*PortName);
    parameters.insert(std::make_pair(GetPortNameParameterHandle(), PortNameEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
  }
  catch (const rti1516ev::InvalidLogicalTime& e)
  {
    throw InvalidLogicalTime(to_string(e.what()));
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void EthStatusInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters )
{
  optional<bool> IsRequest;
  optional<std::string> ChannelName;
  optional<BusType> BusTypeP;
  optional<IBusController*> RequestingFederate;
  optional<IBusController*> Sender;
  optional<IBusController*> Receiver;
  optional<const EthernetStatus&> Frame;
  optional<std::string> PortName;
  rti1516ev::HLAboolean IsRequestDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IsRequestIter = parameters.find(GetIsRequestParameterHandle());
  if (IsRequestIter != parameters.end())
  {
    IsRequestDecoder.decode(IsRequestIter->second);
    IsRequest = IsRequestDecoder.get();
  }
  rti1516ev::HLAASCIIstring ChannelNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ChannelNameIter = parameters.find(GetChannelNameParameterHandle());
  if (ChannelNameIter != parameters.end())
  {
    ChannelNameDecoder.decode(ChannelNameIter->second);
    ChannelName = ChannelNameDecoder.get();
  }
  rti1516ev::HLAinteger32LE BusTypeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator BusTypeIter = parameters.find(GetBusTypeParameterHandle());
  if (BusTypeIter != parameters.end())
  {
    BusTypeDecoder.decode(BusTypeIter->second);
    BusTypeP = static_cast<BusType>(BusTypeDecoder.get());
  }
  rti1516ev::HLAobjectInstanceHandle RequestingFederateDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator RequestingFederateIter = parameters.find(GetRequestingFederateParameterHandle());
  if (RequestingFederateIter != parameters.end())
  {
    RequestingFederateDecoder.decode(RequestingFederateIter->second);
    RequestingFederate = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(RequestingFederateDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle SenderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SenderIter = parameters.find(GetSenderParameterHandle());
  if (SenderIter != parameters.end())
  {
    SenderDecoder.decode(SenderIter->second);
    Sender = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(SenderDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle ReceiverDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ReceiverIter = parameters.find(GetReceiverParameterHandle());
  if (ReceiverIter != parameters.end())
  {
    ReceiverDecoder.decode(ReceiverIter->second);
    Receiver = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(ReceiverDecoder.get()).get();
  }
  EthernetStatusEncoding FrameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator FrameIter = parameters.find(GetFrameParameterHandle());
  if (FrameIter != parameters.end())
  {
    FrameDecoder.decode(FrameIter->second);
    Frame = FrameDecoder;
  }
  rti1516ev::HLAASCIIstring PortNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator PortNameIter = parameters.find(GetPortNameParameterHandle());
  if (PortNameIter != parameters.end())
  {
    PortNameDecoder.decode(PortNameIter->second);
    PortName = PortNameDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(IsRequest, ChannelName, BusTypeP, RequestingFederate, Sender, Receiver, Frame, PortName, optional<int64_t>(), optional<OrderType>());
  }
}

void EthStatusInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters , const rti1516ev::LogicalTime& time, OrderType orderType)
{
  optional<bool> IsRequest;
  optional<std::string> ChannelName;
  optional<BusType> BusTypeP;
  optional<IBusController*> RequestingFederate;
  optional<IBusController*> Sender;
  optional<IBusController*> Receiver;
  optional<const EthernetStatus&> Frame;
  optional<std::string> PortName;

  rti1516ev::HLAboolean IsRequestDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IsRequestIter = parameters.find(GetIsRequestParameterHandle());
  if (IsRequestIter != parameters.end())
  {
    IsRequestDecoder.decode(IsRequestIter->second);
    IsRequest = IsRequestDecoder.get();
  }
  rti1516ev::HLAASCIIstring ChannelNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ChannelNameIter = parameters.find(GetChannelNameParameterHandle());
  if (ChannelNameIter != parameters.end())
  {
    ChannelNameDecoder.decode(ChannelNameIter->second);
    ChannelName = ChannelNameDecoder.get();
  }
  rti1516ev::HLAinteger32LE BusTypeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator BusTypeIter = parameters.find(GetBusTypeParameterHandle());
  if (BusTypeIter != parameters.end())
  {
    BusTypeDecoder.decode(BusTypeIter->second);
    BusTypeP = static_cast<BusType>(BusTypeDecoder.get());
  }
  rti1516ev::HLAobjectInstanceHandle RequestingFederateDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator RequestingFederateIter = parameters.find(GetRequestingFederateParameterHandle());
  if (RequestingFederateIter != parameters.end())
  {
    RequestingFederateDecoder.decode(RequestingFederateIter->second);
    RequestingFederate = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(RequestingFederateDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle SenderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SenderIter = parameters.find(GetSenderParameterHandle());
  if (SenderIter != parameters.end())
  {
    SenderDecoder.decode(SenderIter->second);
    Sender = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(SenderDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle ReceiverDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ReceiverIter = parameters.find(GetReceiverParameterHandle());
  if (ReceiverIter != parameters.end())
  {
    ReceiverDecoder.decode(ReceiverIter->second);
    Receiver = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(ReceiverDecoder.get()).get();
  }
  EthernetStatusEncoding FrameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator FrameIter = parameters.find(GetFrameParameterHandle());
  if (FrameIter != parameters.end())
  {
    FrameDecoder.decode(FrameIter->second);
    Frame = FrameDecoder;
  }
  rti1516ev::HLAASCIIstring PortNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator PortNameIter = parameters.find(GetPortNameParameterHandle());
  if (PortNameIter != parameters.end())
  {
    PortNameDecoder.decode(PortNameIter->second);
    PortName = PortNameDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(IsRequest, ChannelName, BusTypeP, RequestingFederate, Sender, Receiver, Frame, PortName, static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  }
}

uint32_t EthStatusInteractionClass::RegisterReceiveCallback(ReceiveCallback callback)
{
  uint32_t key = mReceiveCallbacksNextKey++;
  mReceiveCallbacks.insert(std::make_pair(key, callback));
  return key;
}

rti1516ev::ParameterHandleSet EthStatusInteractionClass::GetAllParameterHandles()
{
  rti1516ev::ParameterHandleSet result;
  result.insert(GetIsRequestParameterHandle());
  result.insert(GetChannelNameParameterHandle());
  result.insert(GetBusTypeParameterHandle());
  result.insert(GetRequestingFederateParameterHandle());
  result.insert(GetSenderParameterHandle());
  result.insert(GetReceiverParameterHandle());
  result.insert(GetFrameParameterHandle());
  result.insert(GetPortNameParameterHandle());
  return result;
}

// object class type 'CANMessage'
CANMessageInteractionClass::CANMessageInteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry, BusMessageInteractionClass* baseClass)
{
  mInteractionClassRegistry = interactionClassRegistry;
  mRtiAmbassador = rtiAmbassador;

  mBaseClass = baseClass;
  mInteractionClassHandle = rtiAmbassador->getInteractionClassHandle(L"HLAinteractionRoot.BusMessage.CANMessage");
  // parameter Id : HLAinteger32LE
  mIdParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Id");
  // parameter Frame : CANFrame
  mFrameParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Frame");
}

// get the corresponding *object* class registry, for access to objects sent as parameters
ObjectClassRegistry* CANMessageInteractionClass::GetObjectClassRegistry()
{
  return mInteractionClassRegistry->GetObjectClassRegistry();
}

void CANMessageInteractionClass::Publish()
{
  if (!mPublished)
  {
    mRtiAmbassador->publishInteractionClass(mInteractionClassHandle);
    mPublished = true;
  }
}

void CANMessageInteractionClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishInteractionClass(mInteractionClassHandle);
    mPublished = false;
  }
}

void CANMessageInteractionClass::Subscribe(bool deliverToSelf)
{
  mRtiAmbassador->subscribeInteractionClass(mInteractionClassHandle);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  mSubscribed = true;
}

void CANMessageInteractionClass::Subscribe(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<int32_t> Id, optional<const CANFrame&> Frame, bool deliverToSelf)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (Id)
  {
    rti1516ev::HLAinteger32LE IdEncoder(*Id);
    parameters.insert(std::make_pair(GetIdParameterHandle(), IdEncoder.encode()));
  }
  if (Frame)
  {
    const CANFrameEncoding& FrameEncoder = static_cast<const CANFrameEncoding&>(*Frame);
    parameters.insert(std::make_pair(GetFrameParameterHandle(), FrameEncoder.encode()));
  }
  mRtiAmbassador->subscribeInteractionClassWithFilter(mInteractionClassHandle, parameters);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  // we must always set mSubscribed, otherwise we can't unsubscribe
  mSubscribed = true;
}

void CANMessageInteractionClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeInteractionClass(mInteractionClassHandle);
    mSubscribed = false;
  }
}

void CANMessageInteractionClass::send(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<int32_t> Id, optional<const CANFrame&> Frame)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (Id)
  {
    rti1516ev::HLAinteger32LE IdEncoder(*Id);
    parameters.insert(std::make_pair(GetIdParameterHandle(), IdEncoder.encode()));
  }
  if (Frame)
  {
    const CANFrameEncoding& FrameEncoder = static_cast<const CANFrameEncoding&>(*Frame);
    parameters.insert(std::make_pair(GetFrameParameterHandle(), FrameEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData());
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void CANMessageInteractionClass::sendWithTime(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<int32_t> Id, optional<const CANFrame&> Frame, int64_t time)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (Id)
  {
    rti1516ev::HLAinteger32LE IdEncoder(*Id);
    parameters.insert(std::make_pair(GetIdParameterHandle(), IdEncoder.encode()));
  }
  if (Frame)
  {
    const CANFrameEncoding& FrameEncoder = static_cast<const CANFrameEncoding&>(*Frame);
    parameters.insert(std::make_pair(GetFrameParameterHandle(), FrameEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
  }
  catch (const rti1516ev::InvalidLogicalTime& e)
  {
    throw InvalidLogicalTime(to_string(e.what()));
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void CANMessageInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters )
{
  optional<bool> IsRequest;
  optional<std::string> ChannelName;
  optional<BusType> BusTypeP;
  optional<IBusController*> RequestingFederate;
  optional<IBusController*> Sender;
  optional<IBusController*> Receiver;
  optional<int32_t> Id;
  optional<const CANFrame&> Frame;
  rti1516ev::HLAboolean IsRequestDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IsRequestIter = parameters.find(GetIsRequestParameterHandle());
  if (IsRequestIter != parameters.end())
  {
    IsRequestDecoder.decode(IsRequestIter->second);
    IsRequest = IsRequestDecoder.get();
  }
  rti1516ev::HLAASCIIstring ChannelNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ChannelNameIter = parameters.find(GetChannelNameParameterHandle());
  if (ChannelNameIter != parameters.end())
  {
    ChannelNameDecoder.decode(ChannelNameIter->second);
    ChannelName = ChannelNameDecoder.get();
  }
  rti1516ev::HLAinteger32LE BusTypeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator BusTypeIter = parameters.find(GetBusTypeParameterHandle());
  if (BusTypeIter != parameters.end())
  {
    BusTypeDecoder.decode(BusTypeIter->second);
    BusTypeP = static_cast<BusType>(BusTypeDecoder.get());
  }
  rti1516ev::HLAobjectInstanceHandle RequestingFederateDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator RequestingFederateIter = parameters.find(GetRequestingFederateParameterHandle());
  if (RequestingFederateIter != parameters.end())
  {
    RequestingFederateDecoder.decode(RequestingFederateIter->second);
    RequestingFederate = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(RequestingFederateDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle SenderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SenderIter = parameters.find(GetSenderParameterHandle());
  if (SenderIter != parameters.end())
  {
    SenderDecoder.decode(SenderIter->second);
    Sender = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(SenderDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle ReceiverDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ReceiverIter = parameters.find(GetReceiverParameterHandle());
  if (ReceiverIter != parameters.end())
  {
    ReceiverDecoder.decode(ReceiverIter->second);
    Receiver = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(ReceiverDecoder.get()).get();
  }
  rti1516ev::HLAinteger32LE IdDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IdIter = parameters.find(GetIdParameterHandle());
  if (IdIter != parameters.end())
  {
    IdDecoder.decode(IdIter->second);
    Id = IdDecoder.get();
  }
  CANFrameEncoding FrameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator FrameIter = parameters.find(GetFrameParameterHandle());
  if (FrameIter != parameters.end())
  {
    FrameDecoder.decode(FrameIter->second);
    Frame = FrameDecoder;
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(IsRequest, ChannelName, BusTypeP, RequestingFederate, Sender, Receiver, Id, Frame, optional<int64_t>(), optional<OrderType>());
  }
}

void CANMessageInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters , const rti1516ev::LogicalTime& time, OrderType orderType)
{
  optional<bool> IsRequest;
  optional<std::string> ChannelName;
  optional<BusType> BusTypeP;
  optional<IBusController*> RequestingFederate;
  optional<IBusController*> Sender;
  optional<IBusController*> Receiver;
  optional<int32_t> Id;
  optional<const CANFrame&> Frame;

  rti1516ev::HLAboolean IsRequestDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IsRequestIter = parameters.find(GetIsRequestParameterHandle());
  if (IsRequestIter != parameters.end())
  {
    IsRequestDecoder.decode(IsRequestIter->second);
    IsRequest = IsRequestDecoder.get();
  }
  rti1516ev::HLAASCIIstring ChannelNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ChannelNameIter = parameters.find(GetChannelNameParameterHandle());
  if (ChannelNameIter != parameters.end())
  {
    ChannelNameDecoder.decode(ChannelNameIter->second);
    ChannelName = ChannelNameDecoder.get();
  }
  rti1516ev::HLAinteger32LE BusTypeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator BusTypeIter = parameters.find(GetBusTypeParameterHandle());
  if (BusTypeIter != parameters.end())
  {
    BusTypeDecoder.decode(BusTypeIter->second);
    BusTypeP = static_cast<BusType>(BusTypeDecoder.get());
  }
  rti1516ev::HLAobjectInstanceHandle RequestingFederateDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator RequestingFederateIter = parameters.find(GetRequestingFederateParameterHandle());
  if (RequestingFederateIter != parameters.end())
  {
    RequestingFederateDecoder.decode(RequestingFederateIter->second);
    RequestingFederate = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(RequestingFederateDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle SenderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SenderIter = parameters.find(GetSenderParameterHandle());
  if (SenderIter != parameters.end())
  {
    SenderDecoder.decode(SenderIter->second);
    Sender = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(SenderDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle ReceiverDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ReceiverIter = parameters.find(GetReceiverParameterHandle());
  if (ReceiverIter != parameters.end())
  {
    ReceiverDecoder.decode(ReceiverIter->second);
    Receiver = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(ReceiverDecoder.get()).get();
  }
  rti1516ev::HLAinteger32LE IdDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IdIter = parameters.find(GetIdParameterHandle());
  if (IdIter != parameters.end())
  {
    IdDecoder.decode(IdIter->second);
    Id = IdDecoder.get();
  }
  CANFrameEncoding FrameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator FrameIter = parameters.find(GetFrameParameterHandle());
  if (FrameIter != parameters.end())
  {
    FrameDecoder.decode(FrameIter->second);
    Frame = FrameDecoder;
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(IsRequest, ChannelName, BusTypeP, RequestingFederate, Sender, Receiver, Id, Frame, static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  }
}

uint32_t CANMessageInteractionClass::RegisterReceiveCallback(ReceiveCallback callback)
{
  uint32_t key = mReceiveCallbacksNextKey++;
  mReceiveCallbacks.insert(std::make_pair(key, callback));
  return key;
}

rti1516ev::ParameterHandleSet CANMessageInteractionClass::GetAllParameterHandles()
{
  rti1516ev::ParameterHandleSet result;
  result.insert(GetIsRequestParameterHandle());
  result.insert(GetChannelNameParameterHandle());
  result.insert(GetBusTypeParameterHandle());
  result.insert(GetRequestingFederateParameterHandle());
  result.insert(GetSenderParameterHandle());
  result.insert(GetReceiverParameterHandle());
  result.insert(GetIdParameterHandle());
  result.insert(GetFrameParameterHandle());
  return result;
}

// object class type 'CANErrorFrame'
CANErrorFrameInteractionClass::CANErrorFrameInteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry, BusMessageInteractionClass* baseClass)
{
  mInteractionClassRegistry = interactionClassRegistry;
  mRtiAmbassador = rtiAmbassador;

  mBaseClass = baseClass;
  mInteractionClassHandle = rtiAmbassador->getInteractionClassHandle(L"HLAinteractionRoot.BusMessage.CANErrorFrame");
  // parameter Frame : HLAopaqueData
  mFrameParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Frame");
}

// get the corresponding *object* class registry, for access to objects sent as parameters
ObjectClassRegistry* CANErrorFrameInteractionClass::GetObjectClassRegistry()
{
  return mInteractionClassRegistry->GetObjectClassRegistry();
}

void CANErrorFrameInteractionClass::Publish()
{
  if (!mPublished)
  {
    mRtiAmbassador->publishInteractionClass(mInteractionClassHandle);
    mPublished = true;
  }
}

void CANErrorFrameInteractionClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishInteractionClass(mInteractionClassHandle);
    mPublished = false;
  }
}

void CANErrorFrameInteractionClass::Subscribe(bool deliverToSelf)
{
  mRtiAmbassador->subscribeInteractionClass(mInteractionClassHandle);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  mSubscribed = true;
}

void CANErrorFrameInteractionClass::Subscribe(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const std::vector<uint8_t>&> Frame, bool deliverToSelf)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (Frame)
  {
    rti1516ev::HLAopaqueData FrameEncoder(*Frame);
    parameters.insert(std::make_pair(GetFrameParameterHandle(), FrameEncoder.encode()));
  }
  mRtiAmbassador->subscribeInteractionClassWithFilter(mInteractionClassHandle, parameters);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  // we must always set mSubscribed, otherwise we can't unsubscribe
  mSubscribed = true;
}

void CANErrorFrameInteractionClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeInteractionClass(mInteractionClassHandle);
    mSubscribed = false;
  }
}

void CANErrorFrameInteractionClass::send(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const std::vector<uint8_t>&> Frame)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (Frame)
  {
    rti1516ev::HLAopaqueData FrameEncoder(*Frame);
    parameters.insert(std::make_pair(GetFrameParameterHandle(), FrameEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData());
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void CANErrorFrameInteractionClass::sendWithTime(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const std::vector<uint8_t>&> Frame, int64_t time)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (Frame)
  {
    rti1516ev::HLAopaqueData FrameEncoder(*Frame);
    parameters.insert(std::make_pair(GetFrameParameterHandle(), FrameEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
  }
  catch (const rti1516ev::InvalidLogicalTime& e)
  {
    throw InvalidLogicalTime(to_string(e.what()));
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void CANErrorFrameInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters )
{
  optional<bool> IsRequest;
  optional<std::string> ChannelName;
  optional<BusType> BusTypeP;
  optional<IBusController*> RequestingFederate;
  optional<IBusController*> Sender;
  optional<IBusController*> Receiver;
  optional<const std::vector<uint8_t>&> Frame;
  rti1516ev::HLAboolean IsRequestDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IsRequestIter = parameters.find(GetIsRequestParameterHandle());
  if (IsRequestIter != parameters.end())
  {
    IsRequestDecoder.decode(IsRequestIter->second);
    IsRequest = IsRequestDecoder.get();
  }
  rti1516ev::HLAASCIIstring ChannelNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ChannelNameIter = parameters.find(GetChannelNameParameterHandle());
  if (ChannelNameIter != parameters.end())
  {
    ChannelNameDecoder.decode(ChannelNameIter->second);
    ChannelName = ChannelNameDecoder.get();
  }
  rti1516ev::HLAinteger32LE BusTypeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator BusTypeIter = parameters.find(GetBusTypeParameterHandle());
  if (BusTypeIter != parameters.end())
  {
    BusTypeDecoder.decode(BusTypeIter->second);
    BusTypeP = static_cast<BusType>(BusTypeDecoder.get());
  }
  rti1516ev::HLAobjectInstanceHandle RequestingFederateDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator RequestingFederateIter = parameters.find(GetRequestingFederateParameterHandle());
  if (RequestingFederateIter != parameters.end())
  {
    RequestingFederateDecoder.decode(RequestingFederateIter->second);
    RequestingFederate = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(RequestingFederateDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle SenderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SenderIter = parameters.find(GetSenderParameterHandle());
  if (SenderIter != parameters.end())
  {
    SenderDecoder.decode(SenderIter->second);
    Sender = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(SenderDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle ReceiverDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ReceiverIter = parameters.find(GetReceiverParameterHandle());
  if (ReceiverIter != parameters.end())
  {
    ReceiverDecoder.decode(ReceiverIter->second);
    Receiver = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(ReceiverDecoder.get()).get();
  }
  rti1516ev::HLAopaqueData FrameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator FrameIter = parameters.find(GetFrameParameterHandle());
  if (FrameIter != parameters.end())
  {
    FrameDecoder.decode(FrameIter->second);
    Frame = FrameDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(IsRequest, ChannelName, BusTypeP, RequestingFederate, Sender, Receiver, Frame, optional<int64_t>(), optional<OrderType>());
  }
}

void CANErrorFrameInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters , const rti1516ev::LogicalTime& time, OrderType orderType)
{
  optional<bool> IsRequest;
  optional<std::string> ChannelName;
  optional<BusType> BusTypeP;
  optional<IBusController*> RequestingFederate;
  optional<IBusController*> Sender;
  optional<IBusController*> Receiver;
  optional<const std::vector<uint8_t>&> Frame;

  rti1516ev::HLAboolean IsRequestDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IsRequestIter = parameters.find(GetIsRequestParameterHandle());
  if (IsRequestIter != parameters.end())
  {
    IsRequestDecoder.decode(IsRequestIter->second);
    IsRequest = IsRequestDecoder.get();
  }
  rti1516ev::HLAASCIIstring ChannelNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ChannelNameIter = parameters.find(GetChannelNameParameterHandle());
  if (ChannelNameIter != parameters.end())
  {
    ChannelNameDecoder.decode(ChannelNameIter->second);
    ChannelName = ChannelNameDecoder.get();
  }
  rti1516ev::HLAinteger32LE BusTypeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator BusTypeIter = parameters.find(GetBusTypeParameterHandle());
  if (BusTypeIter != parameters.end())
  {
    BusTypeDecoder.decode(BusTypeIter->second);
    BusTypeP = static_cast<BusType>(BusTypeDecoder.get());
  }
  rti1516ev::HLAobjectInstanceHandle RequestingFederateDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator RequestingFederateIter = parameters.find(GetRequestingFederateParameterHandle());
  if (RequestingFederateIter != parameters.end())
  {
    RequestingFederateDecoder.decode(RequestingFederateIter->second);
    RequestingFederate = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(RequestingFederateDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle SenderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SenderIter = parameters.find(GetSenderParameterHandle());
  if (SenderIter != parameters.end())
  {
    SenderDecoder.decode(SenderIter->second);
    Sender = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(SenderDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle ReceiverDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ReceiverIter = parameters.find(GetReceiverParameterHandle());
  if (ReceiverIter != parameters.end())
  {
    ReceiverDecoder.decode(ReceiverIter->second);
    Receiver = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(ReceiverDecoder.get()).get();
  }
  rti1516ev::HLAopaqueData FrameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator FrameIter = parameters.find(GetFrameParameterHandle());
  if (FrameIter != parameters.end())
  {
    FrameDecoder.decode(FrameIter->second);
    Frame = FrameDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(IsRequest, ChannelName, BusTypeP, RequestingFederate, Sender, Receiver, Frame, static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  }
}

uint32_t CANErrorFrameInteractionClass::RegisterReceiveCallback(ReceiveCallback callback)
{
  uint32_t key = mReceiveCallbacksNextKey++;
  mReceiveCallbacks.insert(std::make_pair(key, callback));
  return key;
}

rti1516ev::ParameterHandleSet CANErrorFrameInteractionClass::GetAllParameterHandles()
{
  rti1516ev::ParameterHandleSet result;
  result.insert(GetIsRequestParameterHandle());
  result.insert(GetChannelNameParameterHandle());
  result.insert(GetBusTypeParameterHandle());
  result.insert(GetRequestingFederateParameterHandle());
  result.insert(GetSenderParameterHandle());
  result.insert(GetReceiverParameterHandle());
  result.insert(GetFrameParameterHandle());
  return result;
}

// object class type 'FlexRaySymbol'
FlexRaySymbolInteractionClass::FlexRaySymbolInteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry, BusMessageInteractionClass* baseClass)
{
  mInteractionClassRegistry = interactionClassRegistry;
  mRtiAmbassador = rtiAmbassador;

  mBaseClass = baseClass;
  mInteractionClassHandle = rtiAmbassador->getInteractionClassHandle(L"HLAinteractionRoot.BusMessage.FlexRaySymbol");
  // parameter SymbolPattern : FlexRaySymbolPattern
  mSymbolPatternParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"SymbolPattern");
  // parameter FlexRayChannel : FlexRayChannel
  mFlexRayChannelParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"FlexRayChannel");
}

// get the corresponding *object* class registry, for access to objects sent as parameters
ObjectClassRegistry* FlexRaySymbolInteractionClass::GetObjectClassRegistry()
{
  return mInteractionClassRegistry->GetObjectClassRegistry();
}

void FlexRaySymbolInteractionClass::Publish()
{
  if (!mPublished)
  {
    mRtiAmbassador->publishInteractionClass(mInteractionClassHandle);
    mPublished = true;
  }
}

void FlexRaySymbolInteractionClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishInteractionClass(mInteractionClassHandle);
    mPublished = false;
  }
}

void FlexRaySymbolInteractionClass::Subscribe(bool deliverToSelf)
{
  mRtiAmbassador->subscribeInteractionClass(mInteractionClassHandle);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  mSubscribed = true;
}

void FlexRaySymbolInteractionClass::Subscribe(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<FlexRaySymbolPattern> SymbolPattern, optional<FlexRayChannel> FlexRayChannel, bool deliverToSelf)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (SymbolPattern)
  {
    rti1516ev::HLAoctet SymbolPatternEncoder(static_cast<uint8_t>(*SymbolPattern));
    parameters.insert(std::make_pair(GetSymbolPatternParameterHandle(), SymbolPatternEncoder.encode()));
  }
  if (FlexRayChannel)
  {
    rti1516ev::HLAoctet FlexRayChannelEncoder(static_cast<uint8_t>(*FlexRayChannel));
    parameters.insert(std::make_pair(GetFlexRayChannelParameterHandle(), FlexRayChannelEncoder.encode()));
  }
  mRtiAmbassador->subscribeInteractionClassWithFilter(mInteractionClassHandle, parameters);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  // we must always set mSubscribed, otherwise we can't unsubscribe
  mSubscribed = true;
}

void FlexRaySymbolInteractionClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeInteractionClass(mInteractionClassHandle);
    mSubscribed = false;
  }
}

void FlexRaySymbolInteractionClass::send(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<FlexRaySymbolPattern> SymbolPattern, optional<FlexRayChannel> FlexRayChannel)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (SymbolPattern)
  {
    rti1516ev::HLAoctet SymbolPatternEncoder(static_cast<uint8_t>(*SymbolPattern));
    parameters.insert(std::make_pair(GetSymbolPatternParameterHandle(), SymbolPatternEncoder.encode()));
  }
  if (FlexRayChannel)
  {
    rti1516ev::HLAoctet FlexRayChannelEncoder(static_cast<uint8_t>(*FlexRayChannel));
    parameters.insert(std::make_pair(GetFlexRayChannelParameterHandle(), FlexRayChannelEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData());
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void FlexRaySymbolInteractionClass::sendWithTime(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<FlexRaySymbolPattern> SymbolPattern, optional<FlexRayChannel> FlexRayChannel, int64_t time)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (SymbolPattern)
  {
    rti1516ev::HLAoctet SymbolPatternEncoder(static_cast<uint8_t>(*SymbolPattern));
    parameters.insert(std::make_pair(GetSymbolPatternParameterHandle(), SymbolPatternEncoder.encode()));
  }
  if (FlexRayChannel)
  {
    rti1516ev::HLAoctet FlexRayChannelEncoder(static_cast<uint8_t>(*FlexRayChannel));
    parameters.insert(std::make_pair(GetFlexRayChannelParameterHandle(), FlexRayChannelEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
  }
  catch (const rti1516ev::InvalidLogicalTime& e)
  {
    throw InvalidLogicalTime(to_string(e.what()));
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void FlexRaySymbolInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters )
{
  optional<bool> IsRequest;
  optional<std::string> ChannelName;
  optional<BusType> BusTypeP;
  optional<IBusController*> RequestingFederate;
  optional<IBusController*> Sender;
  optional<IBusController*> Receiver;
  optional<FlexRaySymbolPattern> SymbolPattern;
  optional<FlexRayChannel> FlexRayChannelP;
  rti1516ev::HLAboolean IsRequestDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IsRequestIter = parameters.find(GetIsRequestParameterHandle());
  if (IsRequestIter != parameters.end())
  {
    IsRequestDecoder.decode(IsRequestIter->second);
    IsRequest = IsRequestDecoder.get();
  }
  rti1516ev::HLAASCIIstring ChannelNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ChannelNameIter = parameters.find(GetChannelNameParameterHandle());
  if (ChannelNameIter != parameters.end())
  {
    ChannelNameDecoder.decode(ChannelNameIter->second);
    ChannelName = ChannelNameDecoder.get();
  }
  rti1516ev::HLAinteger32LE BusTypeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator BusTypeIter = parameters.find(GetBusTypeParameterHandle());
  if (BusTypeIter != parameters.end())
  {
    BusTypeDecoder.decode(BusTypeIter->second);
    BusTypeP = static_cast<BusType>(BusTypeDecoder.get());
  }
  rti1516ev::HLAobjectInstanceHandle RequestingFederateDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator RequestingFederateIter = parameters.find(GetRequestingFederateParameterHandle());
  if (RequestingFederateIter != parameters.end())
  {
    RequestingFederateDecoder.decode(RequestingFederateIter->second);
    RequestingFederate = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(RequestingFederateDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle SenderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SenderIter = parameters.find(GetSenderParameterHandle());
  if (SenderIter != parameters.end())
  {
    SenderDecoder.decode(SenderIter->second);
    Sender = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(SenderDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle ReceiverDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ReceiverIter = parameters.find(GetReceiverParameterHandle());
  if (ReceiverIter != parameters.end())
  {
    ReceiverDecoder.decode(ReceiverIter->second);
    Receiver = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(ReceiverDecoder.get()).get();
  }
  rti1516ev::HLAoctet SymbolPatternDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SymbolPatternIter = parameters.find(GetSymbolPatternParameterHandle());
  if (SymbolPatternIter != parameters.end())
  {
    SymbolPatternDecoder.decode(SymbolPatternIter->second);
    SymbolPattern = static_cast<FlexRaySymbolPattern>(SymbolPatternDecoder.get());
  }
  rti1516ev::HLAoctet FlexRayChannelDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator FlexRayChannelIter = parameters.find(GetFlexRayChannelParameterHandle());
  if (FlexRayChannelIter != parameters.end())
  {
    FlexRayChannelDecoder.decode(FlexRayChannelIter->second);
    FlexRayChannelP = static_cast<FlexRayChannel>(FlexRayChannelDecoder.get());
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(IsRequest, ChannelName, BusTypeP, RequestingFederate, Sender, Receiver, SymbolPattern, FlexRayChannelP, optional<int64_t>(), optional<OrderType>());
  }
}

void FlexRaySymbolInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters , const rti1516ev::LogicalTime& time, OrderType orderType)
{
  optional<bool> IsRequest;
  optional<std::string> ChannelName;
  optional<BusType> BusTypeP;
  optional<IBusController*> RequestingFederate;
  optional<IBusController*> Sender;
  optional<IBusController*> Receiver;
  optional<FlexRaySymbolPattern> SymbolPattern;
  optional<FlexRayChannel> FlexRayChannelP;

  rti1516ev::HLAboolean IsRequestDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IsRequestIter = parameters.find(GetIsRequestParameterHandle());
  if (IsRequestIter != parameters.end())
  {
    IsRequestDecoder.decode(IsRequestIter->second);
    IsRequest = IsRequestDecoder.get();
  }
  rti1516ev::HLAASCIIstring ChannelNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ChannelNameIter = parameters.find(GetChannelNameParameterHandle());
  if (ChannelNameIter != parameters.end())
  {
    ChannelNameDecoder.decode(ChannelNameIter->second);
    ChannelName = ChannelNameDecoder.get();
  }
  rti1516ev::HLAinteger32LE BusTypeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator BusTypeIter = parameters.find(GetBusTypeParameterHandle());
  if (BusTypeIter != parameters.end())
  {
    BusTypeDecoder.decode(BusTypeIter->second);
    BusTypeP = static_cast<BusType>(BusTypeDecoder.get());
  }
  rti1516ev::HLAobjectInstanceHandle RequestingFederateDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator RequestingFederateIter = parameters.find(GetRequestingFederateParameterHandle());
  if (RequestingFederateIter != parameters.end())
  {
    RequestingFederateDecoder.decode(RequestingFederateIter->second);
    RequestingFederate = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(RequestingFederateDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle SenderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SenderIter = parameters.find(GetSenderParameterHandle());
  if (SenderIter != parameters.end())
  {
    SenderDecoder.decode(SenderIter->second);
    Sender = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(SenderDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle ReceiverDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ReceiverIter = parameters.find(GetReceiverParameterHandle());
  if (ReceiverIter != parameters.end())
  {
    ReceiverDecoder.decode(ReceiverIter->second);
    Receiver = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(ReceiverDecoder.get()).get();
  }
  rti1516ev::HLAoctet SymbolPatternDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SymbolPatternIter = parameters.find(GetSymbolPatternParameterHandle());
  if (SymbolPatternIter != parameters.end())
  {
    SymbolPatternDecoder.decode(SymbolPatternIter->second);
    SymbolPattern = static_cast<FlexRaySymbolPattern>(SymbolPatternDecoder.get());
  }
  rti1516ev::HLAoctet FlexRayChannelDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator FlexRayChannelIter = parameters.find(GetFlexRayChannelParameterHandle());
  if (FlexRayChannelIter != parameters.end())
  {
    FlexRayChannelDecoder.decode(FlexRayChannelIter->second);
    FlexRayChannelP = static_cast<FlexRayChannel>(FlexRayChannelDecoder.get());
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(IsRequest, ChannelName, BusTypeP, RequestingFederate, Sender, Receiver, SymbolPattern, FlexRayChannelP, static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  }
}

uint32_t FlexRaySymbolInteractionClass::RegisterReceiveCallback(ReceiveCallback callback)
{
  uint32_t key = mReceiveCallbacksNextKey++;
  mReceiveCallbacks.insert(std::make_pair(key, callback));
  return key;
}

rti1516ev::ParameterHandleSet FlexRaySymbolInteractionClass::GetAllParameterHandles()
{
  rti1516ev::ParameterHandleSet result;
  result.insert(GetIsRequestParameterHandle());
  result.insert(GetChannelNameParameterHandle());
  result.insert(GetBusTypeParameterHandle());
  result.insert(GetRequestingFederateParameterHandle());
  result.insert(GetSenderParameterHandle());
  result.insert(GetReceiverParameterHandle());
  result.insert(GetSymbolPatternParameterHandle());
  result.insert(GetFlexRayChannelParameterHandle());
  return result;
}

// object class type 'FlexRayCycleStart'
FlexRayCycleStartInteractionClass::FlexRayCycleStartInteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry, BusMessageInteractionClass* baseClass)
{
  mInteractionClassRegistry = interactionClassRegistry;
  mRtiAmbassador = rtiAmbassador;

  mBaseClass = baseClass;
  mInteractionClassHandle = rtiAmbassador->getInteractionClassHandle(L"HLAinteractionRoot.BusMessage.FlexRayCycleStart");
  // parameter Cycle : HLAoctet
  mCycleParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Cycle");
}

// get the corresponding *object* class registry, for access to objects sent as parameters
ObjectClassRegistry* FlexRayCycleStartInteractionClass::GetObjectClassRegistry()
{
  return mInteractionClassRegistry->GetObjectClassRegistry();
}

void FlexRayCycleStartInteractionClass::Publish()
{
  if (!mPublished)
  {
    mRtiAmbassador->publishInteractionClass(mInteractionClassHandle);
    mPublished = true;
  }
}

void FlexRayCycleStartInteractionClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishInteractionClass(mInteractionClassHandle);
    mPublished = false;
  }
}

void FlexRayCycleStartInteractionClass::Subscribe(bool deliverToSelf)
{
  mRtiAmbassador->subscribeInteractionClass(mInteractionClassHandle);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  mSubscribed = true;
}

void FlexRayCycleStartInteractionClass::Subscribe(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<uint8_t> Cycle, bool deliverToSelf)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (Cycle)
  {
    rti1516ev::HLAoctet CycleEncoder(*Cycle);
    parameters.insert(std::make_pair(GetCycleParameterHandle(), CycleEncoder.encode()));
  }
  mRtiAmbassador->subscribeInteractionClassWithFilter(mInteractionClassHandle, parameters);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  // we must always set mSubscribed, otherwise we can't unsubscribe
  mSubscribed = true;
}

void FlexRayCycleStartInteractionClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeInteractionClass(mInteractionClassHandle);
    mSubscribed = false;
  }
}

void FlexRayCycleStartInteractionClass::send(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<uint8_t> Cycle)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (Cycle)
  {
    rti1516ev::HLAoctet CycleEncoder(*Cycle);
    parameters.insert(std::make_pair(GetCycleParameterHandle(), CycleEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData());
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void FlexRayCycleStartInteractionClass::sendWithTime(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<uint8_t> Cycle, int64_t time)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (Cycle)
  {
    rti1516ev::HLAoctet CycleEncoder(*Cycle);
    parameters.insert(std::make_pair(GetCycleParameterHandle(), CycleEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
  }
  catch (const rti1516ev::InvalidLogicalTime& e)
  {
    throw InvalidLogicalTime(to_string(e.what()));
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void FlexRayCycleStartInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters )
{
  optional<bool> IsRequest;
  optional<std::string> ChannelName;
  optional<BusType> BusTypeP;
  optional<IBusController*> RequestingFederate;
  optional<IBusController*> Sender;
  optional<IBusController*> Receiver;
  optional<uint8_t> Cycle;
  rti1516ev::HLAboolean IsRequestDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IsRequestIter = parameters.find(GetIsRequestParameterHandle());
  if (IsRequestIter != parameters.end())
  {
    IsRequestDecoder.decode(IsRequestIter->second);
    IsRequest = IsRequestDecoder.get();
  }
  rti1516ev::HLAASCIIstring ChannelNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ChannelNameIter = parameters.find(GetChannelNameParameterHandle());
  if (ChannelNameIter != parameters.end())
  {
    ChannelNameDecoder.decode(ChannelNameIter->second);
    ChannelName = ChannelNameDecoder.get();
  }
  rti1516ev::HLAinteger32LE BusTypeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator BusTypeIter = parameters.find(GetBusTypeParameterHandle());
  if (BusTypeIter != parameters.end())
  {
    BusTypeDecoder.decode(BusTypeIter->second);
    BusTypeP = static_cast<BusType>(BusTypeDecoder.get());
  }
  rti1516ev::HLAobjectInstanceHandle RequestingFederateDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator RequestingFederateIter = parameters.find(GetRequestingFederateParameterHandle());
  if (RequestingFederateIter != parameters.end())
  {
    RequestingFederateDecoder.decode(RequestingFederateIter->second);
    RequestingFederate = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(RequestingFederateDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle SenderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SenderIter = parameters.find(GetSenderParameterHandle());
  if (SenderIter != parameters.end())
  {
    SenderDecoder.decode(SenderIter->second);
    Sender = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(SenderDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle ReceiverDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ReceiverIter = parameters.find(GetReceiverParameterHandle());
  if (ReceiverIter != parameters.end())
  {
    ReceiverDecoder.decode(ReceiverIter->second);
    Receiver = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(ReceiverDecoder.get()).get();
  }
  rti1516ev::HLAoctet CycleDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator CycleIter = parameters.find(GetCycleParameterHandle());
  if (CycleIter != parameters.end())
  {
    CycleDecoder.decode(CycleIter->second);
    Cycle = CycleDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(IsRequest, ChannelName, BusTypeP, RequestingFederate, Sender, Receiver, Cycle, optional<int64_t>(), optional<OrderType>());
  }
}

void FlexRayCycleStartInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters , const rti1516ev::LogicalTime& time, OrderType orderType)
{
  optional<bool> IsRequest;
  optional<std::string> ChannelName;
  optional<BusType> BusTypeP;
  optional<IBusController*> RequestingFederate;
  optional<IBusController*> Sender;
  optional<IBusController*> Receiver;
  optional<uint8_t> Cycle;

  rti1516ev::HLAboolean IsRequestDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IsRequestIter = parameters.find(GetIsRequestParameterHandle());
  if (IsRequestIter != parameters.end())
  {
    IsRequestDecoder.decode(IsRequestIter->second);
    IsRequest = IsRequestDecoder.get();
  }
  rti1516ev::HLAASCIIstring ChannelNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ChannelNameIter = parameters.find(GetChannelNameParameterHandle());
  if (ChannelNameIter != parameters.end())
  {
    ChannelNameDecoder.decode(ChannelNameIter->second);
    ChannelName = ChannelNameDecoder.get();
  }
  rti1516ev::HLAinteger32LE BusTypeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator BusTypeIter = parameters.find(GetBusTypeParameterHandle());
  if (BusTypeIter != parameters.end())
  {
    BusTypeDecoder.decode(BusTypeIter->second);
    BusTypeP = static_cast<BusType>(BusTypeDecoder.get());
  }
  rti1516ev::HLAobjectInstanceHandle RequestingFederateDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator RequestingFederateIter = parameters.find(GetRequestingFederateParameterHandle());
  if (RequestingFederateIter != parameters.end())
  {
    RequestingFederateDecoder.decode(RequestingFederateIter->second);
    RequestingFederate = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(RequestingFederateDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle SenderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SenderIter = parameters.find(GetSenderParameterHandle());
  if (SenderIter != parameters.end())
  {
    SenderDecoder.decode(SenderIter->second);
    Sender = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(SenderDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle ReceiverDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ReceiverIter = parameters.find(GetReceiverParameterHandle());
  if (ReceiverIter != parameters.end())
  {
    ReceiverDecoder.decode(ReceiverIter->second);
    Receiver = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(ReceiverDecoder.get()).get();
  }
  rti1516ev::HLAoctet CycleDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator CycleIter = parameters.find(GetCycleParameterHandle());
  if (CycleIter != parameters.end())
  {
    CycleDecoder.decode(CycleIter->second);
    Cycle = CycleDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(IsRequest, ChannelName, BusTypeP, RequestingFederate, Sender, Receiver, Cycle, static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  }
}

uint32_t FlexRayCycleStartInteractionClass::RegisterReceiveCallback(ReceiveCallback callback)
{
  uint32_t key = mReceiveCallbacksNextKey++;
  mReceiveCallbacks.insert(std::make_pair(key, callback));
  return key;
}

rti1516ev::ParameterHandleSet FlexRayCycleStartInteractionClass::GetAllParameterHandles()
{
  rti1516ev::ParameterHandleSet result;
  result.insert(GetIsRequestParameterHandle());
  result.insert(GetChannelNameParameterHandle());
  result.insert(GetBusTypeParameterHandle());
  result.insert(GetRequestingFederateParameterHandle());
  result.insert(GetSenderParameterHandle());
  result.insert(GetReceiverParameterHandle());
  result.insert(GetCycleParameterHandle());
  return result;
}

// object class type 'FlexRayFrame'
FlexRayFrameInteractionClass::FlexRayFrameInteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry, BusMessageInteractionClass* baseClass)
{
  mInteractionClassRegistry = interactionClassRegistry;
  mRtiAmbassador = rtiAmbassador;

  mBaseClass = baseClass;
  mInteractionClassHandle = rtiAmbassador->getInteractionClassHandle(L"HLAinteractionRoot.BusMessage.FlexRayFrame");
  // parameter FrameID : HLAinteger16LE
  mFrameIDParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"FrameID");
  // parameter FlexRayChannel : FlexRayChannel
  mFlexRayChannelParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"FlexRayChannel");
  // parameter PayloadPreambleIndicator : HLAboolean
  mPayloadPreambleIndicatorParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"PayloadPreambleIndicator");
  // parameter Header : FlexRayHeader
  mHeaderParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Header");
  // parameter Payload : FlexRayPayload
  mPayloadParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Payload");
}

// get the corresponding *object* class registry, for access to objects sent as parameters
ObjectClassRegistry* FlexRayFrameInteractionClass::GetObjectClassRegistry()
{
  return mInteractionClassRegistry->GetObjectClassRegistry();
}

void FlexRayFrameInteractionClass::Publish()
{
  if (!mPublished)
  {
    mRtiAmbassador->publishInteractionClass(mInteractionClassHandle);
    mPublished = true;
  }
}

void FlexRayFrameInteractionClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishInteractionClass(mInteractionClassHandle);
    mPublished = false;
  }
}

void FlexRayFrameInteractionClass::Subscribe(bool deliverToSelf)
{
  mRtiAmbassador->subscribeInteractionClass(mInteractionClassHandle);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  mSubscribed = true;
}

void FlexRayFrameInteractionClass::Subscribe(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<int16_t> FrameID, optional<FlexRayChannel> FlexRayChannel, optional<bool> PayloadPreambleIndicator, optional<const FlexRayHeader&> Header, optional<const FlexRayPayload&> Payload, bool deliverToSelf)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (FrameID)
  {
    rti1516ev::HLAinteger16LE FrameIDEncoder(*FrameID);
    parameters.insert(std::make_pair(GetFrameIDParameterHandle(), FrameIDEncoder.encode()));
  }
  if (FlexRayChannel)
  {
    rti1516ev::HLAoctet FlexRayChannelEncoder(static_cast<uint8_t>(*FlexRayChannel));
    parameters.insert(std::make_pair(GetFlexRayChannelParameterHandle(), FlexRayChannelEncoder.encode()));
  }
  if (PayloadPreambleIndicator)
  {
    rti1516ev::HLAboolean PayloadPreambleIndicatorEncoder(*PayloadPreambleIndicator);
    parameters.insert(std::make_pair(GetPayloadPreambleIndicatorParameterHandle(), PayloadPreambleIndicatorEncoder.encode()));
  }
  if (Header)
  {
    const FlexRayHeaderEncoding& HeaderEncoder = static_cast<const FlexRayHeaderEncoding&>(*Header);
    parameters.insert(std::make_pair(GetHeaderParameterHandle(), HeaderEncoder.encode()));
  }
  if (Payload)
  {
    const FlexRayPayloadEncoding& PayloadEncoder = static_cast<const FlexRayPayloadEncoding&>(*Payload);
    parameters.insert(std::make_pair(GetPayloadParameterHandle(), PayloadEncoder.encode()));
  }
  mRtiAmbassador->subscribeInteractionClassWithFilter(mInteractionClassHandle, parameters);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  // we must always set mSubscribed, otherwise we can't unsubscribe
  mSubscribed = true;
}

void FlexRayFrameInteractionClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeInteractionClass(mInteractionClassHandle);
    mSubscribed = false;
  }
}

void FlexRayFrameInteractionClass::send(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<int16_t> FrameID, optional<FlexRayChannel> FlexRayChannel, optional<bool> PayloadPreambleIndicator, optional<const FlexRayHeader&> Header, optional<const FlexRayPayload&> Payload)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (FrameID)
  {
    rti1516ev::HLAinteger16LE FrameIDEncoder(*FrameID);
    parameters.insert(std::make_pair(GetFrameIDParameterHandle(), FrameIDEncoder.encode()));
  }
  if (FlexRayChannel)
  {
    rti1516ev::HLAoctet FlexRayChannelEncoder(static_cast<uint8_t>(*FlexRayChannel));
    parameters.insert(std::make_pair(GetFlexRayChannelParameterHandle(), FlexRayChannelEncoder.encode()));
  }
  if (PayloadPreambleIndicator)
  {
    rti1516ev::HLAboolean PayloadPreambleIndicatorEncoder(*PayloadPreambleIndicator);
    parameters.insert(std::make_pair(GetPayloadPreambleIndicatorParameterHandle(), PayloadPreambleIndicatorEncoder.encode()));
  }
  if (Header)
  {
    const FlexRayHeaderEncoding& HeaderEncoder = static_cast<const FlexRayHeaderEncoding&>(*Header);
    parameters.insert(std::make_pair(GetHeaderParameterHandle(), HeaderEncoder.encode()));
  }
  if (Payload)
  {
    const FlexRayPayloadEncoding& PayloadEncoder = static_cast<const FlexRayPayloadEncoding&>(*Payload);
    parameters.insert(std::make_pair(GetPayloadParameterHandle(), PayloadEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData());
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void FlexRayFrameInteractionClass::sendWithTime(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<int16_t> FrameID, optional<FlexRayChannel> FlexRayChannel, optional<bool> PayloadPreambleIndicator, optional<const FlexRayHeader&> Header, optional<const FlexRayPayload&> Payload, int64_t time)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (IsRequest)
  {
    rti1516ev::HLAboolean IsRequestEncoder(*IsRequest);
    parameters.insert(std::make_pair(GetIsRequestParameterHandle(), IsRequestEncoder.encode()));
  }
  if (ChannelName)
  {
    rti1516ev::HLAASCIIstring ChannelNameEncoder(*ChannelName);
    parameters.insert(std::make_pair(GetChannelNameParameterHandle(), ChannelNameEncoder.encode()));
  }
  if (BusType)
  {
    rti1516ev::HLAinteger32LE BusTypeEncoder(static_cast<int32_t>(*BusType));
    parameters.insert(std::make_pair(GetBusTypeParameterHandle(), BusTypeEncoder.encode()));
  }
  if (RequestingFederate)
  {
    rti1516ev::HLAobjectInstanceHandle RequestingFederateEncoder(dynamic_cast<IObjectImplBase*>(*RequestingFederate)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetRequestingFederateParameterHandle(), RequestingFederateEncoder.encode()));
  }
  if (Sender)
  {
    rti1516ev::HLAobjectInstanceHandle SenderEncoder(dynamic_cast<IObjectImplBase*>(*Sender)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetSenderParameterHandle(), SenderEncoder.encode()));
  }
  if (Receiver)
  {
    rti1516ev::HLAobjectInstanceHandle ReceiverEncoder(dynamic_cast<IObjectImplBase*>(*Receiver)->GetObjectInstanceHandle());
    parameters.insert(std::make_pair(GetReceiverParameterHandle(), ReceiverEncoder.encode()));
  }
  if (FrameID)
  {
    rti1516ev::HLAinteger16LE FrameIDEncoder(*FrameID);
    parameters.insert(std::make_pair(GetFrameIDParameterHandle(), FrameIDEncoder.encode()));
  }
  if (FlexRayChannel)
  {
    rti1516ev::HLAoctet FlexRayChannelEncoder(static_cast<uint8_t>(*FlexRayChannel));
    parameters.insert(std::make_pair(GetFlexRayChannelParameterHandle(), FlexRayChannelEncoder.encode()));
  }
  if (PayloadPreambleIndicator)
  {
    rti1516ev::HLAboolean PayloadPreambleIndicatorEncoder(*PayloadPreambleIndicator);
    parameters.insert(std::make_pair(GetPayloadPreambleIndicatorParameterHandle(), PayloadPreambleIndicatorEncoder.encode()));
  }
  if (Header)
  {
    const FlexRayHeaderEncoding& HeaderEncoder = static_cast<const FlexRayHeaderEncoding&>(*Header);
    parameters.insert(std::make_pair(GetHeaderParameterHandle(), HeaderEncoder.encode()));
  }
  if (Payload)
  {
    const FlexRayPayloadEncoding& PayloadEncoder = static_cast<const FlexRayPayloadEncoding&>(*Payload);
    parameters.insert(std::make_pair(GetPayloadParameterHandle(), PayloadEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
  }
  catch (const rti1516ev::InvalidLogicalTime& e)
  {
    throw InvalidLogicalTime(to_string(e.what()));
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void FlexRayFrameInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters )
{
  optional<bool> IsRequest;
  optional<std::string> ChannelName;
  optional<BusType> BusTypeP;
  optional<IBusController*> RequestingFederate;
  optional<IBusController*> Sender;
  optional<IBusController*> Receiver;
  optional<int16_t> FrameID;
  optional<FlexRayChannel> FlexRayChannelP;
  optional<bool> PayloadPreambleIndicator;
  optional<const FlexRayHeader&> Header;
  optional<const FlexRayPayload&> Payload;
  rti1516ev::HLAboolean IsRequestDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IsRequestIter = parameters.find(GetIsRequestParameterHandle());
  if (IsRequestIter != parameters.end())
  {
    IsRequestDecoder.decode(IsRequestIter->second);
    IsRequest = IsRequestDecoder.get();
  }
  rti1516ev::HLAASCIIstring ChannelNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ChannelNameIter = parameters.find(GetChannelNameParameterHandle());
  if (ChannelNameIter != parameters.end())
  {
    ChannelNameDecoder.decode(ChannelNameIter->second);
    ChannelName = ChannelNameDecoder.get();
  }
  rti1516ev::HLAinteger32LE BusTypeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator BusTypeIter = parameters.find(GetBusTypeParameterHandle());
  if (BusTypeIter != parameters.end())
  {
    BusTypeDecoder.decode(BusTypeIter->second);
    BusTypeP = static_cast<BusType>(BusTypeDecoder.get());
  }
  rti1516ev::HLAobjectInstanceHandle RequestingFederateDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator RequestingFederateIter = parameters.find(GetRequestingFederateParameterHandle());
  if (RequestingFederateIter != parameters.end())
  {
    RequestingFederateDecoder.decode(RequestingFederateIter->second);
    RequestingFederate = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(RequestingFederateDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle SenderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SenderIter = parameters.find(GetSenderParameterHandle());
  if (SenderIter != parameters.end())
  {
    SenderDecoder.decode(SenderIter->second);
    Sender = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(SenderDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle ReceiverDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ReceiverIter = parameters.find(GetReceiverParameterHandle());
  if (ReceiverIter != parameters.end())
  {
    ReceiverDecoder.decode(ReceiverIter->second);
    Receiver = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(ReceiverDecoder.get()).get();
  }
  rti1516ev::HLAinteger16LE FrameIDDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator FrameIDIter = parameters.find(GetFrameIDParameterHandle());
  if (FrameIDIter != parameters.end())
  {
    FrameIDDecoder.decode(FrameIDIter->second);
    FrameID = FrameIDDecoder.get();
  }
  rti1516ev::HLAoctet FlexRayChannelDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator FlexRayChannelIter = parameters.find(GetFlexRayChannelParameterHandle());
  if (FlexRayChannelIter != parameters.end())
  {
    FlexRayChannelDecoder.decode(FlexRayChannelIter->second);
    FlexRayChannelP = static_cast<FlexRayChannel>(FlexRayChannelDecoder.get());
  }
  rti1516ev::HLAboolean PayloadPreambleIndicatorDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator PayloadPreambleIndicatorIter = parameters.find(GetPayloadPreambleIndicatorParameterHandle());
  if (PayloadPreambleIndicatorIter != parameters.end())
  {
    PayloadPreambleIndicatorDecoder.decode(PayloadPreambleIndicatorIter->second);
    PayloadPreambleIndicator = PayloadPreambleIndicatorDecoder.get();
  }
  FlexRayHeaderEncoding HeaderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator HeaderIter = parameters.find(GetHeaderParameterHandle());
  if (HeaderIter != parameters.end())
  {
    HeaderDecoder.decode(HeaderIter->second);
    Header = HeaderDecoder;
  }
  FlexRayPayloadEncoding PayloadDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator PayloadIter = parameters.find(GetPayloadParameterHandle());
  if (PayloadIter != parameters.end())
  {
    PayloadDecoder.decode(PayloadIter->second);
    Payload = PayloadDecoder;
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(IsRequest, ChannelName, BusTypeP, RequestingFederate, Sender, Receiver, FrameID, FlexRayChannelP, PayloadPreambleIndicator, Header, Payload, optional<int64_t>(), optional<OrderType>());
  }
}

void FlexRayFrameInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters , const rti1516ev::LogicalTime& time, OrderType orderType)
{
  optional<bool> IsRequest;
  optional<std::string> ChannelName;
  optional<BusType> BusTypeP;
  optional<IBusController*> RequestingFederate;
  optional<IBusController*> Sender;
  optional<IBusController*> Receiver;
  optional<int16_t> FrameID;
  optional<FlexRayChannel> FlexRayChannelP;
  optional<bool> PayloadPreambleIndicator;
  optional<const FlexRayHeader&> Header;
  optional<const FlexRayPayload&> Payload;

  rti1516ev::HLAboolean IsRequestDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator IsRequestIter = parameters.find(GetIsRequestParameterHandle());
  if (IsRequestIter != parameters.end())
  {
    IsRequestDecoder.decode(IsRequestIter->second);
    IsRequest = IsRequestDecoder.get();
  }
  rti1516ev::HLAASCIIstring ChannelNameDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ChannelNameIter = parameters.find(GetChannelNameParameterHandle());
  if (ChannelNameIter != parameters.end())
  {
    ChannelNameDecoder.decode(ChannelNameIter->second);
    ChannelName = ChannelNameDecoder.get();
  }
  rti1516ev::HLAinteger32LE BusTypeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator BusTypeIter = parameters.find(GetBusTypeParameterHandle());
  if (BusTypeIter != parameters.end())
  {
    BusTypeDecoder.decode(BusTypeIter->second);
    BusTypeP = static_cast<BusType>(BusTypeDecoder.get());
  }
  rti1516ev::HLAobjectInstanceHandle RequestingFederateDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator RequestingFederateIter = parameters.find(GetRequestingFederateParameterHandle());
  if (RequestingFederateIter != parameters.end())
  {
    RequestingFederateDecoder.decode(RequestingFederateIter->second);
    RequestingFederate = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(RequestingFederateDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle SenderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator SenderIter = parameters.find(GetSenderParameterHandle());
  if (SenderIter != parameters.end())
  {
    SenderDecoder.decode(SenderIter->second);
    Sender = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(SenderDecoder.get()).get();
  }
  rti1516ev::HLAobjectInstanceHandle ReceiverDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator ReceiverIter = parameters.find(GetReceiverParameterHandle());
  if (ReceiverIter != parameters.end())
  {
    ReceiverDecoder.decode(ReceiverIter->second);
    Receiver = static_cast<BusControllerObjectClass*>(GetObjectClassRegistry()->GetBusControllerObjectClass())->GetObjectInstance(ReceiverDecoder.get()).get();
  }
  rti1516ev::HLAinteger16LE FrameIDDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator FrameIDIter = parameters.find(GetFrameIDParameterHandle());
  if (FrameIDIter != parameters.end())
  {
    FrameIDDecoder.decode(FrameIDIter->second);
    FrameID = FrameIDDecoder.get();
  }
  rti1516ev::HLAoctet FlexRayChannelDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator FlexRayChannelIter = parameters.find(GetFlexRayChannelParameterHandle());
  if (FlexRayChannelIter != parameters.end())
  {
    FlexRayChannelDecoder.decode(FlexRayChannelIter->second);
    FlexRayChannelP = static_cast<FlexRayChannel>(FlexRayChannelDecoder.get());
  }
  rti1516ev::HLAboolean PayloadPreambleIndicatorDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator PayloadPreambleIndicatorIter = parameters.find(GetPayloadPreambleIndicatorParameterHandle());
  if (PayloadPreambleIndicatorIter != parameters.end())
  {
    PayloadPreambleIndicatorDecoder.decode(PayloadPreambleIndicatorIter->second);
    PayloadPreambleIndicator = PayloadPreambleIndicatorDecoder.get();
  }
  FlexRayHeaderEncoding HeaderDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator HeaderIter = parameters.find(GetHeaderParameterHandle());
  if (HeaderIter != parameters.end())
  {
    HeaderDecoder.decode(HeaderIter->second);
    Header = HeaderDecoder;
  }
  FlexRayPayloadEncoding PayloadDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator PayloadIter = parameters.find(GetPayloadParameterHandle());
  if (PayloadIter != parameters.end())
  {
    PayloadDecoder.decode(PayloadIter->second);
    Payload = PayloadDecoder;
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(IsRequest, ChannelName, BusTypeP, RequestingFederate, Sender, Receiver, FrameID, FlexRayChannelP, PayloadPreambleIndicator, Header, Payload, static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  }
}

uint32_t FlexRayFrameInteractionClass::RegisterReceiveCallback(ReceiveCallback callback)
{
  uint32_t key = mReceiveCallbacksNextKey++;
  mReceiveCallbacks.insert(std::make_pair(key, callback));
  return key;
}

rti1516ev::ParameterHandleSet FlexRayFrameInteractionClass::GetAllParameterHandles()
{
  rti1516ev::ParameterHandleSet result;
  result.insert(GetIsRequestParameterHandle());
  result.insert(GetChannelNameParameterHandle());
  result.insert(GetBusTypeParameterHandle());
  result.insert(GetRequestingFederateParameterHandle());
  result.insert(GetSenderParameterHandle());
  result.insert(GetReceiverParameterHandle());
  result.insert(GetFrameIDParameterHandle());
  result.insert(GetFlexRayChannelParameterHandle());
  result.insert(GetPayloadPreambleIndicatorParameterHandle());
  result.insert(GetHeaderParameterHandle());
  result.insert(GetPayloadParameterHandle());
  return result;
}

// object class type 'PythonCommand'
PythonCommandInteractionClass::PythonCommandInteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry, HLAinteractionRootInteractionClass* baseClass)
{
  mInteractionClassRegistry = interactionClassRegistry;
  mRtiAmbassador = rtiAmbassador;

  mBaseClass = baseClass;
  mInteractionClassHandle = rtiAmbassador->getInteractionClassHandle(L"HLAinteractionRoot.PythonCommand");
  // parameter Code : HLAopaqueData
  mCodeParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Code");
  // parameter Target : HLAopaqueData
  mTargetParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Target");
  // parameter RefID : HLAopaqueData
  mRefIDParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"RefID");
}

// get the corresponding *object* class registry, for access to objects sent as parameters
ObjectClassRegistry* PythonCommandInteractionClass::GetObjectClassRegistry()
{
  return mInteractionClassRegistry->GetObjectClassRegistry();
}

void PythonCommandInteractionClass::Publish()
{
  if (!mPublished)
  {
    mRtiAmbassador->publishInteractionClass(mInteractionClassHandle);
    mPublished = true;
  }
}

void PythonCommandInteractionClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishInteractionClass(mInteractionClassHandle);
    mPublished = false;
  }
}

void PythonCommandInteractionClass::Subscribe(bool deliverToSelf)
{
  mRtiAmbassador->subscribeInteractionClass(mInteractionClassHandle);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  mSubscribed = true;
}

void PythonCommandInteractionClass::Subscribe(optional<const std::vector<uint8_t>&> Code, optional<const std::vector<uint8_t>&> Target, optional<const std::vector<uint8_t>&> RefID, bool deliverToSelf)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (Code)
  {
    rti1516ev::HLAopaqueData CodeEncoder(*Code);
    parameters.insert(std::make_pair(GetCodeParameterHandle(), CodeEncoder.encode()));
  }
  if (Target)
  {
    rti1516ev::HLAopaqueData TargetEncoder(*Target);
    parameters.insert(std::make_pair(GetTargetParameterHandle(), TargetEncoder.encode()));
  }
  if (RefID)
  {
    rti1516ev::HLAopaqueData RefIDEncoder(*RefID);
    parameters.insert(std::make_pair(GetRefIDParameterHandle(), RefIDEncoder.encode()));
  }
  mRtiAmbassador->subscribeInteractionClassWithFilter(mInteractionClassHandle, parameters);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  // we must always set mSubscribed, otherwise we can't unsubscribe
  mSubscribed = true;
}

void PythonCommandInteractionClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeInteractionClass(mInteractionClassHandle);
    mSubscribed = false;
  }
}

void PythonCommandInteractionClass::send(optional<const std::vector<uint8_t>&> Code, optional<const std::vector<uint8_t>&> Target, optional<const std::vector<uint8_t>&> RefID)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (Code)
  {
    rti1516ev::HLAopaqueData CodeEncoder(*Code);
    parameters.insert(std::make_pair(GetCodeParameterHandle(), CodeEncoder.encode()));
  }
  if (Target)
  {
    rti1516ev::HLAopaqueData TargetEncoder(*Target);
    parameters.insert(std::make_pair(GetTargetParameterHandle(), TargetEncoder.encode()));
  }
  if (RefID)
  {
    rti1516ev::HLAopaqueData RefIDEncoder(*RefID);
    parameters.insert(std::make_pair(GetRefIDParameterHandle(), RefIDEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData());
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void PythonCommandInteractionClass::sendWithTime(optional<const std::vector<uint8_t>&> Code, optional<const std::vector<uint8_t>&> Target, optional<const std::vector<uint8_t>&> RefID, int64_t time)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (Code)
  {
    rti1516ev::HLAopaqueData CodeEncoder(*Code);
    parameters.insert(std::make_pair(GetCodeParameterHandle(), CodeEncoder.encode()));
  }
  if (Target)
  {
    rti1516ev::HLAopaqueData TargetEncoder(*Target);
    parameters.insert(std::make_pair(GetTargetParameterHandle(), TargetEncoder.encode()));
  }
  if (RefID)
  {
    rti1516ev::HLAopaqueData RefIDEncoder(*RefID);
    parameters.insert(std::make_pair(GetRefIDParameterHandle(), RefIDEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
  }
  catch (const rti1516ev::InvalidLogicalTime& e)
  {
    throw InvalidLogicalTime(to_string(e.what()));
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void PythonCommandInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters )
{
  optional<const std::vector<uint8_t>&> Code;
  optional<const std::vector<uint8_t>&> Target;
  optional<const std::vector<uint8_t>&> RefID;
  rti1516ev::HLAopaqueData CodeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator CodeIter = parameters.find(GetCodeParameterHandle());
  if (CodeIter != parameters.end())
  {
    CodeDecoder.decode(CodeIter->second);
    Code = CodeDecoder.get();
  }
  rti1516ev::HLAopaqueData TargetDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator TargetIter = parameters.find(GetTargetParameterHandle());
  if (TargetIter != parameters.end())
  {
    TargetDecoder.decode(TargetIter->second);
    Target = TargetDecoder.get();
  }
  rti1516ev::HLAopaqueData RefIDDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator RefIDIter = parameters.find(GetRefIDParameterHandle());
  if (RefIDIter != parameters.end())
  {
    RefIDDecoder.decode(RefIDIter->second);
    RefID = RefIDDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(Code, Target, RefID, optional<int64_t>(), optional<OrderType>());
  }
}

void PythonCommandInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters , const rti1516ev::LogicalTime& time, OrderType orderType)
{
  optional<const std::vector<uint8_t>&> Code;
  optional<const std::vector<uint8_t>&> Target;
  optional<const std::vector<uint8_t>&> RefID;

  rti1516ev::HLAopaqueData CodeDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator CodeIter = parameters.find(GetCodeParameterHandle());
  if (CodeIter != parameters.end())
  {
    CodeDecoder.decode(CodeIter->second);
    Code = CodeDecoder.get();
  }
  rti1516ev::HLAopaqueData TargetDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator TargetIter = parameters.find(GetTargetParameterHandle());
  if (TargetIter != parameters.end())
  {
    TargetDecoder.decode(TargetIter->second);
    Target = TargetDecoder.get();
  }
  rti1516ev::HLAopaqueData RefIDDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator RefIDIter = parameters.find(GetRefIDParameterHandle());
  if (RefIDIter != parameters.end())
  {
    RefIDDecoder.decode(RefIDIter->second);
    RefID = RefIDDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(Code, Target, RefID, static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  }
}

uint32_t PythonCommandInteractionClass::RegisterReceiveCallback(ReceiveCallback callback)
{
  uint32_t key = mReceiveCallbacksNextKey++;
  mReceiveCallbacks.insert(std::make_pair(key, callback));
  return key;
}

rti1516ev::ParameterHandleSet PythonCommandInteractionClass::GetAllParameterHandles()
{
  rti1516ev::ParameterHandleSet result;
  result.insert(GetCodeParameterHandle());
  result.insert(GetTargetParameterHandle());
  result.insert(GetRefIDParameterHandle());
  return result;
}

 

InteractionClassRegistry::InteractionClassRegistry(ObjectClassRegistry* objectClassRegistry)
  : mRtiAmbassador(nullptr), mObjectClassRegistry(objectClassRegistry)
{
}

InteractionClassRegistry::~InteractionClassRegistry()
{
}

void InteractionClassRegistry::Initialize(rti1516ev::RTIambassador* rtiAmbassador)
{
  mRtiAmbassador = rtiAmbassador;
  try
  {
    mHLAinteractionRootInteractionClass = std::unique_ptr<HLAinteractionRootInteractionClass>(new HLAinteractionRootInteractionClass(mRtiAmbassador, this));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mHLAinteractionRootInteractionClass.get() != nullptr);
    mMeasurementInitInteractionClass = std::unique_ptr<MeasurementInitInteractionClass>(new MeasurementInitInteractionClass(mRtiAmbassador, this, mHLAinteractionRootInteractionClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mHLAinteractionRootInteractionClass.get() != nullptr);
    mMeasurementStopInteractionClass = std::unique_ptr<MeasurementStopInteractionClass>(new MeasurementStopInteractionClass(mRtiAmbassador, this, mHLAinteractionRootInteractionClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mHLAinteractionRootInteractionClass.get() != nullptr);
    mKeyEventInteractionClass = std::unique_ptr<KeyEventInteractionClass>(new KeyEventInteractionClass(mRtiAmbassador, this, mHLAinteractionRootInteractionClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mHLAinteractionRootInteractionClass.get() != nullptr);
    mTextLogInteractionClass = std::unique_ptr<TextLogInteractionClass>(new TextLogInteractionClass(mRtiAmbassador, this, mHLAinteractionRootInteractionClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mHLAinteractionRootInteractionClass.get() != nullptr);
    mSystemVariableUpdateInteractionClass = std::unique_ptr<SystemVariableUpdateInteractionClass>(new SystemVariableUpdateInteractionClass(mRtiAmbassador, this, mHLAinteractionRootInteractionClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mHLAinteractionRootInteractionClass.get() != nullptr);
    mSystemVariableModificationInteractionClass = std::unique_ptr<SystemVariableModificationInteractionClass>(new SystemVariableModificationInteractionClass(mRtiAmbassador, this, mHLAinteractionRootInteractionClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mHLAinteractionRootInteractionClass.get() != nullptr);
    mValueEntityUpdateInteractionClass = std::unique_ptr<ValueEntityUpdateInteractionClass>(new ValueEntityUpdateInteractionClass(mRtiAmbassador, this, mHLAinteractionRootInteractionClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mHLAinteractionRootInteractionClass.get() != nullptr);
    mBusMessageInteractionClass = std::unique_ptr<BusMessageInteractionClass>(new BusMessageInteractionClass(mRtiAmbassador, this, mHLAinteractionRootInteractionClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mBusMessageInteractionClass.get() != nullptr);
    mEthPacketInteractionClass = std::unique_ptr<EthPacketInteractionClass>(new EthPacketInteractionClass(mRtiAmbassador, this, mBusMessageInteractionClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mBusMessageInteractionClass.get() != nullptr);
    mEthPacketErrorInteractionClass = std::unique_ptr<EthPacketErrorInteractionClass>(new EthPacketErrorInteractionClass(mRtiAmbassador, this, mBusMessageInteractionClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mBusMessageInteractionClass.get() != nullptr);
    mEthPacketErrorForwardedInteractionClass = std::unique_ptr<EthPacketErrorForwardedInteractionClass>(new EthPacketErrorForwardedInteractionClass(mRtiAmbassador, this, mBusMessageInteractionClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mBusMessageInteractionClass.get() != nullptr);
    mEthForwardedPacketInteractionClass = std::unique_ptr<EthForwardedPacketInteractionClass>(new EthForwardedPacketInteractionClass(mRtiAmbassador, this, mBusMessageInteractionClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mBusMessageInteractionClass.get() != nullptr);
    mEthStatusInteractionClass = std::unique_ptr<EthStatusInteractionClass>(new EthStatusInteractionClass(mRtiAmbassador, this, mBusMessageInteractionClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mBusMessageInteractionClass.get() != nullptr);
    mCANMessageInteractionClass = std::unique_ptr<CANMessageInteractionClass>(new CANMessageInteractionClass(mRtiAmbassador, this, mBusMessageInteractionClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mBusMessageInteractionClass.get() != nullptr);
    mCANErrorFrameInteractionClass = std::unique_ptr<CANErrorFrameInteractionClass>(new CANErrorFrameInteractionClass(mRtiAmbassador, this, mBusMessageInteractionClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mBusMessageInteractionClass.get() != nullptr);
    mFlexRaySymbolInteractionClass = std::unique_ptr<FlexRaySymbolInteractionClass>(new FlexRaySymbolInteractionClass(mRtiAmbassador, this, mBusMessageInteractionClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mBusMessageInteractionClass.get() != nullptr);
    mFlexRayCycleStartInteractionClass = std::unique_ptr<FlexRayCycleStartInteractionClass>(new FlexRayCycleStartInteractionClass(mRtiAmbassador, this, mBusMessageInteractionClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mBusMessageInteractionClass.get() != nullptr);
    mFlexRayFrameInteractionClass = std::unique_ptr<FlexRayFrameInteractionClass>(new FlexRayFrameInteractionClass(mRtiAmbassador, this, mBusMessageInteractionClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mHLAinteractionRootInteractionClass.get() != nullptr);
    mPythonCommandInteractionClass = std::unique_ptr<PythonCommandInteractionClass>(new PythonCommandInteractionClass(mRtiAmbassador, this, mHLAinteractionRootInteractionClass.get()));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
} // Initialize

void InteractionClassRegistry::Finalize()
{
  mHLAinteractionRootInteractionClass.reset();
  mMeasurementInitInteractionClass.reset();
  mMeasurementStopInteractionClass.reset();
  mKeyEventInteractionClass.reset();
  mTextLogInteractionClass.reset();
  mSystemVariableUpdateInteractionClass.reset();
  mSystemVariableModificationInteractionClass.reset();
  mValueEntityUpdateInteractionClass.reset();
  mBusMessageInteractionClass.reset();
  mEthPacketInteractionClass.reset();
  mEthPacketErrorInteractionClass.reset();
  mEthPacketErrorForwardedInteractionClass.reset();
  mEthForwardedPacketInteractionClass.reset();
  mEthStatusInteractionClass.reset();
  mCANMessageInteractionClass.reset();
  mCANErrorFrameInteractionClass.reset();
  mFlexRaySymbolInteractionClass.reset();
  mFlexRayCycleStartInteractionClass.reset();
  mFlexRayFrameInteractionClass.reset();
  mPythonCommandInteractionClass.reset();
  mRtiAmbassador = nullptr;
} // Initialize

void InteractionClassRegistry::ReceiveInteraction(rti1516ev::InteractionClassHandle theInteractionClass, const rti1516ev::ParameterHandleValueMap & parameters)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  if (theInteractionClass == mHLAinteractionRootInteractionClass->GetInteractionClassHandle())
  {
    mHLAinteractionRootInteractionClass->ReceiveInteraction(parameters);
  }
  else if (theInteractionClass == mMeasurementInitInteractionClass->GetInteractionClassHandle())
  {
    mMeasurementInitInteractionClass->ReceiveInteraction(parameters);
  }
  else if (theInteractionClass == mMeasurementStopInteractionClass->GetInteractionClassHandle())
  {
    mMeasurementStopInteractionClass->ReceiveInteraction(parameters);
  }
  else if (theInteractionClass == mKeyEventInteractionClass->GetInteractionClassHandle())
  {
    mKeyEventInteractionClass->ReceiveInteraction(parameters);
  }
  else if (theInteractionClass == mTextLogInteractionClass->GetInteractionClassHandle())
  {
    mTextLogInteractionClass->ReceiveInteraction(parameters);
  }
  else if (theInteractionClass == mSystemVariableUpdateInteractionClass->GetInteractionClassHandle())
  {
    mSystemVariableUpdateInteractionClass->ReceiveInteraction(parameters);
  }
  else if (theInteractionClass == mSystemVariableModificationInteractionClass->GetInteractionClassHandle())
  {
    mSystemVariableModificationInteractionClass->ReceiveInteraction(parameters);
  }
  else if (theInteractionClass == mValueEntityUpdateInteractionClass->GetInteractionClassHandle())
  {
    mValueEntityUpdateInteractionClass->ReceiveInteraction(parameters);
  }
  else if (theInteractionClass == mBusMessageInteractionClass->GetInteractionClassHandle())
  {
    mBusMessageInteractionClass->ReceiveInteraction(parameters);
  }
  else if (theInteractionClass == mEthPacketInteractionClass->GetInteractionClassHandle())
  {
    mEthPacketInteractionClass->ReceiveInteraction(parameters);
  }
  else if (theInteractionClass == mEthPacketErrorInteractionClass->GetInteractionClassHandle())
  {
    mEthPacketErrorInteractionClass->ReceiveInteraction(parameters);
  }
  else if (theInteractionClass == mEthPacketErrorForwardedInteractionClass->GetInteractionClassHandle())
  {
    mEthPacketErrorForwardedInteractionClass->ReceiveInteraction(parameters);
  }
  else if (theInteractionClass == mEthForwardedPacketInteractionClass->GetInteractionClassHandle())
  {
    mEthForwardedPacketInteractionClass->ReceiveInteraction(parameters);
  }
  else if (theInteractionClass == mEthStatusInteractionClass->GetInteractionClassHandle())
  {
    mEthStatusInteractionClass->ReceiveInteraction(parameters);
  }
  else if (theInteractionClass == mCANMessageInteractionClass->GetInteractionClassHandle())
  {
    mCANMessageInteractionClass->ReceiveInteraction(parameters);
  }
  else if (theInteractionClass == mCANErrorFrameInteractionClass->GetInteractionClassHandle())
  {
    mCANErrorFrameInteractionClass->ReceiveInteraction(parameters);
  }
  else if (theInteractionClass == mFlexRaySymbolInteractionClass->GetInteractionClassHandle())
  {
    mFlexRaySymbolInteractionClass->ReceiveInteraction(parameters);
  }
  else if (theInteractionClass == mFlexRayCycleStartInteractionClass->GetInteractionClassHandle())
  {
    mFlexRayCycleStartInteractionClass->ReceiveInteraction(parameters);
  }
  else if (theInteractionClass == mFlexRayFrameInteractionClass->GetInteractionClassHandle())
  {
    mFlexRayFrameInteractionClass->ReceiveInteraction(parameters);
  }
  else if (theInteractionClass == mPythonCommandInteractionClass->GetInteractionClassHandle())
  {
    mPythonCommandInteractionClass->ReceiveInteraction(parameters);
  }
}

void InteractionClassRegistry::ReceiveInteraction(rti1516ev::InteractionClassHandle theInteractionClass,
                                                  const rti1516ev::ParameterHandleValueMap & parameters,
                                                  const rti1516ev::LogicalTime& time,
                                                  OrderType orderType)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  if (theInteractionClass == mHLAinteractionRootInteractionClass->GetInteractionClassHandle())
  {
    mHLAinteractionRootInteractionClass->ReceiveInteraction(parameters, time, orderType);
  }
  else if (theInteractionClass == mMeasurementInitInteractionClass->GetInteractionClassHandle())
  {
    mMeasurementInitInteractionClass->ReceiveInteraction(parameters, time, orderType);
  }
  else if (theInteractionClass == mMeasurementStopInteractionClass->GetInteractionClassHandle())
  {
    mMeasurementStopInteractionClass->ReceiveInteraction(parameters, time, orderType);
  }
  else if (theInteractionClass == mKeyEventInteractionClass->GetInteractionClassHandle())
  {
    mKeyEventInteractionClass->ReceiveInteraction(parameters, time, orderType);
  }
  else if (theInteractionClass == mTextLogInteractionClass->GetInteractionClassHandle())
  {
    mTextLogInteractionClass->ReceiveInteraction(parameters, time, orderType);
  }
  else if (theInteractionClass == mSystemVariableUpdateInteractionClass->GetInteractionClassHandle())
  {
    mSystemVariableUpdateInteractionClass->ReceiveInteraction(parameters, time, orderType);
  }
  else if (theInteractionClass == mSystemVariableModificationInteractionClass->GetInteractionClassHandle())
  {
    mSystemVariableModificationInteractionClass->ReceiveInteraction(parameters, time, orderType);
  }
  else if (theInteractionClass == mValueEntityUpdateInteractionClass->GetInteractionClassHandle())
  {
    mValueEntityUpdateInteractionClass->ReceiveInteraction(parameters, time, orderType);
  }
  else if (theInteractionClass == mBusMessageInteractionClass->GetInteractionClassHandle())
  {
    mBusMessageInteractionClass->ReceiveInteraction(parameters, time, orderType);
  }
  else if (theInteractionClass == mEthPacketInteractionClass->GetInteractionClassHandle())
  {
    mEthPacketInteractionClass->ReceiveInteraction(parameters, time, orderType);
  }
  else if (theInteractionClass == mEthPacketErrorInteractionClass->GetInteractionClassHandle())
  {
    mEthPacketErrorInteractionClass->ReceiveInteraction(parameters, time, orderType);
  }
  else if (theInteractionClass == mEthPacketErrorForwardedInteractionClass->GetInteractionClassHandle())
  {
    mEthPacketErrorForwardedInteractionClass->ReceiveInteraction(parameters, time, orderType);
  }
  else if (theInteractionClass == mEthForwardedPacketInteractionClass->GetInteractionClassHandle())
  {
    mEthForwardedPacketInteractionClass->ReceiveInteraction(parameters, time, orderType);
  }
  else if (theInteractionClass == mEthStatusInteractionClass->GetInteractionClassHandle())
  {
    mEthStatusInteractionClass->ReceiveInteraction(parameters, time, orderType);
  }
  else if (theInteractionClass == mCANMessageInteractionClass->GetInteractionClassHandle())
  {
    mCANMessageInteractionClass->ReceiveInteraction(parameters, time, orderType);
  }
  else if (theInteractionClass == mCANErrorFrameInteractionClass->GetInteractionClassHandle())
  {
    mCANErrorFrameInteractionClass->ReceiveInteraction(parameters, time, orderType);
  }
  else if (theInteractionClass == mFlexRaySymbolInteractionClass->GetInteractionClassHandle())
  {
    mFlexRaySymbolInteractionClass->ReceiveInteraction(parameters, time, orderType);
  }
  else if (theInteractionClass == mFlexRayCycleStartInteractionClass->GetInteractionClassHandle())
  {
    mFlexRayCycleStartInteractionClass->ReceiveInteraction(parameters, time, orderType);
  }
  else if (theInteractionClass == mFlexRayFrameInteractionClass->GetInteractionClassHandle())
  {
    mFlexRayFrameInteractionClass->ReceiveInteraction(parameters, time, orderType);
  }
  else if (theInteractionClass == mPythonCommandInteractionClass->GetInteractionClassHandle())
  {
    mPythonCommandInteractionClass->ReceiveInteraction(parameters, time, orderType);
  }
}

} // namespace NDistSimIB
} // namespace NRTFederateEncoding
