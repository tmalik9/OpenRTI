
// Code automatically generated by FOMCodeGen version 2.0.2.0 from RTFederate.xml, do not edit
#pragma once

#include <vector>
#include <mutex>
#include "RTI/Handle.h"
#include "RTI/RTIambassador.h"
#include "RTI/encoding/BasicDataElements.h"
#include "RTI/encoding/HLAfixedRecord.h"
#include "RTI/encoding/HLAfixedArray.h"
#include "RTI/encoding/HLAvariableArray.h"
#include "RTI/time/HLAinteger64Time.h"

#include "RTI/encoding/HLAopaqueData.h"
#include "RTI/encoding/HLAhandle.h"
#include "interface/RTFederateObjectInterfaces.h"
#include "RTFederateEncodings.h"

class ObjectClassRegistry;

namespace NDistSimIB {
namespace NRTFederateEncoding {

class ObjectClassRegistry;

class HLAobjectRoot;
class HLAobjectRootObjectClass : public IHLAobjectRootObjectClass
{
  public:
    // IHLAobjectRootObjectClass
    HLAobjectRootObjectClass() = default;
    virtual ~HLAobjectRootObjectClass();
    void Publish() override;
    void Unpublish() override;
    void Subscribe(bool deliverToSelf) override;
    void Unsubscribe() override;
    std::shared_ptr<IHLAobjectRoot> GetObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IHLAobjectRoot> CreateObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IHLAobjectRoot> CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback) override;
    uint32_t RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback) override;
    void UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IHLAobjectRoot> newObjectInstance);

    uint32_t RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback) override;
    void UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IHLAobjectRoot> newObjectInstance);
    // Set a user-defined creator function, which returns subclasses of HLAobjectRoot
    using ObjectInstanceCreatorFunction = std::function<HLAobjectRoot*(HLAobjectRootObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)>;
    // When using custom object instance classes, don't forget to set the creator function *before* subscribing to the object class.
    void SetObjectInstanceCreator(ObjectInstanceCreatorFunction creatorFunction) { mCreatorFunction = creatorFunction; }
    // internal
    HLAobjectRootObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry);
    // attribute HLAprivilegeToDeleteObject : no data type
    void DiscoverObjectInstance (rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    rti1516ev::ObjectClassHandle GetObjectClassHandle() const { return mObjectClassHandle; }
    std::shared_ptr<IHLAobjectRoot> GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle);
    rti1516ev::AttributeHandleSet GetAllAttributeHandles();
    ObjectClassRegistry* GetObjectClassRegistry() const { return mRegistry; }

    // add object instance to maps (and to maps of base classes)
    void InsertObjectInstanceName(std::shared_ptr<IHLAobjectRoot> objectInstance, const std::wstring& objectInstanceName);
    void InsertObjectInstanceHandle(std::shared_ptr<IHLAobjectRoot> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle);
    // remove object instance from maps (and from maps of base classes)
    void EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName);
  private:
    ObjectClassRegistry* mRegistry;
    rti1516ev::RTIambassador* mRtiAmbassador;
    // object class handle
    rti1516ev::ObjectClassHandle mObjectClassHandle;
    ObjectInstanceCreatorFunction mCreatorFunction;
    bool mPublished = false;
    bool mSubscribed = false;
    // Attribute handles
    // attribute HLAprivilegeToDeleteObject : no data type
    // this mutex guards the data structures below
    mutable std::recursive_mutex mMutex;
    std::map<std::wstring, std::shared_ptr<IHLAobjectRoot>> mObjectInstancesByName;
    std::map<rti1516ev::ObjectInstanceHandle, std::shared_ptr<IHLAobjectRoot>> mObjectInstancesByHandle;

    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, DiscoverObjectInstanceCallback> mDiscoverCallbacks;
    uint32_t mLastDiscoverObjectInstanceCallbackToken = 0;
    std::map<uint32_t, RemoveObjectInstanceCallback> mRemoveObjectInstanceCallbacks;
    uint32_t mLastRemoveObjectInstanceCallbackToken = 0;
};

class HLAobjectRoot : public IHLAobjectRoot
{
  public:

    virtual ~HLAobjectRoot();
    HLAobjectRoot(const HLAobjectRoot&) = delete;
    HLAobjectRoot(HLAobjectRoot&&) = delete;
    HLAobjectRoot& operator=(const HLAobjectRoot&) = delete;
    HLAobjectRoot& operator=(HLAobjectRoot&&) = delete;
    IHLAobjectRootObjectClass* GetObjectClass() const { return mObjectClass; }
    ObjectClassRegistry* GetObjectClassRegistry() const { return mObjectClass->GetObjectClassRegistry(); }
    std::wstring GetObjectInstanceName() const override { return mObjectInstanceName; }
    rti1516ev::ObjectInstanceHandle GetObjectInstanceHandle() const { return mObjectInstanceHandle; }
    bool IsValid() const override;
    bool IsOwner() const override;
    void Release() override;
    // attribute HLAprivilegeToDeleteObject : no data type
    // IHLAobjectRoot

  protected:
    friend class HLAobjectRootObjectClass;

    HLAobjectRoot();
    HLAobjectRoot(HLAobjectRootObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* ambassador);


    // get attribute handle/value map of all attributes
    rti1516ev::AttributeHandleValueMap GetAllAttributeValues() const;
    // get attribute handle/value map of attributes which have been modified since last call to UpdateModifiedAttributeValues
    rti1516ev::AttributeHandleValueMap GetModifiedAttributeValues() const;

    rti1516ev::RTIambassador* mRtiAmbassador;
    // this mutex guards all of the fields below
    mutable std::recursive_mutex mMutex;

    HLAobjectRootObjectClass* mObjectClass;
    std::wstring mObjectInstanceName;
    rti1516ev::ObjectInstanceHandle mObjectInstanceHandle;
    bool mIsOwner = false;
    // Attribute value encoders
    // attribute HLAprivilegeToDeleteObject : no data type
};

class SystemVariable;
class SystemVariableObjectClass : public ISystemVariableObjectClass
{
  public:
    // ISystemVariableObjectClass
    SystemVariableObjectClass() = default;
    virtual ~SystemVariableObjectClass();
    void Publish() override;
    void Unpublish() override;
    void Subscribe(bool deliverToSelf) override;
    void Unsubscribe() override;
    std::shared_ptr<ISystemVariable> GetObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<ISystemVariable> CreateObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<ISystemVariable> CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback) override;
    uint32_t RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback) override;
    void UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<ISystemVariable> newObjectInstance);

    uint32_t RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback) override;
    void UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<ISystemVariable> newObjectInstance);
    // Set a user-defined creator function, which returns subclasses of SystemVariable
    using ObjectInstanceCreatorFunction = std::function<SystemVariable*(SystemVariableObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)>;
    // When using custom object instance classes, don't forget to set the creator function *before* subscribing to the object class.
    void SetObjectInstanceCreator(ObjectInstanceCreatorFunction creatorFunction) { mCreatorFunction = creatorFunction; }
    // internal
    SystemVariableObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, HLAobjectRootObjectClass* baseClass);

    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute Value : HLAopaqueData
    rti1516ev::AttributeHandle GetValueAttributeHandle() const { return mValueAttributeHandle; }
    void DiscoverObjectInstance (rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    rti1516ev::ObjectClassHandle GetObjectClassHandle() const { return mObjectClassHandle; }
    std::shared_ptr<ISystemVariable> GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle);
    rti1516ev::AttributeHandleSet GetAllAttributeHandles();
    ObjectClassRegistry* GetObjectClassRegistry() const { return mRegistry; }

    // add object instance to maps (and to maps of base classes)
    void InsertObjectInstanceName(std::shared_ptr<ISystemVariable> objectInstance, const std::wstring& objectInstanceName);
    void InsertObjectInstanceHandle(std::shared_ptr<ISystemVariable> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle);
    // remove object instance from maps (and from maps of base classes)
    void EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName);
  private:
    ObjectClassRegistry* mRegistry;
    rti1516ev::RTIambassador* mRtiAmbassador;
    // object class handle
    rti1516ev::ObjectClassHandle mObjectClassHandle;
    HLAobjectRootObjectClass* mBaseClass;
    ObjectInstanceCreatorFunction mCreatorFunction;
    bool mPublished = false;
    bool mSubscribed = false;
    // Attribute handles
    // attribute Value : HLAopaqueData
    rti1516ev::AttributeHandle mValueAttributeHandle;
    // this mutex guards the data structures below
    mutable std::recursive_mutex mMutex;
    std::map<std::wstring, std::shared_ptr<ISystemVariable>> mObjectInstancesByName;
    std::map<rti1516ev::ObjectInstanceHandle, std::shared_ptr<ISystemVariable>> mObjectInstancesByHandle;

    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, DiscoverObjectInstanceCallback> mDiscoverCallbacks;
    uint32_t mLastDiscoverObjectInstanceCallbackToken = 0;
    std::map<uint32_t, RemoveObjectInstanceCallback> mRemoveObjectInstanceCallbacks;
    uint32_t mLastRemoveObjectInstanceCallbackToken = 0;
};

class SystemVariable : public ISystemVariable
{
  public:

    virtual ~SystemVariable();
    SystemVariable(const SystemVariable&) = delete;
    SystemVariable(SystemVariable&&) = delete;
    SystemVariable& operator=(const SystemVariable&) = delete;
    SystemVariable& operator=(SystemVariable&&) = delete;
    ISystemVariableObjectClass* GetObjectClass() const { return mObjectClass; }
    ObjectClassRegistry* GetObjectClassRegistry() const { return mObjectClass->GetObjectClassRegistry(); }
    std::wstring GetObjectInstanceName() const override { return mObjectInstanceName; }
    rti1516ev::ObjectInstanceHandle GetObjectInstanceHandle() const { return mObjectInstanceHandle; }
    bool IsValid() const override;
    bool IsOwner() const override;
    void Release() override;
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute Value : HLAopaqueData
    std::vector<uint8_t> GetValue() const override;
    void SetValue(const std::vector<uint8_t>& newValue) override;
    // ISystemVariable
    void UpdateAllAttributeValues() override;
    void UpdateAllAttributeValues(int64_t time) override;
    void UpdateModifiedAttributeValues() override;
    void UpdateModifiedAttributeValues(int64_t time) override;
    void RequestAttributeValues() override;
    void RequestAllAttributeValues() override;
    uint32_t RegisterUpdateCallback(UpdateCallback callback) override;
    void UnregisterUpdateCallback(uint32_t callbackToken) override;

    // bitmask of attributes ever received
    AttributeBits GetReceivedAttributes() const override;
    // bitmask of attributes received in last update (cleared after update callbacks executed)
    AttributeBits GetUpdatedAttributes() const override;
    // bitmask of attributes ever modified
    AttributeBits GetInitializedAttributes() const override;
    // bitmask of attributes modified since last updateAttributeValues/provideAttributeValues
    AttributeBits GetModifiedAttributes() const override;
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes);
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType);
    void ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributes, optional<int64_t> time);
  protected:
    friend class SystemVariableObjectClass;

    SystemVariable();
    SystemVariable(SystemVariableObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* ambassador);

    void ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType);

    // get attribute handle/value map of all attributes
    rti1516ev::AttributeHandleValueMap GetAllAttributeValues() const;
    // get attribute handle/value map of attributes which have been modified since last call to UpdateModifiedAttributeValues
    rti1516ev::AttributeHandleValueMap GetModifiedAttributeValues() const;

    rti1516ev::RTIambassador* mRtiAmbassador;
    // this mutex guards all of the fields below
    mutable std::recursive_mutex mMutex;

    SystemVariableObjectClass* mObjectClass;
    std::wstring mObjectInstanceName;
    rti1516ev::ObjectInstanceHandle mObjectInstanceHandle;
    bool mIsOwner = false;
    // modified by any ReflectAttributeValues in the past
    AttributeBits mValuesReceived = kNone;
    // modified by any attribute setter
    AttributeBits mValuesSet = kNone;
    // modified by last ReflectAttributeValues
    AttributeBits mLastUpdated = kNone;
    // to be sent with next UpdateModifiedAttributeValues
    AttributeBits mDirty = kNone;
    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, UpdateCallback> mUpdateCallbacks;
    uint32_t mLastCallbackToken = 0;
    // Attribute value encoders
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute Value : HLAopaqueData
    rti1516ev::HLAopaqueData mValue;
};

class ValueEntity;
class ValueEntityObjectClass : public IValueEntityObjectClass
{
  public:
    // IValueEntityObjectClass
    ValueEntityObjectClass() = default;
    virtual ~ValueEntityObjectClass();
    void Publish() override;
    void Unpublish() override;
    void Subscribe(bool deliverToSelf) override;
    void Unsubscribe() override;
    std::shared_ptr<IValueEntity> GetObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IValueEntity> CreateObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IValueEntity> CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback) override;
    uint32_t RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback) override;
    void UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IValueEntity> newObjectInstance);

    uint32_t RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback) override;
    void UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IValueEntity> newObjectInstance);
    // Set a user-defined creator function, which returns subclasses of ValueEntity
    using ObjectInstanceCreatorFunction = std::function<ValueEntity*(ValueEntityObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)>;
    // When using custom object instance classes, don't forget to set the creator function *before* subscribing to the object class.
    void SetObjectInstanceCreator(ObjectInstanceCreatorFunction creatorFunction) { mCreatorFunction = creatorFunction; }
    // internal
    ValueEntityObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, HLAobjectRootObjectClass* baseClass);

    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute Value : HLAopaqueData
    rti1516ev::AttributeHandle GetValueAttributeHandle() const { return mValueAttributeHandle; }
    void DiscoverObjectInstance (rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    rti1516ev::ObjectClassHandle GetObjectClassHandle() const { return mObjectClassHandle; }
    std::shared_ptr<IValueEntity> GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle);
    rti1516ev::AttributeHandleSet GetAllAttributeHandles();
    ObjectClassRegistry* GetObjectClassRegistry() const { return mRegistry; }

    // add object instance to maps (and to maps of base classes)
    void InsertObjectInstanceName(std::shared_ptr<IValueEntity> objectInstance, const std::wstring& objectInstanceName);
    void InsertObjectInstanceHandle(std::shared_ptr<IValueEntity> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle);
    // remove object instance from maps (and from maps of base classes)
    void EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName);
  private:
    ObjectClassRegistry* mRegistry;
    rti1516ev::RTIambassador* mRtiAmbassador;
    // object class handle
    rti1516ev::ObjectClassHandle mObjectClassHandle;
    HLAobjectRootObjectClass* mBaseClass;
    ObjectInstanceCreatorFunction mCreatorFunction;
    bool mPublished = false;
    bool mSubscribed = false;
    // Attribute handles
    // attribute Value : HLAopaqueData
    rti1516ev::AttributeHandle mValueAttributeHandle;
    // this mutex guards the data structures below
    mutable std::recursive_mutex mMutex;
    std::map<std::wstring, std::shared_ptr<IValueEntity>> mObjectInstancesByName;
    std::map<rti1516ev::ObjectInstanceHandle, std::shared_ptr<IValueEntity>> mObjectInstancesByHandle;

    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, DiscoverObjectInstanceCallback> mDiscoverCallbacks;
    uint32_t mLastDiscoverObjectInstanceCallbackToken = 0;
    std::map<uint32_t, RemoveObjectInstanceCallback> mRemoveObjectInstanceCallbacks;
    uint32_t mLastRemoveObjectInstanceCallbackToken = 0;
};

class ValueEntity : public IValueEntity
{
  public:

    virtual ~ValueEntity();
    ValueEntity(const ValueEntity&) = delete;
    ValueEntity(ValueEntity&&) = delete;
    ValueEntity& operator=(const ValueEntity&) = delete;
    ValueEntity& operator=(ValueEntity&&) = delete;
    IValueEntityObjectClass* GetObjectClass() const { return mObjectClass; }
    ObjectClassRegistry* GetObjectClassRegistry() const { return mObjectClass->GetObjectClassRegistry(); }
    std::wstring GetObjectInstanceName() const override { return mObjectInstanceName; }
    rti1516ev::ObjectInstanceHandle GetObjectInstanceHandle() const { return mObjectInstanceHandle; }
    bool IsValid() const override;
    bool IsOwner() const override;
    void Release() override;
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute Value : HLAopaqueData
    std::vector<uint8_t> GetValue() const override;
    void SetValue(const std::vector<uint8_t>& newValue) override;
    // IValueEntity
    void UpdateAllAttributeValues() override;
    void UpdateAllAttributeValues(int64_t time) override;
    void UpdateModifiedAttributeValues() override;
    void UpdateModifiedAttributeValues(int64_t time) override;
    void RequestAttributeValues() override;
    void RequestAllAttributeValues() override;
    uint32_t RegisterUpdateCallback(UpdateCallback callback) override;
    void UnregisterUpdateCallback(uint32_t callbackToken) override;

    // bitmask of attributes ever received
    AttributeBits GetReceivedAttributes() const override;
    // bitmask of attributes received in last update (cleared after update callbacks executed)
    AttributeBits GetUpdatedAttributes() const override;
    // bitmask of attributes ever modified
    AttributeBits GetInitializedAttributes() const override;
    // bitmask of attributes modified since last updateAttributeValues/provideAttributeValues
    AttributeBits GetModifiedAttributes() const override;
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes);
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType);
    void ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributes, optional<int64_t> time);
  protected:
    friend class ValueEntityObjectClass;

    ValueEntity();
    ValueEntity(ValueEntityObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* ambassador);

    void ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType);

    // get attribute handle/value map of all attributes
    rti1516ev::AttributeHandleValueMap GetAllAttributeValues() const;
    // get attribute handle/value map of attributes which have been modified since last call to UpdateModifiedAttributeValues
    rti1516ev::AttributeHandleValueMap GetModifiedAttributeValues() const;

    rti1516ev::RTIambassador* mRtiAmbassador;
    // this mutex guards all of the fields below
    mutable std::recursive_mutex mMutex;

    ValueEntityObjectClass* mObjectClass;
    std::wstring mObjectInstanceName;
    rti1516ev::ObjectInstanceHandle mObjectInstanceHandle;
    bool mIsOwner = false;
    // modified by any ReflectAttributeValues in the past
    AttributeBits mValuesReceived = kNone;
    // modified by any attribute setter
    AttributeBits mValuesSet = kNone;
    // modified by last ReflectAttributeValues
    AttributeBits mLastUpdated = kNone;
    // to be sent with next UpdateModifiedAttributeValues
    AttributeBits mDirty = kNone;
    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, UpdateCallback> mUpdateCallbacks;
    uint32_t mLastCallbackToken = 0;
    // Attribute value encoders
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute Value : HLAopaqueData
    rti1516ev::HLAopaqueData mValue;
};

class DOMemberSource;
class DOMemberSourceObjectClass : public IDOMemberSourceObjectClass
{
  public:
    // IDOMemberSourceObjectClass
    DOMemberSourceObjectClass() = default;
    virtual ~DOMemberSourceObjectClass();
    void Publish() override;
    void Unpublish() override;
    void Subscribe(bool deliverToSelf) override;
    void Unsubscribe() override;
    std::shared_ptr<IDOMemberSource> GetObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IDOMemberSource> CreateObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IDOMemberSource> CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback) override;
    uint32_t RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback) override;
    void UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IDOMemberSource> newObjectInstance);

    uint32_t RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback) override;
    void UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IDOMemberSource> newObjectInstance);
    // Set a user-defined creator function, which returns subclasses of DOMemberSource
    using ObjectInstanceCreatorFunction = std::function<DOMemberSource*(DOMemberSourceObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)>;
    // When using custom object instance classes, don't forget to set the creator function *before* subscribing to the object class.
    void SetObjectInstanceCreator(ObjectInstanceCreatorFunction creatorFunction) { mCreatorFunction = creatorFunction; }
    // internal
    DOMemberSourceObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, HLAobjectRootObjectClass* baseClass);

    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute DOSourceMemberName : HLAASCIIstring
    rti1516ev::AttributeHandle GetDOSourceMemberNameAttributeHandle() const { return mDOSourceMemberNameAttributeHandle; }
    // attribute DOSourceMemberConnectionType : HLAASCIIstring
    rti1516ev::AttributeHandle GetDOSourceMemberConnectionTypeAttributeHandle() const { return mDOSourceMemberConnectionTypeAttributeHandle; }
    // attribute DOSourceMemberDataBytes : HLAopaqueData
    rti1516ev::AttributeHandle GetDOSourceMemberDataBytesAttributeHandle() const { return mDOSourceMemberDataBytesAttributeHandle; }
    void DiscoverObjectInstance (rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    rti1516ev::ObjectClassHandle GetObjectClassHandle() const { return mObjectClassHandle; }
    std::shared_ptr<IDOMemberSource> GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle);
    rti1516ev::AttributeHandleSet GetAllAttributeHandles();
    ObjectClassRegistry* GetObjectClassRegistry() const { return mRegistry; }

    // add object instance to maps (and to maps of base classes)
    void InsertObjectInstanceName(std::shared_ptr<IDOMemberSource> objectInstance, const std::wstring& objectInstanceName);
    void InsertObjectInstanceHandle(std::shared_ptr<IDOMemberSource> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle);
    // remove object instance from maps (and from maps of base classes)
    void EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName);
  private:
    ObjectClassRegistry* mRegistry;
    rti1516ev::RTIambassador* mRtiAmbassador;
    // object class handle
    rti1516ev::ObjectClassHandle mObjectClassHandle;
    HLAobjectRootObjectClass* mBaseClass;
    ObjectInstanceCreatorFunction mCreatorFunction;
    bool mPublished = false;
    bool mSubscribed = false;
    // Attribute handles
    // attribute DOSourceMemberName : HLAASCIIstring
    rti1516ev::AttributeHandle mDOSourceMemberNameAttributeHandle;
    // attribute DOSourceMemberConnectionType : HLAASCIIstring
    rti1516ev::AttributeHandle mDOSourceMemberConnectionTypeAttributeHandle;
    // attribute DOSourceMemberDataBytes : HLAopaqueData
    rti1516ev::AttributeHandle mDOSourceMemberDataBytesAttributeHandle;
    // this mutex guards the data structures below
    mutable std::recursive_mutex mMutex;
    std::map<std::wstring, std::shared_ptr<IDOMemberSource>> mObjectInstancesByName;
    std::map<rti1516ev::ObjectInstanceHandle, std::shared_ptr<IDOMemberSource>> mObjectInstancesByHandle;

    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, DiscoverObjectInstanceCallback> mDiscoverCallbacks;
    uint32_t mLastDiscoverObjectInstanceCallbackToken = 0;
    std::map<uint32_t, RemoveObjectInstanceCallback> mRemoveObjectInstanceCallbacks;
    uint32_t mLastRemoveObjectInstanceCallbackToken = 0;
};

class DOMemberSource : public IDOMemberSource
{
  public:

    virtual ~DOMemberSource();
    DOMemberSource(const DOMemberSource&) = delete;
    DOMemberSource(DOMemberSource&&) = delete;
    DOMemberSource& operator=(const DOMemberSource&) = delete;
    DOMemberSource& operator=(DOMemberSource&&) = delete;
    IDOMemberSourceObjectClass* GetObjectClass() const { return mObjectClass; }
    ObjectClassRegistry* GetObjectClassRegistry() const { return mObjectClass->GetObjectClassRegistry(); }
    std::wstring GetObjectInstanceName() const override { return mObjectInstanceName; }
    rti1516ev::ObjectInstanceHandle GetObjectInstanceHandle() const { return mObjectInstanceHandle; }
    bool IsValid() const override;
    bool IsOwner() const override;
    void Release() override;
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute DOSourceMemberName : HLAASCIIstring
    std::string GetDOSourceMemberName() const override;
    void SetDOSourceMemberName(std::string newValue) override;
    // attribute DOSourceMemberConnectionType : HLAASCIIstring
    std::string GetDOSourceMemberConnectionType() const override;
    void SetDOSourceMemberConnectionType(std::string newValue) override;
    // attribute DOSourceMemberDataBytes : HLAopaqueData
    std::vector<uint8_t> GetDOSourceMemberDataBytes() const override;
    void SetDOSourceMemberDataBytes(const std::vector<uint8_t>& newValue) override;
    // IDOMemberSource
    void UpdateAllAttributeValues() override;
    void UpdateAllAttributeValues(int64_t time) override;
    void UpdateModifiedAttributeValues() override;
    void UpdateModifiedAttributeValues(int64_t time) override;
    void RequestAttributeValues() override;
    void RequestAllAttributeValues() override;
    uint32_t RegisterUpdateCallback(UpdateCallback callback) override;
    void UnregisterUpdateCallback(uint32_t callbackToken) override;

    // bitmask of attributes ever received
    AttributeBits GetReceivedAttributes() const override;
    // bitmask of attributes received in last update (cleared after update callbacks executed)
    AttributeBits GetUpdatedAttributes() const override;
    // bitmask of attributes ever modified
    AttributeBits GetInitializedAttributes() const override;
    // bitmask of attributes modified since last updateAttributeValues/provideAttributeValues
    AttributeBits GetModifiedAttributes() const override;
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes);
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType);
    void ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributes, optional<int64_t> time);
  protected:
    friend class DOMemberSourceObjectClass;

    DOMemberSource();
    DOMemberSource(DOMemberSourceObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* ambassador);

    void ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType);

    // get attribute handle/value map of all attributes
    rti1516ev::AttributeHandleValueMap GetAllAttributeValues() const;
    // get attribute handle/value map of attributes which have been modified since last call to UpdateModifiedAttributeValues
    rti1516ev::AttributeHandleValueMap GetModifiedAttributeValues() const;

    rti1516ev::RTIambassador* mRtiAmbassador;
    // this mutex guards all of the fields below
    mutable std::recursive_mutex mMutex;

    DOMemberSourceObjectClass* mObjectClass;
    std::wstring mObjectInstanceName;
    rti1516ev::ObjectInstanceHandle mObjectInstanceHandle;
    bool mIsOwner = false;
    // modified by any ReflectAttributeValues in the past
    AttributeBits mValuesReceived = kNone;
    // modified by any attribute setter
    AttributeBits mValuesSet = kNone;
    // modified by last ReflectAttributeValues
    AttributeBits mLastUpdated = kNone;
    // to be sent with next UpdateModifiedAttributeValues
    AttributeBits mDirty = kNone;
    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, UpdateCallback> mUpdateCallbacks;
    uint32_t mLastCallbackToken = 0;
    // Attribute value encoders
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute DOSourceMemberName : HLAASCIIstring
    rti1516ev::HLAASCIIstring mDOSourceMemberName;
    // attribute DOSourceMemberConnectionType : HLAASCIIstring
    rti1516ev::HLAASCIIstring mDOSourceMemberConnectionType;
    // attribute DOSourceMemberDataBytes : HLAopaqueData
    rti1516ev::HLAopaqueData mDOSourceMemberDataBytes;
};

class DOMemberTarget;
class DOMemberTargetObjectClass : public IDOMemberTargetObjectClass
{
  public:
    // IDOMemberTargetObjectClass
    DOMemberTargetObjectClass() = default;
    virtual ~DOMemberTargetObjectClass();
    void Publish() override;
    void Unpublish() override;
    void Subscribe(bool deliverToSelf) override;
    void Unsubscribe() override;
    std::shared_ptr<IDOMemberTarget> GetObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IDOMemberTarget> CreateObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IDOMemberTarget> CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback) override;
    uint32_t RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback) override;
    void UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IDOMemberTarget> newObjectInstance);

    uint32_t RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback) override;
    void UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IDOMemberTarget> newObjectInstance);
    // Set a user-defined creator function, which returns subclasses of DOMemberTarget
    using ObjectInstanceCreatorFunction = std::function<DOMemberTarget*(DOMemberTargetObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)>;
    // When using custom object instance classes, don't forget to set the creator function *before* subscribing to the object class.
    void SetObjectInstanceCreator(ObjectInstanceCreatorFunction creatorFunction) { mCreatorFunction = creatorFunction; }
    // internal
    DOMemberTargetObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, HLAobjectRootObjectClass* baseClass);

    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute DOTargetMemberName : HLAASCIIstring
    rti1516ev::AttributeHandle GetDOTargetMemberNameAttributeHandle() const { return mDOTargetMemberNameAttributeHandle; }
    // attribute DOTargetMemberConnectionType : HLAASCIIstring
    rti1516ev::AttributeHandle GetDOTargetMemberConnectionTypeAttributeHandle() const { return mDOTargetMemberConnectionTypeAttributeHandle; }
    void DiscoverObjectInstance (rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    rti1516ev::ObjectClassHandle GetObjectClassHandle() const { return mObjectClassHandle; }
    std::shared_ptr<IDOMemberTarget> GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle);
    rti1516ev::AttributeHandleSet GetAllAttributeHandles();
    ObjectClassRegistry* GetObjectClassRegistry() const { return mRegistry; }

    // add object instance to maps (and to maps of base classes)
    void InsertObjectInstanceName(std::shared_ptr<IDOMemberTarget> objectInstance, const std::wstring& objectInstanceName);
    void InsertObjectInstanceHandle(std::shared_ptr<IDOMemberTarget> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle);
    // remove object instance from maps (and from maps of base classes)
    void EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName);
  private:
    ObjectClassRegistry* mRegistry;
    rti1516ev::RTIambassador* mRtiAmbassador;
    // object class handle
    rti1516ev::ObjectClassHandle mObjectClassHandle;
    HLAobjectRootObjectClass* mBaseClass;
    ObjectInstanceCreatorFunction mCreatorFunction;
    bool mPublished = false;
    bool mSubscribed = false;
    // Attribute handles
    // attribute DOTargetMemberName : HLAASCIIstring
    rti1516ev::AttributeHandle mDOTargetMemberNameAttributeHandle;
    // attribute DOTargetMemberConnectionType : HLAASCIIstring
    rti1516ev::AttributeHandle mDOTargetMemberConnectionTypeAttributeHandle;
    // this mutex guards the data structures below
    mutable std::recursive_mutex mMutex;
    std::map<std::wstring, std::shared_ptr<IDOMemberTarget>> mObjectInstancesByName;
    std::map<rti1516ev::ObjectInstanceHandle, std::shared_ptr<IDOMemberTarget>> mObjectInstancesByHandle;

    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, DiscoverObjectInstanceCallback> mDiscoverCallbacks;
    uint32_t mLastDiscoverObjectInstanceCallbackToken = 0;
    std::map<uint32_t, RemoveObjectInstanceCallback> mRemoveObjectInstanceCallbacks;
    uint32_t mLastRemoveObjectInstanceCallbackToken = 0;
};

class DOMemberTarget : public IDOMemberTarget
{
  public:

    virtual ~DOMemberTarget();
    DOMemberTarget(const DOMemberTarget&) = delete;
    DOMemberTarget(DOMemberTarget&&) = delete;
    DOMemberTarget& operator=(const DOMemberTarget&) = delete;
    DOMemberTarget& operator=(DOMemberTarget&&) = delete;
    IDOMemberTargetObjectClass* GetObjectClass() const { return mObjectClass; }
    ObjectClassRegistry* GetObjectClassRegistry() const { return mObjectClass->GetObjectClassRegistry(); }
    std::wstring GetObjectInstanceName() const override { return mObjectInstanceName; }
    rti1516ev::ObjectInstanceHandle GetObjectInstanceHandle() const { return mObjectInstanceHandle; }
    bool IsValid() const override;
    bool IsOwner() const override;
    void Release() override;
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute DOTargetMemberName : HLAASCIIstring
    std::string GetDOTargetMemberName() const override;
    void SetDOTargetMemberName(std::string newValue) override;
    // attribute DOTargetMemberConnectionType : HLAASCIIstring
    std::string GetDOTargetMemberConnectionType() const override;
    void SetDOTargetMemberConnectionType(std::string newValue) override;
    // IDOMemberTarget
    void UpdateAllAttributeValues() override;
    void UpdateAllAttributeValues(int64_t time) override;
    void UpdateModifiedAttributeValues() override;
    void UpdateModifiedAttributeValues(int64_t time) override;
    void RequestAttributeValues() override;
    void RequestAllAttributeValues() override;
    uint32_t RegisterUpdateCallback(UpdateCallback callback) override;
    void UnregisterUpdateCallback(uint32_t callbackToken) override;

    // bitmask of attributes ever received
    AttributeBits GetReceivedAttributes() const override;
    // bitmask of attributes received in last update (cleared after update callbacks executed)
    AttributeBits GetUpdatedAttributes() const override;
    // bitmask of attributes ever modified
    AttributeBits GetInitializedAttributes() const override;
    // bitmask of attributes modified since last updateAttributeValues/provideAttributeValues
    AttributeBits GetModifiedAttributes() const override;
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes);
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType);
    void ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributes, optional<int64_t> time);
  protected:
    friend class DOMemberTargetObjectClass;

    DOMemberTarget();
    DOMemberTarget(DOMemberTargetObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* ambassador);

    void ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType);

    // get attribute handle/value map of all attributes
    rti1516ev::AttributeHandleValueMap GetAllAttributeValues() const;
    // get attribute handle/value map of attributes which have been modified since last call to UpdateModifiedAttributeValues
    rti1516ev::AttributeHandleValueMap GetModifiedAttributeValues() const;

    rti1516ev::RTIambassador* mRtiAmbassador;
    // this mutex guards all of the fields below
    mutable std::recursive_mutex mMutex;

    DOMemberTargetObjectClass* mObjectClass;
    std::wstring mObjectInstanceName;
    rti1516ev::ObjectInstanceHandle mObjectInstanceHandle;
    bool mIsOwner = false;
    // modified by any ReflectAttributeValues in the past
    AttributeBits mValuesReceived = kNone;
    // modified by any attribute setter
    AttributeBits mValuesSet = kNone;
    // modified by last ReflectAttributeValues
    AttributeBits mLastUpdated = kNone;
    // to be sent with next UpdateModifiedAttributeValues
    AttributeBits mDirty = kNone;
    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, UpdateCallback> mUpdateCallbacks;
    uint32_t mLastCallbackToken = 0;
    // Attribute value encoders
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute DOTargetMemberName : HLAASCIIstring
    rti1516ev::HLAASCIIstring mDOTargetMemberName;
    // attribute DOTargetMemberConnectionType : HLAASCIIstring
    rti1516ev::HLAASCIIstring mDOTargetMemberConnectionType;
};

class BusManagement;
class BusManagementObjectClass : public IBusManagementObjectClass
{
  public:
    // IBusManagementObjectClass
    BusManagementObjectClass() = default;
    virtual ~BusManagementObjectClass();
    void Publish() override;
    void Unpublish() override;
    void Subscribe(bool deliverToSelf) override;
    void Unsubscribe() override;
    std::shared_ptr<IBusManagement> GetObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IBusManagement> CreateObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IBusManagement> CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback) override;
    uint32_t RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback) override;
    void UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IBusManagement> newObjectInstance);

    uint32_t RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback) override;
    void UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IBusManagement> newObjectInstance);
    // Set a user-defined creator function, which returns subclasses of BusManagement
    using ObjectInstanceCreatorFunction = std::function<BusManagement*(BusManagementObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)>;
    // When using custom object instance classes, don't forget to set the creator function *before* subscribing to the object class.
    void SetObjectInstanceCreator(ObjectInstanceCreatorFunction creatorFunction) { mCreatorFunction = creatorFunction; }
    // internal
    BusManagementObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, HLAobjectRootObjectClass* baseClass);

    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute NetworkID : HLAASCIIstring
    rti1516ev::AttributeHandle GetNetworkIDAttributeHandle() const { return mNetworkIDAttributeHandle; }
    void DiscoverObjectInstance (rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    rti1516ev::ObjectClassHandle GetObjectClassHandle() const { return mObjectClassHandle; }
    std::shared_ptr<IBusManagement> GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle);
    rti1516ev::AttributeHandleSet GetAllAttributeHandles();
    ObjectClassRegistry* GetObjectClassRegistry() const { return mRegistry; }

    // add object instance to maps (and to maps of base classes)
    void InsertObjectInstanceName(std::shared_ptr<IBusManagement> objectInstance, const std::wstring& objectInstanceName);
    void InsertObjectInstanceHandle(std::shared_ptr<IBusManagement> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle);
    // remove object instance from maps (and from maps of base classes)
    void EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName);
  private:
    ObjectClassRegistry* mRegistry;
    rti1516ev::RTIambassador* mRtiAmbassador;
    // object class handle
    rti1516ev::ObjectClassHandle mObjectClassHandle;
    HLAobjectRootObjectClass* mBaseClass;
    ObjectInstanceCreatorFunction mCreatorFunction;
    bool mPublished = false;
    bool mSubscribed = false;
    // Attribute handles
    // attribute NetworkID : HLAASCIIstring
    rti1516ev::AttributeHandle mNetworkIDAttributeHandle;
    // this mutex guards the data structures below
    mutable std::recursive_mutex mMutex;
    std::map<std::wstring, std::shared_ptr<IBusManagement>> mObjectInstancesByName;
    std::map<rti1516ev::ObjectInstanceHandle, std::shared_ptr<IBusManagement>> mObjectInstancesByHandle;

    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, DiscoverObjectInstanceCallback> mDiscoverCallbacks;
    uint32_t mLastDiscoverObjectInstanceCallbackToken = 0;
    std::map<uint32_t, RemoveObjectInstanceCallback> mRemoveObjectInstanceCallbacks;
    uint32_t mLastRemoveObjectInstanceCallbackToken = 0;
};

class BusManagement : public IBusManagement
{
  public:

    virtual ~BusManagement();
    BusManagement(const BusManagement&) = delete;
    BusManagement(BusManagement&&) = delete;
    BusManagement& operator=(const BusManagement&) = delete;
    BusManagement& operator=(BusManagement&&) = delete;
    IBusManagementObjectClass* GetObjectClass() const { return mObjectClass; }
    ObjectClassRegistry* GetObjectClassRegistry() const { return mObjectClass->GetObjectClassRegistry(); }
    std::wstring GetObjectInstanceName() const override { return mObjectInstanceName; }
    rti1516ev::ObjectInstanceHandle GetObjectInstanceHandle() const { return mObjectInstanceHandle; }
    bool IsValid() const override;
    bool IsOwner() const override;
    void Release() override;
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute NetworkID : HLAASCIIstring
    std::string GetNetworkID() const override;
    void SetNetworkID(std::string newValue) override;
    // IBusManagement
    void UpdateAllAttributeValues() override;
    void UpdateAllAttributeValues(int64_t time) override;
    void UpdateModifiedAttributeValues() override;
    void UpdateModifiedAttributeValues(int64_t time) override;
    void RequestAttributeValues() override;
    void RequestAllAttributeValues() override;

    // bitmask of attributes ever received
    AttributeBits GetReceivedAttributes() const override;
    // bitmask of attributes received in last update (cleared after update callbacks executed)
    AttributeBits GetUpdatedAttributes() const override;
    // bitmask of attributes ever modified
    AttributeBits GetInitializedAttributes() const override;
    // bitmask of attributes modified since last updateAttributeValues/provideAttributeValues
    AttributeBits GetModifiedAttributes() const override;
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes);
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType);
    void ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributes, optional<int64_t> time);
  protected:
    friend class BusManagementObjectClass;

    BusManagement();
    BusManagement(BusManagementObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* ambassador);


    // get attribute handle/value map of all attributes
    rti1516ev::AttributeHandleValueMap GetAllAttributeValues() const;
    // get attribute handle/value map of attributes which have been modified since last call to UpdateModifiedAttributeValues
    rti1516ev::AttributeHandleValueMap GetModifiedAttributeValues() const;

    rti1516ev::RTIambassador* mRtiAmbassador;
    // this mutex guards all of the fields below
    mutable std::recursive_mutex mMutex;

    BusManagementObjectClass* mObjectClass;
    std::wstring mObjectInstanceName;
    rti1516ev::ObjectInstanceHandle mObjectInstanceHandle;
    bool mIsOwner = false;
    // modified by any ReflectAttributeValues in the past
    AttributeBits mValuesReceived = kNone;
    // modified by any attribute setter
    AttributeBits mValuesSet = kNone;
    // modified by last ReflectAttributeValues
    AttributeBits mLastUpdated = kNone;
    // to be sent with next UpdateModifiedAttributeValues
    AttributeBits mDirty = kNone;
    // Attribute value encoders
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute NetworkID : HLAASCIIstring
    rti1516ev::HLAASCIIstring mNetworkID;
};

class BusManagementCan;
class BusManagementCanObjectClass : public IBusManagementCanObjectClass
{
  public:
    // IBusManagementCanObjectClass
    BusManagementCanObjectClass() = default;
    virtual ~BusManagementCanObjectClass();
    void Publish() override;
    void Unpublish() override;
    void Subscribe(bool deliverToSelf) override;
    void Unsubscribe() override;
    std::shared_ptr<IBusManagementCan> GetObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IBusManagementCan> CreateObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IBusManagementCan> CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback) override;
    uint32_t RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback) override;
    void UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IBusManagementCan> newObjectInstance);

    uint32_t RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback) override;
    void UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IBusManagementCan> newObjectInstance);
    // Set a user-defined creator function, which returns subclasses of BusManagementCan
    using ObjectInstanceCreatorFunction = std::function<BusManagementCan*(BusManagementCanObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)>;
    // When using custom object instance classes, don't forget to set the creator function *before* subscribing to the object class.
    void SetObjectInstanceCreator(ObjectInstanceCreatorFunction creatorFunction) { mCreatorFunction = creatorFunction; }
    // internal
    BusManagementCanObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, BusManagementObjectClass* baseClass);

    // attribute NetworkID : HLAASCIIstring
    rti1516ev::AttributeHandle GetNetworkIDAttributeHandle() const { return mBaseClass->GetNetworkIDAttributeHandle(); }
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute BusState : CanBusState
    rti1516ev::AttributeHandle GetBusStateAttributeHandle() const { return mBusStateAttributeHandle; }
    // attribute TxErrorCount : HLAinteger32LE
    rti1516ev::AttributeHandle GetTxErrorCountAttributeHandle() const { return mTxErrorCountAttributeHandle; }
    // attribute RxErrorCount : HLAinteger32LE
    rti1516ev::AttributeHandle GetRxErrorCountAttributeHandle() const { return mRxErrorCountAttributeHandle; }
    // attribute SendMessagesAsRx : HLAboolean
    rti1516ev::AttributeHandle GetSendMessagesAsRxAttributeHandle() const { return mSendMessagesAsRxAttributeHandle; }
    void DiscoverObjectInstance (rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    rti1516ev::ObjectClassHandle GetObjectClassHandle() const { return mObjectClassHandle; }
    std::shared_ptr<IBusManagementCan> GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle);
    rti1516ev::AttributeHandleSet GetAllAttributeHandles();
    ObjectClassRegistry* GetObjectClassRegistry() const { return mRegistry; }

    // add object instance to maps (and to maps of base classes)
    void InsertObjectInstanceName(std::shared_ptr<IBusManagementCan> objectInstance, const std::wstring& objectInstanceName);
    void InsertObjectInstanceHandle(std::shared_ptr<IBusManagementCan> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle);
    // remove object instance from maps (and from maps of base classes)
    void EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName);
  private:
    ObjectClassRegistry* mRegistry;
    rti1516ev::RTIambassador* mRtiAmbassador;
    // object class handle
    rti1516ev::ObjectClassHandle mObjectClassHandle;
    BusManagementObjectClass* mBaseClass;
    ObjectInstanceCreatorFunction mCreatorFunction;
    bool mPublished = false;
    bool mSubscribed = false;
    // Attribute handles
    // attribute BusState : CanBusState
    rti1516ev::AttributeHandle mBusStateAttributeHandle;
    // attribute TxErrorCount : HLAinteger32LE
    rti1516ev::AttributeHandle mTxErrorCountAttributeHandle;
    // attribute RxErrorCount : HLAinteger32LE
    rti1516ev::AttributeHandle mRxErrorCountAttributeHandle;
    // attribute SendMessagesAsRx : HLAboolean
    rti1516ev::AttributeHandle mSendMessagesAsRxAttributeHandle;
    // this mutex guards the data structures below
    mutable std::recursive_mutex mMutex;
    std::map<std::wstring, std::shared_ptr<IBusManagementCan>> mObjectInstancesByName;
    std::map<rti1516ev::ObjectInstanceHandle, std::shared_ptr<IBusManagementCan>> mObjectInstancesByHandle;

    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, DiscoverObjectInstanceCallback> mDiscoverCallbacks;
    uint32_t mLastDiscoverObjectInstanceCallbackToken = 0;
    std::map<uint32_t, RemoveObjectInstanceCallback> mRemoveObjectInstanceCallbacks;
    uint32_t mLastRemoveObjectInstanceCallbackToken = 0;
};

class BusManagementCan : public IBusManagementCan
{
  public:

    virtual ~BusManagementCan();
    BusManagementCan(const BusManagementCan&) = delete;
    BusManagementCan(BusManagementCan&&) = delete;
    BusManagementCan& operator=(const BusManagementCan&) = delete;
    BusManagementCan& operator=(BusManagementCan&&) = delete;
    IBusManagementCanObjectClass* GetObjectClass() const { return mObjectClass; }
    ObjectClassRegistry* GetObjectClassRegistry() const { return mObjectClass->GetObjectClassRegistry(); }
    std::wstring GetObjectInstanceName() const override { return mObjectInstanceName; }
    rti1516ev::ObjectInstanceHandle GetObjectInstanceHandle() const { return mObjectInstanceHandle; }
    bool IsValid() const override;
    bool IsOwner() const override;
    void Release() override;
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute NetworkID : HLAASCIIstring
    std::string GetNetworkID() const override;
    void SetNetworkID(std::string newValue) override;
    // attribute BusState : CanBusState
    CanBusState GetBusState() const override;
    void SetBusState(CanBusState newValue) override;
    // attribute TxErrorCount : HLAinteger32LE
    int32_t GetTxErrorCount() const override;
    void SetTxErrorCount(int32_t newValue) override;
    // attribute RxErrorCount : HLAinteger32LE
    int32_t GetRxErrorCount() const override;
    void SetRxErrorCount(int32_t newValue) override;
    // attribute SendMessagesAsRx : HLAboolean
    bool GetSendMessagesAsRx() const override;
    void SetSendMessagesAsRx(bool newValue) override;
    // IBusManagementCan
    void UpdateAllAttributeValues() override;
    void UpdateAllAttributeValues(int64_t time) override;
    void UpdateModifiedAttributeValues() override;
    void UpdateModifiedAttributeValues(int64_t time) override;
    void RequestAttributeValues() override;
    void RequestAllAttributeValues() override;
    uint32_t RegisterUpdateCallback(UpdateCallback callback) override;
    void UnregisterUpdateCallback(uint32_t callbackToken) override;

    // bitmask of attributes ever received
    AttributeBits GetReceivedAttributes() const override;
    // bitmask of attributes received in last update (cleared after update callbacks executed)
    AttributeBits GetUpdatedAttributes() const override;
    // bitmask of attributes ever modified
    AttributeBits GetInitializedAttributes() const override;
    // bitmask of attributes modified since last updateAttributeValues/provideAttributeValues
    AttributeBits GetModifiedAttributes() const override;
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes);
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType);
    void ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributes, optional<int64_t> time);
  protected:
    friend class BusManagementCanObjectClass;

    BusManagementCan();
    BusManagementCan(BusManagementCanObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* ambassador);

    void ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType);

    // get attribute handle/value map of all attributes
    rti1516ev::AttributeHandleValueMap GetAllAttributeValues() const;
    // get attribute handle/value map of attributes which have been modified since last call to UpdateModifiedAttributeValues
    rti1516ev::AttributeHandleValueMap GetModifiedAttributeValues() const;

    rti1516ev::RTIambassador* mRtiAmbassador;
    // this mutex guards all of the fields below
    mutable std::recursive_mutex mMutex;

    BusManagementCanObjectClass* mObjectClass;
    std::wstring mObjectInstanceName;
    rti1516ev::ObjectInstanceHandle mObjectInstanceHandle;
    bool mIsOwner = false;
    // modified by any ReflectAttributeValues in the past
    AttributeBits mValuesReceived = kNone;
    // modified by any attribute setter
    AttributeBits mValuesSet = kNone;
    // modified by last ReflectAttributeValues
    AttributeBits mLastUpdated = kNone;
    // to be sent with next UpdateModifiedAttributeValues
    AttributeBits mDirty = kNone;
    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, UpdateCallback> mUpdateCallbacks;
    uint32_t mLastCallbackToken = 0;
    // Attribute value encoders
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute NetworkID : HLAASCIIstring
    rti1516ev::HLAASCIIstring mNetworkID;
    // attribute BusState : CanBusState
    rti1516ev::HLAinteger32LE mBusState;
    // attribute TxErrorCount : HLAinteger32LE
    rti1516ev::HLAinteger32LE mTxErrorCount;
    // attribute RxErrorCount : HLAinteger32LE
    rti1516ev::HLAinteger32LE mRxErrorCount;
    // attribute SendMessagesAsRx : HLAboolean
    rti1516ev::HLAboolean mSendMessagesAsRx;
};

class BusManagementEthernet;
class BusManagementEthernetObjectClass : public IBusManagementEthernetObjectClass
{
  public:
    // IBusManagementEthernetObjectClass
    BusManagementEthernetObjectClass() = default;
    virtual ~BusManagementEthernetObjectClass();
    void Publish() override;
    void Unpublish() override;
    void Subscribe(bool deliverToSelf) override;
    void Unsubscribe() override;
    std::shared_ptr<IBusManagementEthernet> GetObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IBusManagementEthernet> CreateObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IBusManagementEthernet> CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback) override;
    uint32_t RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback) override;
    void UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IBusManagementEthernet> newObjectInstance);

    uint32_t RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback) override;
    void UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IBusManagementEthernet> newObjectInstance);
    // Set a user-defined creator function, which returns subclasses of BusManagementEthernet
    using ObjectInstanceCreatorFunction = std::function<BusManagementEthernet*(BusManagementEthernetObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)>;
    // When using custom object instance classes, don't forget to set the creator function *before* subscribing to the object class.
    void SetObjectInstanceCreator(ObjectInstanceCreatorFunction creatorFunction) { mCreatorFunction = creatorFunction; }
    // internal
    BusManagementEthernetObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, BusManagementObjectClass* baseClass);

    // attribute NetworkID : HLAASCIIstring
    rti1516ev::AttributeHandle GetNetworkIDAttributeHandle() const { return mBaseClass->GetNetworkIDAttributeHandle(); }
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute PortName : HLAASCIIstring
    rti1516ev::AttributeHandle GetPortNameAttributeHandle() const { return mPortNameAttributeHandle; }
    // attribute SendMessagesAsRx : HLAboolean
    rti1516ev::AttributeHandle GetSendMessagesAsRxAttributeHandle() const { return mSendMessagesAsRxAttributeHandle; }
    void DiscoverObjectInstance (rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    rti1516ev::ObjectClassHandle GetObjectClassHandle() const { return mObjectClassHandle; }
    std::shared_ptr<IBusManagementEthernet> GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle);
    rti1516ev::AttributeHandleSet GetAllAttributeHandles();
    ObjectClassRegistry* GetObjectClassRegistry() const { return mRegistry; }

    // add object instance to maps (and to maps of base classes)
    void InsertObjectInstanceName(std::shared_ptr<IBusManagementEthernet> objectInstance, const std::wstring& objectInstanceName);
    void InsertObjectInstanceHandle(std::shared_ptr<IBusManagementEthernet> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle);
    // remove object instance from maps (and from maps of base classes)
    void EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName);
  private:
    ObjectClassRegistry* mRegistry;
    rti1516ev::RTIambassador* mRtiAmbassador;
    // object class handle
    rti1516ev::ObjectClassHandle mObjectClassHandle;
    BusManagementObjectClass* mBaseClass;
    ObjectInstanceCreatorFunction mCreatorFunction;
    bool mPublished = false;
    bool mSubscribed = false;
    // Attribute handles
    // attribute PortName : HLAASCIIstring
    rti1516ev::AttributeHandle mPortNameAttributeHandle;
    // attribute SendMessagesAsRx : HLAboolean
    rti1516ev::AttributeHandle mSendMessagesAsRxAttributeHandle;
    // this mutex guards the data structures below
    mutable std::recursive_mutex mMutex;
    std::map<std::wstring, std::shared_ptr<IBusManagementEthernet>> mObjectInstancesByName;
    std::map<rti1516ev::ObjectInstanceHandle, std::shared_ptr<IBusManagementEthernet>> mObjectInstancesByHandle;

    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, DiscoverObjectInstanceCallback> mDiscoverCallbacks;
    uint32_t mLastDiscoverObjectInstanceCallbackToken = 0;
    std::map<uint32_t, RemoveObjectInstanceCallback> mRemoveObjectInstanceCallbacks;
    uint32_t mLastRemoveObjectInstanceCallbackToken = 0;
};

class BusManagementEthernet : public IBusManagementEthernet
{
  public:

    virtual ~BusManagementEthernet();
    BusManagementEthernet(const BusManagementEthernet&) = delete;
    BusManagementEthernet(BusManagementEthernet&&) = delete;
    BusManagementEthernet& operator=(const BusManagementEthernet&) = delete;
    BusManagementEthernet& operator=(BusManagementEthernet&&) = delete;
    IBusManagementEthernetObjectClass* GetObjectClass() const { return mObjectClass; }
    ObjectClassRegistry* GetObjectClassRegistry() const { return mObjectClass->GetObjectClassRegistry(); }
    std::wstring GetObjectInstanceName() const override { return mObjectInstanceName; }
    rti1516ev::ObjectInstanceHandle GetObjectInstanceHandle() const { return mObjectInstanceHandle; }
    bool IsValid() const override;
    bool IsOwner() const override;
    void Release() override;
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute NetworkID : HLAASCIIstring
    std::string GetNetworkID() const override;
    void SetNetworkID(std::string newValue) override;
    // attribute PortName : HLAASCIIstring
    std::string GetPortName() const override;
    void SetPortName(std::string newValue) override;
    // attribute SendMessagesAsRx : HLAboolean
    bool GetSendMessagesAsRx() const override;
    void SetSendMessagesAsRx(bool newValue) override;
    // IBusManagementEthernet
    void UpdateAllAttributeValues() override;
    void UpdateAllAttributeValues(int64_t time) override;
    void UpdateModifiedAttributeValues() override;
    void UpdateModifiedAttributeValues(int64_t time) override;
    void RequestAttributeValues() override;
    void RequestAllAttributeValues() override;
    uint32_t RegisterUpdateCallback(UpdateCallback callback) override;
    void UnregisterUpdateCallback(uint32_t callbackToken) override;

    // bitmask of attributes ever received
    AttributeBits GetReceivedAttributes() const override;
    // bitmask of attributes received in last update (cleared after update callbacks executed)
    AttributeBits GetUpdatedAttributes() const override;
    // bitmask of attributes ever modified
    AttributeBits GetInitializedAttributes() const override;
    // bitmask of attributes modified since last updateAttributeValues/provideAttributeValues
    AttributeBits GetModifiedAttributes() const override;
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes);
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType);
    void ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributes, optional<int64_t> time);
  protected:
    friend class BusManagementEthernetObjectClass;

    BusManagementEthernet();
    BusManagementEthernet(BusManagementEthernetObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* ambassador);

    void ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType);

    // get attribute handle/value map of all attributes
    rti1516ev::AttributeHandleValueMap GetAllAttributeValues() const;
    // get attribute handle/value map of attributes which have been modified since last call to UpdateModifiedAttributeValues
    rti1516ev::AttributeHandleValueMap GetModifiedAttributeValues() const;

    rti1516ev::RTIambassador* mRtiAmbassador;
    // this mutex guards all of the fields below
    mutable std::recursive_mutex mMutex;

    BusManagementEthernetObjectClass* mObjectClass;
    std::wstring mObjectInstanceName;
    rti1516ev::ObjectInstanceHandle mObjectInstanceHandle;
    bool mIsOwner = false;
    // modified by any ReflectAttributeValues in the past
    AttributeBits mValuesReceived = kNone;
    // modified by any attribute setter
    AttributeBits mValuesSet = kNone;
    // modified by last ReflectAttributeValues
    AttributeBits mLastUpdated = kNone;
    // to be sent with next UpdateModifiedAttributeValues
    AttributeBits mDirty = kNone;
    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, UpdateCallback> mUpdateCallbacks;
    uint32_t mLastCallbackToken = 0;
    // Attribute value encoders
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute NetworkID : HLAASCIIstring
    rti1516ev::HLAASCIIstring mNetworkID;
    // attribute PortName : HLAASCIIstring
    rti1516ev::HLAASCIIstring mPortName;
    // attribute SendMessagesAsRx : HLAboolean
    rti1516ev::HLAboolean mSendMessagesAsRx;
};

class FlexRayCluster;
class FlexRayClusterObjectClass : public IFlexRayClusterObjectClass
{
  public:
    // IFlexRayClusterObjectClass
    FlexRayClusterObjectClass() = default;
    virtual ~FlexRayClusterObjectClass();
    void Publish() override;
    void Unpublish() override;
    void Subscribe(bool deliverToSelf) override;
    void Unsubscribe() override;
    std::shared_ptr<IFlexRayCluster> GetObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IFlexRayCluster> CreateObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IFlexRayCluster> CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback) override;
    uint32_t RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback) override;
    void UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IFlexRayCluster> newObjectInstance);

    uint32_t RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback) override;
    void UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IFlexRayCluster> newObjectInstance);
    // Set a user-defined creator function, which returns subclasses of FlexRayCluster
    using ObjectInstanceCreatorFunction = std::function<FlexRayCluster*(FlexRayClusterObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)>;
    // When using custom object instance classes, don't forget to set the creator function *before* subscribing to the object class.
    void SetObjectInstanceCreator(ObjectInstanceCreatorFunction creatorFunction) { mCreatorFunction = creatorFunction; }
    // internal
    FlexRayClusterObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, BusManagementObjectClass* baseClass);

    // attribute NetworkID : HLAASCIIstring
    rti1516ev::AttributeHandle GetNetworkIDAttributeHandle() const { return mBaseClass->GetNetworkIDAttributeHandle(); }
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute gColdstartAttempts : HLAoctet
    rti1516ev::AttributeHandle GetgColdstartAttemptsAttributeHandle() const { return mgColdstartAttemptsAttributeHandle; }
    // attribute gCycleCountMax : HLAoctet
    rti1516ev::AttributeHandle GetgCycleCountMaxAttributeHandle() const { return mgCycleCountMaxAttributeHandle; }
    // attribute gdActionPointOffset : HLAinteger32LE
    rti1516ev::AttributeHandle GetgdActionPointOffsetAttributeHandle() const { return mgdActionPointOffsetAttributeHandle; }
    // attribute gdDynamicSlotIdlePhase : HLAinteger32LE
    rti1516ev::AttributeHandle GetgdDynamicSlotIdlePhaseAttributeHandle() const { return mgdDynamicSlotIdlePhaseAttributeHandle; }
    // attribute gdMiniSlot : HLAinteger32LE
    rti1516ev::AttributeHandle GetgdMiniSlotAttributeHandle() const { return mgdMiniSlotAttributeHandle; }
    // attribute gdMiniSlotActionPointOffset : HLAinteger32LE
    rti1516ev::AttributeHandle GetgdMiniSlotActionPointOffsetAttributeHandle() const { return mgdMiniSlotActionPointOffsetAttributeHandle; }
    // attribute gdStaticSlot : HLAinteger32LE
    rti1516ev::AttributeHandle GetgdStaticSlotAttributeHandle() const { return mgdStaticSlotAttributeHandle; }
    // attribute gdSymbolWindow : HLAinteger32LE
    rti1516ev::AttributeHandle GetgdSymbolWindowAttributeHandle() const { return mgdSymbolWindowAttributeHandle; }
    // attribute gdSymbolWindowActionPointOffset : HLAinteger32LE
    rti1516ev::AttributeHandle GetgdSymbolWindowActionPointOffsetAttributeHandle() const { return mgdSymbolWindowActionPointOffsetAttributeHandle; }
    // attribute gdTSSTransmitter : HLAinteger32LE
    rti1516ev::AttributeHandle GetgdTSSTransmitterAttributeHandle() const { return mgdTSSTransmitterAttributeHandle; }
    // attribute gdWakeupTxActive : HLAinteger32LE
    rti1516ev::AttributeHandle GetgdWakeupTxActiveAttributeHandle() const { return mgdWakeupTxActiveAttributeHandle; }
    // attribute gdWakeupTxIdle : HLAinteger32LE
    rti1516ev::AttributeHandle GetgdWakeupTxIdleAttributeHandle() const { return mgdWakeupTxIdleAttributeHandle; }
    // attribute gListenNoise : HLAoctet
    rti1516ev::AttributeHandle GetgListenNoiseAttributeHandle() const { return mgListenNoiseAttributeHandle; }
    // attribute gMacroPerCycle : HLAinteger32LE
    rti1516ev::AttributeHandle GetgMacroPerCycleAttributeHandle() const { return mgMacroPerCycleAttributeHandle; }
    // attribute gMaxWithoutClockCorrectionFatal : HLAoctet
    rti1516ev::AttributeHandle GetgMaxWithoutClockCorrectionFatalAttributeHandle() const { return mgMaxWithoutClockCorrectionFatalAttributeHandle; }
    // attribute gMaxWithoutClockCorrectionPassive : HLAoctet
    rti1516ev::AttributeHandle GetgMaxWithoutClockCorrectionPassiveAttributeHandle() const { return mgMaxWithoutClockCorrectionPassiveAttributeHandle; }
    // attribute gNumberOfMiniSlots : HLAinteger32LE
    rti1516ev::AttributeHandle GetgNumberOfMiniSlotsAttributeHandle() const { return mgNumberOfMiniSlotsAttributeHandle; }
    // attribute gNumberOfStaticSlots : HLAinteger32LE
    rti1516ev::AttributeHandle GetgNumberOfStaticSlotsAttributeHandle() const { return mgNumberOfStaticSlotsAttributeHandle; }
    // attribute gPayloadLengthStatic : HLAinteger32LE
    rti1516ev::AttributeHandle GetgPayloadLengthStaticAttributeHandle() const { return mgPayloadLengthStaticAttributeHandle; }
    // attribute gSyncFrameIDCountMax : HLAoctet
    rti1516ev::AttributeHandle GetgSyncFrameIDCountMaxAttributeHandle() const { return mgSyncFrameIDCountMaxAttributeHandle; }
    void DiscoverObjectInstance (rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    rti1516ev::ObjectClassHandle GetObjectClassHandle() const { return mObjectClassHandle; }
    std::shared_ptr<IFlexRayCluster> GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle);
    rti1516ev::AttributeHandleSet GetAllAttributeHandles();
    ObjectClassRegistry* GetObjectClassRegistry() const { return mRegistry; }

    // add object instance to maps (and to maps of base classes)
    void InsertObjectInstanceName(std::shared_ptr<IFlexRayCluster> objectInstance, const std::wstring& objectInstanceName);
    void InsertObjectInstanceHandle(std::shared_ptr<IFlexRayCluster> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle);
    // remove object instance from maps (and from maps of base classes)
    void EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName);
  private:
    ObjectClassRegistry* mRegistry;
    rti1516ev::RTIambassador* mRtiAmbassador;
    // object class handle
    rti1516ev::ObjectClassHandle mObjectClassHandle;
    BusManagementObjectClass* mBaseClass;
    ObjectInstanceCreatorFunction mCreatorFunction;
    bool mPublished = false;
    bool mSubscribed = false;
    // Attribute handles
    // attribute gColdstartAttempts : HLAoctet
    rti1516ev::AttributeHandle mgColdstartAttemptsAttributeHandle;
    // attribute gCycleCountMax : HLAoctet
    rti1516ev::AttributeHandle mgCycleCountMaxAttributeHandle;
    // attribute gdActionPointOffset : HLAinteger32LE
    rti1516ev::AttributeHandle mgdActionPointOffsetAttributeHandle;
    // attribute gdDynamicSlotIdlePhase : HLAinteger32LE
    rti1516ev::AttributeHandle mgdDynamicSlotIdlePhaseAttributeHandle;
    // attribute gdMiniSlot : HLAinteger32LE
    rti1516ev::AttributeHandle mgdMiniSlotAttributeHandle;
    // attribute gdMiniSlotActionPointOffset : HLAinteger32LE
    rti1516ev::AttributeHandle mgdMiniSlotActionPointOffsetAttributeHandle;
    // attribute gdStaticSlot : HLAinteger32LE
    rti1516ev::AttributeHandle mgdStaticSlotAttributeHandle;
    // attribute gdSymbolWindow : HLAinteger32LE
    rti1516ev::AttributeHandle mgdSymbolWindowAttributeHandle;
    // attribute gdSymbolWindowActionPointOffset : HLAinteger32LE
    rti1516ev::AttributeHandle mgdSymbolWindowActionPointOffsetAttributeHandle;
    // attribute gdTSSTransmitter : HLAinteger32LE
    rti1516ev::AttributeHandle mgdTSSTransmitterAttributeHandle;
    // attribute gdWakeupTxActive : HLAinteger32LE
    rti1516ev::AttributeHandle mgdWakeupTxActiveAttributeHandle;
    // attribute gdWakeupTxIdle : HLAinteger32LE
    rti1516ev::AttributeHandle mgdWakeupTxIdleAttributeHandle;
    // attribute gListenNoise : HLAoctet
    rti1516ev::AttributeHandle mgListenNoiseAttributeHandle;
    // attribute gMacroPerCycle : HLAinteger32LE
    rti1516ev::AttributeHandle mgMacroPerCycleAttributeHandle;
    // attribute gMaxWithoutClockCorrectionFatal : HLAoctet
    rti1516ev::AttributeHandle mgMaxWithoutClockCorrectionFatalAttributeHandle;
    // attribute gMaxWithoutClockCorrectionPassive : HLAoctet
    rti1516ev::AttributeHandle mgMaxWithoutClockCorrectionPassiveAttributeHandle;
    // attribute gNumberOfMiniSlots : HLAinteger32LE
    rti1516ev::AttributeHandle mgNumberOfMiniSlotsAttributeHandle;
    // attribute gNumberOfStaticSlots : HLAinteger32LE
    rti1516ev::AttributeHandle mgNumberOfStaticSlotsAttributeHandle;
    // attribute gPayloadLengthStatic : HLAinteger32LE
    rti1516ev::AttributeHandle mgPayloadLengthStaticAttributeHandle;
    // attribute gSyncFrameIDCountMax : HLAoctet
    rti1516ev::AttributeHandle mgSyncFrameIDCountMaxAttributeHandle;
    // this mutex guards the data structures below
    mutable std::recursive_mutex mMutex;
    std::map<std::wstring, std::shared_ptr<IFlexRayCluster>> mObjectInstancesByName;
    std::map<rti1516ev::ObjectInstanceHandle, std::shared_ptr<IFlexRayCluster>> mObjectInstancesByHandle;

    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, DiscoverObjectInstanceCallback> mDiscoverCallbacks;
    uint32_t mLastDiscoverObjectInstanceCallbackToken = 0;
    std::map<uint32_t, RemoveObjectInstanceCallback> mRemoveObjectInstanceCallbacks;
    uint32_t mLastRemoveObjectInstanceCallbackToken = 0;
};

class FlexRayCluster : public IFlexRayCluster
{
  public:

    virtual ~FlexRayCluster();
    FlexRayCluster(const FlexRayCluster&) = delete;
    FlexRayCluster(FlexRayCluster&&) = delete;
    FlexRayCluster& operator=(const FlexRayCluster&) = delete;
    FlexRayCluster& operator=(FlexRayCluster&&) = delete;
    IFlexRayClusterObjectClass* GetObjectClass() const { return mObjectClass; }
    ObjectClassRegistry* GetObjectClassRegistry() const { return mObjectClass->GetObjectClassRegistry(); }
    std::wstring GetObjectInstanceName() const override { return mObjectInstanceName; }
    rti1516ev::ObjectInstanceHandle GetObjectInstanceHandle() const { return mObjectInstanceHandle; }
    bool IsValid() const override;
    bool IsOwner() const override;
    void Release() override;
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute NetworkID : HLAASCIIstring
    std::string GetNetworkID() const override;
    void SetNetworkID(std::string newValue) override;
    // attribute gColdstartAttempts : HLAoctet
    uint8_t GetgColdstartAttempts() const override;
    void SetgColdstartAttempts(uint8_t newValue) override;
    // attribute gCycleCountMax : HLAoctet
    uint8_t GetgCycleCountMax() const override;
    void SetgCycleCountMax(uint8_t newValue) override;
    // attribute gdActionPointOffset : HLAinteger32LE
    int32_t GetgdActionPointOffset() const override;
    void SetgdActionPointOffset(int32_t newValue) override;
    // attribute gdDynamicSlotIdlePhase : HLAinteger32LE
    int32_t GetgdDynamicSlotIdlePhase() const override;
    void SetgdDynamicSlotIdlePhase(int32_t newValue) override;
    // attribute gdMiniSlot : HLAinteger32LE
    int32_t GetgdMiniSlot() const override;
    void SetgdMiniSlot(int32_t newValue) override;
    // attribute gdMiniSlotActionPointOffset : HLAinteger32LE
    int32_t GetgdMiniSlotActionPointOffset() const override;
    void SetgdMiniSlotActionPointOffset(int32_t newValue) override;
    // attribute gdStaticSlot : HLAinteger32LE
    int32_t GetgdStaticSlot() const override;
    void SetgdStaticSlot(int32_t newValue) override;
    // attribute gdSymbolWindow : HLAinteger32LE
    int32_t GetgdSymbolWindow() const override;
    void SetgdSymbolWindow(int32_t newValue) override;
    // attribute gdSymbolWindowActionPointOffset : HLAinteger32LE
    int32_t GetgdSymbolWindowActionPointOffset() const override;
    void SetgdSymbolWindowActionPointOffset(int32_t newValue) override;
    // attribute gdTSSTransmitter : HLAinteger32LE
    int32_t GetgdTSSTransmitter() const override;
    void SetgdTSSTransmitter(int32_t newValue) override;
    // attribute gdWakeupTxActive : HLAinteger32LE
    int32_t GetgdWakeupTxActive() const override;
    void SetgdWakeupTxActive(int32_t newValue) override;
    // attribute gdWakeupTxIdle : HLAinteger32LE
    int32_t GetgdWakeupTxIdle() const override;
    void SetgdWakeupTxIdle(int32_t newValue) override;
    // attribute gListenNoise : HLAoctet
    uint8_t GetgListenNoise() const override;
    void SetgListenNoise(uint8_t newValue) override;
    // attribute gMacroPerCycle : HLAinteger32LE
    int32_t GetgMacroPerCycle() const override;
    void SetgMacroPerCycle(int32_t newValue) override;
    // attribute gMaxWithoutClockCorrectionFatal : HLAoctet
    uint8_t GetgMaxWithoutClockCorrectionFatal() const override;
    void SetgMaxWithoutClockCorrectionFatal(uint8_t newValue) override;
    // attribute gMaxWithoutClockCorrectionPassive : HLAoctet
    uint8_t GetgMaxWithoutClockCorrectionPassive() const override;
    void SetgMaxWithoutClockCorrectionPassive(uint8_t newValue) override;
    // attribute gNumberOfMiniSlots : HLAinteger32LE
    int32_t GetgNumberOfMiniSlots() const override;
    void SetgNumberOfMiniSlots(int32_t newValue) override;
    // attribute gNumberOfStaticSlots : HLAinteger32LE
    int32_t GetgNumberOfStaticSlots() const override;
    void SetgNumberOfStaticSlots(int32_t newValue) override;
    // attribute gPayloadLengthStatic : HLAinteger32LE
    int32_t GetgPayloadLengthStatic() const override;
    void SetgPayloadLengthStatic(int32_t newValue) override;
    // attribute gSyncFrameIDCountMax : HLAoctet
    uint8_t GetgSyncFrameIDCountMax() const override;
    void SetgSyncFrameIDCountMax(uint8_t newValue) override;
    // IFlexRayCluster
    void UpdateAllAttributeValues() override;
    void UpdateAllAttributeValues(int64_t time) override;
    void UpdateModifiedAttributeValues() override;
    void UpdateModifiedAttributeValues(int64_t time) override;
    void RequestAttributeValues() override;
    void RequestAllAttributeValues() override;
    uint32_t RegisterUpdateCallback(UpdateCallback callback) override;
    void UnregisterUpdateCallback(uint32_t callbackToken) override;

    // bitmask of attributes ever received
    AttributeBits GetReceivedAttributes() const override;
    // bitmask of attributes received in last update (cleared after update callbacks executed)
    AttributeBits GetUpdatedAttributes() const override;
    // bitmask of attributes ever modified
    AttributeBits GetInitializedAttributes() const override;
    // bitmask of attributes modified since last updateAttributeValues/provideAttributeValues
    AttributeBits GetModifiedAttributes() const override;
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes);
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType);
    void ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributes, optional<int64_t> time);
  protected:
    friend class FlexRayClusterObjectClass;

    FlexRayCluster();
    FlexRayCluster(FlexRayClusterObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* ambassador);

    void ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType);

    // get attribute handle/value map of all attributes
    rti1516ev::AttributeHandleValueMap GetAllAttributeValues() const;
    // get attribute handle/value map of attributes which have been modified since last call to UpdateModifiedAttributeValues
    rti1516ev::AttributeHandleValueMap GetModifiedAttributeValues() const;

    rti1516ev::RTIambassador* mRtiAmbassador;
    // this mutex guards all of the fields below
    mutable std::recursive_mutex mMutex;

    FlexRayClusterObjectClass* mObjectClass;
    std::wstring mObjectInstanceName;
    rti1516ev::ObjectInstanceHandle mObjectInstanceHandle;
    bool mIsOwner = false;
    // modified by any ReflectAttributeValues in the past
    AttributeBits mValuesReceived = kNone;
    // modified by any attribute setter
    AttributeBits mValuesSet = kNone;
    // modified by last ReflectAttributeValues
    AttributeBits mLastUpdated = kNone;
    // to be sent with next UpdateModifiedAttributeValues
    AttributeBits mDirty = kNone;
    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, UpdateCallback> mUpdateCallbacks;
    uint32_t mLastCallbackToken = 0;
    // Attribute value encoders
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute NetworkID : HLAASCIIstring
    rti1516ev::HLAASCIIstring mNetworkID;
    // attribute gColdstartAttempts : HLAoctet
    rti1516ev::HLAoctet mgColdstartAttempts;
    // attribute gCycleCountMax : HLAoctet
    rti1516ev::HLAoctet mgCycleCountMax;
    // attribute gdActionPointOffset : HLAinteger32LE
    rti1516ev::HLAinteger32LE mgdActionPointOffset;
    // attribute gdDynamicSlotIdlePhase : HLAinteger32LE
    rti1516ev::HLAinteger32LE mgdDynamicSlotIdlePhase;
    // attribute gdMiniSlot : HLAinteger32LE
    rti1516ev::HLAinteger32LE mgdMiniSlot;
    // attribute gdMiniSlotActionPointOffset : HLAinteger32LE
    rti1516ev::HLAinteger32LE mgdMiniSlotActionPointOffset;
    // attribute gdStaticSlot : HLAinteger32LE
    rti1516ev::HLAinteger32LE mgdStaticSlot;
    // attribute gdSymbolWindow : HLAinteger32LE
    rti1516ev::HLAinteger32LE mgdSymbolWindow;
    // attribute gdSymbolWindowActionPointOffset : HLAinteger32LE
    rti1516ev::HLAinteger32LE mgdSymbolWindowActionPointOffset;
    // attribute gdTSSTransmitter : HLAinteger32LE
    rti1516ev::HLAinteger32LE mgdTSSTransmitter;
    // attribute gdWakeupTxActive : HLAinteger32LE
    rti1516ev::HLAinteger32LE mgdWakeupTxActive;
    // attribute gdWakeupTxIdle : HLAinteger32LE
    rti1516ev::HLAinteger32LE mgdWakeupTxIdle;
    // attribute gListenNoise : HLAoctet
    rti1516ev::HLAoctet mgListenNoise;
    // attribute gMacroPerCycle : HLAinteger32LE
    rti1516ev::HLAinteger32LE mgMacroPerCycle;
    // attribute gMaxWithoutClockCorrectionFatal : HLAoctet
    rti1516ev::HLAoctet mgMaxWithoutClockCorrectionFatal;
    // attribute gMaxWithoutClockCorrectionPassive : HLAoctet
    rti1516ev::HLAoctet mgMaxWithoutClockCorrectionPassive;
    // attribute gNumberOfMiniSlots : HLAinteger32LE
    rti1516ev::HLAinteger32LE mgNumberOfMiniSlots;
    // attribute gNumberOfStaticSlots : HLAinteger32LE
    rti1516ev::HLAinteger32LE mgNumberOfStaticSlots;
    // attribute gPayloadLengthStatic : HLAinteger32LE
    rti1516ev::HLAinteger32LE mgPayloadLengthStatic;
    // attribute gSyncFrameIDCountMax : HLAoctet
    rti1516ev::HLAoctet mgSyncFrameIDCountMax;
};

class BusController;
class BusControllerObjectClass : public IBusControllerObjectClass
{
  public:
    // IBusControllerObjectClass
    BusControllerObjectClass() = default;
    virtual ~BusControllerObjectClass();
    void Publish() override;
    void Unpublish() override;
    void Subscribe(bool deliverToSelf) override;
    void Unsubscribe() override;
    std::shared_ptr<IBusController> GetObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IBusController> CreateObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IBusController> CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback) override;
    uint32_t RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback) override;
    void UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IBusController> newObjectInstance);

    uint32_t RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback) override;
    void UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IBusController> newObjectInstance);
    // Set a user-defined creator function, which returns subclasses of BusController
    using ObjectInstanceCreatorFunction = std::function<BusController*(BusControllerObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)>;
    // When using custom object instance classes, don't forget to set the creator function *before* subscribing to the object class.
    void SetObjectInstanceCreator(ObjectInstanceCreatorFunction creatorFunction) { mCreatorFunction = creatorFunction; }
    // internal
    BusControllerObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, HLAobjectRootObjectClass* baseClass);

    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute NetworkID : HLAASCIIstring
    rti1516ev::AttributeHandle GetNetworkIDAttributeHandle() const { return mNetworkIDAttributeHandle; }
    // attribute DeviceID : HLAASCIIstring
    rti1516ev::AttributeHandle GetDeviceIDAttributeHandle() const { return mDeviceIDAttributeHandle; }
    void DiscoverObjectInstance (rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    rti1516ev::ObjectClassHandle GetObjectClassHandle() const { return mObjectClassHandle; }
    std::shared_ptr<IBusController> GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle);
    rti1516ev::AttributeHandleSet GetAllAttributeHandles();
    ObjectClassRegistry* GetObjectClassRegistry() const { return mRegistry; }

    // add object instance to maps (and to maps of base classes)
    void InsertObjectInstanceName(std::shared_ptr<IBusController> objectInstance, const std::wstring& objectInstanceName);
    void InsertObjectInstanceHandle(std::shared_ptr<IBusController> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle);
    // remove object instance from maps (and from maps of base classes)
    void EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName);
  private:
    ObjectClassRegistry* mRegistry;
    rti1516ev::RTIambassador* mRtiAmbassador;
    // object class handle
    rti1516ev::ObjectClassHandle mObjectClassHandle;
    HLAobjectRootObjectClass* mBaseClass;
    ObjectInstanceCreatorFunction mCreatorFunction;
    bool mPublished = false;
    bool mSubscribed = false;
    // Attribute handles
    // attribute NetworkID : HLAASCIIstring
    rti1516ev::AttributeHandle mNetworkIDAttributeHandle;
    // attribute DeviceID : HLAASCIIstring
    rti1516ev::AttributeHandle mDeviceIDAttributeHandle;
    // this mutex guards the data structures below
    mutable std::recursive_mutex mMutex;
    std::map<std::wstring, std::shared_ptr<IBusController>> mObjectInstancesByName;
    std::map<rti1516ev::ObjectInstanceHandle, std::shared_ptr<IBusController>> mObjectInstancesByHandle;

    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, DiscoverObjectInstanceCallback> mDiscoverCallbacks;
    uint32_t mLastDiscoverObjectInstanceCallbackToken = 0;
    std::map<uint32_t, RemoveObjectInstanceCallback> mRemoveObjectInstanceCallbacks;
    uint32_t mLastRemoveObjectInstanceCallbackToken = 0;
};

class BusController : public IBusController
{
  public:

    virtual ~BusController();
    BusController(const BusController&) = delete;
    BusController(BusController&&) = delete;
    BusController& operator=(const BusController&) = delete;
    BusController& operator=(BusController&&) = delete;
    IBusControllerObjectClass* GetObjectClass() const { return mObjectClass; }
    ObjectClassRegistry* GetObjectClassRegistry() const { return mObjectClass->GetObjectClassRegistry(); }
    std::wstring GetObjectInstanceName() const override { return mObjectInstanceName; }
    rti1516ev::ObjectInstanceHandle GetObjectInstanceHandle() const { return mObjectInstanceHandle; }
    bool IsValid() const override;
    bool IsOwner() const override;
    void Release() override;
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute NetworkID : HLAASCIIstring
    std::string GetNetworkID() const override;
    void SetNetworkID(std::string newValue) override;
    // attribute DeviceID : HLAASCIIstring
    std::string GetDeviceID() const override;
    void SetDeviceID(std::string newValue) override;
    // IBusController
    void UpdateAllAttributeValues() override;
    void UpdateAllAttributeValues(int64_t time) override;
    void UpdateModifiedAttributeValues() override;
    void UpdateModifiedAttributeValues(int64_t time) override;
    void RequestAttributeValues() override;
    void RequestAllAttributeValues() override;

    // bitmask of attributes ever received
    AttributeBits GetReceivedAttributes() const override;
    // bitmask of attributes received in last update (cleared after update callbacks executed)
    AttributeBits GetUpdatedAttributes() const override;
    // bitmask of attributes ever modified
    AttributeBits GetInitializedAttributes() const override;
    // bitmask of attributes modified since last updateAttributeValues/provideAttributeValues
    AttributeBits GetModifiedAttributes() const override;
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes);
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType);
    void ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributes, optional<int64_t> time);
  protected:
    friend class BusControllerObjectClass;

    BusController();
    BusController(BusControllerObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* ambassador);


    // get attribute handle/value map of all attributes
    rti1516ev::AttributeHandleValueMap GetAllAttributeValues() const;
    // get attribute handle/value map of attributes which have been modified since last call to UpdateModifiedAttributeValues
    rti1516ev::AttributeHandleValueMap GetModifiedAttributeValues() const;

    rti1516ev::RTIambassador* mRtiAmbassador;
    // this mutex guards all of the fields below
    mutable std::recursive_mutex mMutex;

    BusControllerObjectClass* mObjectClass;
    std::wstring mObjectInstanceName;
    rti1516ev::ObjectInstanceHandle mObjectInstanceHandle;
    bool mIsOwner = false;
    // modified by any ReflectAttributeValues in the past
    AttributeBits mValuesReceived = kNone;
    // modified by any attribute setter
    AttributeBits mValuesSet = kNone;
    // modified by last ReflectAttributeValues
    AttributeBits mLastUpdated = kNone;
    // to be sent with next UpdateModifiedAttributeValues
    AttributeBits mDirty = kNone;
    // Attribute value encoders
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute NetworkID : HLAASCIIstring
    rti1516ev::HLAASCIIstring mNetworkID;
    // attribute DeviceID : HLAASCIIstring
    rti1516ev::HLAASCIIstring mDeviceID;
};

class BusControllerCan;
class BusControllerCanObjectClass : public IBusControllerCanObjectClass
{
  public:
    // IBusControllerCanObjectClass
    BusControllerCanObjectClass() = default;
    virtual ~BusControllerCanObjectClass();
    void Publish() override;
    void Unpublish() override;
    void Subscribe(bool deliverToSelf) override;
    void Unsubscribe() override;
    std::shared_ptr<IBusControllerCan> GetObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IBusControllerCan> CreateObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IBusControllerCan> CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback) override;
    uint32_t RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback) override;
    void UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IBusControllerCan> newObjectInstance);

    uint32_t RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback) override;
    void UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IBusControllerCan> newObjectInstance);
    // Set a user-defined creator function, which returns subclasses of BusControllerCan
    using ObjectInstanceCreatorFunction = std::function<BusControllerCan*(BusControllerCanObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)>;
    // When using custom object instance classes, don't forget to set the creator function *before* subscribing to the object class.
    void SetObjectInstanceCreator(ObjectInstanceCreatorFunction creatorFunction) { mCreatorFunction = creatorFunction; }
    // internal
    BusControllerCanObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, BusControllerObjectClass* baseClass);

    // attribute NetworkID : HLAASCIIstring
    rti1516ev::AttributeHandle GetNetworkIDAttributeHandle() const { return mBaseClass->GetNetworkIDAttributeHandle(); }
    // attribute DeviceID : HLAASCIIstring
    rti1516ev::AttributeHandle GetDeviceIDAttributeHandle() const { return mBaseClass->GetDeviceIDAttributeHandle(); }
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute BaudRate : HLAinteger32LE
    rti1516ev::AttributeHandle GetBaudRateAttributeHandle() const { return mBaudRateAttributeHandle; }
    // attribute DataBaudRate : HLAinteger32LE
    rti1516ev::AttributeHandle GetDataBaudRateAttributeHandle() const { return mDataBaudRateAttributeHandle; }
    // attribute PreScaler : HLAinteger32LE
    rti1516ev::AttributeHandle GetPreScalerAttributeHandle() const { return mPreScalerAttributeHandle; }
    // attribute OperationMode : CanOperationMode
    rti1516ev::AttributeHandle GetOperationModeAttributeHandle() const { return mOperationModeAttributeHandle; }
    // attribute Sync_Seg : HLAinteger32LE
    rti1516ev::AttributeHandle GetSync_SegAttributeHandle() const { return mSync_SegAttributeHandle; }
    // attribute Prop_Seg : HLAinteger32LE
    rti1516ev::AttributeHandle GetProp_SegAttributeHandle() const { return mProp_SegAttributeHandle; }
    // attribute Phase_Seg1 : HLAinteger32LE
    rti1516ev::AttributeHandle GetPhase_Seg1AttributeHandle() const { return mPhase_Seg1AttributeHandle; }
    // attribute Phase_Seg2 : HLAinteger32LE
    rti1516ev::AttributeHandle GetPhase_Seg2AttributeHandle() const { return mPhase_Seg2AttributeHandle; }
    // attribute SamplingMode : CanSamplingMode
    rti1516ev::AttributeHandle GetSamplingModeAttributeHandle() const { return mSamplingModeAttributeHandle; }
    void DiscoverObjectInstance (rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    rti1516ev::ObjectClassHandle GetObjectClassHandle() const { return mObjectClassHandle; }
    std::shared_ptr<IBusControllerCan> GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle);
    rti1516ev::AttributeHandleSet GetAllAttributeHandles();
    ObjectClassRegistry* GetObjectClassRegistry() const { return mRegistry; }

    // add object instance to maps (and to maps of base classes)
    void InsertObjectInstanceName(std::shared_ptr<IBusControllerCan> objectInstance, const std::wstring& objectInstanceName);
    void InsertObjectInstanceHandle(std::shared_ptr<IBusControllerCan> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle);
    // remove object instance from maps (and from maps of base classes)
    void EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName);
  private:
    ObjectClassRegistry* mRegistry;
    rti1516ev::RTIambassador* mRtiAmbassador;
    // object class handle
    rti1516ev::ObjectClassHandle mObjectClassHandle;
    BusControllerObjectClass* mBaseClass;
    ObjectInstanceCreatorFunction mCreatorFunction;
    bool mPublished = false;
    bool mSubscribed = false;
    // Attribute handles
    // attribute BaudRate : HLAinteger32LE
    rti1516ev::AttributeHandle mBaudRateAttributeHandle;
    // attribute DataBaudRate : HLAinteger32LE
    rti1516ev::AttributeHandle mDataBaudRateAttributeHandle;
    // attribute PreScaler : HLAinteger32LE
    rti1516ev::AttributeHandle mPreScalerAttributeHandle;
    // attribute OperationMode : CanOperationMode
    rti1516ev::AttributeHandle mOperationModeAttributeHandle;
    // attribute Sync_Seg : HLAinteger32LE
    rti1516ev::AttributeHandle mSync_SegAttributeHandle;
    // attribute Prop_Seg : HLAinteger32LE
    rti1516ev::AttributeHandle mProp_SegAttributeHandle;
    // attribute Phase_Seg1 : HLAinteger32LE
    rti1516ev::AttributeHandle mPhase_Seg1AttributeHandle;
    // attribute Phase_Seg2 : HLAinteger32LE
    rti1516ev::AttributeHandle mPhase_Seg2AttributeHandle;
    // attribute SamplingMode : CanSamplingMode
    rti1516ev::AttributeHandle mSamplingModeAttributeHandle;
    // this mutex guards the data structures below
    mutable std::recursive_mutex mMutex;
    std::map<std::wstring, std::shared_ptr<IBusControllerCan>> mObjectInstancesByName;
    std::map<rti1516ev::ObjectInstanceHandle, std::shared_ptr<IBusControllerCan>> mObjectInstancesByHandle;

    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, DiscoverObjectInstanceCallback> mDiscoverCallbacks;
    uint32_t mLastDiscoverObjectInstanceCallbackToken = 0;
    std::map<uint32_t, RemoveObjectInstanceCallback> mRemoveObjectInstanceCallbacks;
    uint32_t mLastRemoveObjectInstanceCallbackToken = 0;
};

class BusControllerCan : public IBusControllerCan
{
  public:

    virtual ~BusControllerCan();
    BusControllerCan(const BusControllerCan&) = delete;
    BusControllerCan(BusControllerCan&&) = delete;
    BusControllerCan& operator=(const BusControllerCan&) = delete;
    BusControllerCan& operator=(BusControllerCan&&) = delete;
    IBusControllerCanObjectClass* GetObjectClass() const { return mObjectClass; }
    ObjectClassRegistry* GetObjectClassRegistry() const { return mObjectClass->GetObjectClassRegistry(); }
    std::wstring GetObjectInstanceName() const override { return mObjectInstanceName; }
    rti1516ev::ObjectInstanceHandle GetObjectInstanceHandle() const { return mObjectInstanceHandle; }
    bool IsValid() const override;
    bool IsOwner() const override;
    void Release() override;
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute NetworkID : HLAASCIIstring
    std::string GetNetworkID() const override;
    void SetNetworkID(std::string newValue) override;
    // attribute DeviceID : HLAASCIIstring
    std::string GetDeviceID() const override;
    void SetDeviceID(std::string newValue) override;
    // attribute BaudRate : HLAinteger32LE
    int32_t GetBaudRate() const override;
    void SetBaudRate(int32_t newValue) override;
    // attribute DataBaudRate : HLAinteger32LE
    int32_t GetDataBaudRate() const override;
    void SetDataBaudRate(int32_t newValue) override;
    // attribute PreScaler : HLAinteger32LE
    int32_t GetPreScaler() const override;
    void SetPreScaler(int32_t newValue) override;
    // attribute OperationMode : CanOperationMode
    CanOperationMode GetOperationMode() const override;
    void SetOperationMode(CanOperationMode newValue) override;
    // attribute Sync_Seg : HLAinteger32LE
    int32_t GetSync_Seg() const override;
    void SetSync_Seg(int32_t newValue) override;
    // attribute Prop_Seg : HLAinteger32LE
    int32_t GetProp_Seg() const override;
    void SetProp_Seg(int32_t newValue) override;
    // attribute Phase_Seg1 : HLAinteger32LE
    int32_t GetPhase_Seg1() const override;
    void SetPhase_Seg1(int32_t newValue) override;
    // attribute Phase_Seg2 : HLAinteger32LE
    int32_t GetPhase_Seg2() const override;
    void SetPhase_Seg2(int32_t newValue) override;
    // attribute SamplingMode : CanSamplingMode
    CanSamplingMode GetSamplingMode() const override;
    void SetSamplingMode(CanSamplingMode newValue) override;
    // IBusControllerCan
    void UpdateAllAttributeValues() override;
    void UpdateAllAttributeValues(int64_t time) override;
    void UpdateModifiedAttributeValues() override;
    void UpdateModifiedAttributeValues(int64_t time) override;
    void RequestAttributeValues() override;
    void RequestAllAttributeValues() override;
    uint32_t RegisterUpdateCallback(UpdateCallback callback) override;
    void UnregisterUpdateCallback(uint32_t callbackToken) override;

    // bitmask of attributes ever received
    AttributeBits GetReceivedAttributes() const override;
    // bitmask of attributes received in last update (cleared after update callbacks executed)
    AttributeBits GetUpdatedAttributes() const override;
    // bitmask of attributes ever modified
    AttributeBits GetInitializedAttributes() const override;
    // bitmask of attributes modified since last updateAttributeValues/provideAttributeValues
    AttributeBits GetModifiedAttributes() const override;
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes);
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType);
    void ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributes, optional<int64_t> time);
  protected:
    friend class BusControllerCanObjectClass;

    BusControllerCan();
    BusControllerCan(BusControllerCanObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* ambassador);

    void ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType);

    // get attribute handle/value map of all attributes
    rti1516ev::AttributeHandleValueMap GetAllAttributeValues() const;
    // get attribute handle/value map of attributes which have been modified since last call to UpdateModifiedAttributeValues
    rti1516ev::AttributeHandleValueMap GetModifiedAttributeValues() const;

    rti1516ev::RTIambassador* mRtiAmbassador;
    // this mutex guards all of the fields below
    mutable std::recursive_mutex mMutex;

    BusControllerCanObjectClass* mObjectClass;
    std::wstring mObjectInstanceName;
    rti1516ev::ObjectInstanceHandle mObjectInstanceHandle;
    bool mIsOwner = false;
    // modified by any ReflectAttributeValues in the past
    AttributeBits mValuesReceived = kNone;
    // modified by any attribute setter
    AttributeBits mValuesSet = kNone;
    // modified by last ReflectAttributeValues
    AttributeBits mLastUpdated = kNone;
    // to be sent with next UpdateModifiedAttributeValues
    AttributeBits mDirty = kNone;
    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, UpdateCallback> mUpdateCallbacks;
    uint32_t mLastCallbackToken = 0;
    // Attribute value encoders
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute NetworkID : HLAASCIIstring
    rti1516ev::HLAASCIIstring mNetworkID;
    // attribute DeviceID : HLAASCIIstring
    rti1516ev::HLAASCIIstring mDeviceID;
    // attribute BaudRate : HLAinteger32LE
    rti1516ev::HLAinteger32LE mBaudRate;
    // attribute DataBaudRate : HLAinteger32LE
    rti1516ev::HLAinteger32LE mDataBaudRate;
    // attribute PreScaler : HLAinteger32LE
    rti1516ev::HLAinteger32LE mPreScaler;
    // attribute OperationMode : CanOperationMode
    rti1516ev::HLAinteger32LE mOperationMode;
    // attribute Sync_Seg : HLAinteger32LE
    rti1516ev::HLAinteger32LE mSync_Seg;
    // attribute Prop_Seg : HLAinteger32LE
    rti1516ev::HLAinteger32LE mProp_Seg;
    // attribute Phase_Seg1 : HLAinteger32LE
    rti1516ev::HLAinteger32LE mPhase_Seg1;
    // attribute Phase_Seg2 : HLAinteger32LE
    rti1516ev::HLAinteger32LE mPhase_Seg2;
    // attribute SamplingMode : CanSamplingMode
    rti1516ev::HLAinteger32LE mSamplingMode;
};

class BusControllerEthernet;
class BusControllerEthernetObjectClass : public IBusControllerEthernetObjectClass
{
  public:
    // IBusControllerEthernetObjectClass
    BusControllerEthernetObjectClass() = default;
    virtual ~BusControllerEthernetObjectClass();
    void Publish() override;
    void Unpublish() override;
    void Subscribe(bool deliverToSelf) override;
    void Unsubscribe() override;
    std::shared_ptr<IBusControllerEthernet> GetObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IBusControllerEthernet> CreateObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IBusControllerEthernet> CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback) override;
    uint32_t RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback) override;
    void UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IBusControllerEthernet> newObjectInstance);

    uint32_t RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback) override;
    void UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IBusControllerEthernet> newObjectInstance);
    // Set a user-defined creator function, which returns subclasses of BusControllerEthernet
    using ObjectInstanceCreatorFunction = std::function<BusControllerEthernet*(BusControllerEthernetObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)>;
    // When using custom object instance classes, don't forget to set the creator function *before* subscribing to the object class.
    void SetObjectInstanceCreator(ObjectInstanceCreatorFunction creatorFunction) { mCreatorFunction = creatorFunction; }
    // internal
    BusControllerEthernetObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, BusControllerObjectClass* baseClass);

    // attribute NetworkID : HLAASCIIstring
    rti1516ev::AttributeHandle GetNetworkIDAttributeHandle() const { return mBaseClass->GetNetworkIDAttributeHandle(); }
    // attribute DeviceID : HLAASCIIstring
    rti1516ev::AttributeHandle GetDeviceIDAttributeHandle() const { return mBaseClass->GetDeviceIDAttributeHandle(); }
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute PortName : HLAASCIIstring
    rti1516ev::AttributeHandle GetPortNameAttributeHandle() const { return mPortNameAttributeHandle; }
    void DiscoverObjectInstance (rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    rti1516ev::ObjectClassHandle GetObjectClassHandle() const { return mObjectClassHandle; }
    std::shared_ptr<IBusControllerEthernet> GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle);
    rti1516ev::AttributeHandleSet GetAllAttributeHandles();
    ObjectClassRegistry* GetObjectClassRegistry() const { return mRegistry; }

    // add object instance to maps (and to maps of base classes)
    void InsertObjectInstanceName(std::shared_ptr<IBusControllerEthernet> objectInstance, const std::wstring& objectInstanceName);
    void InsertObjectInstanceHandle(std::shared_ptr<IBusControllerEthernet> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle);
    // remove object instance from maps (and from maps of base classes)
    void EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName);
  private:
    ObjectClassRegistry* mRegistry;
    rti1516ev::RTIambassador* mRtiAmbassador;
    // object class handle
    rti1516ev::ObjectClassHandle mObjectClassHandle;
    BusControllerObjectClass* mBaseClass;
    ObjectInstanceCreatorFunction mCreatorFunction;
    bool mPublished = false;
    bool mSubscribed = false;
    // Attribute handles
    // attribute PortName : HLAASCIIstring
    rti1516ev::AttributeHandle mPortNameAttributeHandle;
    // this mutex guards the data structures below
    mutable std::recursive_mutex mMutex;
    std::map<std::wstring, std::shared_ptr<IBusControllerEthernet>> mObjectInstancesByName;
    std::map<rti1516ev::ObjectInstanceHandle, std::shared_ptr<IBusControllerEthernet>> mObjectInstancesByHandle;

    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, DiscoverObjectInstanceCallback> mDiscoverCallbacks;
    uint32_t mLastDiscoverObjectInstanceCallbackToken = 0;
    std::map<uint32_t, RemoveObjectInstanceCallback> mRemoveObjectInstanceCallbacks;
    uint32_t mLastRemoveObjectInstanceCallbackToken = 0;
};

class BusControllerEthernet : public IBusControllerEthernet
{
  public:

    virtual ~BusControllerEthernet();
    BusControllerEthernet(const BusControllerEthernet&) = delete;
    BusControllerEthernet(BusControllerEthernet&&) = delete;
    BusControllerEthernet& operator=(const BusControllerEthernet&) = delete;
    BusControllerEthernet& operator=(BusControllerEthernet&&) = delete;
    IBusControllerEthernetObjectClass* GetObjectClass() const { return mObjectClass; }
    ObjectClassRegistry* GetObjectClassRegistry() const { return mObjectClass->GetObjectClassRegistry(); }
    std::wstring GetObjectInstanceName() const override { return mObjectInstanceName; }
    rti1516ev::ObjectInstanceHandle GetObjectInstanceHandle() const { return mObjectInstanceHandle; }
    bool IsValid() const override;
    bool IsOwner() const override;
    void Release() override;
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute NetworkID : HLAASCIIstring
    std::string GetNetworkID() const override;
    void SetNetworkID(std::string newValue) override;
    // attribute DeviceID : HLAASCIIstring
    std::string GetDeviceID() const override;
    void SetDeviceID(std::string newValue) override;
    // attribute PortName : HLAASCIIstring
    std::string GetPortName() const override;
    void SetPortName(std::string newValue) override;
    // IBusControllerEthernet
    void UpdateAllAttributeValues() override;
    void UpdateAllAttributeValues(int64_t time) override;
    void UpdateModifiedAttributeValues() override;
    void UpdateModifiedAttributeValues(int64_t time) override;
    void RequestAttributeValues() override;
    void RequestAllAttributeValues() override;
    uint32_t RegisterUpdateCallback(UpdateCallback callback) override;
    void UnregisterUpdateCallback(uint32_t callbackToken) override;

    // bitmask of attributes ever received
    AttributeBits GetReceivedAttributes() const override;
    // bitmask of attributes received in last update (cleared after update callbacks executed)
    AttributeBits GetUpdatedAttributes() const override;
    // bitmask of attributes ever modified
    AttributeBits GetInitializedAttributes() const override;
    // bitmask of attributes modified since last updateAttributeValues/provideAttributeValues
    AttributeBits GetModifiedAttributes() const override;
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes);
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType);
    void ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributes, optional<int64_t> time);
  protected:
    friend class BusControllerEthernetObjectClass;

    BusControllerEthernet();
    BusControllerEthernet(BusControllerEthernetObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* ambassador);

    void ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType);

    // get attribute handle/value map of all attributes
    rti1516ev::AttributeHandleValueMap GetAllAttributeValues() const;
    // get attribute handle/value map of attributes which have been modified since last call to UpdateModifiedAttributeValues
    rti1516ev::AttributeHandleValueMap GetModifiedAttributeValues() const;

    rti1516ev::RTIambassador* mRtiAmbassador;
    // this mutex guards all of the fields below
    mutable std::recursive_mutex mMutex;

    BusControllerEthernetObjectClass* mObjectClass;
    std::wstring mObjectInstanceName;
    rti1516ev::ObjectInstanceHandle mObjectInstanceHandle;
    bool mIsOwner = false;
    // modified by any ReflectAttributeValues in the past
    AttributeBits mValuesReceived = kNone;
    // modified by any attribute setter
    AttributeBits mValuesSet = kNone;
    // modified by last ReflectAttributeValues
    AttributeBits mLastUpdated = kNone;
    // to be sent with next UpdateModifiedAttributeValues
    AttributeBits mDirty = kNone;
    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, UpdateCallback> mUpdateCallbacks;
    uint32_t mLastCallbackToken = 0;
    // Attribute value encoders
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute NetworkID : HLAASCIIstring
    rti1516ev::HLAASCIIstring mNetworkID;
    // attribute DeviceID : HLAASCIIstring
    rti1516ev::HLAASCIIstring mDeviceID;
    // attribute PortName : HLAASCIIstring
    rti1516ev::HLAASCIIstring mPortName;
};

class FlexRayControllerStatus;
class FlexRayControllerStatusObjectClass : public IFlexRayControllerStatusObjectClass
{
  public:
    // IFlexRayControllerStatusObjectClass
    FlexRayControllerStatusObjectClass() = default;
    virtual ~FlexRayControllerStatusObjectClass();
    void Publish() override;
    void Unpublish() override;
    void Subscribe(bool deliverToSelf) override;
    void Unsubscribe() override;
    std::shared_ptr<IFlexRayControllerStatus> GetObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IFlexRayControllerStatus> CreateObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IFlexRayControllerStatus> CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback) override;
    uint32_t RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback) override;
    void UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IFlexRayControllerStatus> newObjectInstance);

    uint32_t RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback) override;
    void UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IFlexRayControllerStatus> newObjectInstance);
    // Set a user-defined creator function, which returns subclasses of FlexRayControllerStatus
    using ObjectInstanceCreatorFunction = std::function<FlexRayControllerStatus*(FlexRayControllerStatusObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)>;
    // When using custom object instance classes, don't forget to set the creator function *before* subscribing to the object class.
    void SetObjectInstanceCreator(ObjectInstanceCreatorFunction creatorFunction) { mCreatorFunction = creatorFunction; }
    // internal
    FlexRayControllerStatusObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, BusControllerObjectClass* baseClass);

    // attribute NetworkID : HLAASCIIstring
    rti1516ev::AttributeHandle GetNetworkIDAttributeHandle() const { return mBaseClass->GetNetworkIDAttributeHandle(); }
    // attribute DeviceID : HLAASCIIstring
    rti1516ev::AttributeHandle GetDeviceIDAttributeHandle() const { return mBaseClass->GetDeviceIDAttributeHandle(); }
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute PocState : FlexRayPocState
    rti1516ev::AttributeHandle GetPocStateAttributeHandle() const { return mPocStateAttributeHandle; }
    // attribute chiHaltRequest : HLAboolean
    rti1516ev::AttributeHandle GetchiHaltRequestAttributeHandle() const { return mchiHaltRequestAttributeHandle; }
    // attribute coldstartNoise : HLAboolean
    rti1516ev::AttributeHandle GetcoldstartNoiseAttributeHandle() const { return mcoldstartNoiseAttributeHandle; }
    // attribute freeze : HLAboolean
    rti1516ev::AttributeHandle GetfreezeAttributeHandle() const { return mfreezeAttributeHandle; }
    // attribute chiReadyRequest : HLAboolean
    rti1516ev::AttributeHandle GetchiReadyRequestAttributeHandle() const { return mchiReadyRequestAttributeHandle; }
    // attribute errorMode : FlexRayErrorModeType
    rti1516ev::AttributeHandle GeterrorModeAttributeHandle() const { return merrorModeAttributeHandle; }
    // attribute slotMode : FlexRaySlotModeType
    rti1516ev::AttributeHandle GetslotModeAttributeHandle() const { return mslotModeAttributeHandle; }
    // attribute startupState : FlexRayStartupStateType
    rti1516ev::AttributeHandle GetstartupStateAttributeHandle() const { return mstartupStateAttributeHandle; }
    // attribute wakeupStatus : FlexRayWakeupStatusType
    rti1516ev::AttributeHandle GetwakeupStatusAttributeHandle() const { return mwakeupStatusAttributeHandle; }
    void DiscoverObjectInstance (rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    rti1516ev::ObjectClassHandle GetObjectClassHandle() const { return mObjectClassHandle; }
    std::shared_ptr<IFlexRayControllerStatus> GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle);
    rti1516ev::AttributeHandleSet GetAllAttributeHandles();
    ObjectClassRegistry* GetObjectClassRegistry() const { return mRegistry; }

    // add object instance to maps (and to maps of base classes)
    void InsertObjectInstanceName(std::shared_ptr<IFlexRayControllerStatus> objectInstance, const std::wstring& objectInstanceName);
    void InsertObjectInstanceHandle(std::shared_ptr<IFlexRayControllerStatus> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle);
    // remove object instance from maps (and from maps of base classes)
    void EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName);
  private:
    ObjectClassRegistry* mRegistry;
    rti1516ev::RTIambassador* mRtiAmbassador;
    // object class handle
    rti1516ev::ObjectClassHandle mObjectClassHandle;
    BusControllerObjectClass* mBaseClass;
    ObjectInstanceCreatorFunction mCreatorFunction;
    bool mPublished = false;
    bool mSubscribed = false;
    // Attribute handles
    // attribute PocState : FlexRayPocState
    rti1516ev::AttributeHandle mPocStateAttributeHandle;
    // attribute chiHaltRequest : HLAboolean
    rti1516ev::AttributeHandle mchiHaltRequestAttributeHandle;
    // attribute coldstartNoise : HLAboolean
    rti1516ev::AttributeHandle mcoldstartNoiseAttributeHandle;
    // attribute freeze : HLAboolean
    rti1516ev::AttributeHandle mfreezeAttributeHandle;
    // attribute chiReadyRequest : HLAboolean
    rti1516ev::AttributeHandle mchiReadyRequestAttributeHandle;
    // attribute errorMode : FlexRayErrorModeType
    rti1516ev::AttributeHandle merrorModeAttributeHandle;
    // attribute slotMode : FlexRaySlotModeType
    rti1516ev::AttributeHandle mslotModeAttributeHandle;
    // attribute startupState : FlexRayStartupStateType
    rti1516ev::AttributeHandle mstartupStateAttributeHandle;
    // attribute wakeupStatus : FlexRayWakeupStatusType
    rti1516ev::AttributeHandle mwakeupStatusAttributeHandle;
    // this mutex guards the data structures below
    mutable std::recursive_mutex mMutex;
    std::map<std::wstring, std::shared_ptr<IFlexRayControllerStatus>> mObjectInstancesByName;
    std::map<rti1516ev::ObjectInstanceHandle, std::shared_ptr<IFlexRayControllerStatus>> mObjectInstancesByHandle;

    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, DiscoverObjectInstanceCallback> mDiscoverCallbacks;
    uint32_t mLastDiscoverObjectInstanceCallbackToken = 0;
    std::map<uint32_t, RemoveObjectInstanceCallback> mRemoveObjectInstanceCallbacks;
    uint32_t mLastRemoveObjectInstanceCallbackToken = 0;
};

class FlexRayControllerStatus : public IFlexRayControllerStatus
{
  public:

    virtual ~FlexRayControllerStatus();
    FlexRayControllerStatus(const FlexRayControllerStatus&) = delete;
    FlexRayControllerStatus(FlexRayControllerStatus&&) = delete;
    FlexRayControllerStatus& operator=(const FlexRayControllerStatus&) = delete;
    FlexRayControllerStatus& operator=(FlexRayControllerStatus&&) = delete;
    IFlexRayControllerStatusObjectClass* GetObjectClass() const { return mObjectClass; }
    ObjectClassRegistry* GetObjectClassRegistry() const { return mObjectClass->GetObjectClassRegistry(); }
    std::wstring GetObjectInstanceName() const override { return mObjectInstanceName; }
    rti1516ev::ObjectInstanceHandle GetObjectInstanceHandle() const { return mObjectInstanceHandle; }
    bool IsValid() const override;
    bool IsOwner() const override;
    void Release() override;
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute NetworkID : HLAASCIIstring
    std::string GetNetworkID() const override;
    void SetNetworkID(std::string newValue) override;
    // attribute DeviceID : HLAASCIIstring
    std::string GetDeviceID() const override;
    void SetDeviceID(std::string newValue) override;
    // attribute PocState : FlexRayPocState
    FlexRayPocState GetPocState() const override;
    void SetPocState(FlexRayPocState newValue) override;
    // attribute chiHaltRequest : HLAboolean
    bool GetchiHaltRequest() const override;
    void SetchiHaltRequest(bool newValue) override;
    // attribute coldstartNoise : HLAboolean
    bool GetcoldstartNoise() const override;
    void SetcoldstartNoise(bool newValue) override;
    // attribute freeze : HLAboolean
    bool Getfreeze() const override;
    void Setfreeze(bool newValue) override;
    // attribute chiReadyRequest : HLAboolean
    bool GetchiReadyRequest() const override;
    void SetchiReadyRequest(bool newValue) override;
    // attribute errorMode : FlexRayErrorModeType
    FlexRayErrorModeType GeterrorMode() const override;
    void SeterrorMode(FlexRayErrorModeType newValue) override;
    // attribute slotMode : FlexRaySlotModeType
    FlexRaySlotModeType GetslotMode() const override;
    void SetslotMode(FlexRaySlotModeType newValue) override;
    // attribute startupState : FlexRayStartupStateType
    FlexRayStartupStateType GetstartupState() const override;
    void SetstartupState(FlexRayStartupStateType newValue) override;
    // attribute wakeupStatus : FlexRayWakeupStatusType
    FlexRayWakeupStatusType GetwakeupStatus() const override;
    void SetwakeupStatus(FlexRayWakeupStatusType newValue) override;
    // IFlexRayControllerStatus
    void UpdateAllAttributeValues() override;
    void UpdateAllAttributeValues(int64_t time) override;
    void UpdateModifiedAttributeValues() override;
    void UpdateModifiedAttributeValues(int64_t time) override;
    void RequestAttributeValues() override;
    void RequestAllAttributeValues() override;
    uint32_t RegisterUpdateCallback(UpdateCallback callback) override;
    void UnregisterUpdateCallback(uint32_t callbackToken) override;

    // bitmask of attributes ever received
    AttributeBits GetReceivedAttributes() const override;
    // bitmask of attributes received in last update (cleared after update callbacks executed)
    AttributeBits GetUpdatedAttributes() const override;
    // bitmask of attributes ever modified
    AttributeBits GetInitializedAttributes() const override;
    // bitmask of attributes modified since last updateAttributeValues/provideAttributeValues
    AttributeBits GetModifiedAttributes() const override;
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes);
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType);
    void ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributes, optional<int64_t> time);
  protected:
    friend class FlexRayControllerStatusObjectClass;

    FlexRayControllerStatus();
    FlexRayControllerStatus(FlexRayControllerStatusObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* ambassador);

    void ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType);

    // get attribute handle/value map of all attributes
    rti1516ev::AttributeHandleValueMap GetAllAttributeValues() const;
    // get attribute handle/value map of attributes which have been modified since last call to UpdateModifiedAttributeValues
    rti1516ev::AttributeHandleValueMap GetModifiedAttributeValues() const;

    rti1516ev::RTIambassador* mRtiAmbassador;
    // this mutex guards all of the fields below
    mutable std::recursive_mutex mMutex;

    FlexRayControllerStatusObjectClass* mObjectClass;
    std::wstring mObjectInstanceName;
    rti1516ev::ObjectInstanceHandle mObjectInstanceHandle;
    bool mIsOwner = false;
    // modified by any ReflectAttributeValues in the past
    AttributeBits mValuesReceived = kNone;
    // modified by any attribute setter
    AttributeBits mValuesSet = kNone;
    // modified by last ReflectAttributeValues
    AttributeBits mLastUpdated = kNone;
    // to be sent with next UpdateModifiedAttributeValues
    AttributeBits mDirty = kNone;
    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, UpdateCallback> mUpdateCallbacks;
    uint32_t mLastCallbackToken = 0;
    // Attribute value encoders
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute NetworkID : HLAASCIIstring
    rti1516ev::HLAASCIIstring mNetworkID;
    // attribute DeviceID : HLAASCIIstring
    rti1516ev::HLAASCIIstring mDeviceID;
    // attribute PocState : FlexRayPocState
    rti1516ev::HLAoctet mPocState;
    // attribute chiHaltRequest : HLAboolean
    rti1516ev::HLAboolean mchiHaltRequest;
    // attribute coldstartNoise : HLAboolean
    rti1516ev::HLAboolean mcoldstartNoise;
    // attribute freeze : HLAboolean
    rti1516ev::HLAboolean mfreeze;
    // attribute chiReadyRequest : HLAboolean
    rti1516ev::HLAboolean mchiReadyRequest;
    // attribute errorMode : FlexRayErrorModeType
    rti1516ev::HLAoctet merrorMode;
    // attribute slotMode : FlexRaySlotModeType
    rti1516ev::HLAoctet mslotMode;
    // attribute startupState : FlexRayStartupStateType
    rti1516ev::HLAoctet mstartupState;
    // attribute wakeupStatus : FlexRayWakeupStatusType
    rti1516ev::HLAoctet mwakeupStatus;
};

class FlexRayController;
class FlexRayControllerObjectClass : public IFlexRayControllerObjectClass
{
  public:
    // IFlexRayControllerObjectClass
    FlexRayControllerObjectClass() = default;
    virtual ~FlexRayControllerObjectClass();
    void Publish() override;
    void Unpublish() override;
    void Subscribe(bool deliverToSelf) override;
    void Unsubscribe() override;
    std::shared_ptr<IFlexRayController> GetObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IFlexRayController> CreateObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IFlexRayController> CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback) override;
    uint32_t RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback) override;
    void UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IFlexRayController> newObjectInstance);

    uint32_t RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback) override;
    void UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IFlexRayController> newObjectInstance);
    // Set a user-defined creator function, which returns subclasses of FlexRayController
    using ObjectInstanceCreatorFunction = std::function<FlexRayController*(FlexRayControllerObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)>;
    // When using custom object instance classes, don't forget to set the creator function *before* subscribing to the object class.
    void SetObjectInstanceCreator(ObjectInstanceCreatorFunction creatorFunction) { mCreatorFunction = creatorFunction; }
    // internal
    FlexRayControllerObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, BusControllerObjectClass* baseClass);

    // attribute NetworkID : HLAASCIIstring
    rti1516ev::AttributeHandle GetNetworkIDAttributeHandle() const { return mBaseClass->GetNetworkIDAttributeHandle(); }
    // attribute DeviceID : HLAASCIIstring
    rti1516ev::AttributeHandle GetDeviceIDAttributeHandle() const { return mBaseClass->GetDeviceIDAttributeHandle(); }
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute PocRequest : FlexRayPocState
    rti1516ev::AttributeHandle GetPocRequestAttributeHandle() const { return mPocRequestAttributeHandle; }
    // attribute ChiCommand : FlexRayChiCommand
    rti1516ev::AttributeHandle GetChiCommandAttributeHandle() const { return mChiCommandAttributeHandle; }
    // attribute pAllowHaltDueToClock : HLAoctet
    rti1516ev::AttributeHandle GetpAllowHaltDueToClockAttributeHandle() const { return mpAllowHaltDueToClockAttributeHandle; }
    // attribute pAllowPassiveToActive : HLAoctet
    rti1516ev::AttributeHandle GetpAllowPassiveToActiveAttributeHandle() const { return mpAllowPassiveToActiveAttributeHandle; }
    // attribute pChannels : FlexRayChannel
    rti1516ev::AttributeHandle GetpChannelsAttributeHandle() const { return mpChannelsAttributeHandle; }
    // attribute pClusterDriftDamping : HLAoctet
    rti1516ev::AttributeHandle GetpClusterDriftDampingAttributeHandle() const { return mpClusterDriftDampingAttributeHandle; }
    // attribute pdAcceptedStartupRange : HLAinteger32LE
    rti1516ev::AttributeHandle GetpdAcceptedStartupRangeAttributeHandle() const { return mpdAcceptedStartupRangeAttributeHandle; }
    // attribute pdListenTimeout : HLAinteger32LE
    rti1516ev::AttributeHandle GetpdListenTimeoutAttributeHandle() const { return mpdListenTimeoutAttributeHandle; }
    // attribute pKeySlotId : HLAinteger16LE
    rti1516ev::AttributeHandle GetpKeySlotIdAttributeHandle() const { return mpKeySlotIdAttributeHandle; }
    // attribute pKeySlotOnlyEnabled : HLAoctet
    rti1516ev::AttributeHandle GetpKeySlotOnlyEnabledAttributeHandle() const { return mpKeySlotOnlyEnabledAttributeHandle; }
    // attribute pKeySlotUsedForStartup : HLAoctet
    rti1516ev::AttributeHandle GetpKeySlotUsedForStartupAttributeHandle() const { return mpKeySlotUsedForStartupAttributeHandle; }
    // attribute pKeySlotUsedForSync : HLAoctet
    rti1516ev::AttributeHandle GetpKeySlotUsedForSyncAttributeHandle() const { return mpKeySlotUsedForSyncAttributeHandle; }
    // attribute pLatestTx : HLAinteger16LE
    rti1516ev::AttributeHandle GetpLatestTxAttributeHandle() const { return mpLatestTxAttributeHandle; }
    // attribute pMacroInitialOffsetA : HLAoctet
    rti1516ev::AttributeHandle GetpMacroInitialOffsetAAttributeHandle() const { return mpMacroInitialOffsetAAttributeHandle; }
    // attribute pMacroInitialOffsetB : HLAoctet
    rti1516ev::AttributeHandle GetpMacroInitialOffsetBAttributeHandle() const { return mpMacroInitialOffsetBAttributeHandle; }
    // attribute pMicroInitialOffsetA : HLAinteger32LE
    rti1516ev::AttributeHandle GetpMicroInitialOffsetAAttributeHandle() const { return mpMicroInitialOffsetAAttributeHandle; }
    // attribute pMicroInitialOffsetB : HLAinteger32LE
    rti1516ev::AttributeHandle GetpMicroInitialOffsetBAttributeHandle() const { return mpMicroInitialOffsetBAttributeHandle; }
    // attribute pMicroPerCycle : HLAinteger32LE
    rti1516ev::AttributeHandle GetpMicroPerCycleAttributeHandle() const { return mpMicroPerCycleAttributeHandle; }
    // attribute pOffsetCorrectionOut : HLAinteger32LE
    rti1516ev::AttributeHandle GetpOffsetCorrectionOutAttributeHandle() const { return mpOffsetCorrectionOutAttributeHandle; }
    // attribute pOffsetCorrectionStart : HLAinteger16LE
    rti1516ev::AttributeHandle GetpOffsetCorrectionStartAttributeHandle() const { return mpOffsetCorrectionStartAttributeHandle; }
    // attribute pRateCorrectionOut : HLAinteger32LE
    rti1516ev::AttributeHandle GetpRateCorrectionOutAttributeHandle() const { return mpRateCorrectionOutAttributeHandle; }
    // attribute pWakeupChannel : FlexRayChannel
    rti1516ev::AttributeHandle GetpWakeupChannelAttributeHandle() const { return mpWakeupChannelAttributeHandle; }
    // attribute pWakeupPattern : HLAoctet
    rti1516ev::AttributeHandle GetpWakeupPatternAttributeHandle() const { return mpWakeupPatternAttributeHandle; }
    // attribute pdMicrotick : FlexRayClockPeriod
    rti1516ev::AttributeHandle GetpdMicrotickAttributeHandle() const { return mpdMicrotickAttributeHandle; }
    // attribute pSamplesPerMicrotick : HLAoctet
    rti1516ev::AttributeHandle GetpSamplesPerMicrotickAttributeHandle() const { return mpSamplesPerMicrotickAttributeHandle; }
    void DiscoverObjectInstance (rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    rti1516ev::ObjectClassHandle GetObjectClassHandle() const { return mObjectClassHandle; }
    std::shared_ptr<IFlexRayController> GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle);
    rti1516ev::AttributeHandleSet GetAllAttributeHandles();
    ObjectClassRegistry* GetObjectClassRegistry() const { return mRegistry; }

    // add object instance to maps (and to maps of base classes)
    void InsertObjectInstanceName(std::shared_ptr<IFlexRayController> objectInstance, const std::wstring& objectInstanceName);
    void InsertObjectInstanceHandle(std::shared_ptr<IFlexRayController> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle);
    // remove object instance from maps (and from maps of base classes)
    void EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName);
  private:
    ObjectClassRegistry* mRegistry;
    rti1516ev::RTIambassador* mRtiAmbassador;
    // object class handle
    rti1516ev::ObjectClassHandle mObjectClassHandle;
    BusControllerObjectClass* mBaseClass;
    ObjectInstanceCreatorFunction mCreatorFunction;
    bool mPublished = false;
    bool mSubscribed = false;
    // Attribute handles
    // attribute PocRequest : FlexRayPocState
    rti1516ev::AttributeHandle mPocRequestAttributeHandle;
    // attribute ChiCommand : FlexRayChiCommand
    rti1516ev::AttributeHandle mChiCommandAttributeHandle;
    // attribute pAllowHaltDueToClock : HLAoctet
    rti1516ev::AttributeHandle mpAllowHaltDueToClockAttributeHandle;
    // attribute pAllowPassiveToActive : HLAoctet
    rti1516ev::AttributeHandle mpAllowPassiveToActiveAttributeHandle;
    // attribute pChannels : FlexRayChannel
    rti1516ev::AttributeHandle mpChannelsAttributeHandle;
    // attribute pClusterDriftDamping : HLAoctet
    rti1516ev::AttributeHandle mpClusterDriftDampingAttributeHandle;
    // attribute pdAcceptedStartupRange : HLAinteger32LE
    rti1516ev::AttributeHandle mpdAcceptedStartupRangeAttributeHandle;
    // attribute pdListenTimeout : HLAinteger32LE
    rti1516ev::AttributeHandle mpdListenTimeoutAttributeHandle;
    // attribute pKeySlotId : HLAinteger16LE
    rti1516ev::AttributeHandle mpKeySlotIdAttributeHandle;
    // attribute pKeySlotOnlyEnabled : HLAoctet
    rti1516ev::AttributeHandle mpKeySlotOnlyEnabledAttributeHandle;
    // attribute pKeySlotUsedForStartup : HLAoctet
    rti1516ev::AttributeHandle mpKeySlotUsedForStartupAttributeHandle;
    // attribute pKeySlotUsedForSync : HLAoctet
    rti1516ev::AttributeHandle mpKeySlotUsedForSyncAttributeHandle;
    // attribute pLatestTx : HLAinteger16LE
    rti1516ev::AttributeHandle mpLatestTxAttributeHandle;
    // attribute pMacroInitialOffsetA : HLAoctet
    rti1516ev::AttributeHandle mpMacroInitialOffsetAAttributeHandle;
    // attribute pMacroInitialOffsetB : HLAoctet
    rti1516ev::AttributeHandle mpMacroInitialOffsetBAttributeHandle;
    // attribute pMicroInitialOffsetA : HLAinteger32LE
    rti1516ev::AttributeHandle mpMicroInitialOffsetAAttributeHandle;
    // attribute pMicroInitialOffsetB : HLAinteger32LE
    rti1516ev::AttributeHandle mpMicroInitialOffsetBAttributeHandle;
    // attribute pMicroPerCycle : HLAinteger32LE
    rti1516ev::AttributeHandle mpMicroPerCycleAttributeHandle;
    // attribute pOffsetCorrectionOut : HLAinteger32LE
    rti1516ev::AttributeHandle mpOffsetCorrectionOutAttributeHandle;
    // attribute pOffsetCorrectionStart : HLAinteger16LE
    rti1516ev::AttributeHandle mpOffsetCorrectionStartAttributeHandle;
    // attribute pRateCorrectionOut : HLAinteger32LE
    rti1516ev::AttributeHandle mpRateCorrectionOutAttributeHandle;
    // attribute pWakeupChannel : FlexRayChannel
    rti1516ev::AttributeHandle mpWakeupChannelAttributeHandle;
    // attribute pWakeupPattern : HLAoctet
    rti1516ev::AttributeHandle mpWakeupPatternAttributeHandle;
    // attribute pdMicrotick : FlexRayClockPeriod
    rti1516ev::AttributeHandle mpdMicrotickAttributeHandle;
    // attribute pSamplesPerMicrotick : HLAoctet
    rti1516ev::AttributeHandle mpSamplesPerMicrotickAttributeHandle;
    // this mutex guards the data structures below
    mutable std::recursive_mutex mMutex;
    std::map<std::wstring, std::shared_ptr<IFlexRayController>> mObjectInstancesByName;
    std::map<rti1516ev::ObjectInstanceHandle, std::shared_ptr<IFlexRayController>> mObjectInstancesByHandle;

    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, DiscoverObjectInstanceCallback> mDiscoverCallbacks;
    uint32_t mLastDiscoverObjectInstanceCallbackToken = 0;
    std::map<uint32_t, RemoveObjectInstanceCallback> mRemoveObjectInstanceCallbacks;
    uint32_t mLastRemoveObjectInstanceCallbackToken = 0;
};

class FlexRayController : public IFlexRayController
{
  public:

    virtual ~FlexRayController();
    FlexRayController(const FlexRayController&) = delete;
    FlexRayController(FlexRayController&&) = delete;
    FlexRayController& operator=(const FlexRayController&) = delete;
    FlexRayController& operator=(FlexRayController&&) = delete;
    IFlexRayControllerObjectClass* GetObjectClass() const { return mObjectClass; }
    ObjectClassRegistry* GetObjectClassRegistry() const { return mObjectClass->GetObjectClassRegistry(); }
    std::wstring GetObjectInstanceName() const override { return mObjectInstanceName; }
    rti1516ev::ObjectInstanceHandle GetObjectInstanceHandle() const { return mObjectInstanceHandle; }
    bool IsValid() const override;
    bool IsOwner() const override;
    void Release() override;
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute NetworkID : HLAASCIIstring
    std::string GetNetworkID() const override;
    void SetNetworkID(std::string newValue) override;
    // attribute DeviceID : HLAASCIIstring
    std::string GetDeviceID() const override;
    void SetDeviceID(std::string newValue) override;
    // attribute PocRequest : FlexRayPocState
    FlexRayPocState GetPocRequest() const override;
    void SetPocRequest(FlexRayPocState newValue) override;
    // attribute ChiCommand : FlexRayChiCommand
    FlexRayChiCommand GetChiCommand() const override;
    void SetChiCommand(FlexRayChiCommand newValue) override;
    // attribute pAllowHaltDueToClock : HLAoctet
    uint8_t GetpAllowHaltDueToClock() const override;
    void SetpAllowHaltDueToClock(uint8_t newValue) override;
    // attribute pAllowPassiveToActive : HLAoctet
    uint8_t GetpAllowPassiveToActive() const override;
    void SetpAllowPassiveToActive(uint8_t newValue) override;
    // attribute pChannels : FlexRayChannel
    FlexRayChannel GetpChannels() const override;
    void SetpChannels(FlexRayChannel newValue) override;
    // attribute pClusterDriftDamping : HLAoctet
    uint8_t GetpClusterDriftDamping() const override;
    void SetpClusterDriftDamping(uint8_t newValue) override;
    // attribute pdAcceptedStartupRange : HLAinteger32LE
    int32_t GetpdAcceptedStartupRange() const override;
    void SetpdAcceptedStartupRange(int32_t newValue) override;
    // attribute pdListenTimeout : HLAinteger32LE
    int32_t GetpdListenTimeout() const override;
    void SetpdListenTimeout(int32_t newValue) override;
    // attribute pKeySlotId : HLAinteger16LE
    int16_t GetpKeySlotId() const override;
    void SetpKeySlotId(int16_t newValue) override;
    // attribute pKeySlotOnlyEnabled : HLAoctet
    uint8_t GetpKeySlotOnlyEnabled() const override;
    void SetpKeySlotOnlyEnabled(uint8_t newValue) override;
    // attribute pKeySlotUsedForStartup : HLAoctet
    uint8_t GetpKeySlotUsedForStartup() const override;
    void SetpKeySlotUsedForStartup(uint8_t newValue) override;
    // attribute pKeySlotUsedForSync : HLAoctet
    uint8_t GetpKeySlotUsedForSync() const override;
    void SetpKeySlotUsedForSync(uint8_t newValue) override;
    // attribute pLatestTx : HLAinteger16LE
    int16_t GetpLatestTx() const override;
    void SetpLatestTx(int16_t newValue) override;
    // attribute pMacroInitialOffsetA : HLAoctet
    uint8_t GetpMacroInitialOffsetA() const override;
    void SetpMacroInitialOffsetA(uint8_t newValue) override;
    // attribute pMacroInitialOffsetB : HLAoctet
    uint8_t GetpMacroInitialOffsetB() const override;
    void SetpMacroInitialOffsetB(uint8_t newValue) override;
    // attribute pMicroInitialOffsetA : HLAinteger32LE
    int32_t GetpMicroInitialOffsetA() const override;
    void SetpMicroInitialOffsetA(int32_t newValue) override;
    // attribute pMicroInitialOffsetB : HLAinteger32LE
    int32_t GetpMicroInitialOffsetB() const override;
    void SetpMicroInitialOffsetB(int32_t newValue) override;
    // attribute pMicroPerCycle : HLAinteger32LE
    int32_t GetpMicroPerCycle() const override;
    void SetpMicroPerCycle(int32_t newValue) override;
    // attribute pOffsetCorrectionOut : HLAinteger32LE
    int32_t GetpOffsetCorrectionOut() const override;
    void SetpOffsetCorrectionOut(int32_t newValue) override;
    // attribute pOffsetCorrectionStart : HLAinteger16LE
    int16_t GetpOffsetCorrectionStart() const override;
    void SetpOffsetCorrectionStart(int16_t newValue) override;
    // attribute pRateCorrectionOut : HLAinteger32LE
    int32_t GetpRateCorrectionOut() const override;
    void SetpRateCorrectionOut(int32_t newValue) override;
    // attribute pWakeupChannel : FlexRayChannel
    FlexRayChannel GetpWakeupChannel() const override;
    void SetpWakeupChannel(FlexRayChannel newValue) override;
    // attribute pWakeupPattern : HLAoctet
    uint8_t GetpWakeupPattern() const override;
    void SetpWakeupPattern(uint8_t newValue) override;
    // attribute pdMicrotick : FlexRayClockPeriod
    FlexRayClockPeriod GetpdMicrotick() const override;
    void SetpdMicrotick(FlexRayClockPeriod newValue) override;
    // attribute pSamplesPerMicrotick : HLAoctet
    uint8_t GetpSamplesPerMicrotick() const override;
    void SetpSamplesPerMicrotick(uint8_t newValue) override;
    // IFlexRayController
    void UpdateAllAttributeValues() override;
    void UpdateAllAttributeValues(int64_t time) override;
    void UpdateModifiedAttributeValues() override;
    void UpdateModifiedAttributeValues(int64_t time) override;
    void RequestAttributeValues() override;
    void RequestAllAttributeValues() override;
    uint32_t RegisterUpdateCallback(UpdateCallback callback) override;
    void UnregisterUpdateCallback(uint32_t callbackToken) override;

    // bitmask of attributes ever received
    AttributeBits GetReceivedAttributes() const override;
    // bitmask of attributes received in last update (cleared after update callbacks executed)
    AttributeBits GetUpdatedAttributes() const override;
    // bitmask of attributes ever modified
    AttributeBits GetInitializedAttributes() const override;
    // bitmask of attributes modified since last updateAttributeValues/provideAttributeValues
    AttributeBits GetModifiedAttributes() const override;
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes);
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType);
    void ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributes, optional<int64_t> time);
  protected:
    friend class FlexRayControllerObjectClass;

    FlexRayController();
    FlexRayController(FlexRayControllerObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* ambassador);

    void ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType);

    // get attribute handle/value map of all attributes
    rti1516ev::AttributeHandleValueMap GetAllAttributeValues() const;
    // get attribute handle/value map of attributes which have been modified since last call to UpdateModifiedAttributeValues
    rti1516ev::AttributeHandleValueMap GetModifiedAttributeValues() const;

    rti1516ev::RTIambassador* mRtiAmbassador;
    // this mutex guards all of the fields below
    mutable std::recursive_mutex mMutex;

    FlexRayControllerObjectClass* mObjectClass;
    std::wstring mObjectInstanceName;
    rti1516ev::ObjectInstanceHandle mObjectInstanceHandle;
    bool mIsOwner = false;
    // modified by any ReflectAttributeValues in the past
    AttributeBits mValuesReceived = kNone;
    // modified by any attribute setter
    AttributeBits mValuesSet = kNone;
    // modified by last ReflectAttributeValues
    AttributeBits mLastUpdated = kNone;
    // to be sent with next UpdateModifiedAttributeValues
    AttributeBits mDirty = kNone;
    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, UpdateCallback> mUpdateCallbacks;
    uint32_t mLastCallbackToken = 0;
    // Attribute value encoders
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute NetworkID : HLAASCIIstring
    rti1516ev::HLAASCIIstring mNetworkID;
    // attribute DeviceID : HLAASCIIstring
    rti1516ev::HLAASCIIstring mDeviceID;
    // attribute PocRequest : FlexRayPocState
    rti1516ev::HLAoctet mPocRequest;
    // attribute ChiCommand : FlexRayChiCommand
    rti1516ev::HLAoctet mChiCommand;
    // attribute pAllowHaltDueToClock : HLAoctet
    rti1516ev::HLAoctet mpAllowHaltDueToClock;
    // attribute pAllowPassiveToActive : HLAoctet
    rti1516ev::HLAoctet mpAllowPassiveToActive;
    // attribute pChannels : FlexRayChannel
    rti1516ev::HLAoctet mpChannels;
    // attribute pClusterDriftDamping : HLAoctet
    rti1516ev::HLAoctet mpClusterDriftDamping;
    // attribute pdAcceptedStartupRange : HLAinteger32LE
    rti1516ev::HLAinteger32LE mpdAcceptedStartupRange;
    // attribute pdListenTimeout : HLAinteger32LE
    rti1516ev::HLAinteger32LE mpdListenTimeout;
    // attribute pKeySlotId : HLAinteger16LE
    rti1516ev::HLAinteger16LE mpKeySlotId;
    // attribute pKeySlotOnlyEnabled : HLAoctet
    rti1516ev::HLAoctet mpKeySlotOnlyEnabled;
    // attribute pKeySlotUsedForStartup : HLAoctet
    rti1516ev::HLAoctet mpKeySlotUsedForStartup;
    // attribute pKeySlotUsedForSync : HLAoctet
    rti1516ev::HLAoctet mpKeySlotUsedForSync;
    // attribute pLatestTx : HLAinteger16LE
    rti1516ev::HLAinteger16LE mpLatestTx;
    // attribute pMacroInitialOffsetA : HLAoctet
    rti1516ev::HLAoctet mpMacroInitialOffsetA;
    // attribute pMacroInitialOffsetB : HLAoctet
    rti1516ev::HLAoctet mpMacroInitialOffsetB;
    // attribute pMicroInitialOffsetA : HLAinteger32LE
    rti1516ev::HLAinteger32LE mpMicroInitialOffsetA;
    // attribute pMicroInitialOffsetB : HLAinteger32LE
    rti1516ev::HLAinteger32LE mpMicroInitialOffsetB;
    // attribute pMicroPerCycle : HLAinteger32LE
    rti1516ev::HLAinteger32LE mpMicroPerCycle;
    // attribute pOffsetCorrectionOut : HLAinteger32LE
    rti1516ev::HLAinteger32LE mpOffsetCorrectionOut;
    // attribute pOffsetCorrectionStart : HLAinteger16LE
    rti1516ev::HLAinteger16LE mpOffsetCorrectionStart;
    // attribute pRateCorrectionOut : HLAinteger32LE
    rti1516ev::HLAinteger32LE mpRateCorrectionOut;
    // attribute pWakeupChannel : FlexRayChannel
    rti1516ev::HLAoctet mpWakeupChannel;
    // attribute pWakeupPattern : HLAoctet
    rti1516ev::HLAoctet mpWakeupPattern;
    // attribute pdMicrotick : FlexRayClockPeriod
    rti1516ev::HLAoctet mpdMicrotick;
    // attribute pSamplesPerMicrotick : HLAoctet
    rti1516ev::HLAoctet mpSamplesPerMicrotick;
};

class FlexRaySendBuffer;
class FlexRaySendBufferObjectClass : public IFlexRaySendBufferObjectClass
{
  public:
    // IFlexRaySendBufferObjectClass
    FlexRaySendBufferObjectClass() = default;
    virtual ~FlexRaySendBufferObjectClass();
    void Publish() override;
    void Unpublish() override;
    void Subscribe(bool deliverToSelf) override;
    void Unsubscribe() override;
    std::shared_ptr<IFlexRaySendBuffer> GetObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IFlexRaySendBuffer> CreateObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IFlexRaySendBuffer> CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback) override;
    uint32_t RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback) override;
    void UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IFlexRaySendBuffer> newObjectInstance);

    uint32_t RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback) override;
    void UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IFlexRaySendBuffer> newObjectInstance);
    // Set a user-defined creator function, which returns subclasses of FlexRaySendBuffer
    using ObjectInstanceCreatorFunction = std::function<FlexRaySendBuffer*(FlexRaySendBufferObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)>;
    // When using custom object instance classes, don't forget to set the creator function *before* subscribing to the object class.
    void SetObjectInstanceCreator(ObjectInstanceCreatorFunction creatorFunction) { mCreatorFunction = creatorFunction; }
    // internal
    FlexRaySendBufferObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, HLAobjectRootObjectClass* baseClass);

    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute Sender : HLAobjectInstanceHandle.FlexRayController
    rti1516ev::AttributeHandle GetSenderAttributeHandle() const { return mSenderAttributeHandle; }
    // attribute TransmissionMode : FlexRayTransmissionMode
    rti1516ev::AttributeHandle GetTransmissionModeAttributeHandle() const { return mTransmissionModeAttributeHandle; }
    // attribute Payload : FlexRayPayload
    rti1516ev::AttributeHandle GetPayloadAttributeHandle() const { return mPayloadAttributeHandle; }
    // attribute CycleOffset : HLAoctet
    rti1516ev::AttributeHandle GetCycleOffsetAttributeHandle() const { return mCycleOffsetAttributeHandle; }
    // attribute CycleRepetition : HLAoctet
    rti1516ev::AttributeHandle GetCycleRepetitionAttributeHandle() const { return mCycleRepetitionAttributeHandle; }
    // attribute SlotId : HLAinteger16LE
    rti1516ev::AttributeHandle GetSlotIdAttributeHandle() const { return mSlotIdAttributeHandle; }
    // attribute Channel : FlexRayChannel
    rti1516ev::AttributeHandle GetChannelAttributeHandle() const { return mChannelAttributeHandle; }
    // attribute PPIndicator : HLAboolean
    rti1516ev::AttributeHandle GetPPIndicatorAttributeHandle() const { return mPPIndicatorAttributeHandle; }
    // attribute HeaderCRC : HLAinteger16LE
    rti1516ev::AttributeHandle GetHeaderCRCAttributeHandle() const { return mHeaderCRCAttributeHandle; }
    void DiscoverObjectInstance (rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    rti1516ev::ObjectClassHandle GetObjectClassHandle() const { return mObjectClassHandle; }
    std::shared_ptr<IFlexRaySendBuffer> GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle);
    rti1516ev::AttributeHandleSet GetAllAttributeHandles();
    ObjectClassRegistry* GetObjectClassRegistry() const { return mRegistry; }

    // add object instance to maps (and to maps of base classes)
    void InsertObjectInstanceName(std::shared_ptr<IFlexRaySendBuffer> objectInstance, const std::wstring& objectInstanceName);
    void InsertObjectInstanceHandle(std::shared_ptr<IFlexRaySendBuffer> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle);
    // remove object instance from maps (and from maps of base classes)
    void EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName);
  private:
    ObjectClassRegistry* mRegistry;
    rti1516ev::RTIambassador* mRtiAmbassador;
    // object class handle
    rti1516ev::ObjectClassHandle mObjectClassHandle;
    HLAobjectRootObjectClass* mBaseClass;
    ObjectInstanceCreatorFunction mCreatorFunction;
    bool mPublished = false;
    bool mSubscribed = false;
    // Attribute handles
    // attribute Sender : HLAobjectInstanceHandle.FlexRayController
    rti1516ev::AttributeHandle mSenderAttributeHandle;
    // attribute TransmissionMode : FlexRayTransmissionMode
    rti1516ev::AttributeHandle mTransmissionModeAttributeHandle;
    // attribute Payload : FlexRayPayload
    rti1516ev::AttributeHandle mPayloadAttributeHandle;
    // attribute CycleOffset : HLAoctet
    rti1516ev::AttributeHandle mCycleOffsetAttributeHandle;
    // attribute CycleRepetition : HLAoctet
    rti1516ev::AttributeHandle mCycleRepetitionAttributeHandle;
    // attribute SlotId : HLAinteger16LE
    rti1516ev::AttributeHandle mSlotIdAttributeHandle;
    // attribute Channel : FlexRayChannel
    rti1516ev::AttributeHandle mChannelAttributeHandle;
    // attribute PPIndicator : HLAboolean
    rti1516ev::AttributeHandle mPPIndicatorAttributeHandle;
    // attribute HeaderCRC : HLAinteger16LE
    rti1516ev::AttributeHandle mHeaderCRCAttributeHandle;
    // this mutex guards the data structures below
    mutable std::recursive_mutex mMutex;
    std::map<std::wstring, std::shared_ptr<IFlexRaySendBuffer>> mObjectInstancesByName;
    std::map<rti1516ev::ObjectInstanceHandle, std::shared_ptr<IFlexRaySendBuffer>> mObjectInstancesByHandle;

    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, DiscoverObjectInstanceCallback> mDiscoverCallbacks;
    uint32_t mLastDiscoverObjectInstanceCallbackToken = 0;
    std::map<uint32_t, RemoveObjectInstanceCallback> mRemoveObjectInstanceCallbacks;
    uint32_t mLastRemoveObjectInstanceCallbackToken = 0;
};

class FlexRaySendBuffer : public IFlexRaySendBuffer
{
  public:

    virtual ~FlexRaySendBuffer();
    FlexRaySendBuffer(const FlexRaySendBuffer&) = delete;
    FlexRaySendBuffer(FlexRaySendBuffer&&) = delete;
    FlexRaySendBuffer& operator=(const FlexRaySendBuffer&) = delete;
    FlexRaySendBuffer& operator=(FlexRaySendBuffer&&) = delete;
    IFlexRaySendBufferObjectClass* GetObjectClass() const { return mObjectClass; }
    ObjectClassRegistry* GetObjectClassRegistry() const { return mObjectClass->GetObjectClassRegistry(); }
    std::wstring GetObjectInstanceName() const override { return mObjectInstanceName; }
    rti1516ev::ObjectInstanceHandle GetObjectInstanceHandle() const { return mObjectInstanceHandle; }
    bool IsValid() const override;
    bool IsOwner() const override;
    void Release() override;
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute Sender : HLAobjectInstanceHandle.FlexRayController
    IFlexRayController* GetSender() const override;
    void SetSender(IFlexRayController* newValue) override;
    // attribute TransmissionMode : FlexRayTransmissionMode
    FlexRayTransmissionMode GetTransmissionMode() const override;
    void SetTransmissionMode(FlexRayTransmissionMode newValue) override;
    // attribute Payload : FlexRayPayload
    const FlexRayPayload& GetPayload() const override;
    FlexRayPayload& GetPayload() override;
    void SetPayload(const FlexRayPayload& newValue) override;
    // attribute CycleOffset : HLAoctet
    uint8_t GetCycleOffset() const override;
    void SetCycleOffset(uint8_t newValue) override;
    // attribute CycleRepetition : HLAoctet
    uint8_t GetCycleRepetition() const override;
    void SetCycleRepetition(uint8_t newValue) override;
    // attribute SlotId : HLAinteger16LE
    int16_t GetSlotId() const override;
    void SetSlotId(int16_t newValue) override;
    // attribute Channel : FlexRayChannel
    FlexRayChannel GetChannel() const override;
    void SetChannel(FlexRayChannel newValue) override;
    // attribute PPIndicator : HLAboolean
    bool GetPPIndicator() const override;
    void SetPPIndicator(bool newValue) override;
    // attribute HeaderCRC : HLAinteger16LE
    int16_t GetHeaderCRC() const override;
    void SetHeaderCRC(int16_t newValue) override;
    // IFlexRaySendBuffer
    void UpdateAllAttributeValues() override;
    void UpdateAllAttributeValues(int64_t time) override;
    void UpdateModifiedAttributeValues() override;
    void UpdateModifiedAttributeValues(int64_t time) override;
    void RequestAttributeValues() override;
    void RequestAllAttributeValues() override;
    uint32_t RegisterUpdateCallback(UpdateCallback callback) override;
    void UnregisterUpdateCallback(uint32_t callbackToken) override;

    // bitmask of attributes ever received
    AttributeBits GetReceivedAttributes() const override;
    // bitmask of attributes received in last update (cleared after update callbacks executed)
    AttributeBits GetUpdatedAttributes() const override;
    // bitmask of attributes ever modified
    AttributeBits GetInitializedAttributes() const override;
    // bitmask of attributes modified since last updateAttributeValues/provideAttributeValues
    AttributeBits GetModifiedAttributes() const override;
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes);
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType);
    void ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributes, optional<int64_t> time);
  protected:
    friend class FlexRaySendBufferObjectClass;

    FlexRaySendBuffer();
    FlexRaySendBuffer(FlexRaySendBufferObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* ambassador);

    void ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType);

    // get attribute handle/value map of all attributes
    rti1516ev::AttributeHandleValueMap GetAllAttributeValues() const;
    // get attribute handle/value map of attributes which have been modified since last call to UpdateModifiedAttributeValues
    rti1516ev::AttributeHandleValueMap GetModifiedAttributeValues() const;

    rti1516ev::RTIambassador* mRtiAmbassador;
    // this mutex guards all of the fields below
    mutable std::recursive_mutex mMutex;

    FlexRaySendBufferObjectClass* mObjectClass;
    std::wstring mObjectInstanceName;
    rti1516ev::ObjectInstanceHandle mObjectInstanceHandle;
    bool mIsOwner = false;
    // modified by any ReflectAttributeValues in the past
    AttributeBits mValuesReceived = kNone;
    // modified by any attribute setter
    AttributeBits mValuesSet = kNone;
    // modified by last ReflectAttributeValues
    AttributeBits mLastUpdated = kNone;
    // to be sent with next UpdateModifiedAttributeValues
    AttributeBits mDirty = kNone;
    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, UpdateCallback> mUpdateCallbacks;
    uint32_t mLastCallbackToken = 0;
    // Attribute value encoders
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute Sender : HLAobjectInstanceHandle.FlexRayController
    rti1516ev::HLAobjectInstanceHandle mSender;
    // attribute TransmissionMode : FlexRayTransmissionMode
    rti1516ev::HLAoctet mTransmissionMode;
    // attribute Payload : FlexRayPayload
    FlexRayPayloadEncoding mPayload;
    // attribute CycleOffset : HLAoctet
    rti1516ev::HLAoctet mCycleOffset;
    // attribute CycleRepetition : HLAoctet
    rti1516ev::HLAoctet mCycleRepetition;
    // attribute SlotId : HLAinteger16LE
    rti1516ev::HLAinteger16LE mSlotId;
    // attribute Channel : FlexRayChannel
    rti1516ev::HLAoctet mChannel;
    // attribute PPIndicator : HLAboolean
    rti1516ev::HLAboolean mPPIndicator;
    // attribute HeaderCRC : HLAinteger16LE
    rti1516ev::HLAinteger16LE mHeaderCRC;
};

 

class ObjectClassRegistry : public IObjectClassRegistry
{
  public:
    ObjectClassRegistry();
    ~ObjectClassRegistry();
    void Initialize(rti1516ev::RTIambassador* rtiAmbassador);
    void Finalize();

    IHLAobjectRootObjectClass* GetHLAobjectRootObjectClass() const override { return mHLAobjectRootObjectClass.get(); }
    ISystemVariableObjectClass* GetSystemVariableObjectClass() const override { return mSystemVariableObjectClass.get(); }
    IValueEntityObjectClass* GetValueEntityObjectClass() const override { return mValueEntityObjectClass.get(); }
    IDOMemberSourceObjectClass* GetDOMemberSourceObjectClass() const override { return mDOMemberSourceObjectClass.get(); }
    IDOMemberTargetObjectClass* GetDOMemberTargetObjectClass() const override { return mDOMemberTargetObjectClass.get(); }
    IBusManagementObjectClass* GetBusManagementObjectClass() const override { return mBusManagementObjectClass.get(); }
    IBusManagementCanObjectClass* GetBusManagementCanObjectClass() const override { return mBusManagementCanObjectClass.get(); }
    IBusManagementEthernetObjectClass* GetBusManagementEthernetObjectClass() const override { return mBusManagementEthernetObjectClass.get(); }
    IFlexRayClusterObjectClass* GetFlexRayClusterObjectClass() const override { return mFlexRayClusterObjectClass.get(); }
    IBusControllerObjectClass* GetBusControllerObjectClass() const override { return mBusControllerObjectClass.get(); }
    IBusControllerCanObjectClass* GetBusControllerCanObjectClass() const override { return mBusControllerCanObjectClass.get(); }
    IBusControllerEthernetObjectClass* GetBusControllerEthernetObjectClass() const override { return mBusControllerEthernetObjectClass.get(); }
    IFlexRayControllerStatusObjectClass* GetFlexRayControllerStatusObjectClass() const override { return mFlexRayControllerStatusObjectClass.get(); }
    IFlexRayControllerObjectClass* GetFlexRayControllerObjectClass() const override { return mFlexRayControllerObjectClass.get(); }
    IFlexRaySendBufferObjectClass* GetFlexRaySendBufferObjectClass() const override { return mFlexRaySendBufferObjectClass.get(); }

    void DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    void ReflectAttributeValues(rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes);
    void ReflectAttributeValues(rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType);
    void ProvideAttributeValues(rti1516ev::ObjectClassHandle theObjectClass, rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time);
    void ObjectInstanceNameReservationSucceeded(std::wstring const & theObjectInstanceName);
    void ObjectInstanceNameReservationFailed(std::wstring const & theObjectInstanceName);
    void RegisterObjectInstanceName(const std::wstring& theObjectInstanceName, std::function<void(bool)> completionCallback);

  private:
    std::map<std::wstring, std::function<void(bool)> > mObjectInstanceNameReservationCallbacks;
    rti1516ev::RTIambassador* mRtiAmbassador;
    std::unique_ptr<HLAobjectRootObjectClass> mHLAobjectRootObjectClass;
    std::unique_ptr<SystemVariableObjectClass> mSystemVariableObjectClass;
    std::unique_ptr<ValueEntityObjectClass> mValueEntityObjectClass;
    std::unique_ptr<DOMemberSourceObjectClass> mDOMemberSourceObjectClass;
    std::unique_ptr<DOMemberTargetObjectClass> mDOMemberTargetObjectClass;
    std::unique_ptr<BusManagementObjectClass> mBusManagementObjectClass;
    std::unique_ptr<BusManagementCanObjectClass> mBusManagementCanObjectClass;
    std::unique_ptr<BusManagementEthernetObjectClass> mBusManagementEthernetObjectClass;
    std::unique_ptr<FlexRayClusterObjectClass> mFlexRayClusterObjectClass;
    std::unique_ptr<BusControllerObjectClass> mBusControllerObjectClass;
    std::unique_ptr<BusControllerCanObjectClass> mBusControllerCanObjectClass;
    std::unique_ptr<BusControllerEthernetObjectClass> mBusControllerEthernetObjectClass;
    std::unique_ptr<FlexRayControllerStatusObjectClass> mFlexRayControllerStatusObjectClass;
    std::unique_ptr<FlexRayControllerObjectClass> mFlexRayControllerObjectClass;
    std::unique_ptr<FlexRaySendBufferObjectClass> mFlexRaySendBufferObjectClass;
}; // class ObjectClassRegistry

} // namespace NDistSimIB
} // namespace NRTFederateEncoding
