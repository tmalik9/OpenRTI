
// Code automatically generated by FOMCodeGen version 2.0.1.12 from RTFederate.xml, do not edit

// Name: CANoe RT Federate
// Copyright: Copyright (c) Vector Informatik GmbH. All rights reserved.
// Version: 1.0
// Description: CANoe Simulation Object Model

#pragma once

#include <vector>
#include <ostream>
#include <cassert>
#include <new>
#include <utility>
#include <type_traits>



namespace NDistSimIB {
namespace NRTFederateEncoding {

// define placement_new in case some other header has redefined operator new to sth. different (e.g. MS crtdbg)
#ifndef _PLACEMENT_NEW_DEFINED
#pragma push_macro("new")
#undef new
template <class X, typename ... Types>
inline X* placement_new(void* addr, Types&& ... args)
{
  return new (addr) X(std::forward<Types>(args)...);
}
#pragma pop_macro("new")
#define _PLACEMENT_NEW_DEFINED
#endif

// define our own simplified 'optional' types, similar to but independent of std::optional (since C++17) or boost::optional
#pragma warning(push)
#pragma warning(disable: 4324) // MSVC: 'struct_name' : structure was padded due to __declspec(align())
// (empty) base template
template<typename T, bool X=std::is_class<T>::value > struct optional {};
// specialization for classes and structs used by-value, w. in-place copy-construction
template<typename T> struct optional<T, true>
{
  static_assert(!std::is_reference< T >::value, "reference is not supported as optional value");
  // constructors
  optional() : _valid(false) {}
  optional(const optional& rhs): _valid(rhs._valid) { create(rhs); }
  optional(const T& w): _valid(true) { create(w); }
  template<typename Other>
  optional(const Other& w): _valid(true) { create(w); }

  // destructor
  ~optional() { if(_valid) destroy(); }

  // check for value presence
  bool operator ! () const { return !_valid; }
  explicit operator bool() const { return _valid; }

  // assign
  optional& operator = (optional const& rhs) { return assign(rhs); }
  optional& operator = (T const& w) { return assign(w); }

  // get value
  const T& operator * () const { return *get(); }
  T& operator * () { return *get(); }
  T const* operator -> () const { return get(); }
  T* operator -> () { return get(); }
private:
  template<typename Other>
  void create(const Other& w) { placement_new<T>(_value, w); }
  void create(const optional& rhs) { if(_valid) create(*rhs.get()); }
  void destroy() { get()->~T(); }
  T const* get() const { assert(_valid && "no optional value"); return reinterpret_cast< const T* >(_value); }
  T* get() { assert(_valid && "no optional value"); return reinterpret_cast< T* >(_value); }
  void cleanup() { destroy(); _valid = false; }
  optional& assign(const T& w) {
    if(_valid) *get() = w;
    else create(w), _valid = true;
    return *this;
  }
  optional& assign(const optional& rhs) {
    if(rhs._valid) return assign(*rhs.get());
    if(!_valid) return *this;
    cleanup();
    return *this;
  }
  bool _valid;
  alignas(alignof(T)) uint8_t _value[sizeof(T)];
};
// Specialization for const-ref parameters, implemented by holding a pointer to the original variable.
// Note that non-const references are *not* supported (but could be easily added)!
template<typename T> struct optional<const T&, false>
{
  // constructors
  optional() : _valid(false) {}
  optional(const optional& rhs): _valid(rhs._valid), _pointer(rhs._pointer) { }
  optional(const T& rhs): _valid(true), _pointer(&rhs) { }
  template<typename Other>
  optional(const Other& rhs): _valid(true), _pointer(&rhs) { }

  // destructor
  ~optional() { }

  // check for value presence
  bool operator ! () const { return !_valid; }
  explicit operator bool() const { return _valid; }

  // assign
  optional& operator = (const optional& rhs) {
    _valid = rhs._valid;
    _pointer = rhs._pointer;
    return *this;
  }
  optional& operator = (const T& w) {
    _valid = true;
    _pointer = &w;
    return *this;
  }
  // get value
  T const& operator * () const { return *get(); }
  T const* operator -> () const { return get(); }
private:
  const T* get() const {
    assert(_valid && "no optional value");
    return _pointer;
  }
  bool _valid;
  const T* _pointer = nullptr;
};
// Specialization for everything else, which includes fundamental types and pointer types.
template<typename T> struct optional<T, false>
{
  // constructors
  optional() : _valid(false) {}
  optional(const optional& rhs): _valid(rhs._valid), _value(rhs._value) { }
  optional(const T& rhs): _valid(true), _value(rhs) { }
  template<typename Other>
  optional(const Other& rhs): _valid(true), _value(rhs) { }

  // destructor
  ~optional() { }

  // check for value presence
  bool operator ! () const { return !_valid; }
  explicit operator bool() const { return _valid; }

  // assign
  optional& operator = (const optional& rhs) {
    _valid = rhs._valid;
    _value = rhs._value;
    return *this;
  }
  optional& operator = (const T& w) {
    _valid = true;
    _value = w;
    return *this;
  }
  // get value
  T const& operator * () const { return _value; }
  T const* operator -> () const { return &_value; }
private:
  bool _valid;
  T _value;
};
#pragma warning(pop)

// extended receive order type, includes 'interpolated' for application-generated timestamps
enum class OrderType { RECEIVE, TIMESTAMP, INTERPOLATED };

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, OrderType value)
{
  switch (value)
  {
    case OrderType::RECEIVE: os << "RECEIVE"; break;
    case OrderType::TIMESTAMP: os << "TIMESTAMP"; break;
    case OrderType::INTERPOLATED: os << "INTERPOLATED"; break;
  }
  return os;
}

inline std::string to_string(OrderType value)
{
  switch (value)
  {
    case OrderType::RECEIVE: return "RECEIVE";
    case OrderType::TIMESTAMP: return "TIMESTAMP";
    case OrderType::INTERPOLATED: return "INTERPOLATED";
  }
}

inline std::wstring to_wstring(OrderType value)
{
  switch (value)
  {
    case OrderType::RECEIVE: return L"RECEIVE";
    case OrderType::TIMESTAMP: return L"TIMESTAMP";
    case OrderType::INTERPOLATED: return L"INTERPOLATED";
  }
}

typedef int64_t VTimeNS;

typedef int32_t VMessageId;

enum class BusType : int32_t
{
      kBtInvalid = 0,
      kBtCAN = 1,
      kBtLIN = 5,
      kBtFlexRay = 7,
      kBtEthernet = 11,
}; // enum BusType

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, BusType value)
{
  switch (value)
  {
    case BusType::kBtInvalid: os << "kBtInvalid"; break;
    case BusType::kBtCAN: os << "kBtCAN"; break;
    case BusType::kBtLIN: os << "kBtLIN"; break;
    case BusType::kBtFlexRay: os << "kBtFlexRay"; break;
    case BusType::kBtEthernet: os << "kBtEthernet"; break;
    default: os << "<invalid BusType>"; break;
  }
  return os;
}

inline std::string to_string(BusType value)
{
  switch (value)
  {
    case BusType::kBtInvalid: return "kBtInvalid";
    case BusType::kBtCAN: return "kBtCAN";
    case BusType::kBtLIN: return "kBtLIN";
    case BusType::kBtFlexRay: return "kBtFlexRay";
    case BusType::kBtEthernet: return "kBtEthernet";
    default: return "<invalid BusType>";
  }
}

inline std::wstring to_wstring(BusType value)
{
  switch (value)
  {
    case BusType::kBtInvalid: return L"kBtInvalid";
    case BusType::kBtCAN: return L"kBtCAN";
    case BusType::kBtLIN: return L"kBtLIN";
    case BusType::kBtFlexRay: return L"kBtFlexRay";
    case BusType::kBtEthernet: return L"kBtEthernet";
    default: return L"<invalid BusType>";
  }
}

enum class SimulatedFlag : uint8_t
{
      kSimulated_fromBus = 0,
      kSimulated_fromTool = 1,
      kSimulated_internalEvent = 2,
}; // enum SimulatedFlag

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, SimulatedFlag value)
{
  switch (value)
  {
    case SimulatedFlag::kSimulated_fromBus: os << "kSimulated_fromBus"; break;
    case SimulatedFlag::kSimulated_fromTool: os << "kSimulated_fromTool"; break;
    case SimulatedFlag::kSimulated_internalEvent: os << "kSimulated_internalEvent"; break;
    default: os << "<invalid SimulatedFlag>"; break;
  }
  return os;
}

inline std::string to_string(SimulatedFlag value)
{
  switch (value)
  {
    case SimulatedFlag::kSimulated_fromBus: return "kSimulated_fromBus";
    case SimulatedFlag::kSimulated_fromTool: return "kSimulated_fromTool";
    case SimulatedFlag::kSimulated_internalEvent: return "kSimulated_internalEvent";
    default: return "<invalid SimulatedFlag>";
  }
}

inline std::wstring to_wstring(SimulatedFlag value)
{
  switch (value)
  {
    case SimulatedFlag::kSimulated_fromBus: return L"kSimulated_fromBus";
    case SimulatedFlag::kSimulated_fromTool: return L"kSimulated_fromTool";
    case SimulatedFlag::kSimulated_internalEvent: return L"kSimulated_internalEvent";
    default: return L"<invalid SimulatedFlag>";
  }
}

enum class DirMask : uint8_t
{
      kMskTxRequest = 0,
      kMskRx = 1,
      kMskTx = 2,
}; // enum DirMask

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, DirMask value)
{
  switch (value)
  {
    case DirMask::kMskTxRequest: os << "kMskTxRequest"; break;
    case DirMask::kMskRx: os << "kMskRx"; break;
    case DirMask::kMskTx: os << "kMskTx"; break;
    default: os << "<invalid DirMask>"; break;
  }
  return os;
}

inline std::string to_string(DirMask value)
{
  switch (value)
  {
    case DirMask::kMskTxRequest: return "kMskTxRequest";
    case DirMask::kMskRx: return "kMskRx";
    case DirMask::kMskTx: return "kMskTx";
    default: return "<invalid DirMask>";
  }
}

inline std::wstring to_wstring(DirMask value)
{
  switch (value)
  {
    case DirMask::kMskTxRequest: return L"kMskTxRequest";
    case DirMask::kMskRx: return L"kMskRx";
    case DirMask::kMskTx: return L"kMskTx";
    default: return L"<invalid DirMask>";
  }
}

enum class MessageFlags : int32_t
{
      kMsgFlagRemoteFrame = 0x10,
      kMsgFlagEDL = 0x1000,
      kMsgFlagBRS = 0x2000,
}; // enum MessageFlags

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, MessageFlags value)
{
  switch (value)
  {
    case MessageFlags::kMsgFlagRemoteFrame: os << "kMsgFlagRemoteFrame"; break;
    case MessageFlags::kMsgFlagEDL: os << "kMsgFlagEDL"; break;
    case MessageFlags::kMsgFlagBRS: os << "kMsgFlagBRS"; break;
    default: os << "<invalid MessageFlags>"; break;
  }
  return os;
}

inline std::string to_string(MessageFlags value)
{
  switch (value)
  {
    case MessageFlags::kMsgFlagRemoteFrame: return "kMsgFlagRemoteFrame";
    case MessageFlags::kMsgFlagEDL: return "kMsgFlagEDL";
    case MessageFlags::kMsgFlagBRS: return "kMsgFlagBRS";
    default: return "<invalid MessageFlags>";
  }
}

inline std::wstring to_wstring(MessageFlags value)
{
  switch (value)
  {
    case MessageFlags::kMsgFlagRemoteFrame: return L"kMsgFlagRemoteFrame";
    case MessageFlags::kMsgFlagEDL: return L"kMsgFlagEDL";
    case MessageFlags::kMsgFlagBRS: return L"kMsgFlagBRS";
    default: return L"<invalid MessageFlags>";
  }
}

enum class LinkStatus : int32_t
{
      kLinkUnknown = 0,
      kLinkDown = 1,
      kLinkUp = 2,
      kLinkNegotiate = 3,
      kLinkError = 4,
}; // enum LinkStatus

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, LinkStatus value)
{
  switch (value)
  {
    case LinkStatus::kLinkUnknown: os << "kLinkUnknown"; break;
    case LinkStatus::kLinkDown: os << "kLinkDown"; break;
    case LinkStatus::kLinkUp: os << "kLinkUp"; break;
    case LinkStatus::kLinkNegotiate: os << "kLinkNegotiate"; break;
    case LinkStatus::kLinkError: os << "kLinkError"; break;
    default: os << "<invalid LinkStatus>"; break;
  }
  return os;
}

inline std::string to_string(LinkStatus value)
{
  switch (value)
  {
    case LinkStatus::kLinkUnknown: return "kLinkUnknown";
    case LinkStatus::kLinkDown: return "kLinkDown";
    case LinkStatus::kLinkUp: return "kLinkUp";
    case LinkStatus::kLinkNegotiate: return "kLinkNegotiate";
    case LinkStatus::kLinkError: return "kLinkError";
    default: return "<invalid LinkStatus>";
  }
}

inline std::wstring to_wstring(LinkStatus value)
{
  switch (value)
  {
    case LinkStatus::kLinkUnknown: return L"kLinkUnknown";
    case LinkStatus::kLinkDown: return L"kLinkDown";
    case LinkStatus::kLinkUp: return L"kLinkUp";
    case LinkStatus::kLinkNegotiate: return L"kLinkNegotiate";
    case LinkStatus::kLinkError: return L"kLinkError";
    default: return L"<invalid LinkStatus>";
  }
}

enum class EthernetPhy : int32_t
{
      kPhyUnknown = 0,
      kPhyIEEE_802_3 = 1,
      kPhyBroadR_Reach = 2,
}; // enum EthernetPhy

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, EthernetPhy value)
{
  switch (value)
  {
    case EthernetPhy::kPhyUnknown: os << "kPhyUnknown"; break;
    case EthernetPhy::kPhyIEEE_802_3: os << "kPhyIEEE_802_3"; break;
    case EthernetPhy::kPhyBroadR_Reach: os << "kPhyBroadR_Reach"; break;
    default: os << "<invalid EthernetPhy>"; break;
  }
  return os;
}

inline std::string to_string(EthernetPhy value)
{
  switch (value)
  {
    case EthernetPhy::kPhyUnknown: return "kPhyUnknown";
    case EthernetPhy::kPhyIEEE_802_3: return "kPhyIEEE_802_3";
    case EthernetPhy::kPhyBroadR_Reach: return "kPhyBroadR_Reach";
    default: return "<invalid EthernetPhy>";
  }
}

inline std::wstring to_wstring(EthernetPhy value)
{
  switch (value)
  {
    case EthernetPhy::kPhyUnknown: return L"kPhyUnknown";
    case EthernetPhy::kPhyIEEE_802_3: return L"kPhyIEEE_802_3";
    case EthernetPhy::kPhyBroadR_Reach: return L"kPhyBroadR_Reach";
    default: return L"<invalid EthernetPhy>";
  }
}

enum class Duplex : int32_t
{
      kDuplexUnkown = 0,
      kDuplexHalf = 1,
      kDuplexFull = 2,
}; // enum Duplex

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, Duplex value)
{
  switch (value)
  {
    case Duplex::kDuplexUnkown: os << "kDuplexUnkown"; break;
    case Duplex::kDuplexHalf: os << "kDuplexHalf"; break;
    case Duplex::kDuplexFull: os << "kDuplexFull"; break;
    default: os << "<invalid Duplex>"; break;
  }
  return os;
}

inline std::string to_string(Duplex value)
{
  switch (value)
  {
    case Duplex::kDuplexUnkown: return "kDuplexUnkown";
    case Duplex::kDuplexHalf: return "kDuplexHalf";
    case Duplex::kDuplexFull: return "kDuplexFull";
    default: return "<invalid Duplex>";
  }
}

inline std::wstring to_wstring(Duplex value)
{
  switch (value)
  {
    case Duplex::kDuplexUnkown: return L"kDuplexUnkown";
    case Duplex::kDuplexHalf: return L"kDuplexHalf";
    case Duplex::kDuplexFull: return L"kDuplexFull";
    default: return L"<invalid Duplex>";
  }
}

enum class MdiType : int32_t
{
      kMdiUnknown = 0,
      kMdiStraight = 1,
      kMdiCrossover = 2,
}; // enum MdiType

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, MdiType value)
{
  switch (value)
  {
    case MdiType::kMdiUnknown: os << "kMdiUnknown"; break;
    case MdiType::kMdiStraight: os << "kMdiStraight"; break;
    case MdiType::kMdiCrossover: os << "kMdiCrossover"; break;
    default: os << "<invalid MdiType>"; break;
  }
  return os;
}

inline std::string to_string(MdiType value)
{
  switch (value)
  {
    case MdiType::kMdiUnknown: return "kMdiUnknown";
    case MdiType::kMdiStraight: return "kMdiStraight";
    case MdiType::kMdiCrossover: return "kMdiCrossover";
    default: return "<invalid MdiType>";
  }
}

inline std::wstring to_wstring(MdiType value)
{
  switch (value)
  {
    case MdiType::kMdiUnknown: return L"kMdiUnknown";
    case MdiType::kMdiStraight: return L"kMdiStraight";
    case MdiType::kMdiCrossover: return L"kMdiCrossover";
    default: return L"<invalid MdiType>";
  }
}

enum class Connector : int32_t
{
      kConnectorUnknown = 0,
      kConnectorRJ45 = 1,
      kConnectorDSub = 2,
}; // enum Connector

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, Connector value)
{
  switch (value)
  {
    case Connector::kConnectorUnknown: os << "kConnectorUnknown"; break;
    case Connector::kConnectorRJ45: os << "kConnectorRJ45"; break;
    case Connector::kConnectorDSub: os << "kConnectorDSub"; break;
    default: os << "<invalid Connector>"; break;
  }
  return os;
}

inline std::string to_string(Connector value)
{
  switch (value)
  {
    case Connector::kConnectorUnknown: return "kConnectorUnknown";
    case Connector::kConnectorRJ45: return "kConnectorRJ45";
    case Connector::kConnectorDSub: return "kConnectorDSub";
    default: return "<invalid Connector>";
  }
}

inline std::wstring to_wstring(Connector value)
{
  switch (value)
  {
    case Connector::kConnectorUnknown: return L"kConnectorUnknown";
    case Connector::kConnectorRJ45: return L"kConnectorRJ45";
    case Connector::kConnectorDSub: return L"kConnectorDSub";
    default: return L"<invalid Connector>";
  }
}

enum class ClockMode : int32_t
{
      kClockModeUnknown = 0,
      kClockModeMaster = 1,
      kClockModeSlave = 2,
}; // enum ClockMode

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, ClockMode value)
{
  switch (value)
  {
    case ClockMode::kClockModeUnknown: os << "kClockModeUnknown"; break;
    case ClockMode::kClockModeMaster: os << "kClockModeMaster"; break;
    case ClockMode::kClockModeSlave: os << "kClockModeSlave"; break;
    default: os << "<invalid ClockMode>"; break;
  }
  return os;
}

inline std::string to_string(ClockMode value)
{
  switch (value)
  {
    case ClockMode::kClockModeUnknown: return "kClockModeUnknown";
    case ClockMode::kClockModeMaster: return "kClockModeMaster";
    case ClockMode::kClockModeSlave: return "kClockModeSlave";
    default: return "<invalid ClockMode>";
  }
}

inline std::wstring to_wstring(ClockMode value)
{
  switch (value)
  {
    case ClockMode::kClockModeUnknown: return L"kClockModeUnknown";
    case ClockMode::kClockModeMaster: return L"kClockModeMaster";
    case ClockMode::kClockModeSlave: return L"kClockModeSlave";
    default: return L"<invalid ClockMode>";
  }
}

enum class BrPair : int32_t
{
      kBrPairUnknown = 0,
      kBrPair1Pair = 1,
      kBrPair2Pair = 2,
      kBrPair4Pair = 3,
}; // enum BrPair

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, BrPair value)
{
  switch (value)
  {
    case BrPair::kBrPairUnknown: os << "kBrPairUnknown"; break;
    case BrPair::kBrPair1Pair: os << "kBrPair1Pair"; break;
    case BrPair::kBrPair2Pair: os << "kBrPair2Pair"; break;
    case BrPair::kBrPair4Pair: os << "kBrPair4Pair"; break;
    default: os << "<invalid BrPair>"; break;
  }
  return os;
}

inline std::string to_string(BrPair value)
{
  switch (value)
  {
    case BrPair::kBrPairUnknown: return "kBrPairUnknown";
    case BrPair::kBrPair1Pair: return "kBrPair1Pair";
    case BrPair::kBrPair2Pair: return "kBrPair2Pair";
    case BrPair::kBrPair4Pair: return "kBrPair4Pair";
    default: return "<invalid BrPair>";
  }
}

inline std::wstring to_wstring(BrPair value)
{
  switch (value)
  {
    case BrPair::kBrPairUnknown: return L"kBrPairUnknown";
    case BrPair::kBrPair1Pair: return L"kBrPair1Pair";
    case BrPair::kBrPair2Pair: return L"kBrPair2Pair";
    case BrPair::kBrPair4Pair: return L"kBrPair4Pair";
    default: return L"<invalid BrPair>";
  }
}

enum class CanOperationMode : int32_t
{
      kCanOperationModeCan = 0,
      kCanOperationModeCanFD = 1,
      kCanOperationModeCanXL = 2,
}; // enum CanOperationMode

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, CanOperationMode value)
{
  switch (value)
  {
    case CanOperationMode::kCanOperationModeCan: os << "kCanOperationModeCan"; break;
    case CanOperationMode::kCanOperationModeCanFD: os << "kCanOperationModeCanFD"; break;
    case CanOperationMode::kCanOperationModeCanXL: os << "kCanOperationModeCanXL"; break;
    default: os << "<invalid CanOperationMode>"; break;
  }
  return os;
}

inline std::string to_string(CanOperationMode value)
{
  switch (value)
  {
    case CanOperationMode::kCanOperationModeCan: return "kCanOperationModeCan";
    case CanOperationMode::kCanOperationModeCanFD: return "kCanOperationModeCanFD";
    case CanOperationMode::kCanOperationModeCanXL: return "kCanOperationModeCanXL";
    default: return "<invalid CanOperationMode>";
  }
}

inline std::wstring to_wstring(CanOperationMode value)
{
  switch (value)
  {
    case CanOperationMode::kCanOperationModeCan: return L"kCanOperationModeCan";
    case CanOperationMode::kCanOperationModeCanFD: return L"kCanOperationModeCanFD";
    case CanOperationMode::kCanOperationModeCanXL: return L"kCanOperationModeCanXL";
    default: return L"<invalid CanOperationMode>";
  }
}

enum class CanSamplingMode : int32_t
{
      kCanSamplingModeSampling_1 = 0,
      kCanSamplingModeSampling_3 = 1,
}; // enum CanSamplingMode

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, CanSamplingMode value)
{
  switch (value)
  {
    case CanSamplingMode::kCanSamplingModeSampling_1: os << "kCanSamplingModeSampling_1"; break;
    case CanSamplingMode::kCanSamplingModeSampling_3: os << "kCanSamplingModeSampling_3"; break;
    default: os << "<invalid CanSamplingMode>"; break;
  }
  return os;
}

inline std::string to_string(CanSamplingMode value)
{
  switch (value)
  {
    case CanSamplingMode::kCanSamplingModeSampling_1: return "kCanSamplingModeSampling_1";
    case CanSamplingMode::kCanSamplingModeSampling_3: return "kCanSamplingModeSampling_3";
    default: return "<invalid CanSamplingMode>";
  }
}

inline std::wstring to_wstring(CanSamplingMode value)
{
  switch (value)
  {
    case CanSamplingMode::kCanSamplingModeSampling_1: return L"kCanSamplingModeSampling_1";
    case CanSamplingMode::kCanSamplingModeSampling_3: return L"kCanSamplingModeSampling_3";
    default: return L"<invalid CanSamplingMode>";
  }
}

enum class CanBusState : int32_t
{
      kCanBusStateOnline = 0,
      kCanBusStateOffline = 1,
      kCanBusStateError = 2,
}; // enum CanBusState

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, CanBusState value)
{
  switch (value)
  {
    case CanBusState::kCanBusStateOnline: os << "kCanBusStateOnline"; break;
    case CanBusState::kCanBusStateOffline: os << "kCanBusStateOffline"; break;
    case CanBusState::kCanBusStateError: os << "kCanBusStateError"; break;
    default: os << "<invalid CanBusState>"; break;
  }
  return os;
}

inline std::string to_string(CanBusState value)
{
  switch (value)
  {
    case CanBusState::kCanBusStateOnline: return "kCanBusStateOnline";
    case CanBusState::kCanBusStateOffline: return "kCanBusStateOffline";
    case CanBusState::kCanBusStateError: return "kCanBusStateError";
    default: return "<invalid CanBusState>";
  }
}

inline std::wstring to_wstring(CanBusState value)
{
  switch (value)
  {
    case CanBusState::kCanBusStateOnline: return L"kCanBusStateOnline";
    case CanBusState::kCanBusStateOffline: return L"kCanBusStateOffline";
    case CanBusState::kCanBusStateError: return L"kCanBusStateError";
    default: return L"<invalid CanBusState>";
  }
}

enum class FlexRayChannel : uint8_t
{
      None = 0,
      A = 1,
      B = 2,
      AB = 3,
}; // enum FlexRayChannel

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, FlexRayChannel value)
{
  switch (value)
  {
    case FlexRayChannel::None: os << "None"; break;
    case FlexRayChannel::A: os << "A"; break;
    case FlexRayChannel::B: os << "B"; break;
    case FlexRayChannel::AB: os << "AB"; break;
    default: os << "<invalid FlexRayChannel>"; break;
  }
  return os;
}

inline std::string to_string(FlexRayChannel value)
{
  switch (value)
  {
    case FlexRayChannel::None: return "None";
    case FlexRayChannel::A: return "A";
    case FlexRayChannel::B: return "B";
    case FlexRayChannel::AB: return "AB";
    default: return "<invalid FlexRayChannel>";
  }
}

inline std::wstring to_wstring(FlexRayChannel value)
{
  switch (value)
  {
    case FlexRayChannel::None: return L"None";
    case FlexRayChannel::A: return L"A";
    case FlexRayChannel::B: return L"B";
    case FlexRayChannel::AB: return L"AB";
    default: return L"<invalid FlexRayChannel>";
  }
}

enum class FlexRaySymbolPattern : uint8_t
{
      CAS = 0,
      WUP = 1,
      WUDOP = 2,
}; // enum FlexRaySymbolPattern

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, FlexRaySymbolPattern value)
{
  switch (value)
  {
    case FlexRaySymbolPattern::CAS: os << "CAS"; break;
    case FlexRaySymbolPattern::WUP: os << "WUP"; break;
    case FlexRaySymbolPattern::WUDOP: os << "WUDOP"; break;
    default: os << "<invalid FlexRaySymbolPattern>"; break;
  }
  return os;
}

inline std::string to_string(FlexRaySymbolPattern value)
{
  switch (value)
  {
    case FlexRaySymbolPattern::CAS: return "CAS";
    case FlexRaySymbolPattern::WUP: return "WUP";
    case FlexRaySymbolPattern::WUDOP: return "WUDOP";
    default: return "<invalid FlexRaySymbolPattern>";
  }
}

inline std::wstring to_wstring(FlexRaySymbolPattern value)
{
  switch (value)
  {
    case FlexRaySymbolPattern::CAS: return L"CAS";
    case FlexRaySymbolPattern::WUP: return L"WUP";
    case FlexRaySymbolPattern::WUDOP: return L"WUDOP";
    default: return L"<invalid FlexRaySymbolPattern>";
  }
}

enum class FlexRayChiCommand : uint8_t
{
      RUN = 0,
      DEFERRED_HALT = 1,
      FREEZE = 2,
      ALLOW_COLDSTART = 3,
      ALL_SLOTS = 4,
      WAKEUP = 5,
}; // enum FlexRayChiCommand

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, FlexRayChiCommand value)
{
  switch (value)
  {
    case FlexRayChiCommand::RUN: os << "RUN"; break;
    case FlexRayChiCommand::DEFERRED_HALT: os << "DEFERRED_HALT"; break;
    case FlexRayChiCommand::FREEZE: os << "FREEZE"; break;
    case FlexRayChiCommand::ALLOW_COLDSTART: os << "ALLOW_COLDSTART"; break;
    case FlexRayChiCommand::ALL_SLOTS: os << "ALL_SLOTS"; break;
    case FlexRayChiCommand::WAKEUP: os << "WAKEUP"; break;
    default: os << "<invalid FlexRayChiCommand>"; break;
  }
  return os;
}

inline std::string to_string(FlexRayChiCommand value)
{
  switch (value)
  {
    case FlexRayChiCommand::RUN: return "RUN";
    case FlexRayChiCommand::DEFERRED_HALT: return "DEFERRED_HALT";
    case FlexRayChiCommand::FREEZE: return "FREEZE";
    case FlexRayChiCommand::ALLOW_COLDSTART: return "ALLOW_COLDSTART";
    case FlexRayChiCommand::ALL_SLOTS: return "ALL_SLOTS";
    case FlexRayChiCommand::WAKEUP: return "WAKEUP";
    default: return "<invalid FlexRayChiCommand>";
  }
}

inline std::wstring to_wstring(FlexRayChiCommand value)
{
  switch (value)
  {
    case FlexRayChiCommand::RUN: return L"RUN";
    case FlexRayChiCommand::DEFERRED_HALT: return L"DEFERRED_HALT";
    case FlexRayChiCommand::FREEZE: return L"FREEZE";
    case FlexRayChiCommand::ALLOW_COLDSTART: return L"ALLOW_COLDSTART";
    case FlexRayChiCommand::ALL_SLOTS: return L"ALL_SLOTS";
    case FlexRayChiCommand::WAKEUP: return L"WAKEUP";
    default: return L"<invalid FlexRayChiCommand>";
  }
}

enum class FlexRayTransmissionMode : uint8_t
{
      SingleShot = 0,
      Continuous = 1,
}; // enum FlexRayTransmissionMode

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, FlexRayTransmissionMode value)
{
  switch (value)
  {
    case FlexRayTransmissionMode::SingleShot: os << "SingleShot"; break;
    case FlexRayTransmissionMode::Continuous: os << "Continuous"; break;
    default: os << "<invalid FlexRayTransmissionMode>"; break;
  }
  return os;
}

inline std::string to_string(FlexRayTransmissionMode value)
{
  switch (value)
  {
    case FlexRayTransmissionMode::SingleShot: return "SingleShot";
    case FlexRayTransmissionMode::Continuous: return "Continuous";
    default: return "<invalid FlexRayTransmissionMode>";
  }
}

inline std::wstring to_wstring(FlexRayTransmissionMode value)
{
  switch (value)
  {
    case FlexRayTransmissionMode::SingleShot: return L"SingleShot";
    case FlexRayTransmissionMode::Continuous: return L"Continuous";
    default: return L"<invalid FlexRayTransmissionMode>";
  }
}

enum class FlexRayPocState : uint8_t
{
      DefaultConfig = 0,
      Config = 1,
      Ready = 2,
      Startup = 3,
      Wakeup = 4,
      NormalActive = 5,
      NormalPassive = 6,
      Halt = 7,
}; // enum FlexRayPocState

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, FlexRayPocState value)
{
  switch (value)
  {
    case FlexRayPocState::DefaultConfig: os << "DefaultConfig"; break;
    case FlexRayPocState::Config: os << "Config"; break;
    case FlexRayPocState::Ready: os << "Ready"; break;
    case FlexRayPocState::Startup: os << "Startup"; break;
    case FlexRayPocState::Wakeup: os << "Wakeup"; break;
    case FlexRayPocState::NormalActive: os << "NormalActive"; break;
    case FlexRayPocState::NormalPassive: os << "NormalPassive"; break;
    case FlexRayPocState::Halt: os << "Halt"; break;
    default: os << "<invalid FlexRayPocState>"; break;
  }
  return os;
}

inline std::string to_string(FlexRayPocState value)
{
  switch (value)
  {
    case FlexRayPocState::DefaultConfig: return "DefaultConfig";
    case FlexRayPocState::Config: return "Config";
    case FlexRayPocState::Ready: return "Ready";
    case FlexRayPocState::Startup: return "Startup";
    case FlexRayPocState::Wakeup: return "Wakeup";
    case FlexRayPocState::NormalActive: return "NormalActive";
    case FlexRayPocState::NormalPassive: return "NormalPassive";
    case FlexRayPocState::Halt: return "Halt";
    default: return "<invalid FlexRayPocState>";
  }
}

inline std::wstring to_wstring(FlexRayPocState value)
{
  switch (value)
  {
    case FlexRayPocState::DefaultConfig: return L"DefaultConfig";
    case FlexRayPocState::Config: return L"Config";
    case FlexRayPocState::Ready: return L"Ready";
    case FlexRayPocState::Startup: return L"Startup";
    case FlexRayPocState::Wakeup: return L"Wakeup";
    case FlexRayPocState::NormalActive: return L"NormalActive";
    case FlexRayPocState::NormalPassive: return L"NormalPassive";
    case FlexRayPocState::Halt: return L"Halt";
    default: return L"<invalid FlexRayPocState>";
  }
}

enum class FlexRaySlotModeType : uint8_t
{
      KeySlot = 0,
      AllPending = 1,
      All = 2,
}; // enum FlexRaySlotModeType

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, FlexRaySlotModeType value)
{
  switch (value)
  {
    case FlexRaySlotModeType::KeySlot: os << "KeySlot"; break;
    case FlexRaySlotModeType::AllPending: os << "AllPending"; break;
    case FlexRaySlotModeType::All: os << "All"; break;
    default: os << "<invalid FlexRaySlotModeType>"; break;
  }
  return os;
}

inline std::string to_string(FlexRaySlotModeType value)
{
  switch (value)
  {
    case FlexRaySlotModeType::KeySlot: return "KeySlot";
    case FlexRaySlotModeType::AllPending: return "AllPending";
    case FlexRaySlotModeType::All: return "All";
    default: return "<invalid FlexRaySlotModeType>";
  }
}

inline std::wstring to_wstring(FlexRaySlotModeType value)
{
  switch (value)
  {
    case FlexRaySlotModeType::KeySlot: return L"KeySlot";
    case FlexRaySlotModeType::AllPending: return L"AllPending";
    case FlexRaySlotModeType::All: return L"All";
    default: return L"<invalid FlexRaySlotModeType>";
  }
}

enum class FlexRayErrorModeType : uint8_t
{
      Active = 0,
      Passive = 1,
      CommHalt = 2,
}; // enum FlexRayErrorModeType

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, FlexRayErrorModeType value)
{
  switch (value)
  {
    case FlexRayErrorModeType::Active: os << "Active"; break;
    case FlexRayErrorModeType::Passive: os << "Passive"; break;
    case FlexRayErrorModeType::CommHalt: os << "CommHalt"; break;
    default: os << "<invalid FlexRayErrorModeType>"; break;
  }
  return os;
}

inline std::string to_string(FlexRayErrorModeType value)
{
  switch (value)
  {
    case FlexRayErrorModeType::Active: return "Active";
    case FlexRayErrorModeType::Passive: return "Passive";
    case FlexRayErrorModeType::CommHalt: return "CommHalt";
    default: return "<invalid FlexRayErrorModeType>";
  }
}

inline std::wstring to_wstring(FlexRayErrorModeType value)
{
  switch (value)
  {
    case FlexRayErrorModeType::Active: return L"Active";
    case FlexRayErrorModeType::Passive: return L"Passive";
    case FlexRayErrorModeType::CommHalt: return L"CommHalt";
    default: return L"<invalid FlexRayErrorModeType>";
  }
}

enum class FlexRayStartupStateType : uint8_t
{
      Undefined = 0,
      ColdStartListen = 1,
      IntegrationColdstartCheck = 2,
      ColdStartJoin = 3,
      ColdStartCollisionResolution = 4,
      ColdStartConsistencyCheck = 5,
      IntegrationListen = 6,
      InitializeSchedule = 7,
      IntegrationConsistencyCheck = 8,
      ColdStartGap = 9,
      ExternalStartup = 10,
}; // enum FlexRayStartupStateType

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, FlexRayStartupStateType value)
{
  switch (value)
  {
    case FlexRayStartupStateType::Undefined: os << "Undefined"; break;
    case FlexRayStartupStateType::ColdStartListen: os << "ColdStartListen"; break;
    case FlexRayStartupStateType::IntegrationColdstartCheck: os << "IntegrationColdstartCheck"; break;
    case FlexRayStartupStateType::ColdStartJoin: os << "ColdStartJoin"; break;
    case FlexRayStartupStateType::ColdStartCollisionResolution: os << "ColdStartCollisionResolution"; break;
    case FlexRayStartupStateType::ColdStartConsistencyCheck: os << "ColdStartConsistencyCheck"; break;
    case FlexRayStartupStateType::IntegrationListen: os << "IntegrationListen"; break;
    case FlexRayStartupStateType::InitializeSchedule: os << "InitializeSchedule"; break;
    case FlexRayStartupStateType::IntegrationConsistencyCheck: os << "IntegrationConsistencyCheck"; break;
    case FlexRayStartupStateType::ColdStartGap: os << "ColdStartGap"; break;
    case FlexRayStartupStateType::ExternalStartup: os << "ExternalStartup"; break;
    default: os << "<invalid FlexRayStartupStateType>"; break;
  }
  return os;
}

inline std::string to_string(FlexRayStartupStateType value)
{
  switch (value)
  {
    case FlexRayStartupStateType::Undefined: return "Undefined";
    case FlexRayStartupStateType::ColdStartListen: return "ColdStartListen";
    case FlexRayStartupStateType::IntegrationColdstartCheck: return "IntegrationColdstartCheck";
    case FlexRayStartupStateType::ColdStartJoin: return "ColdStartJoin";
    case FlexRayStartupStateType::ColdStartCollisionResolution: return "ColdStartCollisionResolution";
    case FlexRayStartupStateType::ColdStartConsistencyCheck: return "ColdStartConsistencyCheck";
    case FlexRayStartupStateType::IntegrationListen: return "IntegrationListen";
    case FlexRayStartupStateType::InitializeSchedule: return "InitializeSchedule";
    case FlexRayStartupStateType::IntegrationConsistencyCheck: return "IntegrationConsistencyCheck";
    case FlexRayStartupStateType::ColdStartGap: return "ColdStartGap";
    case FlexRayStartupStateType::ExternalStartup: return "ExternalStartup";
    default: return "<invalid FlexRayStartupStateType>";
  }
}

inline std::wstring to_wstring(FlexRayStartupStateType value)
{
  switch (value)
  {
    case FlexRayStartupStateType::Undefined: return L"Undefined";
    case FlexRayStartupStateType::ColdStartListen: return L"ColdStartListen";
    case FlexRayStartupStateType::IntegrationColdstartCheck: return L"IntegrationColdstartCheck";
    case FlexRayStartupStateType::ColdStartJoin: return L"ColdStartJoin";
    case FlexRayStartupStateType::ColdStartCollisionResolution: return L"ColdStartCollisionResolution";
    case FlexRayStartupStateType::ColdStartConsistencyCheck: return L"ColdStartConsistencyCheck";
    case FlexRayStartupStateType::IntegrationListen: return L"IntegrationListen";
    case FlexRayStartupStateType::InitializeSchedule: return L"InitializeSchedule";
    case FlexRayStartupStateType::IntegrationConsistencyCheck: return L"IntegrationConsistencyCheck";
    case FlexRayStartupStateType::ColdStartGap: return L"ColdStartGap";
    case FlexRayStartupStateType::ExternalStartup: return L"ExternalStartup";
    default: return L"<invalid FlexRayStartupStateType>";
  }
}

enum class FlexRayWakeupStatusType : uint8_t
{
      Undefined = 0,
      ReceivedHeader = 1,
      ReceivedWup = 2,
      CollisionHeader = 3,
      CollisionWup = 4,
      CollisionUnknown = 5,
      Transmitted = 6,
}; // enum FlexRayWakeupStatusType

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, FlexRayWakeupStatusType value)
{
  switch (value)
  {
    case FlexRayWakeupStatusType::Undefined: os << "Undefined"; break;
    case FlexRayWakeupStatusType::ReceivedHeader: os << "ReceivedHeader"; break;
    case FlexRayWakeupStatusType::ReceivedWup: os << "ReceivedWup"; break;
    case FlexRayWakeupStatusType::CollisionHeader: os << "CollisionHeader"; break;
    case FlexRayWakeupStatusType::CollisionWup: os << "CollisionWup"; break;
    case FlexRayWakeupStatusType::CollisionUnknown: os << "CollisionUnknown"; break;
    case FlexRayWakeupStatusType::Transmitted: os << "Transmitted"; break;
    default: os << "<invalid FlexRayWakeupStatusType>"; break;
  }
  return os;
}

inline std::string to_string(FlexRayWakeupStatusType value)
{
  switch (value)
  {
    case FlexRayWakeupStatusType::Undefined: return "Undefined";
    case FlexRayWakeupStatusType::ReceivedHeader: return "ReceivedHeader";
    case FlexRayWakeupStatusType::ReceivedWup: return "ReceivedWup";
    case FlexRayWakeupStatusType::CollisionHeader: return "CollisionHeader";
    case FlexRayWakeupStatusType::CollisionWup: return "CollisionWup";
    case FlexRayWakeupStatusType::CollisionUnknown: return "CollisionUnknown";
    case FlexRayWakeupStatusType::Transmitted: return "Transmitted";
    default: return "<invalid FlexRayWakeupStatusType>";
  }
}

inline std::wstring to_wstring(FlexRayWakeupStatusType value)
{
  switch (value)
  {
    case FlexRayWakeupStatusType::Undefined: return L"Undefined";
    case FlexRayWakeupStatusType::ReceivedHeader: return L"ReceivedHeader";
    case FlexRayWakeupStatusType::ReceivedWup: return L"ReceivedWup";
    case FlexRayWakeupStatusType::CollisionHeader: return L"CollisionHeader";
    case FlexRayWakeupStatusType::CollisionWup: return L"CollisionWup";
    case FlexRayWakeupStatusType::CollisionUnknown: return L"CollisionUnknown";
    case FlexRayWakeupStatusType::Transmitted: return L"Transmitted";
    default: return L"<invalid FlexRayWakeupStatusType>";
  }
}

enum class FlexRayClockPeriod : uint8_t
{
      T12_5NS = 1,
      T25NS = 2,
      T50NS = 3,
}; // enum FlexRayClockPeriod

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, FlexRayClockPeriod value)
{
  switch (value)
  {
    case FlexRayClockPeriod::T12_5NS: os << "T12_5NS"; break;
    case FlexRayClockPeriod::T25NS: os << "T25NS"; break;
    case FlexRayClockPeriod::T50NS: os << "T50NS"; break;
    default: os << "<invalid FlexRayClockPeriod>"; break;
  }
  return os;
}

inline std::string to_string(FlexRayClockPeriod value)
{
  switch (value)
  {
    case FlexRayClockPeriod::T12_5NS: return "T12_5NS";
    case FlexRayClockPeriod::T25NS: return "T25NS";
    case FlexRayClockPeriod::T50NS: return "T50NS";
    default: return "<invalid FlexRayClockPeriod>";
  }
}

inline std::wstring to_wstring(FlexRayClockPeriod value)
{
  switch (value)
  {
    case FlexRayClockPeriod::T12_5NS: return L"T12_5NS";
    case FlexRayClockPeriod::T25NS: return L"T25NS";
    case FlexRayClockPeriod::T50NS: return L"T50NS";
    default: return L"<invalid FlexRayClockPeriod>";
  }
}

// Base class for all bus events, inclulding error and status events
class BusEvent
{
  public:
    virtual ~BusEvent() noexcept {}
    virtual uint32_t getVersion() const = 0;

}; // class BusEvent

// Base class for all other bus messages
class BusMessage : public BusEvent
{
  public:
    virtual ~BusMessage() noexcept {}
    virtual void SetClientIndex(int16_t value) = 0;
    virtual int16_t GetClientIndex() const = 0;
    virtual bool IsClientIndexAvailable() const = 0;
    virtual void SetDir(DirMask value) = 0;
    virtual DirMask GetDir() const = 0;
    virtual bool IsDirAvailable() const = 0;
    virtual void SetOriginalTimeStamp(VTimeNS value) = 0;
    virtual VTimeNS GetOriginalTimeStamp() const = 0;
    virtual bool IsOriginalTimeStampAvailable() const = 0;
    virtual void SetSimulated(SimulatedFlag value) = 0;
    virtual SimulatedFlag GetSimulated() const = 0;
    virtual bool IsSimulatedAvailable() const = 0;

}; // class BusMessage

// CAN Frame
class CANFrame : public BusMessage
{
  public:
    virtual ~CANFrame() noexcept {}
    virtual void SetId(VMessageId value) = 0;
    virtual VMessageId GetId() const = 0;
    virtual bool IsIdAvailable() const = 0;
    virtual void SetFlags(int32_t value) = 0;
    virtual int32_t GetFlags() const = 0;
    virtual bool IsFlagsAvailable() const = 0;
    virtual void SetDataLength(uint8_t value) = 0;
    virtual uint8_t GetDataLength() const = 0;
    virtual bool IsDataLengthAvailable() const = 0;
    virtual void SetData(const std::vector<uint8_t>& value) = 0;
    virtual void SetData(const uint8_t* value, size_t size) = 0;
    virtual const std::vector<uint8_t>& GetData() const = 0;
    virtual bool IsDataAvailable() const = 0;
    virtual void SetFrameLengthNS(int32_t value) = 0;
    virtual int32_t GetFrameLengthNS() const = 0;
    virtual bool IsFrameLengthNSAvailable() const = 0;
    virtual void SetBitCount(int16_t value) = 0;
    virtual int16_t GetBitCount() const = 0;
    virtual bool IsBitCountAvailable() const = 0;

}; // class CANFrame

// CAN Error Frame
class CANErrorFrame : public BusEvent
{
  public:
    virtual ~CANErrorFrame() noexcept {}
    virtual void SetErrorBitPosition(int16_t value) = 0;
    virtual int16_t GetErrorBitPosition() const = 0;
    virtual bool IsErrorBitPositionAvailable() const = 0;
    virtual void SetFrameLengthNS(int32_t value) = 0;
    virtual int32_t GetFrameLengthNS() const = 0;
    virtual bool IsFrameLengthNSAvailable() const = 0;
    virtual void SetClientIndex(int16_t value) = 0;
    virtual int16_t GetClientIndex() const = 0;
    virtual bool IsClientIndexAvailable() const = 0;

}; // class CANErrorFrame

// Ethernet Status Event
class EthernetStatus : public BusEvent
{
  public:
    virtual ~EthernetStatus() noexcept {}
    virtual void SetBusType(int16_t value) = 0;
    virtual int16_t GetBusType() const = 0;
    virtual bool IsBusTypeAvailable() const = 0;
    virtual void SetHardwareChannel(int64_t value) = 0;
    virtual int64_t GetHardwareChannel() const = 0;
    virtual bool IsHardwareChannelAvailable() const = 0;
    virtual void SetLinkStatus(LinkStatus value) = 0;
    virtual LinkStatus GetLinkStatus() const = 0;
    virtual bool IsLinkStatusAvailable() const = 0;
    virtual void SetBitrate(int32_t value) = 0;
    virtual int32_t GetBitrate() const = 0;
    virtual bool IsBitrateAvailable() const = 0;
    virtual void SetEthernetPhy(EthernetPhy value) = 0;
    virtual EthernetPhy GetEthernetPhy() const = 0;
    virtual bool IsEthernetPhyAvailable() const = 0;
    virtual void SetDuplex(Duplex value) = 0;
    virtual Duplex GetDuplex() const = 0;
    virtual bool IsDuplexAvailable() const = 0;
    virtual void SetMdiType(MdiType value) = 0;
    virtual MdiType GetMdiType() const = 0;
    virtual bool IsMdiTypeAvailable() const = 0;
    virtual void SetConnector(Connector value) = 0;
    virtual Connector GetConnector() const = 0;
    virtual bool IsConnectorAvailable() const = 0;
    virtual void SetClockMode(ClockMode value) = 0;
    virtual ClockMode GetClockMode() const = 0;
    virtual bool IsClockModeAvailable() const = 0;
    virtual void SetBrPair(BrPair value) = 0;
    virtual BrPair GetBrPair() const = 0;
    virtual bool IsBrPairAvailable() const = 0;
    virtual void SetDeviceOperationMode(int32_t value) = 0;
    virtual int32_t GetDeviceOperationMode() const = 0;
    virtual bool IsDeviceOperationModeAvailable() const = 0;

}; // class EthernetStatus

// Ethernet Packet
class EthernetPacket : public BusMessage
{
  public:
    virtual ~EthernetPacket() noexcept {}
    virtual void SetBusType(int16_t value) = 0;
    virtual int16_t GetBusType() const = 0;
    virtual bool IsBusTypeAvailable() const = 0;
    virtual void SetHardwareChannel(int64_t value) = 0;
    virtual int64_t GetHardwareChannel() const = 0;
    virtual bool IsHardwareChannelAvailable() const = 0;
    virtual void SetFrameDuration(VTimeNS value) = 0;
    virtual VTimeNS GetFrameDuration() const = 0;
    virtual bool IsFrameDurationAvailable() const = 0;
    virtual void SetEthernetChecksum(int32_t value) = 0;
    virtual int32_t GetEthernetChecksum() const = 0;
    virtual bool IsEthernetChecksumAvailable() const = 0;
    virtual void SetPacketData(const std::vector<uint8_t>& value) = 0;
    virtual void SetPacketData(const uint8_t* value, size_t size) = 0;
    virtual const std::vector<uint8_t>& GetPacketData() const = 0;
    virtual bool IsPacketDataAvailable() const = 0;

}; // class EthernetPacket

class EthernetPacketForwarded : public EthernetPacket
{
  public:
    virtual ~EthernetPacketForwarded() noexcept {}

}; // class EthernetPacketForwarded

class EthernetPacketError : public BusMessage
{
  public:
    virtual ~EthernetPacketError() noexcept {}
    virtual void SetBusType(int16_t value) = 0;
    virtual int16_t GetBusType() const = 0;
    virtual bool IsBusTypeAvailable() const = 0;
    virtual void SetHardwareChannel(int64_t value) = 0;
    virtual int64_t GetHardwareChannel() const = 0;
    virtual bool IsHardwareChannelAvailable() const = 0;
    virtual void SetFrameDuration(VTimeNS value) = 0;
    virtual VTimeNS GetFrameDuration() const = 0;
    virtual bool IsFrameDurationAvailable() const = 0;
    virtual void SetErrorCode(int32_t value) = 0;
    virtual int32_t GetErrorCode() const = 0;
    virtual bool IsErrorCodeAvailable() const = 0;
    virtual void SetEthernetChecksum(int32_t value) = 0;
    virtual int32_t GetEthernetChecksum() const = 0;
    virtual bool IsEthernetChecksumAvailable() const = 0;
    virtual void SetPacketData(const std::vector<uint8_t>& value) = 0;
    virtual void SetPacketData(const uint8_t* value, size_t size) = 0;
    virtual const std::vector<uint8_t>& GetPacketData() const = 0;
    virtual bool IsPacketDataAvailable() const = 0;

}; // class EthernetPacketError

class EthernetPacketErrorForwarded : public EthernetPacketError
{
  public:
    virtual ~EthernetPacketErrorForwarded() noexcept {}

}; // class EthernetPacketErrorForwarded

// Payload of FlexRay Frame
class FlexRayPayload : public BusMessage
{
  public:
    virtual ~FlexRayPayload() noexcept {}
    virtual void SetPayloadData(const std::vector<uint8_t>& value) = 0;
    virtual void SetPayloadData(const uint8_t* value, size_t size) = 0;
    virtual const std::vector<uint8_t>& GetPayloadData() const = 0;
    virtual bool IsPayloadDataAvailable() const = 0;
    virtual void SetPayloadValid(bool value) = 0;
    virtual bool GetPayloadValid() const = 0;
    virtual bool IsPayloadValidAvailable() const = 0;

}; // class FlexRayPayload

// Header of FlexRay Frame
class FlexRayHeader
{
  public:
    virtual ~FlexRayHeader() noexcept {}
    virtual uint32_t getVersion() const = 0;
    virtual void SetSuFindicator(bool value) = 0;
    virtual bool GetSuFindicator() const = 0;
    virtual bool IsSuFindicatorAvailable() const = 0;
    virtual void SetSyFIndicator(bool value) = 0;
    virtual bool GetSyFIndicator() const = 0;
    virtual bool IsSyFIndicatorAvailable() const = 0;
    virtual void SetNFIndicator(bool value) = 0;
    virtual bool GetNFIndicator() const = 0;
    virtual bool IsNFIndicatorAvailable() const = 0;
    virtual void SetPPIndicator(bool value) = 0;
    virtual bool GetPPIndicator() const = 0;
    virtual bool IsPPIndicatorAvailable() const = 0;
    virtual void SetFrameID(int16_t value) = 0;
    virtual int16_t GetFrameID() const = 0;
    virtual bool IsFrameIDAvailable() const = 0;
    virtual void SetpayloadLength(uint8_t value) = 0;
    virtual uint8_t GetpayloadLength() const = 0;
    virtual bool IspayloadLengthAvailable() const = 0;
    virtual void SetHeaderCRC(int16_t value) = 0;
    virtual int16_t GetHeaderCRC() const = 0;
    virtual bool IsHeaderCRCAvailable() const = 0;
    virtual void SetCycle(uint8_t value) = 0;
    virtual uint8_t GetCycle() const = 0;
    virtual bool IsCycleAvailable() const = 0;

}; // class FlexRayHeader

// FlexRay Frame
class FlexRayFrame : public FlexRayPayload
{
  public:
    virtual ~FlexRayFrame() noexcept {}

}; // class FlexRayFrame


} // namespace NDistSimIB
} // namespace NRTFederateEncoding
