
// Code automatically generated by FOMCodeGen version 2.0.4.0 from RTFederate.xml, do not edit

// Name: CANoe RT Federate
// Copyright: Copyright (c) Vector Informatik GmbH. All rights reserved.
// Version: 1.0
// Description: CANoe Simulation Object Model

#pragma once

#include <vector>
#include <functional>


#include "RTFederateDataTypes.h"
#include "RTFederateObjectInterfaces.h"

namespace NDistSimIB {
namespace NRTFederateEncoding {

// IHLAinteractionRootInteractionClass represents the HLA interaction class HLAinteractionRoot.
class IHLAinteractionRootInteractionClass
{
  public:
    // Publish/unpublish the interaction class. Sending an interaction of this class requires publishing the interaction class.
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    // Subscribe the interaction class. Receiving interactions requires having subscribed to this interaction class.
    // Note that the appropriate callbacks should have been registered *before* subscribing to the interaction class.
    virtual void Subscribe(bool deliverToSelf) = 0;
    // Unsubscribe the interaction class, cancelling reception of interactions. Calling Unsubscribe will also clear all filtered subscriptions, if any.
    virtual void Unsubscribe() = 0;
    // Send an interaction as receive order message.
    virtual void send() = 0;
    // Send a time stamped interaction.
    virtual void sendWithTime(int64_t time) = 0;
    // Register an interaction callback. The optional time stamp will be delivered by the application. When the time stamp is valid,
    // the optional order type will indicate the source of the time stamp.
    using ReceiveCallback = std::function<void(optional<int64_t> time, optional<OrderType> orderType, bool sentBySelf)>;
    virtual uint32_t RegisterReceiveCallback(ReceiveCallback callback) = 0;
};

// IMeasurementInitInteractionClass represents the HLA interaction class HLAinteractionRoot.MeasurementInit.
class IMeasurementInitInteractionClass
{
  public:
    // Publish/unpublish the interaction class. Sending an interaction of this class requires publishing the interaction class.
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    // Subscribe the interaction class. Receiving interactions requires having subscribed to this interaction class.
    // Note that the appropriate callbacks should have been registered *before* subscribing to the interaction class.
    virtual void Subscribe(bool deliverToSelf) = 0;
    // Unsubscribe the interaction class, cancelling reception of interactions. Calling Unsubscribe will also clear all filtered subscriptions, if any.
    virtual void Unsubscribe() = 0;
    // Send an interaction as receive order message.
    virtual void send() = 0;
    // Send a time stamped interaction.
    virtual void sendWithTime(int64_t time) = 0;
    // Register an interaction callback. The optional time stamp will be delivered by the application. When the time stamp is valid,
    // the optional order type will indicate the source of the time stamp.
    using ReceiveCallback = std::function<void(optional<int64_t> time, optional<OrderType> orderType, bool sentBySelf)>;
    virtual uint32_t RegisterReceiveCallback(ReceiveCallback callback) = 0;
};

// IMeasurementStopInteractionClass represents the HLA interaction class HLAinteractionRoot.MeasurementStop.
class IMeasurementStopInteractionClass
{
  public:
    // Publish/unpublish the interaction class. Sending an interaction of this class requires publishing the interaction class.
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    // Subscribe the interaction class. Receiving interactions requires having subscribed to this interaction class.
    // Note that the appropriate callbacks should have been registered *before* subscribing to the interaction class.
    virtual void Subscribe(bool deliverToSelf) = 0;
    // Subscribe the interaction class with filter values. Only interactions with parameters matching the given values will be received.
    // Filtered subscriptions may be issued several times with differing value tuples. 'nullopt' may be used as a wildcard, matching
    // any incoming value.
    virtual void Subscribe(optional<std::wstring> NextFederationSuffix, bool deliverToSelf) = 0;
    // Unsubscribe the interaction class, cancelling reception of interactions. Calling Unsubscribe will also clear all filtered subscriptions, if any.
    virtual void Unsubscribe() = 0;
    // Send an interaction as receive order message.
    virtual void send(optional<std::wstring> NextFederationSuffix) = 0;
    // Send a time stamped interaction.
    virtual void sendWithTime(optional<std::wstring> NextFederationSuffix, int64_t time) = 0;
    // Register an interaction callback. The optional time stamp will be delivered by the application. When the time stamp is valid,
    // the optional order type will indicate the source of the time stamp.
    using ReceiveCallback = std::function<void(optional<std::wstring> NextFederationSuffix, optional<int64_t> time, optional<OrderType> orderType, bool sentBySelf)>;
    virtual uint32_t RegisterReceiveCallback(ReceiveCallback callback) = 0;
};

// IKeyEventInteractionClass represents the HLA interaction class HLAinteractionRoot.KeyEvent.
class IKeyEventInteractionClass
{
  public:
    // Publish/unpublish the interaction class. Sending an interaction of this class requires publishing the interaction class.
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    // Subscribe the interaction class. Receiving interactions requires having subscribed to this interaction class.
    // Note that the appropriate callbacks should have been registered *before* subscribing to the interaction class.
    virtual void Subscribe(bool deliverToSelf) = 0;
    // Subscribe the interaction class with filter values. Only interactions with parameters matching the given values will be received.
    // Filtered subscriptions may be issued several times with differing value tuples. 'nullopt' may be used as a wildcard, matching
    // any incoming value.
    virtual void Subscribe(optional<int32_t> KeyCode, bool deliverToSelf) = 0;
    // Unsubscribe the interaction class, cancelling reception of interactions. Calling Unsubscribe will also clear all filtered subscriptions, if any.
    virtual void Unsubscribe() = 0;
    // Send an interaction as receive order message.
    virtual void send(optional<int32_t> KeyCode) = 0;
    // Send a time stamped interaction.
    virtual void sendWithTime(optional<int32_t> KeyCode, int64_t time) = 0;
    // Register an interaction callback. The optional time stamp will be delivered by the application. When the time stamp is valid,
    // the optional order type will indicate the source of the time stamp.
    using ReceiveCallback = std::function<void(optional<int32_t> KeyCode, optional<int64_t> time, optional<OrderType> orderType, bool sentBySelf)>;
    virtual uint32_t RegisterReceiveCallback(ReceiveCallback callback) = 0;
};

// ITextLogInteractionClass represents the HLA interaction class HLAinteractionRoot.TextLog.
class ITextLogInteractionClass
{
  public:
    // Publish/unpublish the interaction class. Sending an interaction of this class requires publishing the interaction class.
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    // Subscribe the interaction class. Receiving interactions requires having subscribed to this interaction class.
    // Note that the appropriate callbacks should have been registered *before* subscribing to the interaction class.
    virtual void Subscribe(bool deliverToSelf) = 0;
    // Subscribe the interaction class with filter values. Only interactions with parameters matching the given values will be received.
    // Filtered subscriptions may be issued several times with differing value tuples. 'nullopt' may be used as a wildcard, matching
    // any incoming value.
    virtual void Subscribe(optional<std::wstring> Sender, optional<std::wstring> Text, bool deliverToSelf) = 0;
    // Unsubscribe the interaction class, cancelling reception of interactions. Calling Unsubscribe will also clear all filtered subscriptions, if any.
    virtual void Unsubscribe() = 0;
    // Send an interaction as receive order message.
    virtual void send(optional<std::wstring> Sender, optional<std::wstring> Text) = 0;
    // Send a time stamped interaction.
    virtual void sendWithTime(optional<std::wstring> Sender, optional<std::wstring> Text, int64_t time) = 0;
    // Register an interaction callback. The optional time stamp will be delivered by the application. When the time stamp is valid,
    // the optional order type will indicate the source of the time stamp.
    using ReceiveCallback = std::function<void(optional<std::wstring> Sender, optional<std::wstring> Text, optional<int64_t> time, optional<OrderType> orderType, bool sentBySelf)>;
    virtual uint32_t RegisterReceiveCallback(ReceiveCallback callback) = 0;
};

// ISystemVariableUpdateInteractionClass represents the HLA interaction class HLAinteractionRoot.SystemVariableUpdate.
class ISystemVariableUpdateInteractionClass
{
  public:
    // Publish/unpublish the interaction class. Sending an interaction of this class requires publishing the interaction class.
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    // Subscribe the interaction class. Receiving interactions requires having subscribed to this interaction class.
    // Note that the appropriate callbacks should have been registered *before* subscribing to the interaction class.
    virtual void Subscribe(bool deliverToSelf) = 0;
    // Subscribe the interaction class with filter values. Only interactions with parameters matching the given values will be received.
    // Filtered subscriptions may be issued several times with differing value tuples. 'nullopt' may be used as a wildcard, matching
    // any incoming value.
    virtual void Subscribe(optional<std::string> Id, optional<const std::vector<uint8_t>&> Value, optional<int32_t> Client, optional<bool> HasChanged, bool deliverToSelf) = 0;
    // Unsubscribe the interaction class, cancelling reception of interactions. Calling Unsubscribe will also clear all filtered subscriptions, if any.
    virtual void Unsubscribe() = 0;
    // Send an interaction as receive order message.
    virtual void send(optional<std::string> Id, optional<const std::vector<uint8_t>&> Value, optional<int32_t> Client, optional<bool> HasChanged) = 0;
    // Send a time stamped interaction.
    virtual void sendWithTime(optional<std::string> Id, optional<const std::vector<uint8_t>&> Value, optional<int32_t> Client, optional<bool> HasChanged, int64_t time) = 0;
    // Register an interaction callback. The optional time stamp will be delivered by the application. When the time stamp is valid,
    // the optional order type will indicate the source of the time stamp.
    using ReceiveCallback = std::function<void(optional<std::string> Id, optional<const std::vector<uint8_t>&> Value, optional<int32_t> Client, optional<bool> HasChanged, optional<int64_t> time, optional<OrderType> orderType, bool sentBySelf)>;
    virtual uint32_t RegisterReceiveCallback(ReceiveCallback callback) = 0;
};

// ISystemVariableModificationInteractionClass represents the HLA interaction class HLAinteractionRoot.SystemVariableModification.
class ISystemVariableModificationInteractionClass
{
  public:
    // Publish/unpublish the interaction class. Sending an interaction of this class requires publishing the interaction class.
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    // Subscribe the interaction class. Receiving interactions requires having subscribed to this interaction class.
    // Note that the appropriate callbacks should have been registered *before* subscribing to the interaction class.
    virtual void Subscribe(bool deliverToSelf) = 0;
    // Subscribe the interaction class with filter values. Only interactions with parameters matching the given values will be received.
    // Filtered subscriptions may be issued several times with differing value tuples. 'nullopt' may be used as a wildcard, matching
    // any incoming value.
    virtual void Subscribe(optional<const std::vector<uint8_t>&> Value, bool deliverToSelf) = 0;
    // Unsubscribe the interaction class, cancelling reception of interactions. Calling Unsubscribe will also clear all filtered subscriptions, if any.
    virtual void Unsubscribe() = 0;
    // Send an interaction as receive order message.
    virtual void send(optional<const std::vector<uint8_t>&> Value) = 0;
    // Send a time stamped interaction.
    virtual void sendWithTime(optional<const std::vector<uint8_t>&> Value, int64_t time) = 0;
    // Register an interaction callback. The optional time stamp will be delivered by the application. When the time stamp is valid,
    // the optional order type will indicate the source of the time stamp.
    using ReceiveCallback = std::function<void(optional<const std::vector<uint8_t>&> Value, optional<int64_t> time, optional<OrderType> orderType, bool sentBySelf)>;
    virtual uint32_t RegisterReceiveCallback(ReceiveCallback callback) = 0;
};

// IValueEntityUpdateInteractionClass represents the HLA interaction class HLAinteractionRoot.ValueEntityUpdate.
class IValueEntityUpdateInteractionClass
{
  public:
    // Publish/unpublish the interaction class. Sending an interaction of this class requires publishing the interaction class.
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    // Subscribe the interaction class. Receiving interactions requires having subscribed to this interaction class.
    // Note that the appropriate callbacks should have been registered *before* subscribing to the interaction class.
    virtual void Subscribe(bool deliverToSelf) = 0;
    // Subscribe the interaction class with filter values. Only interactions with parameters matching the given values will be received.
    // Filtered subscriptions may be issued several times with differing value tuples. 'nullopt' may be used as a wildcard, matching
    // any incoming value.
    virtual void Subscribe(optional<const std::vector<uint8_t>&> Id, optional<const std::vector<uint8_t>&> Value, bool deliverToSelf) = 0;
    // Unsubscribe the interaction class, cancelling reception of interactions. Calling Unsubscribe will also clear all filtered subscriptions, if any.
    virtual void Unsubscribe() = 0;
    // Send an interaction as receive order message.
    virtual void send(optional<const std::vector<uint8_t>&> Id, optional<const std::vector<uint8_t>&> Value) = 0;
    // Send a time stamped interaction.
    virtual void sendWithTime(optional<const std::vector<uint8_t>&> Id, optional<const std::vector<uint8_t>&> Value, int64_t time) = 0;
    // Register an interaction callback. The optional time stamp will be delivered by the application. When the time stamp is valid,
    // the optional order type will indicate the source of the time stamp.
    using ReceiveCallback = std::function<void(optional<const std::vector<uint8_t>&> Id, optional<const std::vector<uint8_t>&> Value, optional<int64_t> time, optional<OrderType> orderType, bool sentBySelf)>;
    virtual uint32_t RegisterReceiveCallback(ReceiveCallback callback) = 0;
};

// IBusMessageInteractionClass represents the HLA interaction class HLAinteractionRoot.BusMessage.
class IBusMessageInteractionClass
{
  public:
    // Publish/unpublish the interaction class. Sending an interaction of this class requires publishing the interaction class.
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    // Subscribe the interaction class. Receiving interactions requires having subscribed to this interaction class.
    // Note that the appropriate callbacks should have been registered *before* subscribing to the interaction class.
    virtual void Subscribe(bool deliverToSelf) = 0;
    // Subscribe the interaction class with filter values. Only interactions with parameters matching the given values will be received.
    // Filtered subscriptions may be issued several times with differing value tuples. 'nullopt' may be used as a wildcard, matching
    // any incoming value.
    virtual void Subscribe(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, bool deliverToSelf) = 0;
    // Unsubscribe the interaction class, cancelling reception of interactions. Calling Unsubscribe will also clear all filtered subscriptions, if any.
    virtual void Unsubscribe() = 0;
    // Send an interaction as receive order message.
    virtual void send(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver) = 0;
    // Send a time stamped interaction.
    virtual void sendWithTime(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, int64_t time) = 0;
    // Register an interaction callback. The optional time stamp will be delivered by the application. When the time stamp is valid,
    // the optional order type will indicate the source of the time stamp.
    using ReceiveCallback = std::function<void(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<int64_t> time, optional<OrderType> orderType, bool sentBySelf)>;
    virtual uint32_t RegisterReceiveCallback(ReceiveCallback callback) = 0;
};

// IEthPacketInteractionClass represents the HLA interaction class HLAinteractionRoot.BusMessage.EthPacket.
class IEthPacketInteractionClass
{
  public:
    // Publish/unpublish the interaction class. Sending an interaction of this class requires publishing the interaction class.
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    // Subscribe the interaction class. Receiving interactions requires having subscribed to this interaction class.
    // Note that the appropriate callbacks should have been registered *before* subscribing to the interaction class.
    virtual void Subscribe(bool deliverToSelf) = 0;
    // Subscribe the interaction class with filter values. Only interactions with parameters matching the given values will be received.
    // Filtered subscriptions may be issued several times with differing value tuples. 'nullopt' may be used as a wildcard, matching
    // any incoming value.
    virtual void Subscribe(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacket&> Frame, optional<std::string> PortName, bool deliverToSelf) = 0;
    // Unsubscribe the interaction class, cancelling reception of interactions. Calling Unsubscribe will also clear all filtered subscriptions, if any.
    virtual void Unsubscribe() = 0;
    // Send an interaction as receive order message.
    virtual void send(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacket&> Frame, optional<std::string> PortName) = 0;
    // Send a time stamped interaction.
    virtual void sendWithTime(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacket&> Frame, optional<std::string> PortName, int64_t time) = 0;
    // Register an interaction callback. The optional time stamp will be delivered by the application. When the time stamp is valid,
    // the optional order type will indicate the source of the time stamp.
    using ReceiveCallback = std::function<void(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacket&> Frame, optional<std::string> PortName, optional<int64_t> time, optional<OrderType> orderType, bool sentBySelf)>;
    virtual uint32_t RegisterReceiveCallback(ReceiveCallback callback) = 0;
};

// IEthPacketErrorInteractionClass represents the HLA interaction class HLAinteractionRoot.BusMessage.EthPacketError.
class IEthPacketErrorInteractionClass
{
  public:
    // Publish/unpublish the interaction class. Sending an interaction of this class requires publishing the interaction class.
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    // Subscribe the interaction class. Receiving interactions requires having subscribed to this interaction class.
    // Note that the appropriate callbacks should have been registered *before* subscribing to the interaction class.
    virtual void Subscribe(bool deliverToSelf) = 0;
    // Subscribe the interaction class with filter values. Only interactions with parameters matching the given values will be received.
    // Filtered subscriptions may be issued several times with differing value tuples. 'nullopt' may be used as a wildcard, matching
    // any incoming value.
    virtual void Subscribe(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacketError&> Frame, bool deliverToSelf) = 0;
    // Unsubscribe the interaction class, cancelling reception of interactions. Calling Unsubscribe will also clear all filtered subscriptions, if any.
    virtual void Unsubscribe() = 0;
    // Send an interaction as receive order message.
    virtual void send(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacketError&> Frame) = 0;
    // Send a time stamped interaction.
    virtual void sendWithTime(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacketError&> Frame, int64_t time) = 0;
    // Register an interaction callback. The optional time stamp will be delivered by the application. When the time stamp is valid,
    // the optional order type will indicate the source of the time stamp.
    using ReceiveCallback = std::function<void(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacketError&> Frame, optional<int64_t> time, optional<OrderType> orderType, bool sentBySelf)>;
    virtual uint32_t RegisterReceiveCallback(ReceiveCallback callback) = 0;
};

// IEthPacketErrorForwardedInteractionClass represents the HLA interaction class HLAinteractionRoot.BusMessage.EthPacketErrorForwarded.
class IEthPacketErrorForwardedInteractionClass
{
  public:
    // Publish/unpublish the interaction class. Sending an interaction of this class requires publishing the interaction class.
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    // Subscribe the interaction class. Receiving interactions requires having subscribed to this interaction class.
    // Note that the appropriate callbacks should have been registered *before* subscribing to the interaction class.
    virtual void Subscribe(bool deliverToSelf) = 0;
    // Subscribe the interaction class with filter values. Only interactions with parameters matching the given values will be received.
    // Filtered subscriptions may be issued several times with differing value tuples. 'nullopt' may be used as a wildcard, matching
    // any incoming value.
    virtual void Subscribe(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacketErrorForwarded&> Frame, bool deliverToSelf) = 0;
    // Unsubscribe the interaction class, cancelling reception of interactions. Calling Unsubscribe will also clear all filtered subscriptions, if any.
    virtual void Unsubscribe() = 0;
    // Send an interaction as receive order message.
    virtual void send(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacketErrorForwarded&> Frame) = 0;
    // Send a time stamped interaction.
    virtual void sendWithTime(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacketErrorForwarded&> Frame, int64_t time) = 0;
    // Register an interaction callback. The optional time stamp will be delivered by the application. When the time stamp is valid,
    // the optional order type will indicate the source of the time stamp.
    using ReceiveCallback = std::function<void(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacketErrorForwarded&> Frame, optional<int64_t> time, optional<OrderType> orderType, bool sentBySelf)>;
    virtual uint32_t RegisterReceiveCallback(ReceiveCallback callback) = 0;
};

// IEthForwardedPacketInteractionClass represents the HLA interaction class HLAinteractionRoot.BusMessage.EthForwardedPacket.
class IEthForwardedPacketInteractionClass
{
  public:
    // Publish/unpublish the interaction class. Sending an interaction of this class requires publishing the interaction class.
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    // Subscribe the interaction class. Receiving interactions requires having subscribed to this interaction class.
    // Note that the appropriate callbacks should have been registered *before* subscribing to the interaction class.
    virtual void Subscribe(bool deliverToSelf) = 0;
    // Subscribe the interaction class with filter values. Only interactions with parameters matching the given values will be received.
    // Filtered subscriptions may be issued several times with differing value tuples. 'nullopt' may be used as a wildcard, matching
    // any incoming value.
    virtual void Subscribe(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacketForwarded&> Frame, optional<std::string> PortName, bool deliverToSelf) = 0;
    // Unsubscribe the interaction class, cancelling reception of interactions. Calling Unsubscribe will also clear all filtered subscriptions, if any.
    virtual void Unsubscribe() = 0;
    // Send an interaction as receive order message.
    virtual void send(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacketForwarded&> Frame, optional<std::string> PortName) = 0;
    // Send a time stamped interaction.
    virtual void sendWithTime(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacketForwarded&> Frame, optional<std::string> PortName, int64_t time) = 0;
    // Register an interaction callback. The optional time stamp will be delivered by the application. When the time stamp is valid,
    // the optional order type will indicate the source of the time stamp.
    using ReceiveCallback = std::function<void(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetPacketForwarded&> Frame, optional<std::string> PortName, optional<int64_t> time, optional<OrderType> orderType, bool sentBySelf)>;
    virtual uint32_t RegisterReceiveCallback(ReceiveCallback callback) = 0;
};

// IEthStatusInteractionClass represents the HLA interaction class HLAinteractionRoot.BusMessage.EthStatus.
class IEthStatusInteractionClass
{
  public:
    // Publish/unpublish the interaction class. Sending an interaction of this class requires publishing the interaction class.
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    // Subscribe the interaction class. Receiving interactions requires having subscribed to this interaction class.
    // Note that the appropriate callbacks should have been registered *before* subscribing to the interaction class.
    virtual void Subscribe(bool deliverToSelf) = 0;
    // Subscribe the interaction class with filter values. Only interactions with parameters matching the given values will be received.
    // Filtered subscriptions may be issued several times with differing value tuples. 'nullopt' may be used as a wildcard, matching
    // any incoming value.
    virtual void Subscribe(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetStatus&> Frame, optional<std::string> PortName, bool deliverToSelf) = 0;
    // Unsubscribe the interaction class, cancelling reception of interactions. Calling Unsubscribe will also clear all filtered subscriptions, if any.
    virtual void Unsubscribe() = 0;
    // Send an interaction as receive order message.
    virtual void send(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetStatus&> Frame, optional<std::string> PortName) = 0;
    // Send a time stamped interaction.
    virtual void sendWithTime(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetStatus&> Frame, optional<std::string> PortName, int64_t time) = 0;
    // Register an interaction callback. The optional time stamp will be delivered by the application. When the time stamp is valid,
    // the optional order type will indicate the source of the time stamp.
    using ReceiveCallback = std::function<void(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const EthernetStatus&> Frame, optional<std::string> PortName, optional<int64_t> time, optional<OrderType> orderType, bool sentBySelf)>;
    virtual uint32_t RegisterReceiveCallback(ReceiveCallback callback) = 0;
};

// ICANMessageInteractionClass represents the HLA interaction class HLAinteractionRoot.BusMessage.CANMessage.
class ICANMessageInteractionClass
{
  public:
    // Publish/unpublish the interaction class. Sending an interaction of this class requires publishing the interaction class.
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    // Subscribe the interaction class. Receiving interactions requires having subscribed to this interaction class.
    // Note that the appropriate callbacks should have been registered *before* subscribing to the interaction class.
    virtual void Subscribe(bool deliverToSelf) = 0;
    // Subscribe the interaction class with filter values. Only interactions with parameters matching the given values will be received.
    // Filtered subscriptions may be issued several times with differing value tuples. 'nullopt' may be used as a wildcard, matching
    // any incoming value.
    virtual void Subscribe(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<int32_t> Id, optional<const CANFrame&> Frame, bool deliverToSelf) = 0;
    // Unsubscribe the interaction class, cancelling reception of interactions. Calling Unsubscribe will also clear all filtered subscriptions, if any.
    virtual void Unsubscribe() = 0;
    // Send an interaction as receive order message.
    virtual void send(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<int32_t> Id, optional<const CANFrame&> Frame) = 0;
    // Send a time stamped interaction.
    virtual void sendWithTime(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<int32_t> Id, optional<const CANFrame&> Frame, int64_t time) = 0;
    // Register an interaction callback. The optional time stamp will be delivered by the application. When the time stamp is valid,
    // the optional order type will indicate the source of the time stamp.
    using ReceiveCallback = std::function<void(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<int32_t> Id, optional<const CANFrame&> Frame, optional<int64_t> time, optional<OrderType> orderType, bool sentBySelf)>;
    virtual uint32_t RegisterReceiveCallback(ReceiveCallback callback) = 0;
};

// ICANErrorFrameInteractionClass represents the HLA interaction class HLAinteractionRoot.BusMessage.CANErrorFrame.
class ICANErrorFrameInteractionClass
{
  public:
    // Publish/unpublish the interaction class. Sending an interaction of this class requires publishing the interaction class.
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    // Subscribe the interaction class. Receiving interactions requires having subscribed to this interaction class.
    // Note that the appropriate callbacks should have been registered *before* subscribing to the interaction class.
    virtual void Subscribe(bool deliverToSelf) = 0;
    // Subscribe the interaction class with filter values. Only interactions with parameters matching the given values will be received.
    // Filtered subscriptions may be issued several times with differing value tuples. 'nullopt' may be used as a wildcard, matching
    // any incoming value.
    virtual void Subscribe(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const std::vector<uint8_t>&> Frame, bool deliverToSelf) = 0;
    // Unsubscribe the interaction class, cancelling reception of interactions. Calling Unsubscribe will also clear all filtered subscriptions, if any.
    virtual void Unsubscribe() = 0;
    // Send an interaction as receive order message.
    virtual void send(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const std::vector<uint8_t>&> Frame) = 0;
    // Send a time stamped interaction.
    virtual void sendWithTime(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const std::vector<uint8_t>&> Frame, int64_t time) = 0;
    // Register an interaction callback. The optional time stamp will be delivered by the application. When the time stamp is valid,
    // the optional order type will indicate the source of the time stamp.
    using ReceiveCallback = std::function<void(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<const std::vector<uint8_t>&> Frame, optional<int64_t> time, optional<OrderType> orderType, bool sentBySelf)>;
    virtual uint32_t RegisterReceiveCallback(ReceiveCallback callback) = 0;
};

// IFlexRaySymbolInteractionClass represents the HLA interaction class HLAinteractionRoot.BusMessage.FlexRaySymbol.
class IFlexRaySymbolInteractionClass
{
  public:
    // Publish/unpublish the interaction class. Sending an interaction of this class requires publishing the interaction class.
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    // Subscribe the interaction class. Receiving interactions requires having subscribed to this interaction class.
    // Note that the appropriate callbacks should have been registered *before* subscribing to the interaction class.
    virtual void Subscribe(bool deliverToSelf) = 0;
    // Subscribe the interaction class with filter values. Only interactions with parameters matching the given values will be received.
    // Filtered subscriptions may be issued several times with differing value tuples. 'nullopt' may be used as a wildcard, matching
    // any incoming value.
    virtual void Subscribe(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<FlexRaySymbolPattern> SymbolPattern, optional<FlexRayChannel> FlexRayChannel, bool deliverToSelf) = 0;
    // Unsubscribe the interaction class, cancelling reception of interactions. Calling Unsubscribe will also clear all filtered subscriptions, if any.
    virtual void Unsubscribe() = 0;
    // Send an interaction as receive order message.
    virtual void send(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<FlexRaySymbolPattern> SymbolPattern, optional<FlexRayChannel> FlexRayChannel) = 0;
    // Send a time stamped interaction.
    virtual void sendWithTime(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<FlexRaySymbolPattern> SymbolPattern, optional<FlexRayChannel> FlexRayChannel, int64_t time) = 0;
    // Register an interaction callback. The optional time stamp will be delivered by the application. When the time stamp is valid,
    // the optional order type will indicate the source of the time stamp.
    using ReceiveCallback = std::function<void(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<FlexRaySymbolPattern> SymbolPattern, optional<FlexRayChannel> FlexRayChannel, optional<int64_t> time, optional<OrderType> orderType, bool sentBySelf)>;
    virtual uint32_t RegisterReceiveCallback(ReceiveCallback callback) = 0;
};

// IFlexRayCycleStartInteractionClass represents the HLA interaction class HLAinteractionRoot.BusMessage.FlexRayCycleStart.
class IFlexRayCycleStartInteractionClass
{
  public:
    // Publish/unpublish the interaction class. Sending an interaction of this class requires publishing the interaction class.
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    // Subscribe the interaction class. Receiving interactions requires having subscribed to this interaction class.
    // Note that the appropriate callbacks should have been registered *before* subscribing to the interaction class.
    virtual void Subscribe(bool deliverToSelf) = 0;
    // Subscribe the interaction class with filter values. Only interactions with parameters matching the given values will be received.
    // Filtered subscriptions may be issued several times with differing value tuples. 'nullopt' may be used as a wildcard, matching
    // any incoming value.
    virtual void Subscribe(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<uint8_t> Cycle, bool deliverToSelf) = 0;
    // Unsubscribe the interaction class, cancelling reception of interactions. Calling Unsubscribe will also clear all filtered subscriptions, if any.
    virtual void Unsubscribe() = 0;
    // Send an interaction as receive order message.
    virtual void send(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<uint8_t> Cycle) = 0;
    // Send a time stamped interaction.
    virtual void sendWithTime(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<uint8_t> Cycle, int64_t time) = 0;
    // Register an interaction callback. The optional time stamp will be delivered by the application. When the time stamp is valid,
    // the optional order type will indicate the source of the time stamp.
    using ReceiveCallback = std::function<void(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<uint8_t> Cycle, optional<int64_t> time, optional<OrderType> orderType, bool sentBySelf)>;
    virtual uint32_t RegisterReceiveCallback(ReceiveCallback callback) = 0;
};

// IFlexRayFrameInteractionClass represents the HLA interaction class HLAinteractionRoot.BusMessage.FlexRayFrame.
class IFlexRayFrameInteractionClass
{
  public:
    // Publish/unpublish the interaction class. Sending an interaction of this class requires publishing the interaction class.
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    // Subscribe the interaction class. Receiving interactions requires having subscribed to this interaction class.
    // Note that the appropriate callbacks should have been registered *before* subscribing to the interaction class.
    virtual void Subscribe(bool deliverToSelf) = 0;
    // Subscribe the interaction class with filter values. Only interactions with parameters matching the given values will be received.
    // Filtered subscriptions may be issued several times with differing value tuples. 'nullopt' may be used as a wildcard, matching
    // any incoming value.
    virtual void Subscribe(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<int16_t> FrameID, optional<FlexRayChannel> FlexRayChannel, optional<bool> PayloadPreambleIndicator, optional<const FlexRayHeader&> Header, optional<const FlexRayPayload&> Payload, bool deliverToSelf) = 0;
    // Unsubscribe the interaction class, cancelling reception of interactions. Calling Unsubscribe will also clear all filtered subscriptions, if any.
    virtual void Unsubscribe() = 0;
    // Send an interaction as receive order message.
    virtual void send(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<int16_t> FrameID, optional<FlexRayChannel> FlexRayChannel, optional<bool> PayloadPreambleIndicator, optional<const FlexRayHeader&> Header, optional<const FlexRayPayload&> Payload) = 0;
    // Send a time stamped interaction.
    virtual void sendWithTime(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<int16_t> FrameID, optional<FlexRayChannel> FlexRayChannel, optional<bool> PayloadPreambleIndicator, optional<const FlexRayHeader&> Header, optional<const FlexRayPayload&> Payload, int64_t time) = 0;
    // Register an interaction callback. The optional time stamp will be delivered by the application. When the time stamp is valid,
    // the optional order type will indicate the source of the time stamp.
    using ReceiveCallback = std::function<void(optional<bool> IsRequest, optional<std::string> ChannelName, optional<BusType> BusType, optional<IBusController*> RequestingFederate, optional<IBusController*> Sender, optional<IBusController*> Receiver, optional<int16_t> FrameID, optional<FlexRayChannel> FlexRayChannel, optional<bool> PayloadPreambleIndicator, optional<const FlexRayHeader&> Header, optional<const FlexRayPayload&> Payload, optional<int64_t> time, optional<OrderType> orderType, bool sentBySelf)>;
    virtual uint32_t RegisterReceiveCallback(ReceiveCallback callback) = 0;
};

// IPythonCommandInteractionClass represents the HLA interaction class HLAinteractionRoot.PythonCommand.
class IPythonCommandInteractionClass
{
  public:
    // Publish/unpublish the interaction class. Sending an interaction of this class requires publishing the interaction class.
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    // Subscribe the interaction class. Receiving interactions requires having subscribed to this interaction class.
    // Note that the appropriate callbacks should have been registered *before* subscribing to the interaction class.
    virtual void Subscribe(bool deliverToSelf) = 0;
    // Subscribe the interaction class with filter values. Only interactions with parameters matching the given values will be received.
    // Filtered subscriptions may be issued several times with differing value tuples. 'nullopt' may be used as a wildcard, matching
    // any incoming value.
    virtual void Subscribe(optional<const std::vector<uint8_t>&> Code, optional<const std::vector<uint8_t>&> Target, optional<const std::vector<uint8_t>&> RefID, bool deliverToSelf) = 0;
    // Unsubscribe the interaction class, cancelling reception of interactions. Calling Unsubscribe will also clear all filtered subscriptions, if any.
    virtual void Unsubscribe() = 0;
    // Send an interaction as receive order message.
    virtual void send(optional<const std::vector<uint8_t>&> Code, optional<const std::vector<uint8_t>&> Target, optional<const std::vector<uint8_t>&> RefID) = 0;
    // Send a time stamped interaction.
    virtual void sendWithTime(optional<const std::vector<uint8_t>&> Code, optional<const std::vector<uint8_t>&> Target, optional<const std::vector<uint8_t>&> RefID, int64_t time) = 0;
    // Register an interaction callback. The optional time stamp will be delivered by the application. When the time stamp is valid,
    // the optional order type will indicate the source of the time stamp.
    using ReceiveCallback = std::function<void(optional<const std::vector<uint8_t>&> Code, optional<const std::vector<uint8_t>&> Target, optional<const std::vector<uint8_t>&> RefID, optional<int64_t> time, optional<OrderType> orderType, bool sentBySelf)>;
    virtual uint32_t RegisterReceiveCallback(ReceiveCallback callback) = 0;
};


class IInteractionClassRegistry
{
  public:
    virtual IHLAinteractionRootInteractionClass* GetHLAinteractionRootInteractionClass() const = 0;
    virtual IMeasurementInitInteractionClass* GetMeasurementInitInteractionClass() const = 0;
    virtual IMeasurementStopInteractionClass* GetMeasurementStopInteractionClass() const = 0;
    virtual IKeyEventInteractionClass* GetKeyEventInteractionClass() const = 0;
    virtual ITextLogInteractionClass* GetTextLogInteractionClass() const = 0;
    virtual ISystemVariableUpdateInteractionClass* GetSystemVariableUpdateInteractionClass() const = 0;
    virtual ISystemVariableModificationInteractionClass* GetSystemVariableModificationInteractionClass() const = 0;
    virtual IValueEntityUpdateInteractionClass* GetValueEntityUpdateInteractionClass() const = 0;
    virtual IBusMessageInteractionClass* GetBusMessageInteractionClass() const = 0;
    virtual IEthPacketInteractionClass* GetEthPacketInteractionClass() const = 0;
    virtual IEthPacketErrorInteractionClass* GetEthPacketErrorInteractionClass() const = 0;
    virtual IEthPacketErrorForwardedInteractionClass* GetEthPacketErrorForwardedInteractionClass() const = 0;
    virtual IEthForwardedPacketInteractionClass* GetEthForwardedPacketInteractionClass() const = 0;
    virtual IEthStatusInteractionClass* GetEthStatusInteractionClass() const = 0;
    virtual ICANMessageInteractionClass* GetCANMessageInteractionClass() const = 0;
    virtual ICANErrorFrameInteractionClass* GetCANErrorFrameInteractionClass() const = 0;
    virtual IFlexRaySymbolInteractionClass* GetFlexRaySymbolInteractionClass() const = 0;
    virtual IFlexRayCycleStartInteractionClass* GetFlexRayCycleStartInteractionClass() const = 0;
    virtual IFlexRayFrameInteractionClass* GetFlexRayFrameInteractionClass() const = 0;
    virtual IPythonCommandInteractionClass* GetPythonCommandInteractionClass() const = 0;
  protected:
    virtual ~IInteractionClassRegistry() {}
}; // class IInteractionClassRegistry

} // namespace NDistSimIB
} // namespace NRTFederateEncoding
