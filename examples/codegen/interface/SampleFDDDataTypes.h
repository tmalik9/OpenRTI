
// Code automatically generated by FOMCodeGen version 2.1.0.0 from SampleFDD.xml, do not edit

// Name: CANoe RT Federate
// Copyright: Copyright (c) Vector Informatik GmbH. All rights reserved.
// Version: 1.0
// Description: CANoe Simulation Object Model

#pragma once

#include <vector>
#include <ostream>
#include <cassert>
#include <new>
#include <utility>
#include <type_traits>



namespace NDistSimIB {
namespace NSampleFDDEncoding {

// define placement_new in case some other header has redefined operator new to sth. different (e.g. MS crtdbg)
#ifndef _PLACEMENT_NEW_DEFINED
#pragma push_macro("new")
#undef new
template <class X, typename ... Types>
inline X* placement_new(void* addr, Types&& ... args)
{
  return new (addr) X(std::forward<Types>(args)...);
}
#pragma pop_macro("new")
#define _PLACEMENT_NEW_DEFINED
#endif

// define our own simplified 'optional' types, similar to but independent of std::optional (since C++17) or boost::optional

struct nullopt_t
{
  enum class _Construct { _Token };
  explicit constexpr nullopt_t(_Construct) { }
};

/// Tag to disengage optional objects.
constexpr nullopt_t nullopt { nullopt_t::_Construct::_Token };

class bad_optional_access : public std::exception
{
public:
  virtual const char* what() const noexcept override { return ("Bad optional access"); }
};

// (empty) base template
template<typename T, bool=std::is_class<T>::value > struct optional {};

// Specialization for classes and structs used by-value, w. in-place copy-construction.
// This implementation is limited to copy-constructible and default-destructible classes!
template<typename T> struct optional<T, true>
{
  static_assert(!std::is_reference< T >::value, "reference is not supported as optional value");
  // constructors
  optional() noexcept : _valid(false) {}
  constexpr optional(nullopt_t) noexcept : _valid(false) {}
  optional(const optional& rhs): _valid(rhs._valid) { create(rhs); }
  optional(const T& w): _valid(true) { create(w); }
  template<typename Other>
  optional(const Other& w): _valid(true) { create(w); }
  template<typename Other>
  optional(const optional<Other>& rhs): _valid(rhs.has_value()) { if (rhs.has_value()) create(rhs.value()); }

  // destructor
  ~optional() { if(_valid) destroy(); }

  // check for value presence
  bool has_value() const { return _valid; }
  explicit operator bool() const { return _valid; }
  bool operator ! () const { return !_valid; }

  // assign
  optional& operator = (optional const& rhs) { return assign(rhs); }
  optional& operator = (T const& w) { return assign(w); }

  // unchecked access to value
  const T& operator * () const & { return *get(); }
  T& operator * () & { return *get(); }
  T const* operator -> () const { return get(); }
  T* operator -> () { return get(); }
  // checked access to value
  const T& value() const & {
    if (!_valid) {
      throw bad_optional_access{};
    }
    return *get();
  }
  T& value() & {
    if (!_valid) {
      throw bad_optional_access{};
    }
    return *get();
  }
private:
  template<typename Other>
  void create(const Other& w) { placement_new<T>(&_value, w); }
  void create(const optional& rhs) { if(_valid) create(*rhs.get()); }
  void destroy() { get()->~T(); }
  T const* get() const { assert(_valid && "no optional value"); return reinterpret_cast< const T* >(&_value); }
  T* get() { assert(_valid && "no optional value"); return reinterpret_cast< T* >(&_value); }
  void cleanup() { destroy(); _valid = false; }
  optional& assign(const T& w) {
    if(_valid) *get() = w;
    else create(w), _valid = true;
    return *this;
  }
  optional& assign(const optional& rhs) {
    if(rhs._valid) return assign(*rhs.get());
    if(!_valid) return *this;
    cleanup();
    return *this;
  }
  bool _valid;
	union {
    typename std::remove_cv<T>::type _value;
  };
};
// Specialization for const-ref parameters, implemented by holding a pointer to the original variable.
// Note that non-const references are *not* supported (but could be easily added)!
template<typename T> struct optional<const T&, false>
{
  // constructors
  optional() noexcept : _valid(false), _pointer() {}
  constexpr optional(nullopt_t) noexcept : _valid(false), _pointer() {}
  optional(const optional& rhs): _valid(rhs._valid), _pointer(rhs._pointer) { }
  optional(const T& rhs) noexcept : _valid(true), _pointer(&rhs) { }
  template<typename Other>
  optional(const Other& rhs): _valid(true), _pointer(&rhs) { }
  template<typename Other>
  optional(const optional<Other>& rhs): _valid(rhs.has_value()), _pointer(rhs.operator->()) { }

  // destructor
  ~optional() { }

  // check for value presence
  bool has_value() const { return _valid; }
  explicit operator bool() const { return _valid; }
  bool operator ! () const { return !_valid; }

  // assign
  optional& operator = (const optional& rhs) {
    _valid = rhs._valid;
    _pointer = rhs._pointer;
    return *this;
  }
  optional& operator = (const T& w) {
    _valid = true;
    _pointer = &w;
    return *this;
  }
  // unchecked access to value
  T const& operator * () const & { return *get(); }
  T const* operator -> () const & { return get(); }
  // checked access to value
  const T& value() const & {
    if (!_valid) {
      throw bad_optional_access{};
    }
    return *get();
  }
  T& value() & {
    if (!_valid) {
      throw bad_optional_access{};
    }
    return *get();
  }
private:
  const T* get() const {
    assert(_valid && "no optional value");
    return _pointer;
  }
  bool _valid;
  const T* _pointer = nullptr;
};
// Specialization for everything else, which includes fundamental types and pointer types.
template<typename T> struct optional<T, false>
{
  // constructors
  optional() noexcept : _valid(false), _value() {}
  constexpr optional(nullopt_t) noexcept : _valid(false), _value() {}
  optional(const optional& rhs): _valid(rhs._valid), _value(rhs._value) { }
  optional(const T& rhs) : _valid(true), _value(rhs) { }
  template<typename Other>
  optional(const Other& rhs): _valid(true), _value(rhs) { }
  template<typename Other>
  optional(const optional<Other>& rhs): _valid(rhs.has_value()), _value(rhs.operator*()) { }

  // destructor
  ~optional() { }

  // check for value presence
  bool has_value() const { return _valid; }
  explicit operator bool() const { return _valid; }
  bool operator ! () const { return !_valid; }

  // assign
  optional& operator = (const optional& rhs) {
    _valid = rhs._valid;
    _value = rhs._value;
    return *this;
  }
  optional& operator = (const T& w) {
    _valid = true;
    _value = w;
    return *this;
  }
  // unchecked access to value
  T const& operator * () const & { return _value; }
  T const* operator -> () const { return &_value; }
  // checked access to value
  const T& value() const & {
    if (!_valid) {
      throw bad_optional_access{};
    }
    return _value;
  }
  T& value() & {
    if (!_valid) {
      throw bad_optional_access{};
    }
    return _value;
  }
private:
  bool _valid;
  T _value;
};

class InvalidLogicalTime : public std::logic_error
{
  public:
    InvalidLogicalTime(const std::string& what_arg) : std::logic_error(what_arg) {}
};

class NotConnected : public std::logic_error
{
  public:
    NotConnected() : std::logic_error("not connected") {}
};

class NotInitialized : public std::logic_error
{
  public:
    NotInitialized() : std::logic_error("class registry not initialized") {}
};

// extended receive order type, includes 'interpolated' for application-generated timestamps
enum class OrderType { RECEIVE, TIMESTAMP, INTERPOLATED };

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, OrderType value)
{
  switch (value)
  {
    case OrderType::RECEIVE: os << "RECEIVE"; break;
    case OrderType::TIMESTAMP: os << "TIMESTAMP"; break;
    case OrderType::INTERPOLATED: os << "INTERPOLATED"; break;
  }
  return os;
}

inline std::string to_string(OrderType value)
{
  switch (value)
  {
    case OrderType::RECEIVE: return "RECEIVE";
    case OrderType::TIMESTAMP: return "TIMESTAMP";
    case OrderType::INTERPOLATED: return "INTERPOLATED";
  }
}

inline std::wstring to_wstring(OrderType value)
{
  switch (value)
  {
    case OrderType::RECEIVE: return L"RECEIVE";
    case OrderType::TIMESTAMP: return L"TIMESTAMP";
    case OrderType::INTERPOLATED: return L"INTERPOLATED";
  }
}

typedef int64_t NanoSeconds;

enum class SimulationState : uint8_t
{
      Idle = 0,
      Connected = 1,
      Initializing = 2,
      Initialized = 3,
      ReadyToRun = 4,
      Running = 5,
      Stopping = 6,
      Stopped = 7,
      Error = 8,
}; // enum SimulationState

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, SimulationState value)
{
  switch (value)
  {
    case SimulationState::Idle: os << "Idle"; break;
    case SimulationState::Connected: os << "Connected"; break;
    case SimulationState::Initializing: os << "Initializing"; break;
    case SimulationState::Initialized: os << "Initialized"; break;
    case SimulationState::ReadyToRun: os << "ReadyToRun"; break;
    case SimulationState::Running: os << "Running"; break;
    case SimulationState::Stopping: os << "Stopping"; break;
    case SimulationState::Stopped: os << "Stopped"; break;
    case SimulationState::Error: os << "Error"; break;
    default: os << "<invalid SimulationState>"; break;
  }
  return os;
}

inline std::string to_string(SimulationState value)
{
  switch (value)
  {
    case SimulationState::Idle: return "Idle";
    case SimulationState::Connected: return "Connected";
    case SimulationState::Initializing: return "Initializing";
    case SimulationState::Initialized: return "Initialized";
    case SimulationState::ReadyToRun: return "ReadyToRun";
    case SimulationState::Running: return "Running";
    case SimulationState::Stopping: return "Stopping";
    case SimulationState::Stopped: return "Stopped";
    case SimulationState::Error: return "Error";
    default: return "<invalid SimulationState>";
  }
}

inline std::wstring to_wstring(SimulationState value)
{
  switch (value)
  {
    case SimulationState::Idle: return L"Idle";
    case SimulationState::Connected: return L"Connected";
    case SimulationState::Initializing: return L"Initializing";
    case SimulationState::Initialized: return L"Initialized";
    case SimulationState::ReadyToRun: return L"ReadyToRun";
    case SimulationState::Running: return L"Running";
    case SimulationState::Stopping: return L"Stopping";
    case SimulationState::Stopped: return L"Stopped";
    case SimulationState::Error: return L"Error";
    default: return L"<invalid SimulationState>";
  }
}


} // namespace NDistSimIB
} // namespace NSampleFDDEncoding
