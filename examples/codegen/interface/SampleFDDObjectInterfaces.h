
// Code automatically generated by FOMCodeGen version 2.1.0.0 from SampleFDD.xml, do not edit

// Name: CANoe RT Federate
// Copyright: Copyright (c) Vector Informatik GmbH. All rights reserved.
// Version: 1.0
// Description: CANoe Simulation Object Model

#pragma once

#include <vector>
#include <functional>
#include <memory>


#include "SampleFDDDataTypes.h"

namespace NDistSimIB {
namespace NSampleFDDEncoding {

class IHLAobjectRoot;
// IHLAobjectRootObjectClass represents the HLA object class HLAobjectRoot.
// Instances of IHLAobjectRoot represent the corresponding HLA object instances.
class IHLAobjectRootObjectClass
{
  public:
    using DiscoverObjectInstanceCallback = std::function<void(std::shared_ptr<IHLAobjectRoot>)>;
    using RemoveObjectInstanceCallback = std::function<void(std::shared_ptr<IHLAobjectRoot>)>;
    using ObjectCreatedCallbackType = std::function<void(std::shared_ptr<IHLAobjectRoot>, bool success)>;
    // Publish/unpublish this object class. Creating object instances requires publishing the object class.
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    // Subscribe/unsubscribe this object class. Taking part in object discovery and receiving attribute updates requires subscribing the object class.
    // Note that the appropriate callbacks should have been registered *before* subscribing to the object class.
    virtual void Subscribe(bool deliverToSelf) = 0;
    virtual void Unsubscribe() = 0;
    // Return an existing object instance by name, or nullptr if not existant.
    virtual std::shared_ptr<IHLAobjectRoot> GetObjectInstance(const std::wstring& instanceName) = 0;
    // Create an instance of IHLAobjectRoot. Returns nullptr if the object instance already exists.
    // If another federate has already created an object instance with the same name and the same object class,
    // the discover object instance mechanism will reuse the object returned by 'create object instance'.
    // A discover object instance callback should be installed by the application to appropriately handle this case.
    virtual std::shared_ptr<IHLAobjectRoot> CreateObjectInstance(const std::wstring& instanceName) = 0;
    // Create an instance of IHLAobjectRoot, and notify the application about having completed the HLA object registration.
    // The callback's 'success' parameter indicates whether the object instance name could successfully be reserved for the object.
    virtual std::shared_ptr<IHLAobjectRoot> CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback) = 0;
    // Restore a 'dead' instance of IHLAobjectRoot. Returns nullptr if the object instance already exists.
    // If another federate has already created an object instance with the same name and the same object class,
    // the discover object instance mechanism will reuse the object returned by 'create object instance'.
    // A discover object instance callback should be installed by the application to appropriately handle this case.
    virtual std::shared_ptr<IHLAobjectRoot> RestoreObjectInstance(std::shared_ptr<IHLAobjectRoot> existingObject) = 0;
    // Restore a 'dead' instance of IHLAobjectRoot, and notify the application about having completed the HLA object registration.
    // The callback's 'success' parameter indicates whether the object instance name could successfully be reserved for the object.
    virtual std::shared_ptr<IHLAobjectRoot> RestoreObjectInstance(std::shared_ptr<IHLAobjectRoot> existingObject, ObjectCreatedCallbackType createdCallback) = 0;

    // install a discover object instance callback for this HLA object class
    virtual uint32_t RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback) = 0;
    virtual void UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken) = 0;

    // install a remove object instance callback for the HLA object class
    virtual uint32_t RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback) = 0;
    virtual void UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken) = 0;
};

class IHLAobjectRoot : public std::enable_shared_from_this<IHLAobjectRoot>
{
  public:
    using AttributeBits = uint32_t;
    static const AttributeBits kNone = 0x0;

    IHLAobjectRoot() {}
    virtual ~IHLAobjectRoot() {}
    // copying and moving an object instance is not allowed
    IHLAobjectRoot(const IHLAobjectRoot&) = delete;
    IHLAobjectRoot(IHLAobjectRoot&&) = delete;
    IHLAobjectRoot& operator=(const IHLAobjectRoot&) = delete;
    IHLAobjectRoot& operator=(IHLAobjectRoot&&) = delete;

    virtual std::wstring GetObjectInstanceName() const = 0;
    // has this object a valid HLA object instance handle?
    virtual bool IsValid() const = 0;
    // After having called CreateObjectInstance, wait until object registration completed.
    // Returns false if the object registration failed.
    virtual bool WaitForObjectValid() = 0;
    // has this object been created by this federate?
    virtual bool IsOwner() const = 0;
    // Delete the object from HLA and the class registry.
    // Be careful to keep a shared_ptr to the object while executing Release!
    virtual void Release() = 0;
    // attribute HLAprivilegeToDeleteObject : no data type
};

class IParticipant;
// IParticipantObjectClass represents the HLA object class HLAobjectRoot.Participant.
// Instances of IParticipant represent the corresponding HLA object instances.
class IParticipantObjectClass
{
  public:
    using DiscoverObjectInstanceCallback = std::function<void(std::shared_ptr<IParticipant>)>;
    using RemoveObjectInstanceCallback = std::function<void(std::shared_ptr<IParticipant>)>;
    using ObjectCreatedCallbackType = std::function<void(std::shared_ptr<IParticipant>, bool success)>;
    // Publish/unpublish this object class. Creating object instances requires publishing the object class.
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    // Subscribe/unsubscribe this object class. Taking part in object discovery and receiving attribute updates requires subscribing the object class.
    // Note that the appropriate callbacks should have been registered *before* subscribing to the object class.
    virtual void Subscribe(bool deliverToSelf) = 0;
    virtual void Unsubscribe() = 0;
    // Return an existing object instance by name, or nullptr if not existant.
    virtual std::shared_ptr<IParticipant> GetObjectInstance(const std::wstring& instanceName) = 0;
    // Create an instance of IParticipant. Returns nullptr if the object instance already exists.
    // If another federate has already created an object instance with the same name and the same object class,
    // the discover object instance mechanism will reuse the object returned by 'create object instance'.
    // A discover object instance callback should be installed by the application to appropriately handle this case.
    virtual std::shared_ptr<IParticipant> CreateObjectInstance(const std::wstring& instanceName) = 0;
    // Create an instance of IParticipant, and notify the application about having completed the HLA object registration.
    // The callback's 'success' parameter indicates whether the object instance name could successfully be reserved for the object.
    virtual std::shared_ptr<IParticipant> CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback) = 0;
    // Restore a 'dead' instance of IParticipant. Returns nullptr if the object instance already exists.
    // If another federate has already created an object instance with the same name and the same object class,
    // the discover object instance mechanism will reuse the object returned by 'create object instance'.
    // A discover object instance callback should be installed by the application to appropriately handle this case.
    virtual std::shared_ptr<IParticipant> RestoreObjectInstance(std::shared_ptr<IParticipant> existingObject) = 0;
    // Restore a 'dead' instance of IParticipant, and notify the application about having completed the HLA object registration.
    // The callback's 'success' parameter indicates whether the object instance name could successfully be reserved for the object.
    virtual std::shared_ptr<IParticipant> RestoreObjectInstance(std::shared_ptr<IParticipant> existingObject, ObjectCreatedCallbackType createdCallback) = 0;

    // install a discover object instance callback for this HLA object class
    virtual uint32_t RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback) = 0;
    virtual void UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken) = 0;

    // install a remove object instance callback for the HLA object class
    virtual uint32_t RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback) = 0;
    virtual void UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken) = 0;
};

class IParticipant : public IHLAobjectRoot
{
  public:
    static const AttributeBits kNameBit = 0x2;
    static const AttributeBits kIdBit = 0x4;
    static const AttributeBits kStateBit = 0x8;

    IParticipant() {}
    ~IParticipant() {}
    // copying and moving an object instance is not allowed
    IParticipant(const IParticipant&) = delete;
    IParticipant(IParticipant&&) = delete;
    IParticipant& operator=(const IParticipant&) = delete;
    IParticipant& operator=(IParticipant&&) = delete;

    // attribute Name : HLAunicodeString
    virtual std::wstring GetName() const = 0;
    virtual void SetName(std::wstring newValue) = 0;
    // attribute Id : HLAinteger32LE
    virtual int32_t GetId() const = 0;
    virtual void SetId(int32_t newValue) = 0;
    // attribute State : SimulationState
    virtual SimulationState GetState() const = 0;
    virtual void SetState(SimulationState newValue) = 0;
    // send all attribute values
    virtual void UpdateAllAttributeValues() = 0;
    // send all attribute values, as TSO message
    virtual void UpdateAllAttributeValues(int64_t time) = 0;
    // send attribute values which have been modified since last call
    virtual void UpdateModifiedAttributeValues() = 0;
    // send attribute values which have been modified since last call, as TSO message
    virtual void UpdateModifiedAttributeValues(int64_t time) = 0;
    // bitmask of attributes ever received
    virtual AttributeBits GetReceivedAttributes() const = 0;
    // bitmask of attributes received in last update (cleared after update callbacks executed)
    virtual AttributeBits GetUpdatedAttributes() const = 0;
    // bitmask of attributes ever modified
    virtual AttributeBits GetInitializedAttributes() const = 0;
    // bitmask of attributes modified since last updateAttributeValues/provideAttributeValues
    // (cleared by UpdateAttributeValues or ProvideAttributeValues)
    virtual AttributeBits GetModifiedAttributes() const = 0;
    // request attribute values which haven't been updated in last reflectAttributeValues
    virtual void RequestAttributeValues() = 0;
    // request all attribute values
    virtual void RequestAllAttributeValues() = 0;
    using UpdateCallback = std::function<void(std::shared_ptr<IParticipant>, optional<int64_t> time, optional<OrderType> orderType)>;
    virtual uint32_t RegisterUpdateCallback(UpdateCallback callback) = 0;
    virtual void UnregisterUpdateCallback(uint32_t callbackToken) = 0;
};


class IObjectClassRegistry
{
  public:
    virtual IHLAobjectRootObjectClass* GetHLAobjectRootObjectClass() const = 0;
    virtual IParticipantObjectClass* GetParticipantObjectClass() const = 0;
  protected:
    virtual ~IObjectClassRegistry() {}
}; // class IObjectClassRegistry

} // namespace NDistSimIB
} // namespace NSampleFDDEncoding
