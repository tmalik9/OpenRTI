
// Code automatically generated by FOMCodeGen version 2.1.0.0 from SampleFDD.xml, do not edit
#pragma once

#include <vector>
#include <mutex>
#include <future>

#include "RTI/Handle.h"
#include "RTI/RTIambassador.h"
#include "RTI/encoding/BasicDataElements.h"
#include "RTI/encoding/HLAfixedRecord.h"
#include "RTI/encoding/HLAfixedArray.h"
#include "RTI/encoding/HLAvariableArray.h"
#include "RTI/time/HLAinteger64Time.h"


#include "D:\vfs\OpenRTI-private\examples\codegen\interface/SampleFDDObjectInterfaces.h"
#include "SampleFDDEncodings.h"

class ObjectClassRegistry;

namespace NDistSimIB {
namespace NSampleFDDEncoding {

class ObjectClassRegistry;

// The instance implementation classes are disjunct inheritance-wise.
// So we need some common, internal functions, aggregated in an internal interface.
class IObjectImplBase
{
  public:
    virtual rti1516ev::ObjectInstanceHandle GetObjectInstanceHandle() const = 0;
};

class HLAobjectRoot;
class HLAobjectRootObjectClass : public IHLAobjectRootObjectClass
{
  public:
    // IHLAobjectRootObjectClass
    HLAobjectRootObjectClass() = default;
    virtual ~HLAobjectRootObjectClass();
    void Publish() override;
    void Unpublish() override;
    void Subscribe(bool deliverToSelf) override;
    void Unsubscribe() override;
    std::shared_ptr<IHLAobjectRoot> GetObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IHLAobjectRoot> CreateObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IHLAobjectRoot> CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback) override;
    std::shared_ptr<IHLAobjectRoot> RestoreObjectInstance(std::shared_ptr<IHLAobjectRoot>) override;
    std::shared_ptr<IHLAobjectRoot> RestoreObjectInstance(std::shared_ptr<IHLAobjectRoot>, ObjectCreatedCallbackType createdCallback) override;
    uint32_t RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback) override;
    void UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IHLAobjectRoot> newObjectInstance);

    uint32_t RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback) override;
    void UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IHLAobjectRoot> newObjectInstance);
    // Set a user-defined creator function, which returns subclasses of HLAobjectRoot
    using ObjectInstanceCreatorFunction = std::function<HLAobjectRoot*(HLAobjectRootObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)>;
    // When using custom object instance classes, don't forget to set the creator function *before* subscribing to the object class.
    void SetObjectInstanceCreator(ObjectInstanceCreatorFunction creatorFunction) { mCreatorFunction = creatorFunction; }
    // internal
    HLAobjectRootObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry);
    // attribute HLAprivilegeToDeleteObject : no data type
    void DiscoverObjectInstance (rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    rti1516ev::ObjectClassHandle GetObjectClassHandle() const { return mObjectClassHandle; }
    std::shared_ptr<IHLAobjectRoot> GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle);
    rti1516ev::AttributeHandleSet GetAllAttributeHandles();
    ObjectClassRegistry* GetObjectClassRegistry() const { return mRegistry; }

    // add object instance to maps (and to maps of base classes)
    void InsertObjectInstanceName(std::shared_ptr<IHLAobjectRoot> objectInstance, const std::wstring& objectInstanceName);
    void InsertObjectInstanceHandle(std::shared_ptr<IHLAobjectRoot> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle);
    // remove object instance from maps (and from maps of base classes)
    void EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName);
  private:
    ObjectClassRegistry* mRegistry;
    rti1516ev::RTIambassador* mRtiAmbassador;
    // object class handle
    rti1516ev::ObjectClassHandle mObjectClassHandle;
    ObjectInstanceCreatorFunction mCreatorFunction;
    bool mPublished = false;
    bool mSubscribed = false;
    // Attribute handles
    // attribute HLAprivilegeToDeleteObject : no data type
    // this mutex guards the data structures below
    mutable std::recursive_mutex mMutex;
    std::map<std::wstring, std::shared_ptr<IHLAobjectRoot>> mObjectInstancesByName;
    std::map<rti1516ev::ObjectInstanceHandle, std::shared_ptr<IHLAobjectRoot>> mObjectInstancesByHandle;

    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, DiscoverObjectInstanceCallback> mDiscoverCallbacks;
    uint32_t mLastDiscoverObjectInstanceCallbackToken = 0;
    std::map<uint32_t, RemoveObjectInstanceCallback> mRemoveObjectInstanceCallbacks;
    uint32_t mLastRemoveObjectInstanceCallbackToken = 0;
};


class HLAobjectRoot : public virtual IHLAobjectRoot, public IObjectImplBase
{
  public:

    virtual ~HLAobjectRoot();
    HLAobjectRoot(const HLAobjectRoot&) = delete;
    HLAobjectRoot(HLAobjectRoot&&) = delete;
    HLAobjectRoot& operator=(const HLAobjectRoot&) = delete;
    HLAobjectRoot& operator=(HLAobjectRoot&&) = delete;
    IHLAobjectRootObjectClass* GetObjectClass() const { return mObjectClass; }
    ObjectClassRegistry* GetObjectClassRegistry() const { return mObjectClass->GetObjectClassRegistry(); }
    std::wstring GetObjectInstanceName() const override { return mObjectInstanceName; }
    rti1516ev::ObjectInstanceHandle GetObjectInstanceHandle() const override { return mObjectInstanceHandle; }
    bool IsValid() const override;
    bool WaitForObjectValid() override;
    bool IsOwner() const override;
    void Release() override;
    // attribute HLAprivilegeToDeleteObject : no data type
    // IHLAobjectRoot

  protected:
    friend class HLAobjectRootObjectClass;

    HLAobjectRoot();
    HLAobjectRoot(HLAobjectRootObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* ambassador);


    // get attribute handle/value map of all attributes
    rti1516ev::AttributeHandleValueMap GetAllAttributeValues() const;
    // get attribute handle/value map of attributes which have been modified since last call to UpdateModifiedAttributeValues
    rti1516ev::AttributeHandleValueMap GetModifiedAttributeValues() const;

    rti1516ev::RTIambassador* mRtiAmbassador;
    // this mutex guards all of the fields below
    mutable std::recursive_mutex mMutex;

    HLAobjectRootObjectClass* mObjectClass;
    std::wstring mObjectInstanceName;
    rti1516ev::ObjectInstanceHandle mObjectInstanceHandle;
    bool mIsOwner = false;
    std::promise<bool> mCreatedPromise;
    std::future<bool>  mCreatedFuture;
    // Attribute value encoders
    // attribute HLAprivilegeToDeleteObject : no data type
};

class Participant;
class ParticipantObjectClass : public IParticipantObjectClass
{
  public:
    // IParticipantObjectClass
    ParticipantObjectClass() = default;
    virtual ~ParticipantObjectClass();
    void Publish() override;
    void Unpublish() override;
    void Subscribe(bool deliverToSelf) override;
    void Unsubscribe() override;
    std::shared_ptr<IParticipant> GetObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IParticipant> CreateObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<IParticipant> CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback) override;
    std::shared_ptr<IParticipant> RestoreObjectInstance(std::shared_ptr<IParticipant>) override;
    std::shared_ptr<IParticipant> RestoreObjectInstance(std::shared_ptr<IParticipant>, ObjectCreatedCallbackType createdCallback) override;
    uint32_t RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback) override;
    void UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IParticipant> newObjectInstance);

    uint32_t RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback) override;
    void UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IParticipant> newObjectInstance);
    // Set a user-defined creator function, which returns subclasses of Participant
    using ObjectInstanceCreatorFunction = std::function<Participant*(ParticipantObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)>;
    // When using custom object instance classes, don't forget to set the creator function *before* subscribing to the object class.
    void SetObjectInstanceCreator(ObjectInstanceCreatorFunction creatorFunction) { mCreatorFunction = creatorFunction; }
    // internal
    ParticipantObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, HLAobjectRootObjectClass* baseClass);

    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute Name : HLAunicodeString
    rti1516ev::AttributeHandle GetNameAttributeHandle() const { return mNameAttributeHandle; }
    // attribute Id : HLAinteger32LE
    rti1516ev::AttributeHandle GetIdAttributeHandle() const { return mIdAttributeHandle; }
    // attribute State : SimulationState
    rti1516ev::AttributeHandle GetStateAttributeHandle() const { return mStateAttributeHandle; }
    void DiscoverObjectInstance (rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    rti1516ev::ObjectClassHandle GetObjectClassHandle() const { return mObjectClassHandle; }
    std::shared_ptr<IParticipant> GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle);
    rti1516ev::AttributeHandleSet GetAllAttributeHandles();
    ObjectClassRegistry* GetObjectClassRegistry() const { return mRegistry; }

    // add object instance to maps (and to maps of base classes)
    void InsertObjectInstanceName(std::shared_ptr<IParticipant> objectInstance, const std::wstring& objectInstanceName);
    void InsertObjectInstanceHandle(std::shared_ptr<IParticipant> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle);
    // remove object instance from maps (and from maps of base classes)
    void EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName);
  private:
    ObjectClassRegistry* mRegistry;
    rti1516ev::RTIambassador* mRtiAmbassador;
    // object class handle
    rti1516ev::ObjectClassHandle mObjectClassHandle;
    HLAobjectRootObjectClass* mBaseClass;
    ObjectInstanceCreatorFunction mCreatorFunction;
    bool mPublished = false;
    bool mSubscribed = false;
    // Attribute handles
    // attribute Name : HLAunicodeString
    rti1516ev::AttributeHandle mNameAttributeHandle;
    // attribute Id : HLAinteger32LE
    rti1516ev::AttributeHandle mIdAttributeHandle;
    // attribute State : SimulationState
    rti1516ev::AttributeHandle mStateAttributeHandle;
    // this mutex guards the data structures below
    mutable std::recursive_mutex mMutex;
    std::map<std::wstring, std::shared_ptr<IParticipant>> mObjectInstancesByName;
    std::map<rti1516ev::ObjectInstanceHandle, std::shared_ptr<IParticipant>> mObjectInstancesByHandle;

    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, DiscoverObjectInstanceCallback> mDiscoverCallbacks;
    uint32_t mLastDiscoverObjectInstanceCallbackToken = 0;
    std::map<uint32_t, RemoveObjectInstanceCallback> mRemoveObjectInstanceCallbacks;
    uint32_t mLastRemoveObjectInstanceCallbackToken = 0;
};


class Participant : public virtual IParticipant, public IObjectImplBase
{
  public:

    virtual ~Participant();
    Participant(const Participant&) = delete;
    Participant(Participant&&) = delete;
    Participant& operator=(const Participant&) = delete;
    Participant& operator=(Participant&&) = delete;
    IParticipantObjectClass* GetObjectClass() const { return mObjectClass; }
    ObjectClassRegistry* GetObjectClassRegistry() const { return mObjectClass->GetObjectClassRegistry(); }
    std::wstring GetObjectInstanceName() const override { return mObjectInstanceName; }
    rti1516ev::ObjectInstanceHandle GetObjectInstanceHandle() const override { return mObjectInstanceHandle; }
    bool IsValid() const override;
    bool WaitForObjectValid() override;
    bool IsOwner() const override;
    void Release() override;
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute Name : HLAunicodeString
    std::wstring GetName() const override;
    void SetName(std::wstring newValue) override;
    // attribute Id : HLAinteger32LE
    int32_t GetId() const override;
    void SetId(int32_t newValue) override;
    // attribute State : SimulationState
    SimulationState GetState() const override;
    void SetState(SimulationState newValue) override;
    // IParticipant
    void UpdateAllAttributeValues() override;
    void UpdateAllAttributeValues(int64_t time) override;
    void UpdateModifiedAttributeValues() override;
    void UpdateModifiedAttributeValues(int64_t time) override;
    void RequestAttributeValues() override;
    void RequestAllAttributeValues() override;
    uint32_t RegisterUpdateCallback(UpdateCallback callback) override;
    void UnregisterUpdateCallback(uint32_t callbackToken) override;

    // bitmask of attributes ever received
    AttributeBits GetReceivedAttributes() const override;
    // bitmask of attributes received in last update (cleared after update callbacks executed)
    AttributeBits GetUpdatedAttributes() const override;
    // bitmask of attributes ever modified
    AttributeBits GetInitializedAttributes() const override;
    // bitmask of attributes modified since last updateAttributeValues/provideAttributeValues
    AttributeBits GetModifiedAttributes() const override;
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes);
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType);
    void ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributes, optional<int64_t> time);
  protected:
    friend class ParticipantObjectClass;

    Participant();
    Participant(ParticipantObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* ambassador);

    void ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType);

    // get attribute handle/value map of all attributes
    rti1516ev::AttributeHandleValueMap GetAllAttributeValues() const;
    // get attribute handle/value map of attributes which have been modified since last call to UpdateModifiedAttributeValues
    rti1516ev::AttributeHandleValueMap GetModifiedAttributeValues() const;

    rti1516ev::RTIambassador* mRtiAmbassador;
    // this mutex guards all of the fields below
    mutable std::recursive_mutex mMutex;

    ParticipantObjectClass* mObjectClass;
    std::wstring mObjectInstanceName;
    rti1516ev::ObjectInstanceHandle mObjectInstanceHandle;
    bool mIsOwner = false;
    std::promise<bool> mCreatedPromise;
    std::future<bool>  mCreatedFuture;
    // modified by any ReflectAttributeValues in the past
    AttributeBits mValuesReceived = kNone;
    // modified by any attribute setter
    AttributeBits mValuesSet = kNone;
    // modified by last ReflectAttributeValues
    AttributeBits mLastUpdated = kNone;
    // to be sent with next UpdateModifiedAttributeValues
    AttributeBits mDirty = kNone;
    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, UpdateCallback> mUpdateCallbacks;
    uint32_t mLastCallbackToken = 0;
    // Attribute value encoders
    // attribute HLAprivilegeToDeleteObject : no data type
    // attribute Name : HLAunicodeString
    rti1516ev::HLAunicodeString mName;
    // attribute Id : HLAinteger32LE
    rti1516ev::HLAinteger32LE mId;
    // attribute State : SimulationState
    rti1516ev::HLAoctet mState;
};

 

class ObjectClassRegistry : public IObjectClassRegistry
{
  public:
    ObjectClassRegistry();
    ~ObjectClassRegistry();
    void Initialize(rti1516ev::RTIambassador* rtiAmbassador);
    void Finalize();

    IHLAobjectRootObjectClass* GetHLAobjectRootObjectClass() const override { return mHLAobjectRootObjectClass.get(); }
    IParticipantObjectClass* GetParticipantObjectClass() const override { return mParticipantObjectClass.get(); }

    void DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    void ReflectAttributeValues(rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes);
    void ReflectAttributeValues(rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType);
    void ProvideAttributeValues(rti1516ev::ObjectClassHandle theObjectClass, rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time);
    void ObjectInstanceNameReservationSucceeded(std::wstring const & theObjectInstanceName);
    void ObjectInstanceNameReservationFailed(std::wstring const & theObjectInstanceName);
    void RegisterObjectInstanceName(const std::wstring& theObjectInstanceName, std::function<void(bool)> completionCallback);

  private:
    rti1516ev::RTIambassador* mRtiAmbassador;
    std::unique_ptr<HLAobjectRootObjectClass> mHLAobjectRootObjectClass;
    std::unique_ptr<ParticipantObjectClass> mParticipantObjectClass;
    std::map<std::wstring, std::function<void(bool)> > mObjectInstanceNameReservationCallbacks;
    std::map<rti1516ev::ObjectClassHandle, std::function<void(rti1516ev::ObjectInstanceHandle, const std::wstring&)>> mDiscoverCallbacks;
    std::map<rti1516ev::ObjectClassHandle, std::function<void(rti1516ev::ObjectInstanceHandle)>> mRemoveCallbacks;
    std::map<rti1516ev::ObjectClassHandle, std::function<void(rti1516ev::ObjectInstanceHandle, const rti1516ev::AttributeHandleValueMap&)>> mReflectCallbacks;
    std::map<rti1516ev::ObjectClassHandle, std::function<void(rti1516ev::ObjectInstanceHandle, const rti1516ev::AttributeHandleValueMap&, const rti1516ev::LogicalTime&, OrderType)>> mReflectWithTimeCallbacks;
    std::map<rti1516ev::ObjectClassHandle, std::function<void(rti1516ev::ObjectInstanceHandle, const rti1516ev::AttributeHandleSet&, optional<int64_t>)>> mProvideCallbacks;
}; // class ObjectClassRegistry

} // namespace NDistSimIB
} // namespace NSampleFDDEncoding
