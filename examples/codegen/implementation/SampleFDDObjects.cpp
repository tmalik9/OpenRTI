
// Code automatically generated by FOMCodeGen version 2.1.0.0 from SampleFDD.xml, do not edit

#include <vector>
#include <cassert>
#include "SampleFDDObjects.h"

namespace NDistSimIB {
namespace NSampleFDDEncoding {

inline std::string to_string(const std::wstring& str)
{
  if (str.empty()) return std::string();
  const std::ctype<wchar_t>& CType = std::use_facet<std::ctype<wchar_t> >(std::locale());
  std::vector<char> stringBuffer(str.length());
  CType.narrow(str.data(), str.data() + str.length(), '_', &stringBuffer[0]);
  return std::string(&stringBuffer[0], stringBuffer.size());
}

HLAobjectRootObjectClass::HLAobjectRootObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry)
{
  mRegistry = registry;
  mRtiAmbassador = rtiAmbassador;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot");
// attribute HLAobjectRoot.HLAprivilegeToDeleteObject : no data type
  SetObjectInstanceCreator([](HLAobjectRootObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador) -> HLAobjectRoot* {
    return new HLAobjectRoot(objectClass, instanceName, rtiAmbassador);
  });
}

HLAobjectRootObjectClass::~HLAobjectRootObjectClass()
{
  //std::lock_guard<std::recursive_mutex> lock(mMutex);
  while (!mObjectInstancesByHandle.empty())
  {
    // careful - hold the reference to the object instance until it has been removed from the maps,
    // otherwise it's mutex will be destroyed while held
    auto objectInstance = mObjectInstancesByHandle.begin()->second;
    objectInstance->Release();
  }
  assert(mObjectInstancesByHandle.empty());
  assert(mObjectInstancesByName.empty());
}

void HLAobjectRootObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void HLAobjectRootObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void HLAobjectRootObjectClass::Subscribe(bool deliverToSelf)
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    if (deliverToSelf) mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void HLAobjectRootObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

rti1516ev::AttributeHandleSet HLAobjectRootObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  return result;
}

void HLAobjectRootObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  assert(mObjectInstancesByHandle.find(objectInstanceHandle) == mObjectInstancesByHandle.end());
  std::shared_ptr<HLAobjectRoot> discoveredObject;
  auto objectInstanceIter = mObjectInstancesByName.find(objectInstanceName);
  if (objectInstanceIter == mObjectInstancesByName.end())
  {
    discoveredObject = std::shared_ptr<HLAobjectRoot>(mCreatorFunction(this, objectInstanceName, mRtiAmbassador));
    InsertObjectInstanceName(discoveredObject, objectInstanceName);
  }
  else
  {
    // Federate currently tries to reserve an object that was already created by another federate
    discoveredObject = std::dynamic_pointer_cast<HLAobjectRoot>(objectInstanceIter->second);
  }
  discoveredObject->mObjectInstanceHandle = objectInstanceHandle;
  discoveredObject->mIsOwner = false;
  InsertObjectInstanceHandle(discoveredObject, objectInstanceHandle);
  ExecuteDiscoverObjectInstanceCallbacks(discoveredObject);
}

void HLAobjectRootObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring objectInstanceName = mRtiAmbassador->getObjectInstanceName(objectInstanceHandle);
  auto iter = mObjectInstancesByName.find(objectInstanceName);
  assert(iter != mObjectInstancesByName.end());
  auto objectInstance = std::dynamic_pointer_cast<HLAobjectRoot>(iter->second);
  ExecuteRemoveObjectInstanceCallbacks(objectInstance);
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  EraseObjectInstance(objectInstanceHandle, objectInstanceName);
}

std::shared_ptr<IHLAobjectRoot> HLAobjectRootObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  return nullptr;
}

std::shared_ptr<IHLAobjectRoot> HLAobjectRootObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  return nullptr;
}

std::shared_ptr<IHLAobjectRoot> HLAobjectRootObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"HLAobjectRoot");
  }
  try {
    /* auto existingObjectInstance =*/ mRtiAmbassador->getObjectInstanceHandle(instanceName);
    return nullptr;
  }
  catch (const rti1516ev::ObjectInstanceNotKnown&)
  {
    // continue
  }
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  std::shared_ptr<HLAobjectRoot> newObject = std::shared_ptr<HLAobjectRoot>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  newObject->mCreatedPromise = std::promise<bool>();
  newObject->mCreatedFuture = newObject->mCreatedPromise.get_future();
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
    }
    newObject->mCreatedPromise.set_value(success);
  });
  return newObject;
}

std::shared_ptr<IHLAobjectRoot> HLAobjectRootObjectClass::CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"HLAobjectRoot");
  }
  std::shared_ptr<HLAobjectRoot> newObject = std::shared_ptr<HLAobjectRoot>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  newObject->mCreatedPromise = std::promise<bool>();
  newObject->mCreatedFuture = newObject->mCreatedPromise.get_future();
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
      createdCallback(newObject, true);
    }
    else
    {
      createdCallback(newObject, false);
    }
    newObject->mCreatedPromise.set_value(success);
  });
  return newObject;
}

std::shared_ptr<IHLAobjectRoot> HLAobjectRootObjectClass::RestoreObjectInstance(std::shared_ptr<IHLAobjectRoot> deadObject)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring instanceName = deadObject->GetObjectInstanceName();
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    // object already exists
    return nullptr;
  }
  if (!mPublished)
  {
    Publish();
  }
  try {
    /* auto existingObjectInstance =*/ mRtiAmbassador->getObjectInstanceHandle(instanceName);
    // object already exists, but has not been created by the class registry - indicate failure
    return nullptr;
  }
  catch (const rti1516ev::ObjectInstanceNotKnown&)
  {
    // continue
  }
  auto deadObjectImpl = std::dynamic_pointer_cast<HLAobjectRoot>(deadObject);
  deadObjectImpl->mRtiAmbassador = mRtiAmbassador;
  deadObjectImpl->mObjectClass = this;
  deadObjectImpl->mCreatedPromise = std::promise<bool>();
  deadObjectImpl->mCreatedFuture = deadObjectImpl->mCreatedPromise.get_future();
  InsertObjectInstanceName(deadObjectImpl, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, deadObjectImpl, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      deadObjectImpl->mObjectInstanceHandle = instanceHandle;
      deadObjectImpl->mIsOwner = true;
      InsertObjectInstanceHandle(deadObjectImpl, instanceHandle);
    }
    deadObjectImpl->mCreatedPromise.set_value(success);
  });
  return deadObject;
}

std::shared_ptr<IHLAobjectRoot> HLAobjectRootObjectClass::RestoreObjectInstance(std::shared_ptr<IHLAobjectRoot> deadObject, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring instanceName = deadObject->GetObjectInstanceName();
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    // object already exists
    return nullptr;
  }
  if (!mPublished)
  {
    Publish();
  }
  try {
    /* auto existingObjectInstance =*/ mRtiAmbassador->getObjectInstanceHandle(instanceName);
    // object already exists, but has not been created by the class registry - indicate failure
    return nullptr;
  }
  catch (const rti1516ev::ObjectInstanceNotKnown&)
  {
    // continue
  }
  auto deadObjectImpl = std::dynamic_pointer_cast<HLAobjectRoot>(deadObject);
  deadObjectImpl->mRtiAmbassador = mRtiAmbassador;
  deadObjectImpl->mObjectClass = this;
  deadObjectImpl->mCreatedPromise = std::promise<bool>();
  deadObjectImpl->mCreatedFuture = deadObjectImpl->mCreatedPromise.get_future();
  InsertObjectInstanceName(deadObjectImpl, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, deadObjectImpl, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      deadObjectImpl->mObjectInstanceHandle = instanceHandle;
      deadObjectImpl->mIsOwner = true;
      InsertObjectInstanceHandle(deadObjectImpl, instanceHandle);
      createdCallback(deadObjectImpl, true);
    }
    else
    {
      createdCallback(deadObjectImpl, false);
    }
    deadObjectImpl->mCreatedPromise.set_value(success);
  });
  return deadObject;
}

uint32_t HLAobjectRootObjectClass::RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastDiscoverObjectInstanceCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastDiscoverObjectInstanceCallbackToken, callback));
  return mLastDiscoverObjectInstanceCallbackToken;
}

void HLAobjectRootObjectClass::UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mDiscoverCallbacks.erase(callbackToken);
}

void HLAobjectRootObjectClass::ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IHLAobjectRoot> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

uint32_t HLAobjectRootObjectClass::RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastRemoveObjectInstanceCallbackToken++;
  mRemoveObjectInstanceCallbacks.insert(std::make_pair(mLastRemoveObjectInstanceCallbackToken, callback));
  return mLastRemoveObjectInstanceCallbackToken;
}

void HLAobjectRootObjectClass::UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mRemoveObjectInstanceCallbacks.erase(callbackToken);
}

void HLAobjectRootObjectClass::ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IHLAobjectRoot> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mRemoveObjectInstanceCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

void HLAobjectRootObjectClass::InsertObjectInstanceName(std::shared_ptr<IHLAobjectRoot> objectInstance, const std::wstring& objectInstanceName)
{
  // prerequisite: mMutex must be locked
  mObjectInstancesByName.insert(std::make_pair(objectInstanceName, objectInstance));
}

void HLAobjectRootObjectClass::InsertObjectInstanceHandle(std::shared_ptr<IHLAobjectRoot> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByHandle.insert(std::make_pair(objectInstanceHandle, objectInstance));
}

void HLAobjectRootObjectClass::EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByName.erase(objectInstanceName);
  mObjectInstancesByHandle.erase(objectInstanceHandle);
}


// object instances of type 'HLAobjectRoot'
HLAobjectRoot::HLAobjectRoot()
  : mRtiAmbassador()
  , mObjectClass()
  , mObjectInstanceName()
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

HLAobjectRoot::HLAobjectRoot(HLAobjectRootObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mRtiAmbassador(rtiAmbassador)
  , mObjectClass(objectClass)
  , mObjectInstanceName(instanceName)
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

HLAobjectRoot::~HLAobjectRoot()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    try
    {
      mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    }
    catch (const rti1516ev::Exception&)
    {
    }
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

bool HLAobjectRoot::IsValid() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mObjectInstanceHandle.isValid();
}

bool HLAobjectRoot::WaitForObjectValid()
{
  return mCreatedFuture.get();
}

bool HLAobjectRoot::IsOwner() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mIsOwner;
}

void HLAobjectRoot::Release()
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (mObjectInstanceHandle.isValid())
  {
    if (mIsOwner)
    {
      try
      {
        mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
      }
      catch (const rti1516ev::Exception&)
      {
        // ignore - must execute rest of function
      }
      mIsOwner = false;
    }
    mObjectClass->EraseObjectInstance(mObjectInstanceHandle, mObjectInstanceName);
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mObjectClass = nullptr;
    mRtiAmbassador = nullptr;
  }
}

// attribute HLAobjectRoot.HLAprivilegeToDeleteObject : no data type

rti1516ev::AttributeHandleValueMap HLAobjectRoot::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  return result;
}

rti1516ev::AttributeHandleValueMap HLAobjectRoot::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  return result;
}

// object class type 'Participant'
ParticipantObjectClass::ParticipantObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, HLAobjectRootObjectClass* baseClass)
{
  mRegistry = registry;
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.Participant");
  // attribute Name : HLAunicodeString
  mNameAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"Name");
  // attribute Id : HLAinteger32LE
  mIdAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"Id");
  // attribute State : SimulationState
  mStateAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"State");
  SetObjectInstanceCreator([](ParticipantObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador) -> Participant* {
    return new Participant(objectClass, instanceName, rtiAmbassador);
  });
}

ParticipantObjectClass::~ParticipantObjectClass()
{
  //std::lock_guard<std::recursive_mutex> lock(mMutex);
  while (!mObjectInstancesByHandle.empty())
  {
    // careful - hold the reference to the object instance until it has been removed from the maps,
    // otherwise it's mutex will be destroyed while held
    auto objectInstance = mObjectInstancesByHandle.begin()->second;
    objectInstance->Release();
  }
  assert(mObjectInstancesByHandle.empty());
  assert(mObjectInstancesByName.empty());
}

void ParticipantObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void ParticipantObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void ParticipantObjectClass::Subscribe(bool deliverToSelf)
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    if (deliverToSelf) mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void ParticipantObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

rti1516ev::AttributeHandleSet ParticipantObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetNameAttributeHandle());
  result.insert(GetIdAttributeHandle());
  result.insert(GetStateAttributeHandle());
  return result;
}

void ParticipantObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  assert(mObjectInstancesByHandle.find(objectInstanceHandle) == mObjectInstancesByHandle.end());
  std::shared_ptr<Participant> discoveredObject;
  auto objectInstanceIter = mObjectInstancesByName.find(objectInstanceName);
  if (objectInstanceIter == mObjectInstancesByName.end())
  {
    discoveredObject = std::shared_ptr<Participant>(mCreatorFunction(this, objectInstanceName, mRtiAmbassador));
    InsertObjectInstanceName(discoveredObject, objectInstanceName);
  }
  else
  {
    // Federate currently tries to reserve an object that was already created by another federate
    discoveredObject = std::dynamic_pointer_cast<Participant>(objectInstanceIter->second);
  }
  discoveredObject->mObjectInstanceHandle = objectInstanceHandle;
  discoveredObject->mIsOwner = false;
  InsertObjectInstanceHandle(discoveredObject, objectInstanceHandle);
  ExecuteDiscoverObjectInstanceCallbacks(discoveredObject);
}

void ParticipantObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring objectInstanceName = mRtiAmbassador->getObjectInstanceName(objectInstanceHandle);
  auto iter = mObjectInstancesByName.find(objectInstanceName);
  assert(iter != mObjectInstancesByName.end());
  auto objectInstance = std::dynamic_pointer_cast<Participant>(iter->second);
  ExecuteRemoveObjectInstanceCallbacks(objectInstance);
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  EraseObjectInstance(objectInstanceHandle, objectInstanceName);
}

std::shared_ptr<IParticipant> ParticipantObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IHLAobjectRoot> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceName);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IParticipant>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IParticipant> ParticipantObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IHLAobjectRoot> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceHandle);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IParticipant>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IParticipant> ParticipantObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"Participant");
  }
  try {
    /* auto existingObjectInstance =*/ mRtiAmbassador->getObjectInstanceHandle(instanceName);
    return nullptr;
  }
  catch (const rti1516ev::ObjectInstanceNotKnown&)
  {
    // continue
  }
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  std::shared_ptr<Participant> newObject = std::shared_ptr<Participant>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  newObject->mCreatedPromise = std::promise<bool>();
  newObject->mCreatedFuture = newObject->mCreatedPromise.get_future();
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
    }
    newObject->mCreatedPromise.set_value(success);
  });
  return newObject;
}

std::shared_ptr<IParticipant> ParticipantObjectClass::CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"Participant");
  }
  std::shared_ptr<Participant> newObject = std::shared_ptr<Participant>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  newObject->mCreatedPromise = std::promise<bool>();
  newObject->mCreatedFuture = newObject->mCreatedPromise.get_future();
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
      createdCallback(newObject, true);
    }
    else
    {
      createdCallback(newObject, false);
    }
    newObject->mCreatedPromise.set_value(success);
  });
  return newObject;
}

std::shared_ptr<IParticipant> ParticipantObjectClass::RestoreObjectInstance(std::shared_ptr<IParticipant> deadObject)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring instanceName = deadObject->GetObjectInstanceName();
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    // object already exists
    return nullptr;
  }
  if (!mPublished)
  {
    Publish();
  }
  try {
    /* auto existingObjectInstance =*/ mRtiAmbassador->getObjectInstanceHandle(instanceName);
    // object already exists, but has not been created by the class registry - indicate failure
    return nullptr;
  }
  catch (const rti1516ev::ObjectInstanceNotKnown&)
  {
    // continue
  }
  auto deadObjectImpl = std::dynamic_pointer_cast<Participant>(deadObject);
  deadObjectImpl->mRtiAmbassador = mRtiAmbassador;
  deadObjectImpl->mObjectClass = this;
  deadObjectImpl->mCreatedPromise = std::promise<bool>();
  deadObjectImpl->mCreatedFuture = deadObjectImpl->mCreatedPromise.get_future();
  InsertObjectInstanceName(deadObjectImpl, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, deadObjectImpl, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      deadObjectImpl->mObjectInstanceHandle = instanceHandle;
      deadObjectImpl->mIsOwner = true;
      InsertObjectInstanceHandle(deadObjectImpl, instanceHandle);
    }
    deadObjectImpl->mCreatedPromise.set_value(success);
  });
  return deadObject;
}

std::shared_ptr<IParticipant> ParticipantObjectClass::RestoreObjectInstance(std::shared_ptr<IParticipant> deadObject, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring instanceName = deadObject->GetObjectInstanceName();
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    // object already exists
    return nullptr;
  }
  if (!mPublished)
  {
    Publish();
  }
  try {
    /* auto existingObjectInstance =*/ mRtiAmbassador->getObjectInstanceHandle(instanceName);
    // object already exists, but has not been created by the class registry - indicate failure
    return nullptr;
  }
  catch (const rti1516ev::ObjectInstanceNotKnown&)
  {
    // continue
  }
  auto deadObjectImpl = std::dynamic_pointer_cast<Participant>(deadObject);
  deadObjectImpl->mRtiAmbassador = mRtiAmbassador;
  deadObjectImpl->mObjectClass = this;
  deadObjectImpl->mCreatedPromise = std::promise<bool>();
  deadObjectImpl->mCreatedFuture = deadObjectImpl->mCreatedPromise.get_future();
  InsertObjectInstanceName(deadObjectImpl, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, deadObjectImpl, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      deadObjectImpl->mObjectInstanceHandle = instanceHandle;
      deadObjectImpl->mIsOwner = true;
      InsertObjectInstanceHandle(deadObjectImpl, instanceHandle);
      createdCallback(deadObjectImpl, true);
    }
    else
    {
      createdCallback(deadObjectImpl, false);
    }
    deadObjectImpl->mCreatedPromise.set_value(success);
  });
  return deadObject;
}

uint32_t ParticipantObjectClass::RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastDiscoverObjectInstanceCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastDiscoverObjectInstanceCallbackToken, callback));
  return mLastDiscoverObjectInstanceCallbackToken;
}

void ParticipantObjectClass::UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mDiscoverCallbacks.erase(callbackToken);
}

void ParticipantObjectClass::ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IParticipant> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

uint32_t ParticipantObjectClass::RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastRemoveObjectInstanceCallbackToken++;
  mRemoveObjectInstanceCallbacks.insert(std::make_pair(mLastRemoveObjectInstanceCallbackToken, callback));
  return mLastRemoveObjectInstanceCallbackToken;
}

void ParticipantObjectClass::UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mRemoveObjectInstanceCallbacks.erase(callbackToken);
}

void ParticipantObjectClass::ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IParticipant> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mRemoveObjectInstanceCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

void ParticipantObjectClass::InsertObjectInstanceName(std::shared_ptr<IParticipant> objectInstance, const std::wstring& objectInstanceName)
{
  // prerequisite: mMutex must be locked
  mObjectInstancesByName.insert(std::make_pair(objectInstanceName, objectInstance));
  mBaseClass->InsertObjectInstanceName(objectInstance, objectInstanceName);
}

void ParticipantObjectClass::InsertObjectInstanceHandle(std::shared_ptr<IParticipant> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByHandle.insert(std::make_pair(objectInstanceHandle, objectInstance));
  mBaseClass->InsertObjectInstanceHandle(objectInstance, objectInstanceHandle);
}

void ParticipantObjectClass::EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mBaseClass->EraseObjectInstance(objectInstanceHandle, objectInstanceName);
  mObjectInstancesByName.erase(objectInstanceName);
  mObjectInstancesByHandle.erase(objectInstanceHandle);
}


// object instances of type 'Participant'
Participant::Participant()
  : mRtiAmbassador()
  , mObjectClass()
  , mObjectInstanceName()
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

Participant::Participant(ParticipantObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mRtiAmbassador(rtiAmbassador)
  , mObjectClass(objectClass)
  , mObjectInstanceName(instanceName)
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

Participant::~Participant()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    try
    {
      mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    }
    catch (const rti1516ev::Exception&)
    {
    }
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

bool Participant::IsValid() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mObjectInstanceHandle.isValid();
}

bool Participant::WaitForObjectValid()
{
  return mCreatedFuture.get();
}

bool Participant::IsOwner() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mIsOwner;
}

void Participant::Release()
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (mObjectInstanceHandle.isValid())
  {
    if (mIsOwner)
    {
      try
      {
        mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
      }
      catch (const rti1516ev::Exception&)
      {
        // ignore - must execute rest of function
      }
      mIsOwner = false;
    }
    mObjectClass->EraseObjectInstance(mObjectInstanceHandle, mObjectInstanceName);
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mObjectClass = nullptr;
    mRtiAmbassador = nullptr;
  }
}

// attribute Participant.HLAprivilegeToDeleteObject : no data type

// attribute Name : HLAunicodeString
std::wstring Participant::GetName() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mName.get();
}

void Participant::SetName(std::wstring newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mName.set(newValue);
  mDirty |= kNameBit;
  mValuesSet |= kNameBit;
}

// attribute Id : HLAinteger32LE
int32_t Participant::GetId() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mId.get();
}

void Participant::SetId(int32_t newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mId.set(newValue);
  mDirty |= kIdBit;
  mValuesSet |= kIdBit;
}

// attribute State : SimulationState
SimulationState Participant::GetState() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return static_cast<SimulationState>(mState.get());
}

void Participant::SetState(SimulationState newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mState.set(static_cast<uint8_t>(newValue));
  mDirty |= kStateBit;
  mValuesSet |= kStateBit;
}

rti1516ev::AttributeHandleValueMap Participant::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetNameAttributeHandle()] = mName.encode();
  result[mObjectClass->GetIdAttributeHandle()] = mId.encode();
  result[mObjectClass->GetStateAttributeHandle()] = mState.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap Participant::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kNameBit)
  {
    result[mObjectClass->GetNameAttributeHandle()] = mName.encode();
  }
  if (mDirty & kIdBit)
  {
    result[mObjectClass->GetIdAttributeHandle()] = mId.encode();
  }
  if (mDirty & kStateBit)
  {
    result[mObjectClass->GetStateAttributeHandle()] = mState.encode();
  }
  return result;
}

Participant::AttributeBits Participant::GetReceivedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesReceived;
}

Participant::AttributeBits Participant::GetUpdatedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mLastUpdated;
}

Participant::AttributeBits Participant::GetInitializedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesSet;
}

Participant::AttributeBits Participant::GetModifiedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDirty;
}

void Participant::UpdateAllAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void Participant::UpdateAllAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    try {
      mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
      mDirty = kNone;
    }
    catch (const rti1516ev::InvalidLogicalTime& e)
    {
      throw InvalidLogicalTime(to_string(e.what()));
    }
    catch (const rti1516ev::Exception& e)
    {
      throw std::runtime_error(to_string(e.what()));
    }
  }
}

void Participant::UpdateModifiedAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void Participant::UpdateModifiedAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
        mDirty = kNone;
      }
      catch (const rti1516ev::InvalidLogicalTime& e)
      {
        throw InvalidLogicalTime(to_string(e.what()));
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void Participant::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetNameAttributeHandle())
    {
      mName.decode(attributeHandleValue.second);
      mLastUpdated |= kNameBit;
    }
    else if (attributeHandle == mObjectClass->GetIdAttributeHandle())
    {
      mId.decode(attributeHandleValue.second);
      mLastUpdated |= kIdBit;
    }
    else if (attributeHandle == mObjectClass->GetStateAttributeHandle())
    {
      mState.decode(attributeHandleValue.second);
      mLastUpdated |= kStateBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(optional<int64_t>(), optional<OrderType>());
  mLastUpdated = kNone;
} // Participant::ReflectAttributeValues

void Participant::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& time, OrderType orderType)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetNameAttributeHandle())
    {
      mName.decode(attributeHandleValue.second);
      mLastUpdated |= kNameBit;
    }
    else if (attributeHandle == mObjectClass->GetIdAttributeHandle())
    {
      mId.decode(attributeHandleValue.second);
      mLastUpdated |= kIdBit;
    }
    else if (attributeHandle == mObjectClass->GetStateAttributeHandle())
    {
      mState.decode(attributeHandleValue.second);
      mLastUpdated |= kStateBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  mLastUpdated = kNone;
} // Participant::ReflectAttributeValues

// request attributes not being part of the last update
void Participant::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    if ((mLastUpdated & kNameBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetNameAttributeHandle());
    }
    if ((mLastUpdated & kIdBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetIdAttributeHandle());
    }
    if ((mLastUpdated & kStateBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetStateAttributeHandle());
    }
  } // scope of lock_guard
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// request all attributes, regardless of current state
void Participant::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetNameAttributeHandle());
  requestAttributes.insert(mObjectClass->GetIdAttributeHandle());
  requestAttributes.insert(mObjectClass->GetStateAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// provide requested attributes set since last sent update
void Participant::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    for (auto& attributeHandle : attributeHandles)
    {
      if (attributeHandle == mObjectClass->GetNameAttributeHandle() && (mValuesSet & kNameBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mName.encode()));
        mDirty &= ~kNameBit;
      }
      else if (attributeHandle == mObjectClass->GetIdAttributeHandle() && (mValuesSet & kIdBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mId.encode()));
        mDirty &= ~kIdBit;
      }
      else if (attributeHandle == mObjectClass->GetStateAttributeHandle() && (mValuesSet & kStateBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mState.encode()));
        mDirty &= ~kStateBit;
      }
    } // for (auto& attributeHandleValue : attributes)
  } // scope of lock_guard
  if (time)
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(*time));
  else
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // Participant::ReflectAttributeValues

uint32_t Participant::RegisterUpdateCallback(UpdateCallback callback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void Participant::UnregisterUpdateCallback(uint32_t callbackToken)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mUpdateCallbacks.erase(callbackToken);
}

void Participant::ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(std::static_pointer_cast<IParticipant>(shared_from_this()), time, orderType);
  }
}

ObjectClassRegistry::ObjectClassRegistry()
  : mRtiAmbassador(nullptr)
{
}

ObjectClassRegistry::~ObjectClassRegistry()
{
}

void ObjectClassRegistry::Initialize(rti1516ev::RTIambassador* rtiAmbassador)
{
  mRtiAmbassador = rtiAmbassador;
  try
  {
    mHLAobjectRootObjectClass = std::unique_ptr<HLAobjectRootObjectClass>(new HLAobjectRootObjectClass(mRtiAmbassador, this));
    mDiscoverCallbacks.insert(std::make_pair(
      mHLAobjectRootObjectClass->GetObjectClassHandle(),
      [this](rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName) {
        mHLAobjectRootObjectClass->DiscoverObjectInstance(objectInstanceHandle, objectInstanceName);
      }));
    mRemoveCallbacks.insert(std::make_pair(
      mHLAobjectRootObjectClass->GetObjectClassHandle(),
      [this](rti1516ev::ObjectInstanceHandle objectInstanceHandle) {
        mHLAobjectRootObjectClass->RemoveObjectInstance(objectInstanceHandle);
      }));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mHLAobjectRootObjectClass.get() != nullptr);
    mParticipantObjectClass = std::unique_ptr<ParticipantObjectClass>(new ParticipantObjectClass(mRtiAmbassador, this, mHLAobjectRootObjectClass.get()));
    mDiscoverCallbacks.insert(std::make_pair(
      mParticipantObjectClass->GetObjectClassHandle(),
      [this](rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName) {
        mParticipantObjectClass->DiscoverObjectInstance(objectInstanceHandle, objectInstanceName);
      }));
    mRemoveCallbacks.insert(std::make_pair(
      mParticipantObjectClass->GetObjectClassHandle(),
      [this](rti1516ev::ObjectInstanceHandle objectInstanceHandle) {
        mParticipantObjectClass->RemoveObjectInstance(objectInstanceHandle);
      }));
    mReflectCallbacks.insert(std::make_pair(
      mParticipantObjectClass->GetObjectClassHandle(),
      [this](rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes) {
        auto objectInstance = std::dynamic_pointer_cast<Participant>(mParticipantObjectClass->GetObjectInstance(theObject));
        if (objectInstance != nullptr) {
          objectInstance->ReflectAttributeValues(attributes);
        }
      }));
    mReflectWithTimeCallbacks.insert(std::make_pair(
      mParticipantObjectClass->GetObjectClassHandle(),
      [this](rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes, const rti1516ev::LogicalTime& time, OrderType orderType) {
        auto objectInstance = std::dynamic_pointer_cast<Participant>(mParticipantObjectClass->GetObjectInstance(theObject));
        objectInstance->ReflectAttributeValues(attributes, time, orderType);
      }));
    mProvideCallbacks.insert(std::make_pair(
      mParticipantObjectClass->GetObjectClassHandle(),
      [this](rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time) {
        auto objectInstance = std::dynamic_pointer_cast<Participant>(mParticipantObjectClass->GetObjectInstance(theObject));
        if (objectInstance != nullptr) {
          objectInstance->ProvideAttributeValues(attributeHandles, time);
        }
      }));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
} // Initialize

void ObjectClassRegistry::Finalize()
{
  mDiscoverCallbacks.clear();
  mRemoveCallbacks.clear();
  mReflectCallbacks.clear();
  mReflectWithTimeCallbacks.clear();
  mProvideCallbacks.clear();
  mParticipantObjectClass.reset();
  mHLAobjectRootObjectClass.reset();
  mRtiAmbassador = nullptr;
} // Initialize

void ObjectClassRegistry::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  rti1516ev::ObjectClassHandle theObjectClass = mRtiAmbassador->getKnownObjectClassHandle(theObject);
  auto iter = mDiscoverCallbacks.find(theObjectClass);
  if (iter != mDiscoverCallbacks.end())
  {
    iter->second(theObject, theObjectInstanceName);
  }
}

void ObjectClassRegistry::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  rti1516ev::ObjectClassHandle theObjectClass = mRtiAmbassador->getKnownObjectClassHandle(theObject);
  auto iter = mRemoveCallbacks.find(theObjectClass);
  if (iter != mRemoveCallbacks.end())
  {
    iter->second(theObject);
  }
}

void ObjectClassRegistry::ReflectAttributeValues(rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  rti1516ev::ObjectClassHandle theObjectClass = mRtiAmbassador->getKnownObjectClassHandle(theObject);
  auto iter = mReflectCallbacks.find(theObjectClass);
  if (iter != mReflectCallbacks.end())
  {
    iter->second(theObject, attributes);
  }
}

void ObjectClassRegistry::ReflectAttributeValues(rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes, const rti1516ev::LogicalTime& time, OrderType orderType)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  rti1516ev::ObjectClassHandle theObjectClass = mRtiAmbassador->getKnownObjectClassHandle(theObject);
  auto iter = mReflectWithTimeCallbacks.find(theObjectClass);
  if (iter != mReflectWithTimeCallbacks.end())
  {
    iter->second(theObject, attributes, time, orderType);
  }
}

void ObjectClassRegistry::ProvideAttributeValues(rti1516ev::ObjectClassHandle theObjectClass, rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  auto iter = mProvideCallbacks.find(theObjectClass);
  if (iter != mProvideCallbacks.end())
  {
    iter->second(theObject, attributeHandles, time);
  }
}

void ObjectClassRegistry::RegisterObjectInstanceName(const std::wstring& theObjectInstanceName, std::function<void(bool)> completionCallback)
{
  mObjectInstanceNameReservationCallbacks.insert(std::make_pair(theObjectInstanceName, completionCallback));
  mRtiAmbassador->reserveObjectInstanceName(theObjectInstanceName);
}

void ObjectClassRegistry::ObjectInstanceNameReservationSucceeded(const std::wstring& theObjectInstanceName)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  auto iter = mObjectInstanceNameReservationCallbacks.find(theObjectInstanceName);
  if (iter != mObjectInstanceNameReservationCallbacks.end())
  {
    iter->second(true);
    mObjectInstanceNameReservationCallbacks.erase(iter);
  }
}

void ObjectClassRegistry::ObjectInstanceNameReservationFailed(const std::wstring& theObjectInstanceName)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  auto iter = mObjectInstanceNameReservationCallbacks.find(theObjectInstanceName);
  if (iter != mObjectInstanceNameReservationCallbacks.end())
  {
    iter->second(false);
    mObjectInstanceNameReservationCallbacks.erase(iter);
  }
}

} // namespace NDistSimIB
} // namespace NSampleFDDEncoding
