
// Code automatically generated by FOMCodeGen version 2.1.0.0 from SampleFDD.xml, do not edit

#include <vector>
#include <cassert>

#include "RTI/time/HLAinteger64Time.h"

#include "SampleFDDInteractions.h"
#include "SampleFDDObjects.h"

namespace NDistSimIB {
namespace NSampleFDDEncoding {

inline std::string to_string(const std::wstring& str)
{
  if (str.empty()) return std::string();
  const std::ctype<wchar_t>& CType = std::use_facet<std::ctype<wchar_t> >(std::locale());
  std::vector<char> stringBuffer(str.length());
  CType.narrow(str.data(), str.data() + str.length(), '_', &stringBuffer[0]);
  return std::string(&stringBuffer[0], stringBuffer.size());
}

HLAinteractionRootInteractionClass::HLAinteractionRootInteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry)
{
  mInteractionClassRegistry = interactionClassRegistry;
  mRtiAmbassador = rtiAmbassador;

  mInteractionClassHandle = rtiAmbassador->getInteractionClassHandle(L"HLAinteractionRoot");
}

// get the corresponding *object* class registry, for access to objects sent as parameters
ObjectClassRegistry* HLAinteractionRootInteractionClass::GetObjectClassRegistry()
{
  return mInteractionClassRegistry->GetObjectClassRegistry();
}

void HLAinteractionRootInteractionClass::Publish()
{
  if (!mPublished)
  {
    mRtiAmbassador->publishInteractionClass(mInteractionClassHandle);
    mPublished = true;
  }
}

void HLAinteractionRootInteractionClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishInteractionClass(mInteractionClassHandle);
    mPublished = false;
  }
}

void HLAinteractionRootInteractionClass::Subscribe(bool deliverToSelf)
{
  mRtiAmbassador->subscribeInteractionClass(mInteractionClassHandle);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  mSubscribed = true;
}


void HLAinteractionRootInteractionClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeInteractionClass(mInteractionClassHandle);
    mSubscribed = false;
  }
}

void HLAinteractionRootInteractionClass::send()
{
  rti1516ev::ParameterHandleValueMap parameters;
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData());
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void HLAinteractionRootInteractionClass::sendWithTime(int64_t time)
{
  rti1516ev::ParameterHandleValueMap parameters;
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
  }
  catch (const rti1516ev::InvalidLogicalTime& e)
  {
    throw InvalidLogicalTime(to_string(e.what()));
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void HLAinteractionRootInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap&)
{
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(optional<int64_t>(), optional<OrderType>());
  }
}

void HLAinteractionRootInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap&, const rti1516ev::LogicalTime& time, OrderType orderType)
{

  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  }
}

HLAinteractionRootInteractionClass::ReceiveCallbackHandle HLAinteractionRootInteractionClass::RegisterReceiveCallback(ReceiveCallback callback)
{
  ReceiveCallbackHandle key = mReceiveCallbacksNextKey++;
  mReceiveCallbacks.insert(std::make_pair(key, callback));
  return key;
}

void HLAinteractionRootInteractionClass::UnregisterReceiveCallback(ReceiveCallbackHandle callbackHandle)
{
  auto iter = mReceiveCallbacks.find(callbackHandle);
  if (iter != mReceiveCallbacks.end())
  {
    mReceiveCallbacks.erase(iter);
  }
}

rti1516ev::ParameterHandleSet HLAinteractionRootInteractionClass::GetAllParameterHandles()
{
  rti1516ev::ParameterHandleSet result;
  return result;
}

// object class type 'Start'
StartInteractionClass::StartInteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry, HLAinteractionRootInteractionClass* baseClass)
{
  mInteractionClassRegistry = interactionClassRegistry;
  mRtiAmbassador = rtiAmbassador;

  mBaseClass = baseClass;
  mInteractionClassHandle = rtiAmbassador->getInteractionClassHandle(L"HLAinteractionRoot.Start");
  // parameter Start.Dummy : no data type
  mDummyParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"Dummy");
}

// get the corresponding *object* class registry, for access to objects sent as parameters
ObjectClassRegistry* StartInteractionClass::GetObjectClassRegistry()
{
  return mInteractionClassRegistry->GetObjectClassRegistry();
}

void StartInteractionClass::Publish()
{
  if (!mPublished)
  {
    mRtiAmbassador->publishInteractionClass(mInteractionClassHandle);
    mPublished = true;
  }
}

void StartInteractionClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishInteractionClass(mInteractionClassHandle);
    mPublished = false;
  }
}

void StartInteractionClass::Subscribe(bool deliverToSelf)
{
  mRtiAmbassador->subscribeInteractionClass(mInteractionClassHandle);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  mSubscribed = true;
}


void StartInteractionClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeInteractionClass(mInteractionClassHandle);
    mSubscribed = false;
  }
}

void StartInteractionClass::send()
{
  rti1516ev::ParameterHandleValueMap parameters;
  parameters.insert(std::make_pair(GetDummyParameterHandle(), rti1516ev::VariableLengthData()));
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData());
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void StartInteractionClass::sendWithTime(int64_t time)
{
  rti1516ev::ParameterHandleValueMap parameters;
  parameters.insert(std::make_pair(GetDummyParameterHandle(), rti1516ev::VariableLengthData()));
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
  }
  catch (const rti1516ev::InvalidLogicalTime& e)
  {
    throw InvalidLogicalTime(to_string(e.what()));
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void StartInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap&)
{
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(optional<int64_t>(), optional<OrderType>());
  }
}

void StartInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap&, const rti1516ev::LogicalTime& time, OrderType orderType)
{

  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  }
}

StartInteractionClass::ReceiveCallbackHandle StartInteractionClass::RegisterReceiveCallback(ReceiveCallback callback)
{
  ReceiveCallbackHandle key = mReceiveCallbacksNextKey++;
  mReceiveCallbacks.insert(std::make_pair(key, callback));
  return key;
}

void StartInteractionClass::UnregisterReceiveCallback(ReceiveCallbackHandle callbackHandle)
{
  auto iter = mReceiveCallbacks.find(callbackHandle);
  if (iter != mReceiveCallbacks.end())
  {
    mReceiveCallbacks.erase(iter);
  }
}

rti1516ev::ParameterHandleSet StartInteractionClass::GetAllParameterHandles()
{
  rti1516ev::ParameterHandleSet result;
  result.insert(GetDummyParameterHandle());
  return result;
}

// object class type 'Stop'
StopInteractionClass::StopInteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry, HLAinteractionRootInteractionClass* baseClass)
{
  mInteractionClassRegistry = interactionClassRegistry;
  mRtiAmbassador = rtiAmbassador;

  mBaseClass = baseClass;
  mInteractionClassHandle = rtiAmbassador->getInteractionClassHandle(L"HLAinteractionRoot.Stop");
  // parameter NextFederationSuffix : HLAunicodeString
  mNextFederationSuffixParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"NextFederationSuffix");
}

// get the corresponding *object* class registry, for access to objects sent as parameters
ObjectClassRegistry* StopInteractionClass::GetObjectClassRegistry()
{
  return mInteractionClassRegistry->GetObjectClassRegistry();
}

void StopInteractionClass::Publish()
{
  if (!mPublished)
  {
    mRtiAmbassador->publishInteractionClass(mInteractionClassHandle);
    mPublished = true;
  }
}

void StopInteractionClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishInteractionClass(mInteractionClassHandle);
    mPublished = false;
  }
}

void StopInteractionClass::Subscribe(bool deliverToSelf)
{
  mRtiAmbassador->subscribeInteractionClass(mInteractionClassHandle);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  mSubscribed = true;
}

void StopInteractionClass::Subscribe(optional<std::wstring> NextFederationSuffix, bool deliverToSelf)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (NextFederationSuffix)
  {
    rti1516ev::HLAunicodeString NextFederationSuffixEncoder(*NextFederationSuffix);
    parameters.insert(std::make_pair(GetNextFederationSuffixParameterHandle(), NextFederationSuffixEncoder.encode()));
  }
  mRtiAmbassador->subscribeInteractionClassWithFilter(mInteractionClassHandle, parameters);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  // we must always set mSubscribed, otherwise we can't unsubscribe
  mSubscribed = true;
}

void StopInteractionClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeInteractionClass(mInteractionClassHandle);
    mSubscribed = false;
  }
}

void StopInteractionClass::send(optional<std::wstring> NextFederationSuffix)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (NextFederationSuffix)
  {
    rti1516ev::HLAunicodeString NextFederationSuffixEncoder(*NextFederationSuffix);
    parameters.insert(std::make_pair(GetNextFederationSuffixParameterHandle(), NextFederationSuffixEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData());
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void StopInteractionClass::sendWithTime(optional<std::wstring> NextFederationSuffix, int64_t time)
{
  rti1516ev::ParameterHandleValueMap parameters;
  if (NextFederationSuffix)
  {
    rti1516ev::HLAunicodeString NextFederationSuffixEncoder(*NextFederationSuffix);
    parameters.insert(std::make_pair(GetNextFederationSuffixParameterHandle(), NextFederationSuffixEncoder.encode()));
  }
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
  }
  catch (const rti1516ev::InvalidLogicalTime& e)
  {
    throw InvalidLogicalTime(to_string(e.what()));
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void StopInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters )
{
  optional<std::wstring> NextFederationSuffix;
  rti1516ev::HLAunicodeString NextFederationSuffixDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator NextFederationSuffixIter = parameters.find(GetNextFederationSuffixParameterHandle());
  if (NextFederationSuffixIter != parameters.end())
  {
    NextFederationSuffixDecoder.decode(NextFederationSuffixIter->second);
    NextFederationSuffix = NextFederationSuffixDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(NextFederationSuffix, optional<int64_t>(), optional<OrderType>());
  }
}

void StopInteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap& parameters , const rti1516ev::LogicalTime& time, OrderType orderType)
{
  optional<std::wstring> NextFederationSuffix;

  rti1516ev::HLAunicodeString NextFederationSuffixDecoder;
  rti1516ev::ParameterHandleValueMap::const_iterator NextFederationSuffixIter = parameters.find(GetNextFederationSuffixParameterHandle());
  if (NextFederationSuffixIter != parameters.end())
  {
    NextFederationSuffixDecoder.decode(NextFederationSuffixIter->second);
    NextFederationSuffix = NextFederationSuffixDecoder.get();
  }
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
    callback(NextFederationSuffix, static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  }
}

StopInteractionClass::ReceiveCallbackHandle StopInteractionClass::RegisterReceiveCallback(ReceiveCallback callback)
{
  ReceiveCallbackHandle key = mReceiveCallbacksNextKey++;
  mReceiveCallbacks.insert(std::make_pair(key, callback));
  return key;
}

void StopInteractionClass::UnregisterReceiveCallback(ReceiveCallbackHandle callbackHandle)
{
  auto iter = mReceiveCallbacks.find(callbackHandle);
  if (iter != mReceiveCallbacks.end())
  {
    mReceiveCallbacks.erase(iter);
  }
}

rti1516ev::ParameterHandleSet StopInteractionClass::GetAllParameterHandles()
{
  rti1516ev::ParameterHandleSet result;
  result.insert(GetNextFederationSuffixParameterHandle());
  return result;
}

 

InteractionClassRegistry::InteractionClassRegistry(ObjectClassRegistry* objectClassRegistry)
  : mRtiAmbassador(nullptr), mObjectClassRegistry(objectClassRegistry)
{
}

InteractionClassRegistry::~InteractionClassRegistry()
{
}

void InteractionClassRegistry::Initialize(rti1516ev::RTIambassador* rtiAmbassador)
{
  mRtiAmbassador = rtiAmbassador;
  try
  {
    mHLAinteractionRootInteractionClass = std::unique_ptr<HLAinteractionRootInteractionClass>(new HLAinteractionRootInteractionClass(mRtiAmbassador, this));
    mReceiveCallbacks.insert(std::make_pair(
      mHLAinteractionRootInteractionClass->GetInteractionClassHandle(),
      [this](const rti1516ev::ParameterHandleValueMap & parameters) {
        mHLAinteractionRootInteractionClass->ReceiveInteraction(parameters);
      }));
    mReceiveWithTimeCallbacks.insert(std::make_pair(
      mHLAinteractionRootInteractionClass->GetInteractionClassHandle(),
      [this](const rti1516ev::ParameterHandleValueMap & parameters, const rti1516ev::LogicalTime& time, OrderType orderType) {
        mHLAinteractionRootInteractionClass->ReceiveInteraction(parameters, time, orderType);
      }));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mHLAinteractionRootInteractionClass.get() != nullptr);
    mStartInteractionClass = std::unique_ptr<StartInteractionClass>(new StartInteractionClass(mRtiAmbassador, this, mHLAinteractionRootInteractionClass.get()));
    mReceiveCallbacks.insert(std::make_pair(
      mStartInteractionClass->GetInteractionClassHandle(),
      [this](const rti1516ev::ParameterHandleValueMap & parameters) {
        mStartInteractionClass->ReceiveInteraction(parameters);
      }));
    mReceiveWithTimeCallbacks.insert(std::make_pair(
      mStartInteractionClass->GetInteractionClassHandle(),
      [this](const rti1516ev::ParameterHandleValueMap & parameters, const rti1516ev::LogicalTime& time, OrderType orderType) {
        mStartInteractionClass->ReceiveInteraction(parameters, time, orderType);
      }));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mHLAinteractionRootInteractionClass.get() != nullptr);
    mStopInteractionClass = std::unique_ptr<StopInteractionClass>(new StopInteractionClass(mRtiAmbassador, this, mHLAinteractionRootInteractionClass.get()));
    mReceiveCallbacks.insert(std::make_pair(
      mStopInteractionClass->GetInteractionClassHandle(),
      [this](const rti1516ev::ParameterHandleValueMap & parameters) {
        mStopInteractionClass->ReceiveInteraction(parameters);
      }));
    mReceiveWithTimeCallbacks.insert(std::make_pair(
      mStopInteractionClass->GetInteractionClassHandle(),
      [this](const rti1516ev::ParameterHandleValueMap & parameters, const rti1516ev::LogicalTime& time, OrderType orderType) {
        mStopInteractionClass->ReceiveInteraction(parameters, time, orderType);
      }));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
} // Initialize

void InteractionClassRegistry::Finalize()
{
  mHLAinteractionRootInteractionClass.reset();
  mStartInteractionClass.reset();
  mStopInteractionClass.reset();
  mRtiAmbassador = nullptr;
} // Initialize

void InteractionClassRegistry::ReceiveInteraction(rti1516ev::InteractionClassHandle theInteractionClass, const rti1516ev::ParameterHandleValueMap & parameters)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  auto iter = mReceiveCallbacks.find(theInteractionClass);
  if (iter != mReceiveCallbacks.end())
  {
    iter->second(parameters);
  }
}

void InteractionClassRegistry::ReceiveInteraction(rti1516ev::InteractionClassHandle theInteractionClass,
                                                  const rti1516ev::ParameterHandleValueMap & parameters,
                                                  const rti1516ev::LogicalTime& time,
                                                  OrderType orderType)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  auto iter = mReceiveWithTimeCallbacks.find(theInteractionClass);
  if (iter != mReceiveWithTimeCallbacks.end())
  {
    iter->second(parameters, time, orderType);
  }
}

} // namespace NDistSimIB
} // namespace NSampleFDDEncoding
