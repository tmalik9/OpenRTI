
// Code automatically generated by FOMCodeGen version 2.1.0.0 from mom.xml, do not edit

#include <vector>
#include <cassert>
#include "momObjects.h"

namespace OpenRTI {
namespace Mom {

inline std::string to_string(const std::wstring& str)
{
  if (str.empty()) return std::string();
  const std::ctype<wchar_t>& CType = std::use_facet<std::ctype<wchar_t> >(std::locale());
  std::vector<char> stringBuffer(str.length());
  CType.narrow(str.data(), str.data() + str.length(), '_', &stringBuffer[0]);
  return std::string(&stringBuffer[0], stringBuffer.size());
}

HLAobjectRootObjectClass::HLAobjectRootObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry)
{
  mRegistry = registry;
  mRtiAmbassador = rtiAmbassador;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot");
  // attribute HLAprivilegeToDeleteObject : HLAtoken
  mHLAprivilegeToDeleteObjectAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAprivilegeToDeleteObject");
  SetObjectInstanceCreator([](HLAobjectRootObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador) -> HLAobjectRoot* {
    return new HLAobjectRoot(objectClass, instanceName, rtiAmbassador);
  });
}

HLAobjectRootObjectClass::~HLAobjectRootObjectClass()
{
  //std::lock_guard<std::recursive_mutex> lock(mMutex);
  while (!mObjectInstancesByHandle.empty())
  {
    // careful - hold the reference to the object instance until it has been removed from the maps,
    // otherwise it's mutex will be destroyed while held
    auto objectInstance = mObjectInstancesByHandle.begin()->second;
    objectInstance->Release();
  }
  assert(mObjectInstancesByHandle.empty());
  assert(mObjectInstancesByName.empty());
}

void HLAobjectRootObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void HLAobjectRootObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void HLAobjectRootObjectClass::Subscribe(bool deliverToSelf)
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    if (deliverToSelf) mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void HLAobjectRootObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

rti1516ev::AttributeHandleSet HLAobjectRootObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetHLAprivilegeToDeleteObjectAttributeHandle());
  return result;
}

void HLAobjectRootObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  assert(mObjectInstancesByHandle.find(objectInstanceHandle) == mObjectInstancesByHandle.end());
  std::shared_ptr<HLAobjectRoot> discoveredObject;
  auto objectInstanceIter = mObjectInstancesByName.find(objectInstanceName);
  if (objectInstanceIter == mObjectInstancesByName.end())
  {
    discoveredObject = std::shared_ptr<HLAobjectRoot>(mCreatorFunction(this, objectInstanceName, mRtiAmbassador));
    InsertObjectInstanceName(discoveredObject, objectInstanceName);
  }
  else
  {
    // Federate currently tries to reserve an object that was already created by another federate
    discoveredObject = std::dynamic_pointer_cast<HLAobjectRoot>(objectInstanceIter->second);
  }
  discoveredObject->mObjectInstanceHandle = objectInstanceHandle;
  discoveredObject->mIsOwner = false;
  InsertObjectInstanceHandle(discoveredObject, objectInstanceHandle);
  ExecuteDiscoverObjectInstanceCallbacks(discoveredObject);
}

void HLAobjectRootObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring objectInstanceName = mRtiAmbassador->getObjectInstanceName(objectInstanceHandle);
  auto iter = mObjectInstancesByName.find(objectInstanceName);
  assert(iter != mObjectInstancesByName.end());
  auto objectInstance = std::dynamic_pointer_cast<HLAobjectRoot>(iter->second);
  ExecuteRemoveObjectInstanceCallbacks(objectInstance);
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  EraseObjectInstance(objectInstanceHandle, objectInstanceName);
}

std::shared_ptr<IHLAobjectRoot> HLAobjectRootObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  return nullptr;
}

std::shared_ptr<IHLAobjectRoot> HLAobjectRootObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  return nullptr;
}

std::shared_ptr<IHLAobjectRoot> HLAobjectRootObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"HLAobjectRoot");
  }
  try {
    /* auto existingObjectInstance =*/ mRtiAmbassador->getObjectInstanceHandle(instanceName);
    return nullptr;
  }
  catch (const rti1516ev::ObjectInstanceNotKnown&)
  {
    // continue
  }
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  std::shared_ptr<HLAobjectRoot> newObject = std::shared_ptr<HLAobjectRoot>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  newObject->mCreatedPromise = std::promise<bool>();
  newObject->mCreatedFuture = newObject->mCreatedPromise.get_future();
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
    }
    newObject->mCreatedPromise.set_value(success);
  });
  return newObject;
}

std::shared_ptr<IHLAobjectRoot> HLAobjectRootObjectClass::CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"HLAobjectRoot");
  }
  std::shared_ptr<HLAobjectRoot> newObject = std::shared_ptr<HLAobjectRoot>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  newObject->mCreatedPromise = std::promise<bool>();
  newObject->mCreatedFuture = newObject->mCreatedPromise.get_future();
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
      createdCallback(newObject, true);
    }
    else
    {
      createdCallback(newObject, false);
    }
    newObject->mCreatedPromise.set_value(success);
  });
  return newObject;
}

std::shared_ptr<IHLAobjectRoot> HLAobjectRootObjectClass::RestoreObjectInstance(std::shared_ptr<IHLAobjectRoot> deadObject)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring instanceName = deadObject->GetObjectInstanceName();
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    // object already exists
    return nullptr;
  }
  if (!mPublished)
  {
    Publish();
  }
  try {
    /* auto existingObjectInstance =*/ mRtiAmbassador->getObjectInstanceHandle(instanceName);
    // object already exists, but has not been created by the class registry - indicate failure
    return nullptr;
  }
  catch (const rti1516ev::ObjectInstanceNotKnown&)
  {
    // continue
  }
  auto deadObjectImpl = std::dynamic_pointer_cast<HLAobjectRoot>(deadObject);
  deadObjectImpl->mRtiAmbassador = mRtiAmbassador;
  deadObjectImpl->mObjectClass = this;
  deadObjectImpl->mCreatedPromise = std::promise<bool>();
  deadObjectImpl->mCreatedFuture = deadObjectImpl->mCreatedPromise.get_future();
  InsertObjectInstanceName(deadObjectImpl, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, deadObjectImpl, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      deadObjectImpl->mObjectInstanceHandle = instanceHandle;
      deadObjectImpl->mIsOwner = true;
      InsertObjectInstanceHandle(deadObjectImpl, instanceHandle);
    }
    deadObjectImpl->mCreatedPromise.set_value(success);
  });
  return deadObject;
}

std::shared_ptr<IHLAobjectRoot> HLAobjectRootObjectClass::RestoreObjectInstance(std::shared_ptr<IHLAobjectRoot> deadObject, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring instanceName = deadObject->GetObjectInstanceName();
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    // object already exists
    return nullptr;
  }
  if (!mPublished)
  {
    Publish();
  }
  try {
    /* auto existingObjectInstance =*/ mRtiAmbassador->getObjectInstanceHandle(instanceName);
    // object already exists, but has not been created by the class registry - indicate failure
    return nullptr;
  }
  catch (const rti1516ev::ObjectInstanceNotKnown&)
  {
    // continue
  }
  auto deadObjectImpl = std::dynamic_pointer_cast<HLAobjectRoot>(deadObject);
  deadObjectImpl->mRtiAmbassador = mRtiAmbassador;
  deadObjectImpl->mObjectClass = this;
  deadObjectImpl->mCreatedPromise = std::promise<bool>();
  deadObjectImpl->mCreatedFuture = deadObjectImpl->mCreatedPromise.get_future();
  InsertObjectInstanceName(deadObjectImpl, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, deadObjectImpl, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      deadObjectImpl->mObjectInstanceHandle = instanceHandle;
      deadObjectImpl->mIsOwner = true;
      InsertObjectInstanceHandle(deadObjectImpl, instanceHandle);
      createdCallback(deadObjectImpl, true);
    }
    else
    {
      createdCallback(deadObjectImpl, false);
    }
    deadObjectImpl->mCreatedPromise.set_value(success);
  });
  return deadObject;
}

uint32_t HLAobjectRootObjectClass::RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastDiscoverObjectInstanceCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastDiscoverObjectInstanceCallbackToken, callback));
  return mLastDiscoverObjectInstanceCallbackToken;
}

void HLAobjectRootObjectClass::UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mDiscoverCallbacks.erase(callbackToken);
}

void HLAobjectRootObjectClass::ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IHLAobjectRoot> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

uint32_t HLAobjectRootObjectClass::RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastRemoveObjectInstanceCallbackToken++;
  mRemoveObjectInstanceCallbacks.insert(std::make_pair(mLastRemoveObjectInstanceCallbackToken, callback));
  return mLastRemoveObjectInstanceCallbackToken;
}

void HLAobjectRootObjectClass::UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mRemoveObjectInstanceCallbacks.erase(callbackToken);
}

void HLAobjectRootObjectClass::ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IHLAobjectRoot> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mRemoveObjectInstanceCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

void HLAobjectRootObjectClass::InsertObjectInstanceName(std::shared_ptr<IHLAobjectRoot> objectInstance, const std::wstring& objectInstanceName)
{
  // prerequisite: mMutex must be locked
  mObjectInstancesByName.insert(std::make_pair(objectInstanceName, objectInstance));
}

void HLAobjectRootObjectClass::InsertObjectInstanceHandle(std::shared_ptr<IHLAobjectRoot> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByHandle.insert(std::make_pair(objectInstanceHandle, objectInstance));
}

void HLAobjectRootObjectClass::EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByName.erase(objectInstanceName);
  mObjectInstancesByHandle.erase(objectInstanceHandle);
}


// object instances of type 'HLAobjectRoot'
HLAobjectRoot::HLAobjectRoot()
  : mRtiAmbassador()
  , mObjectClass()
  , mObjectInstanceName()
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

HLAobjectRoot::HLAobjectRoot(HLAobjectRootObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mRtiAmbassador(rtiAmbassador)
  , mObjectClass(objectClass)
  , mObjectInstanceName(instanceName)
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

HLAobjectRoot::~HLAobjectRoot()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    try
    {
      mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    }
    catch (const rti1516ev::Exception&)
    {
    }
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

bool HLAobjectRoot::IsValid() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mObjectInstanceHandle.isValid();
}

bool HLAobjectRoot::WaitForObjectValid()
{
  return mCreatedFuture.get();
}

bool HLAobjectRoot::IsOwner() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mIsOwner;
}

void HLAobjectRoot::Release()
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (mObjectInstanceHandle.isValid())
  {
    if (mIsOwner)
    {
      try
      {
        mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
      }
      catch (const rti1516ev::Exception&)
      {
        // ignore - must execute rest of function
      }
      mIsOwner = false;
    }
    mObjectClass->EraseObjectInstance(mObjectInstanceHandle, mObjectInstanceName);
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mObjectClass = nullptr;
    mRtiAmbassador = nullptr;
  }
}

// attribute HLAprivilegeToDeleteObject : HLAtoken
const std::vector<uint8_t>& HLAobjectRoot::GetHLAprivilegeToDeleteObject() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAprivilegeToDeleteObject.get();
}

void HLAobjectRoot::SetHLAprivilegeToDeleteObject(const std::vector<uint8_t>& newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAprivilegeToDeleteObject.set(newValue);
  mDirty |= kHLAprivilegeToDeleteObjectBit;
  mValuesSet |= kHLAprivilegeToDeleteObjectBit;
}

rti1516ev::AttributeHandleValueMap HLAobjectRoot::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetHLAprivilegeToDeleteObjectAttributeHandle()] = mHLAprivilegeToDeleteObject.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap HLAobjectRoot::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kHLAprivilegeToDeleteObjectBit)
  {
    result[mObjectClass->GetHLAprivilegeToDeleteObjectAttributeHandle()] = mHLAprivilegeToDeleteObject.encode();
  }
  return result;
}

HLAobjectRoot::AttributeBits HLAobjectRoot::GetReceivedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesReceived;
}

HLAobjectRoot::AttributeBits HLAobjectRoot::GetUpdatedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mLastUpdated;
}

HLAobjectRoot::AttributeBits HLAobjectRoot::GetInitializedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesSet;
}

HLAobjectRoot::AttributeBits HLAobjectRoot::GetModifiedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDirty;
}

void HLAobjectRoot::UpdateAllAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void HLAobjectRoot::UpdateAllAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    try {
      mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
      mDirty = kNone;
    }
    catch (const rti1516ev::InvalidLogicalTime& e)
    {
      throw InvalidLogicalTime(to_string(e.what()));
    }
    catch (const rti1516ev::Exception& e)
    {
      throw std::runtime_error(to_string(e.what()));
    }
  }
}

void HLAobjectRoot::UpdateModifiedAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void HLAobjectRoot::UpdateModifiedAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
        mDirty = kNone;
      }
      catch (const rti1516ev::InvalidLogicalTime& e)
      {
        throw InvalidLogicalTime(to_string(e.what()));
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void HLAobjectRoot::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetHLAprivilegeToDeleteObjectAttributeHandle())
    {
      mHLAprivilegeToDeleteObject.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAprivilegeToDeleteObjectBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  mLastUpdated = kNone;
} // HLAobjectRoot::ReflectAttributeValues

void HLAobjectRoot::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& /* time */, OrderType /* orderType */)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetHLAprivilegeToDeleteObjectAttributeHandle())
    {
      mHLAprivilegeToDeleteObject.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAprivilegeToDeleteObjectBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  mLastUpdated = kNone;
} // HLAobjectRoot::ReflectAttributeValues

// request attributes not being part of the last update
void HLAobjectRoot::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    if ((mLastUpdated & kHLAprivilegeToDeleteObjectBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAprivilegeToDeleteObjectAttributeHandle());
    }
  } // scope of lock_guard
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// request all attributes, regardless of current state
void HLAobjectRoot::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetHLAprivilegeToDeleteObjectAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// provide requested attributes set since last sent update
void HLAobjectRoot::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    for (auto& attributeHandle : attributeHandles)
    {
      if (attributeHandle == mObjectClass->GetHLAprivilegeToDeleteObjectAttributeHandle() && (mValuesSet & kHLAprivilegeToDeleteObjectBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAprivilegeToDeleteObject.encode()));
        mDirty &= ~kHLAprivilegeToDeleteObjectBit;
      }
    } // for (auto& attributeHandleValue : attributes)
  } // scope of lock_guard
  if (time)
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(*time));
  else
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // HLAobjectRoot::ReflectAttributeValues

// object class type 'HLAmanager'
HLAmanagerObjectClass::HLAmanagerObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, HLAobjectRootObjectClass* baseClass)
{
  mRegistry = registry;
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.HLAmanager");
  SetObjectInstanceCreator([](HLAmanagerObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador) -> HLAmanager* {
    return new HLAmanager(objectClass, instanceName, rtiAmbassador);
  });
}

HLAmanagerObjectClass::~HLAmanagerObjectClass()
{
  //std::lock_guard<std::recursive_mutex> lock(mMutex);
  while (!mObjectInstancesByHandle.empty())
  {
    // careful - hold the reference to the object instance until it has been removed from the maps,
    // otherwise it's mutex will be destroyed while held
    auto objectInstance = mObjectInstancesByHandle.begin()->second;
    objectInstance->Release();
  }
  assert(mObjectInstancesByHandle.empty());
  assert(mObjectInstancesByName.empty());
}

void HLAmanagerObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void HLAmanagerObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void HLAmanagerObjectClass::Subscribe(bool deliverToSelf)
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    if (deliverToSelf) mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void HLAmanagerObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

rti1516ev::AttributeHandleSet HLAmanagerObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetHLAprivilegeToDeleteObjectAttributeHandle());
  return result;
}

void HLAmanagerObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  assert(mObjectInstancesByHandle.find(objectInstanceHandle) == mObjectInstancesByHandle.end());
  std::shared_ptr<HLAmanager> discoveredObject;
  auto objectInstanceIter = mObjectInstancesByName.find(objectInstanceName);
  if (objectInstanceIter == mObjectInstancesByName.end())
  {
    discoveredObject = std::shared_ptr<HLAmanager>(mCreatorFunction(this, objectInstanceName, mRtiAmbassador));
    InsertObjectInstanceName(discoveredObject, objectInstanceName);
  }
  else
  {
    // Federate currently tries to reserve an object that was already created by another federate
    discoveredObject = std::dynamic_pointer_cast<HLAmanager>(objectInstanceIter->second);
  }
  discoveredObject->mObjectInstanceHandle = objectInstanceHandle;
  discoveredObject->mIsOwner = false;
  InsertObjectInstanceHandle(discoveredObject, objectInstanceHandle);
  ExecuteDiscoverObjectInstanceCallbacks(discoveredObject);
}

void HLAmanagerObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring objectInstanceName = mRtiAmbassador->getObjectInstanceName(objectInstanceHandle);
  auto iter = mObjectInstancesByName.find(objectInstanceName);
  assert(iter != mObjectInstancesByName.end());
  auto objectInstance = std::dynamic_pointer_cast<HLAmanager>(iter->second);
  ExecuteRemoveObjectInstanceCallbacks(objectInstance);
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  EraseObjectInstance(objectInstanceHandle, objectInstanceName);
}

std::shared_ptr<IHLAmanager> HLAmanagerObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IHLAobjectRoot> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceName);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IHLAmanager>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IHLAmanager> HLAmanagerObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IHLAobjectRoot> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceHandle);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IHLAmanager>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IHLAmanager> HLAmanagerObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"HLAmanager");
  }
  try {
    /* auto existingObjectInstance =*/ mRtiAmbassador->getObjectInstanceHandle(instanceName);
    return nullptr;
  }
  catch (const rti1516ev::ObjectInstanceNotKnown&)
  {
    // continue
  }
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  std::shared_ptr<HLAmanager> newObject = std::shared_ptr<HLAmanager>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  newObject->mCreatedPromise = std::promise<bool>();
  newObject->mCreatedFuture = newObject->mCreatedPromise.get_future();
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
    }
    newObject->mCreatedPromise.set_value(success);
  });
  return newObject;
}

std::shared_ptr<IHLAmanager> HLAmanagerObjectClass::CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"HLAmanager");
  }
  std::shared_ptr<HLAmanager> newObject = std::shared_ptr<HLAmanager>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  newObject->mCreatedPromise = std::promise<bool>();
  newObject->mCreatedFuture = newObject->mCreatedPromise.get_future();
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
      createdCallback(newObject, true);
    }
    else
    {
      createdCallback(newObject, false);
    }
    newObject->mCreatedPromise.set_value(success);
  });
  return newObject;
}

std::shared_ptr<IHLAmanager> HLAmanagerObjectClass::RestoreObjectInstance(std::shared_ptr<IHLAmanager> deadObject)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring instanceName = deadObject->GetObjectInstanceName();
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    // object already exists
    return nullptr;
  }
  if (!mPublished)
  {
    Publish();
  }
  try {
    /* auto existingObjectInstance =*/ mRtiAmbassador->getObjectInstanceHandle(instanceName);
    // object already exists, but has not been created by the class registry - indicate failure
    return nullptr;
  }
  catch (const rti1516ev::ObjectInstanceNotKnown&)
  {
    // continue
  }
  auto deadObjectImpl = std::dynamic_pointer_cast<HLAmanager>(deadObject);
  deadObjectImpl->mRtiAmbassador = mRtiAmbassador;
  deadObjectImpl->mObjectClass = this;
  deadObjectImpl->mCreatedPromise = std::promise<bool>();
  deadObjectImpl->mCreatedFuture = deadObjectImpl->mCreatedPromise.get_future();
  InsertObjectInstanceName(deadObjectImpl, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, deadObjectImpl, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      deadObjectImpl->mObjectInstanceHandle = instanceHandle;
      deadObjectImpl->mIsOwner = true;
      InsertObjectInstanceHandle(deadObjectImpl, instanceHandle);
    }
    deadObjectImpl->mCreatedPromise.set_value(success);
  });
  return deadObject;
}

std::shared_ptr<IHLAmanager> HLAmanagerObjectClass::RestoreObjectInstance(std::shared_ptr<IHLAmanager> deadObject, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring instanceName = deadObject->GetObjectInstanceName();
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    // object already exists
    return nullptr;
  }
  if (!mPublished)
  {
    Publish();
  }
  try {
    /* auto existingObjectInstance =*/ mRtiAmbassador->getObjectInstanceHandle(instanceName);
    // object already exists, but has not been created by the class registry - indicate failure
    return nullptr;
  }
  catch (const rti1516ev::ObjectInstanceNotKnown&)
  {
    // continue
  }
  auto deadObjectImpl = std::dynamic_pointer_cast<HLAmanager>(deadObject);
  deadObjectImpl->mRtiAmbassador = mRtiAmbassador;
  deadObjectImpl->mObjectClass = this;
  deadObjectImpl->mCreatedPromise = std::promise<bool>();
  deadObjectImpl->mCreatedFuture = deadObjectImpl->mCreatedPromise.get_future();
  InsertObjectInstanceName(deadObjectImpl, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, deadObjectImpl, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      deadObjectImpl->mObjectInstanceHandle = instanceHandle;
      deadObjectImpl->mIsOwner = true;
      InsertObjectInstanceHandle(deadObjectImpl, instanceHandle);
      createdCallback(deadObjectImpl, true);
    }
    else
    {
      createdCallback(deadObjectImpl, false);
    }
    deadObjectImpl->mCreatedPromise.set_value(success);
  });
  return deadObject;
}

uint32_t HLAmanagerObjectClass::RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastDiscoverObjectInstanceCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastDiscoverObjectInstanceCallbackToken, callback));
  return mLastDiscoverObjectInstanceCallbackToken;
}

void HLAmanagerObjectClass::UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mDiscoverCallbacks.erase(callbackToken);
}

void HLAmanagerObjectClass::ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IHLAmanager> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

uint32_t HLAmanagerObjectClass::RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastRemoveObjectInstanceCallbackToken++;
  mRemoveObjectInstanceCallbacks.insert(std::make_pair(mLastRemoveObjectInstanceCallbackToken, callback));
  return mLastRemoveObjectInstanceCallbackToken;
}

void HLAmanagerObjectClass::UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mRemoveObjectInstanceCallbacks.erase(callbackToken);
}

void HLAmanagerObjectClass::ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IHLAmanager> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mRemoveObjectInstanceCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

void HLAmanagerObjectClass::InsertObjectInstanceName(std::shared_ptr<IHLAmanager> objectInstance, const std::wstring& objectInstanceName)
{
  // prerequisite: mMutex must be locked
  mObjectInstancesByName.insert(std::make_pair(objectInstanceName, objectInstance));
  mBaseClass->InsertObjectInstanceName(objectInstance, objectInstanceName);
}

void HLAmanagerObjectClass::InsertObjectInstanceHandle(std::shared_ptr<IHLAmanager> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByHandle.insert(std::make_pair(objectInstanceHandle, objectInstance));
  mBaseClass->InsertObjectInstanceHandle(objectInstance, objectInstanceHandle);
}

void HLAmanagerObjectClass::EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mBaseClass->EraseObjectInstance(objectInstanceHandle, objectInstanceName);
  mObjectInstancesByName.erase(objectInstanceName);
  mObjectInstancesByHandle.erase(objectInstanceHandle);
}


// object instances of type 'HLAmanager'
HLAmanager::HLAmanager()
  : mRtiAmbassador()
  , mObjectClass()
  , mObjectInstanceName()
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

HLAmanager::HLAmanager(HLAmanagerObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mRtiAmbassador(rtiAmbassador)
  , mObjectClass(objectClass)
  , mObjectInstanceName(instanceName)
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

HLAmanager::~HLAmanager()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    try
    {
      mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    }
    catch (const rti1516ev::Exception&)
    {
    }
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

bool HLAmanager::IsValid() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mObjectInstanceHandle.isValid();
}

bool HLAmanager::WaitForObjectValid()
{
  return mCreatedFuture.get();
}

bool HLAmanager::IsOwner() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mIsOwner;
}

void HLAmanager::Release()
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (mObjectInstanceHandle.isValid())
  {
    if (mIsOwner)
    {
      try
      {
        mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
      }
      catch (const rti1516ev::Exception&)
      {
        // ignore - must execute rest of function
      }
      mIsOwner = false;
    }
    mObjectClass->EraseObjectInstance(mObjectInstanceHandle, mObjectInstanceName);
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mObjectClass = nullptr;
    mRtiAmbassador = nullptr;
  }
}

// attribute HLAprivilegeToDeleteObject : HLAtoken
const std::vector<uint8_t>& HLAmanager::GetHLAprivilegeToDeleteObject() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAprivilegeToDeleteObject.get();
}

void HLAmanager::SetHLAprivilegeToDeleteObject(const std::vector<uint8_t>& newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAprivilegeToDeleteObject.set(newValue);
  mDirty |= kHLAprivilegeToDeleteObjectBit;
  mValuesSet |= kHLAprivilegeToDeleteObjectBit;
}

rti1516ev::AttributeHandleValueMap HLAmanager::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetHLAprivilegeToDeleteObjectAttributeHandle()] = mHLAprivilegeToDeleteObject.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap HLAmanager::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kHLAprivilegeToDeleteObjectBit)
  {
    result[mObjectClass->GetHLAprivilegeToDeleteObjectAttributeHandle()] = mHLAprivilegeToDeleteObject.encode();
  }
  return result;
}

// object class type 'HLAfederate'
HLAfederateObjectClass::HLAfederateObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, HLAmanagerObjectClass* baseClass)
{
  mRegistry = registry;
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.HLAmanager.HLAfederate");
  // attribute HLAfederateHandle : HLAhandle
  mHLAfederateHandleAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAfederateHandle");
  // attribute HLAfederateName : HLAunicodeString
  mHLAfederateNameAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAfederateName");
  // attribute HLAfederateType : HLAunicodeString
  mHLAfederateTypeAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAfederateType");
  // attribute HLAfederateHost : HLAunicodeString
  mHLAfederateHostAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAfederateHost");
  // attribute HLARTIversion : HLAunicodeString
  mHLARTIversionAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLARTIversion");
  // attribute HLAFOMmoduleDesignatorList : HLAmoduleDesignatorList
  mHLAFOMmoduleDesignatorListAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAFOMmoduleDesignatorList");
  // attribute HLAtimeConstrained : HLAboolean
  mHLAtimeConstrainedAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAtimeConstrained");
  // attribute HLAtimeRegulating : HLAboolean
  mHLAtimeRegulatingAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAtimeRegulating");
  // attribute HLAasynchronousDelivery : HLAboolean
  mHLAasynchronousDeliveryAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAasynchronousDelivery");
  // attribute HLAfederateState : HLAfederateState
  mHLAfederateStateAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAfederateState");
  // attribute HLAtimeManagerState : HLAtimeState
  mHLAtimeManagerStateAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAtimeManagerState");
  // attribute HLAlogicalTime : HLAlogicalTime
  mHLAlogicalTimeAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAlogicalTime");
  // attribute HLAlookahead : HLAtimeInterval
  mHLAlookaheadAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAlookahead");
  // attribute HLAGALT : HLAlogicalTime
  mHLAGALTAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAGALT");
  // attribute HLALITS : HLAlogicalTime
  mHLALITSAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLALITS");
  // attribute HLAROlength : HLAcount
  mHLAROlengthAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAROlength");
  // attribute HLATSOlength : HLAcount
  mHLATSOlengthAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLATSOlength");
  // attribute HLAreflectionsReceived : HLAcount
  mHLAreflectionsReceivedAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAreflectionsReceived");
  // attribute HLAupdatesSent : HLAcount
  mHLAupdatesSentAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAupdatesSent");
  // attribute HLAinteractionsReceived : HLAcount
  mHLAinteractionsReceivedAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAinteractionsReceived");
  // attribute HLAinteractionsSent : HLAcount
  mHLAinteractionsSentAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAinteractionsSent");
  // attribute HLAobjectInstancesThatCanBeDeleted : HLAcount
  mHLAobjectInstancesThatCanBeDeletedAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAobjectInstancesThatCanBeDeleted");
  // attribute HLAobjectInstancesUpdated : HLAcount
  mHLAobjectInstancesUpdatedAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAobjectInstancesUpdated");
  // attribute HLAobjectInstancesReflected : HLAcount
  mHLAobjectInstancesReflectedAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAobjectInstancesReflected");
  // attribute HLAobjectInstancesDeleted : HLAcount
  mHLAobjectInstancesDeletedAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAobjectInstancesDeleted");
  // attribute HLAobjectInstancesRemoved : HLAcount
  mHLAobjectInstancesRemovedAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAobjectInstancesRemoved");
  // attribute HLAobjectInstancesRegistered : HLAcount
  mHLAobjectInstancesRegisteredAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAobjectInstancesRegistered");
  // attribute HLAobjectInstancesDiscovered : HLAcount
  mHLAobjectInstancesDiscoveredAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAobjectInstancesDiscovered");
  // attribute HLAtimeGrantedTime : HLAmsec
  mHLAtimeGrantedTimeAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAtimeGrantedTime");
  // attribute HLAtimeAdvancingTime : HLAmsec
  mHLAtimeAdvancingTimeAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAtimeAdvancingTime");
  // attribute HLAconveyRegionDesignatorSets : HLAswitch
  mHLAconveyRegionDesignatorSetsAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAconveyRegionDesignatorSets");
  // attribute HLAconveyProducingFederate : HLAswitch
  mHLAconveyProducingFederateAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAconveyProducingFederate");
  SetObjectInstanceCreator([](HLAfederateObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador) -> HLAfederate* {
    return new HLAfederate(objectClass, instanceName, rtiAmbassador);
  });
}

HLAfederateObjectClass::~HLAfederateObjectClass()
{
  //std::lock_guard<std::recursive_mutex> lock(mMutex);
  while (!mObjectInstancesByHandle.empty())
  {
    // careful - hold the reference to the object instance until it has been removed from the maps,
    // otherwise it's mutex will be destroyed while held
    auto objectInstance = mObjectInstancesByHandle.begin()->second;
    objectInstance->Release();
  }
  assert(mObjectInstancesByHandle.empty());
  assert(mObjectInstancesByName.empty());
}

void HLAfederateObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void HLAfederateObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void HLAfederateObjectClass::Subscribe(bool deliverToSelf)
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    if (deliverToSelf) mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void HLAfederateObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

rti1516ev::AttributeHandleSet HLAfederateObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetHLAprivilegeToDeleteObjectAttributeHandle());
  result.insert(GetHLAfederateHandleAttributeHandle());
  result.insert(GetHLAfederateNameAttributeHandle());
  result.insert(GetHLAfederateTypeAttributeHandle());
  result.insert(GetHLAfederateHostAttributeHandle());
  result.insert(GetHLARTIversionAttributeHandle());
  result.insert(GetHLAFOMmoduleDesignatorListAttributeHandle());
  result.insert(GetHLAtimeConstrainedAttributeHandle());
  result.insert(GetHLAtimeRegulatingAttributeHandle());
  result.insert(GetHLAasynchronousDeliveryAttributeHandle());
  result.insert(GetHLAfederateStateAttributeHandle());
  result.insert(GetHLAtimeManagerStateAttributeHandle());
  result.insert(GetHLAlogicalTimeAttributeHandle());
  result.insert(GetHLAlookaheadAttributeHandle());
  result.insert(GetHLAGALTAttributeHandle());
  result.insert(GetHLALITSAttributeHandle());
  result.insert(GetHLAROlengthAttributeHandle());
  result.insert(GetHLATSOlengthAttributeHandle());
  result.insert(GetHLAreflectionsReceivedAttributeHandle());
  result.insert(GetHLAupdatesSentAttributeHandle());
  result.insert(GetHLAinteractionsReceivedAttributeHandle());
  result.insert(GetHLAinteractionsSentAttributeHandle());
  result.insert(GetHLAobjectInstancesThatCanBeDeletedAttributeHandle());
  result.insert(GetHLAobjectInstancesUpdatedAttributeHandle());
  result.insert(GetHLAobjectInstancesReflectedAttributeHandle());
  result.insert(GetHLAobjectInstancesDeletedAttributeHandle());
  result.insert(GetHLAobjectInstancesRemovedAttributeHandle());
  result.insert(GetHLAobjectInstancesRegisteredAttributeHandle());
  result.insert(GetHLAobjectInstancesDiscoveredAttributeHandle());
  result.insert(GetHLAtimeGrantedTimeAttributeHandle());
  result.insert(GetHLAtimeAdvancingTimeAttributeHandle());
  result.insert(GetHLAconveyRegionDesignatorSetsAttributeHandle());
  result.insert(GetHLAconveyProducingFederateAttributeHandle());
  return result;
}

void HLAfederateObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  assert(mObjectInstancesByHandle.find(objectInstanceHandle) == mObjectInstancesByHandle.end());
  std::shared_ptr<HLAfederate> discoveredObject;
  auto objectInstanceIter = mObjectInstancesByName.find(objectInstanceName);
  if (objectInstanceIter == mObjectInstancesByName.end())
  {
    discoveredObject = std::shared_ptr<HLAfederate>(mCreatorFunction(this, objectInstanceName, mRtiAmbassador));
    InsertObjectInstanceName(discoveredObject, objectInstanceName);
  }
  else
  {
    // Federate currently tries to reserve an object that was already created by another federate
    discoveredObject = std::dynamic_pointer_cast<HLAfederate>(objectInstanceIter->second);
  }
  discoveredObject->mObjectInstanceHandle = objectInstanceHandle;
  discoveredObject->mIsOwner = false;
  InsertObjectInstanceHandle(discoveredObject, objectInstanceHandle);
  ExecuteDiscoverObjectInstanceCallbacks(discoveredObject);
}

void HLAfederateObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring objectInstanceName = mRtiAmbassador->getObjectInstanceName(objectInstanceHandle);
  auto iter = mObjectInstancesByName.find(objectInstanceName);
  assert(iter != mObjectInstancesByName.end());
  auto objectInstance = std::dynamic_pointer_cast<HLAfederate>(iter->second);
  ExecuteRemoveObjectInstanceCallbacks(objectInstance);
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  EraseObjectInstance(objectInstanceHandle, objectInstanceName);
}

std::shared_ptr<IHLAfederate> HLAfederateObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IHLAmanager> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceName);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IHLAfederate>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IHLAfederate> HLAfederateObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IHLAmanager> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceHandle);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IHLAfederate>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IHLAfederate> HLAfederateObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"HLAfederate");
  }
  try {
    /* auto existingObjectInstance =*/ mRtiAmbassador->getObjectInstanceHandle(instanceName);
    return nullptr;
  }
  catch (const rti1516ev::ObjectInstanceNotKnown&)
  {
    // continue
  }
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  std::shared_ptr<HLAfederate> newObject = std::shared_ptr<HLAfederate>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  newObject->mCreatedPromise = std::promise<bool>();
  newObject->mCreatedFuture = newObject->mCreatedPromise.get_future();
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
    }
    newObject->mCreatedPromise.set_value(success);
  });
  return newObject;
}

std::shared_ptr<IHLAfederate> HLAfederateObjectClass::CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"HLAfederate");
  }
  std::shared_ptr<HLAfederate> newObject = std::shared_ptr<HLAfederate>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  newObject->mCreatedPromise = std::promise<bool>();
  newObject->mCreatedFuture = newObject->mCreatedPromise.get_future();
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
      createdCallback(newObject, true);
    }
    else
    {
      createdCallback(newObject, false);
    }
    newObject->mCreatedPromise.set_value(success);
  });
  return newObject;
}

std::shared_ptr<IHLAfederate> HLAfederateObjectClass::RestoreObjectInstance(std::shared_ptr<IHLAfederate> deadObject)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring instanceName = deadObject->GetObjectInstanceName();
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    // object already exists
    return nullptr;
  }
  if (!mPublished)
  {
    Publish();
  }
  try {
    /* auto existingObjectInstance =*/ mRtiAmbassador->getObjectInstanceHandle(instanceName);
    // object already exists, but has not been created by the class registry - indicate failure
    return nullptr;
  }
  catch (const rti1516ev::ObjectInstanceNotKnown&)
  {
    // continue
  }
  auto deadObjectImpl = std::dynamic_pointer_cast<HLAfederate>(deadObject);
  deadObjectImpl->mRtiAmbassador = mRtiAmbassador;
  deadObjectImpl->mObjectClass = this;
  deadObjectImpl->mCreatedPromise = std::promise<bool>();
  deadObjectImpl->mCreatedFuture = deadObjectImpl->mCreatedPromise.get_future();
  InsertObjectInstanceName(deadObjectImpl, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, deadObjectImpl, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      deadObjectImpl->mObjectInstanceHandle = instanceHandle;
      deadObjectImpl->mIsOwner = true;
      InsertObjectInstanceHandle(deadObjectImpl, instanceHandle);
    }
    deadObjectImpl->mCreatedPromise.set_value(success);
  });
  return deadObject;
}

std::shared_ptr<IHLAfederate> HLAfederateObjectClass::RestoreObjectInstance(std::shared_ptr<IHLAfederate> deadObject, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring instanceName = deadObject->GetObjectInstanceName();
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    // object already exists
    return nullptr;
  }
  if (!mPublished)
  {
    Publish();
  }
  try {
    /* auto existingObjectInstance =*/ mRtiAmbassador->getObjectInstanceHandle(instanceName);
    // object already exists, but has not been created by the class registry - indicate failure
    return nullptr;
  }
  catch (const rti1516ev::ObjectInstanceNotKnown&)
  {
    // continue
  }
  auto deadObjectImpl = std::dynamic_pointer_cast<HLAfederate>(deadObject);
  deadObjectImpl->mRtiAmbassador = mRtiAmbassador;
  deadObjectImpl->mObjectClass = this;
  deadObjectImpl->mCreatedPromise = std::promise<bool>();
  deadObjectImpl->mCreatedFuture = deadObjectImpl->mCreatedPromise.get_future();
  InsertObjectInstanceName(deadObjectImpl, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, deadObjectImpl, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      deadObjectImpl->mObjectInstanceHandle = instanceHandle;
      deadObjectImpl->mIsOwner = true;
      InsertObjectInstanceHandle(deadObjectImpl, instanceHandle);
      createdCallback(deadObjectImpl, true);
    }
    else
    {
      createdCallback(deadObjectImpl, false);
    }
    deadObjectImpl->mCreatedPromise.set_value(success);
  });
  return deadObject;
}

uint32_t HLAfederateObjectClass::RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastDiscoverObjectInstanceCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastDiscoverObjectInstanceCallbackToken, callback));
  return mLastDiscoverObjectInstanceCallbackToken;
}

void HLAfederateObjectClass::UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mDiscoverCallbacks.erase(callbackToken);
}

void HLAfederateObjectClass::ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IHLAfederate> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

uint32_t HLAfederateObjectClass::RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastRemoveObjectInstanceCallbackToken++;
  mRemoveObjectInstanceCallbacks.insert(std::make_pair(mLastRemoveObjectInstanceCallbackToken, callback));
  return mLastRemoveObjectInstanceCallbackToken;
}

void HLAfederateObjectClass::UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mRemoveObjectInstanceCallbacks.erase(callbackToken);
}

void HLAfederateObjectClass::ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IHLAfederate> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mRemoveObjectInstanceCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

void HLAfederateObjectClass::InsertObjectInstanceName(std::shared_ptr<IHLAfederate> objectInstance, const std::wstring& objectInstanceName)
{
  // prerequisite: mMutex must be locked
  mObjectInstancesByName.insert(std::make_pair(objectInstanceName, objectInstance));
  mBaseClass->InsertObjectInstanceName(objectInstance, objectInstanceName);
}

void HLAfederateObjectClass::InsertObjectInstanceHandle(std::shared_ptr<IHLAfederate> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByHandle.insert(std::make_pair(objectInstanceHandle, objectInstance));
  mBaseClass->InsertObjectInstanceHandle(objectInstance, objectInstanceHandle);
}

void HLAfederateObjectClass::EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mBaseClass->EraseObjectInstance(objectInstanceHandle, objectInstanceName);
  mObjectInstancesByName.erase(objectInstanceName);
  mObjectInstancesByHandle.erase(objectInstanceHandle);
}


// object instances of type 'HLAfederate'
HLAfederate::HLAfederate()
  : mRtiAmbassador()
  , mObjectClass()
  , mObjectInstanceName()
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

HLAfederate::HLAfederate(HLAfederateObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mRtiAmbassador(rtiAmbassador)
  , mObjectClass(objectClass)
  , mObjectInstanceName(instanceName)
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

HLAfederate::~HLAfederate()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    try
    {
      mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    }
    catch (const rti1516ev::Exception&)
    {
    }
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

bool HLAfederate::IsValid() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mObjectInstanceHandle.isValid();
}

bool HLAfederate::WaitForObjectValid()
{
  return mCreatedFuture.get();
}

bool HLAfederate::IsOwner() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mIsOwner;
}

void HLAfederate::Release()
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (mObjectInstanceHandle.isValid())
  {
    if (mIsOwner)
    {
      try
      {
        mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
      }
      catch (const rti1516ev::Exception&)
      {
        // ignore - must execute rest of function
      }
      mIsOwner = false;
    }
    mObjectClass->EraseObjectInstance(mObjectInstanceHandle, mObjectInstanceName);
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mObjectClass = nullptr;
    mRtiAmbassador = nullptr;
  }
}

// attribute HLAprivilegeToDeleteObject : HLAtoken
const std::vector<uint8_t>& HLAfederate::GetHLAprivilegeToDeleteObject() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAprivilegeToDeleteObject.get();
}

void HLAfederate::SetHLAprivilegeToDeleteObject(const std::vector<uint8_t>& newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAprivilegeToDeleteObject.set(newValue);
  mDirty |= kHLAprivilegeToDeleteObjectBit;
  mValuesSet |= kHLAprivilegeToDeleteObjectBit;
}

// attribute HLAfederateHandle : HLAhandle
rti1516ev::HLAhandle HLAfederate::GetHLAfederateHandle() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAfederateHandle;
}

void HLAfederate::SetHLAfederateHandle(rti1516ev::HLAhandle newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=False
  mHLAfederateHandle.set(newValue);
  mDirty |= kHLAfederateHandleBit;
  mValuesSet |= kHLAfederateHandleBit;
}

// attribute HLAfederateName : HLAunicodeString
std::wstring HLAfederate::GetHLAfederateName() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAfederateName.get();
}

void HLAfederate::SetHLAfederateName(std::wstring newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAfederateName.set(newValue);
  mDirty |= kHLAfederateNameBit;
  mValuesSet |= kHLAfederateNameBit;
}

// attribute HLAfederateType : HLAunicodeString
std::wstring HLAfederate::GetHLAfederateType() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAfederateType.get();
}

void HLAfederate::SetHLAfederateType(std::wstring newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAfederateType.set(newValue);
  mDirty |= kHLAfederateTypeBit;
  mValuesSet |= kHLAfederateTypeBit;
}

// attribute HLAfederateHost : HLAunicodeString
std::wstring HLAfederate::GetHLAfederateHost() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAfederateHost.get();
}

void HLAfederate::SetHLAfederateHost(std::wstring newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAfederateHost.set(newValue);
  mDirty |= kHLAfederateHostBit;
  mValuesSet |= kHLAfederateHostBit;
}

// attribute HLARTIversion : HLAunicodeString
std::wstring HLAfederate::GetHLARTIversion() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLARTIversion.get();
}

void HLAfederate::SetHLARTIversion(std::wstring newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLARTIversion.set(newValue);
  mDirty |= kHLARTIversionBit;
  mValuesSet |= kHLARTIversionBit;
}

// attribute HLAFOMmoduleDesignatorList : HLAmoduleDesignatorList
const std::vector<std::wstring>& HLAfederate::GetHLAFOMmoduleDesignatorList() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAFOMmoduleDesignatorList.get();
}

void HLAfederate::SetHLAFOMmoduleDesignatorList(const std::vector<std::wstring>& newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAFOMmoduleDesignatorList.set(newValue);
  mDirty |= kHLAFOMmoduleDesignatorListBit;
  mValuesSet |= kHLAFOMmoduleDesignatorListBit;
}

// attribute HLAtimeConstrained : HLAboolean
bool HLAfederate::GetHLAtimeConstrained() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAtimeConstrained.get();
}

void HLAfederate::SetHLAtimeConstrained(bool newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAtimeConstrained.set(newValue);
  mDirty |= kHLAtimeConstrainedBit;
  mValuesSet |= kHLAtimeConstrainedBit;
}

// attribute HLAtimeRegulating : HLAboolean
bool HLAfederate::GetHLAtimeRegulating() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAtimeRegulating.get();
}

void HLAfederate::SetHLAtimeRegulating(bool newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAtimeRegulating.set(newValue);
  mDirty |= kHLAtimeRegulatingBit;
  mValuesSet |= kHLAtimeRegulatingBit;
}

// attribute HLAasynchronousDelivery : HLAboolean
bool HLAfederate::GetHLAasynchronousDelivery() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAasynchronousDelivery.get();
}

void HLAfederate::SetHLAasynchronousDelivery(bool newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAasynchronousDelivery.set(newValue);
  mDirty |= kHLAasynchronousDeliveryBit;
  mValuesSet |= kHLAasynchronousDeliveryBit;
}

// attribute HLAfederateState : HLAfederateState
HLAfederateState HLAfederate::GetHLAfederateState() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return static_cast<HLAfederateState>(mHLAfederateState.get());
}

void HLAfederate::SetHLAfederateState(HLAfederateState newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAfederateState.set(static_cast<int32_t>(newValue));
  mDirty |= kHLAfederateStateBit;
  mValuesSet |= kHLAfederateStateBit;
}

// attribute HLAtimeManagerState : HLAtimeState
HLAtimeState HLAfederate::GetHLAtimeManagerState() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return static_cast<HLAtimeState>(mHLAtimeManagerState.get());
}

void HLAfederate::SetHLAtimeManagerState(HLAtimeState newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAtimeManagerState.set(static_cast<int32_t>(newValue));
  mDirty |= kHLAtimeManagerStateBit;
  mValuesSet |= kHLAtimeManagerStateBit;
}

// attribute HLAlogicalTime : HLAlogicalTime
const std::vector<uint8_t>& HLAfederate::GetHLAlogicalTime() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAlogicalTime.get();
}

void HLAfederate::SetHLAlogicalTime(const std::vector<uint8_t>& newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAlogicalTime.set(newValue);
  mDirty |= kHLAlogicalTimeBit;
  mValuesSet |= kHLAlogicalTimeBit;
}

// attribute HLAlookahead : HLAtimeInterval
const std::vector<uint8_t>& HLAfederate::GetHLAlookahead() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAlookahead.get();
}

void HLAfederate::SetHLAlookahead(const std::vector<uint8_t>& newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAlookahead.set(newValue);
  mDirty |= kHLAlookaheadBit;
  mValuesSet |= kHLAlookaheadBit;
}

// attribute HLAGALT : HLAlogicalTime
const std::vector<uint8_t>& HLAfederate::GetHLAGALT() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAGALT.get();
}

void HLAfederate::SetHLAGALT(const std::vector<uint8_t>& newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAGALT.set(newValue);
  mDirty |= kHLAGALTBit;
  mValuesSet |= kHLAGALTBit;
}

// attribute HLALITS : HLAlogicalTime
const std::vector<uint8_t>& HLAfederate::GetHLALITS() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLALITS.get();
}

void HLAfederate::SetHLALITS(const std::vector<uint8_t>& newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLALITS.set(newValue);
  mDirty |= kHLALITSBit;
  mValuesSet |= kHLALITSBit;
}

// attribute HLAROlength : HLAcount
HLAcount HLAfederate::GetHLAROlength() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAROlength.get();
}

void HLAfederate::SetHLAROlength(HLAcount newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAROlength.set(newValue);
  mDirty |= kHLAROlengthBit;
  mValuesSet |= kHLAROlengthBit;
}

// attribute HLATSOlength : HLAcount
HLAcount HLAfederate::GetHLATSOlength() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLATSOlength.get();
}

void HLAfederate::SetHLATSOlength(HLAcount newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLATSOlength.set(newValue);
  mDirty |= kHLATSOlengthBit;
  mValuesSet |= kHLATSOlengthBit;
}

// attribute HLAreflectionsReceived : HLAcount
HLAcount HLAfederate::GetHLAreflectionsReceived() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAreflectionsReceived.get();
}

void HLAfederate::SetHLAreflectionsReceived(HLAcount newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAreflectionsReceived.set(newValue);
  mDirty |= kHLAreflectionsReceivedBit;
  mValuesSet |= kHLAreflectionsReceivedBit;
}

// attribute HLAupdatesSent : HLAcount
HLAcount HLAfederate::GetHLAupdatesSent() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAupdatesSent.get();
}

void HLAfederate::SetHLAupdatesSent(HLAcount newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAupdatesSent.set(newValue);
  mDirty |= kHLAupdatesSentBit;
  mValuesSet |= kHLAupdatesSentBit;
}

// attribute HLAinteractionsReceived : HLAcount
HLAcount HLAfederate::GetHLAinteractionsReceived() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAinteractionsReceived.get();
}

void HLAfederate::SetHLAinteractionsReceived(HLAcount newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAinteractionsReceived.set(newValue);
  mDirty |= kHLAinteractionsReceivedBit;
  mValuesSet |= kHLAinteractionsReceivedBit;
}

// attribute HLAinteractionsSent : HLAcount
HLAcount HLAfederate::GetHLAinteractionsSent() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAinteractionsSent.get();
}

void HLAfederate::SetHLAinteractionsSent(HLAcount newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAinteractionsSent.set(newValue);
  mDirty |= kHLAinteractionsSentBit;
  mValuesSet |= kHLAinteractionsSentBit;
}

// attribute HLAobjectInstancesThatCanBeDeleted : HLAcount
HLAcount HLAfederate::GetHLAobjectInstancesThatCanBeDeleted() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAobjectInstancesThatCanBeDeleted.get();
}

void HLAfederate::SetHLAobjectInstancesThatCanBeDeleted(HLAcount newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAobjectInstancesThatCanBeDeleted.set(newValue);
  mDirty |= kHLAobjectInstancesThatCanBeDeletedBit;
  mValuesSet |= kHLAobjectInstancesThatCanBeDeletedBit;
}

// attribute HLAobjectInstancesUpdated : HLAcount
HLAcount HLAfederate::GetHLAobjectInstancesUpdated() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAobjectInstancesUpdated.get();
}

void HLAfederate::SetHLAobjectInstancesUpdated(HLAcount newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAobjectInstancesUpdated.set(newValue);
  mDirty |= kHLAobjectInstancesUpdatedBit;
  mValuesSet |= kHLAobjectInstancesUpdatedBit;
}

// attribute HLAobjectInstancesReflected : HLAcount
HLAcount HLAfederate::GetHLAobjectInstancesReflected() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAobjectInstancesReflected.get();
}

void HLAfederate::SetHLAobjectInstancesReflected(HLAcount newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAobjectInstancesReflected.set(newValue);
  mDirty |= kHLAobjectInstancesReflectedBit;
  mValuesSet |= kHLAobjectInstancesReflectedBit;
}

// attribute HLAobjectInstancesDeleted : HLAcount
HLAcount HLAfederate::GetHLAobjectInstancesDeleted() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAobjectInstancesDeleted.get();
}

void HLAfederate::SetHLAobjectInstancesDeleted(HLAcount newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAobjectInstancesDeleted.set(newValue);
  mDirty |= kHLAobjectInstancesDeletedBit;
  mValuesSet |= kHLAobjectInstancesDeletedBit;
}

// attribute HLAobjectInstancesRemoved : HLAcount
HLAcount HLAfederate::GetHLAobjectInstancesRemoved() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAobjectInstancesRemoved.get();
}

void HLAfederate::SetHLAobjectInstancesRemoved(HLAcount newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAobjectInstancesRemoved.set(newValue);
  mDirty |= kHLAobjectInstancesRemovedBit;
  mValuesSet |= kHLAobjectInstancesRemovedBit;
}

// attribute HLAobjectInstancesRegistered : HLAcount
HLAcount HLAfederate::GetHLAobjectInstancesRegistered() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAobjectInstancesRegistered.get();
}

void HLAfederate::SetHLAobjectInstancesRegistered(HLAcount newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAobjectInstancesRegistered.set(newValue);
  mDirty |= kHLAobjectInstancesRegisteredBit;
  mValuesSet |= kHLAobjectInstancesRegisteredBit;
}

// attribute HLAobjectInstancesDiscovered : HLAcount
HLAcount HLAfederate::GetHLAobjectInstancesDiscovered() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAobjectInstancesDiscovered.get();
}

void HLAfederate::SetHLAobjectInstancesDiscovered(HLAcount newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAobjectInstancesDiscovered.set(newValue);
  mDirty |= kHLAobjectInstancesDiscoveredBit;
  mValuesSet |= kHLAobjectInstancesDiscoveredBit;
}

// attribute HLAtimeGrantedTime : HLAmsec
HLAmsec HLAfederate::GetHLAtimeGrantedTime() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAtimeGrantedTime.get();
}

void HLAfederate::SetHLAtimeGrantedTime(HLAmsec newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAtimeGrantedTime.set(newValue);
  mDirty |= kHLAtimeGrantedTimeBit;
  mValuesSet |= kHLAtimeGrantedTimeBit;
}

// attribute HLAtimeAdvancingTime : HLAmsec
HLAmsec HLAfederate::GetHLAtimeAdvancingTime() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAtimeAdvancingTime.get();
}

void HLAfederate::SetHLAtimeAdvancingTime(HLAmsec newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAtimeAdvancingTime.set(newValue);
  mDirty |= kHLAtimeAdvancingTimeBit;
  mValuesSet |= kHLAtimeAdvancingTimeBit;
}

// attribute HLAconveyRegionDesignatorSets : HLAswitch
HLAswitch HLAfederate::GetHLAconveyRegionDesignatorSets() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return static_cast<HLAswitch>(mHLAconveyRegionDesignatorSets.get());
}

void HLAfederate::SetHLAconveyRegionDesignatorSets(HLAswitch newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAconveyRegionDesignatorSets.set(static_cast<int32_t>(newValue));
  mDirty |= kHLAconveyRegionDesignatorSetsBit;
  mValuesSet |= kHLAconveyRegionDesignatorSetsBit;
}

// attribute HLAconveyProducingFederate : HLAswitch
HLAswitch HLAfederate::GetHLAconveyProducingFederate() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return static_cast<HLAswitch>(mHLAconveyProducingFederate.get());
}

void HLAfederate::SetHLAconveyProducingFederate(HLAswitch newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAconveyProducingFederate.set(static_cast<int32_t>(newValue));
  mDirty |= kHLAconveyProducingFederateBit;
  mValuesSet |= kHLAconveyProducingFederateBit;
}

rti1516ev::AttributeHandleValueMap HLAfederate::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetHLAprivilegeToDeleteObjectAttributeHandle()] = mHLAprivilegeToDeleteObject.encode();
  result[mObjectClass->GetHLAfederateHandleAttributeHandle()] = mHLAfederateHandle.encode();
  result[mObjectClass->GetHLAfederateNameAttributeHandle()] = mHLAfederateName.encode();
  result[mObjectClass->GetHLAfederateTypeAttributeHandle()] = mHLAfederateType.encode();
  result[mObjectClass->GetHLAfederateHostAttributeHandle()] = mHLAfederateHost.encode();
  result[mObjectClass->GetHLARTIversionAttributeHandle()] = mHLARTIversion.encode();
  result[mObjectClass->GetHLAFOMmoduleDesignatorListAttributeHandle()] = mHLAFOMmoduleDesignatorList.encode();
  result[mObjectClass->GetHLAtimeConstrainedAttributeHandle()] = mHLAtimeConstrained.encode();
  result[mObjectClass->GetHLAtimeRegulatingAttributeHandle()] = mHLAtimeRegulating.encode();
  result[mObjectClass->GetHLAasynchronousDeliveryAttributeHandle()] = mHLAasynchronousDelivery.encode();
  result[mObjectClass->GetHLAfederateStateAttributeHandle()] = mHLAfederateState.encode();
  result[mObjectClass->GetHLAtimeManagerStateAttributeHandle()] = mHLAtimeManagerState.encode();
  result[mObjectClass->GetHLAlogicalTimeAttributeHandle()] = mHLAlogicalTime.encode();
  result[mObjectClass->GetHLAlookaheadAttributeHandle()] = mHLAlookahead.encode();
  result[mObjectClass->GetHLAGALTAttributeHandle()] = mHLAGALT.encode();
  result[mObjectClass->GetHLALITSAttributeHandle()] = mHLALITS.encode();
  result[mObjectClass->GetHLAROlengthAttributeHandle()] = mHLAROlength.encode();
  result[mObjectClass->GetHLATSOlengthAttributeHandle()] = mHLATSOlength.encode();
  result[mObjectClass->GetHLAreflectionsReceivedAttributeHandle()] = mHLAreflectionsReceived.encode();
  result[mObjectClass->GetHLAupdatesSentAttributeHandle()] = mHLAupdatesSent.encode();
  result[mObjectClass->GetHLAinteractionsReceivedAttributeHandle()] = mHLAinteractionsReceived.encode();
  result[mObjectClass->GetHLAinteractionsSentAttributeHandle()] = mHLAinteractionsSent.encode();
  result[mObjectClass->GetHLAobjectInstancesThatCanBeDeletedAttributeHandle()] = mHLAobjectInstancesThatCanBeDeleted.encode();
  result[mObjectClass->GetHLAobjectInstancesUpdatedAttributeHandle()] = mHLAobjectInstancesUpdated.encode();
  result[mObjectClass->GetHLAobjectInstancesReflectedAttributeHandle()] = mHLAobjectInstancesReflected.encode();
  result[mObjectClass->GetHLAobjectInstancesDeletedAttributeHandle()] = mHLAobjectInstancesDeleted.encode();
  result[mObjectClass->GetHLAobjectInstancesRemovedAttributeHandle()] = mHLAobjectInstancesRemoved.encode();
  result[mObjectClass->GetHLAobjectInstancesRegisteredAttributeHandle()] = mHLAobjectInstancesRegistered.encode();
  result[mObjectClass->GetHLAobjectInstancesDiscoveredAttributeHandle()] = mHLAobjectInstancesDiscovered.encode();
  result[mObjectClass->GetHLAtimeGrantedTimeAttributeHandle()] = mHLAtimeGrantedTime.encode();
  result[mObjectClass->GetHLAtimeAdvancingTimeAttributeHandle()] = mHLAtimeAdvancingTime.encode();
  result[mObjectClass->GetHLAconveyRegionDesignatorSetsAttributeHandle()] = mHLAconveyRegionDesignatorSets.encode();
  result[mObjectClass->GetHLAconveyProducingFederateAttributeHandle()] = mHLAconveyProducingFederate.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap HLAfederate::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kHLAprivilegeToDeleteObjectBit)
  {
    result[mObjectClass->GetHLAprivilegeToDeleteObjectAttributeHandle()] = mHLAprivilegeToDeleteObject.encode();
  }
  if (mDirty & kHLAfederateHandleBit)
  {
    result[mObjectClass->GetHLAfederateHandleAttributeHandle()] = mHLAfederateHandle.encode();
  }
  if (mDirty & kHLAfederateNameBit)
  {
    result[mObjectClass->GetHLAfederateNameAttributeHandle()] = mHLAfederateName.encode();
  }
  if (mDirty & kHLAfederateTypeBit)
  {
    result[mObjectClass->GetHLAfederateTypeAttributeHandle()] = mHLAfederateType.encode();
  }
  if (mDirty & kHLAfederateHostBit)
  {
    result[mObjectClass->GetHLAfederateHostAttributeHandle()] = mHLAfederateHost.encode();
  }
  if (mDirty & kHLARTIversionBit)
  {
    result[mObjectClass->GetHLARTIversionAttributeHandle()] = mHLARTIversion.encode();
  }
  if (mDirty & kHLAFOMmoduleDesignatorListBit)
  {
    result[mObjectClass->GetHLAFOMmoduleDesignatorListAttributeHandle()] = mHLAFOMmoduleDesignatorList.encode();
  }
  if (mDirty & kHLAtimeConstrainedBit)
  {
    result[mObjectClass->GetHLAtimeConstrainedAttributeHandle()] = mHLAtimeConstrained.encode();
  }
  if (mDirty & kHLAtimeRegulatingBit)
  {
    result[mObjectClass->GetHLAtimeRegulatingAttributeHandle()] = mHLAtimeRegulating.encode();
  }
  if (mDirty & kHLAasynchronousDeliveryBit)
  {
    result[mObjectClass->GetHLAasynchronousDeliveryAttributeHandle()] = mHLAasynchronousDelivery.encode();
  }
  if (mDirty & kHLAfederateStateBit)
  {
    result[mObjectClass->GetHLAfederateStateAttributeHandle()] = mHLAfederateState.encode();
  }
  if (mDirty & kHLAtimeManagerStateBit)
  {
    result[mObjectClass->GetHLAtimeManagerStateAttributeHandle()] = mHLAtimeManagerState.encode();
  }
  if (mDirty & kHLAlogicalTimeBit)
  {
    result[mObjectClass->GetHLAlogicalTimeAttributeHandle()] = mHLAlogicalTime.encode();
  }
  if (mDirty & kHLAlookaheadBit)
  {
    result[mObjectClass->GetHLAlookaheadAttributeHandle()] = mHLAlookahead.encode();
  }
  if (mDirty & kHLAGALTBit)
  {
    result[mObjectClass->GetHLAGALTAttributeHandle()] = mHLAGALT.encode();
  }
  if (mDirty & kHLALITSBit)
  {
    result[mObjectClass->GetHLALITSAttributeHandle()] = mHLALITS.encode();
  }
  if (mDirty & kHLAROlengthBit)
  {
    result[mObjectClass->GetHLAROlengthAttributeHandle()] = mHLAROlength.encode();
  }
  if (mDirty & kHLATSOlengthBit)
  {
    result[mObjectClass->GetHLATSOlengthAttributeHandle()] = mHLATSOlength.encode();
  }
  if (mDirty & kHLAreflectionsReceivedBit)
  {
    result[mObjectClass->GetHLAreflectionsReceivedAttributeHandle()] = mHLAreflectionsReceived.encode();
  }
  if (mDirty & kHLAupdatesSentBit)
  {
    result[mObjectClass->GetHLAupdatesSentAttributeHandle()] = mHLAupdatesSent.encode();
  }
  if (mDirty & kHLAinteractionsReceivedBit)
  {
    result[mObjectClass->GetHLAinteractionsReceivedAttributeHandle()] = mHLAinteractionsReceived.encode();
  }
  if (mDirty & kHLAinteractionsSentBit)
  {
    result[mObjectClass->GetHLAinteractionsSentAttributeHandle()] = mHLAinteractionsSent.encode();
  }
  if (mDirty & kHLAobjectInstancesThatCanBeDeletedBit)
  {
    result[mObjectClass->GetHLAobjectInstancesThatCanBeDeletedAttributeHandle()] = mHLAobjectInstancesThatCanBeDeleted.encode();
  }
  if (mDirty & kHLAobjectInstancesUpdatedBit)
  {
    result[mObjectClass->GetHLAobjectInstancesUpdatedAttributeHandle()] = mHLAobjectInstancesUpdated.encode();
  }
  if (mDirty & kHLAobjectInstancesReflectedBit)
  {
    result[mObjectClass->GetHLAobjectInstancesReflectedAttributeHandle()] = mHLAobjectInstancesReflected.encode();
  }
  if (mDirty & kHLAobjectInstancesDeletedBit)
  {
    result[mObjectClass->GetHLAobjectInstancesDeletedAttributeHandle()] = mHLAobjectInstancesDeleted.encode();
  }
  if (mDirty & kHLAobjectInstancesRemovedBit)
  {
    result[mObjectClass->GetHLAobjectInstancesRemovedAttributeHandle()] = mHLAobjectInstancesRemoved.encode();
  }
  if (mDirty & kHLAobjectInstancesRegisteredBit)
  {
    result[mObjectClass->GetHLAobjectInstancesRegisteredAttributeHandle()] = mHLAobjectInstancesRegistered.encode();
  }
  if (mDirty & kHLAobjectInstancesDiscoveredBit)
  {
    result[mObjectClass->GetHLAobjectInstancesDiscoveredAttributeHandle()] = mHLAobjectInstancesDiscovered.encode();
  }
  if (mDirty & kHLAtimeGrantedTimeBit)
  {
    result[mObjectClass->GetHLAtimeGrantedTimeAttributeHandle()] = mHLAtimeGrantedTime.encode();
  }
  if (mDirty & kHLAtimeAdvancingTimeBit)
  {
    result[mObjectClass->GetHLAtimeAdvancingTimeAttributeHandle()] = mHLAtimeAdvancingTime.encode();
  }
  if (mDirty & kHLAconveyRegionDesignatorSetsBit)
  {
    result[mObjectClass->GetHLAconveyRegionDesignatorSetsAttributeHandle()] = mHLAconveyRegionDesignatorSets.encode();
  }
  if (mDirty & kHLAconveyProducingFederateBit)
  {
    result[mObjectClass->GetHLAconveyProducingFederateAttributeHandle()] = mHLAconveyProducingFederate.encode();
  }
  return result;
}

HLAfederate::AttributeBits HLAfederate::GetReceivedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesReceived;
}

HLAfederate::AttributeBits HLAfederate::GetUpdatedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mLastUpdated;
}

HLAfederate::AttributeBits HLAfederate::GetInitializedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesSet;
}

HLAfederate::AttributeBits HLAfederate::GetModifiedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDirty;
}

void HLAfederate::UpdateAllAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void HLAfederate::UpdateAllAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    try {
      mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
      mDirty = kNone;
    }
    catch (const rti1516ev::InvalidLogicalTime& e)
    {
      throw InvalidLogicalTime(to_string(e.what()));
    }
    catch (const rti1516ev::Exception& e)
    {
      throw std::runtime_error(to_string(e.what()));
    }
  }
}

void HLAfederate::UpdateModifiedAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void HLAfederate::UpdateModifiedAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
        mDirty = kNone;
      }
      catch (const rti1516ev::InvalidLogicalTime& e)
      {
        throw InvalidLogicalTime(to_string(e.what()));
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void HLAfederate::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetHLAprivilegeToDeleteObjectAttributeHandle())
    {
      mHLAprivilegeToDeleteObject.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAprivilegeToDeleteObjectBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAfederateHandleAttributeHandle())
    {
      mHLAfederateHandle.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAfederateHandleBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAfederateNameAttributeHandle())
    {
      mHLAfederateName.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAfederateNameBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAfederateTypeAttributeHandle())
    {
      mHLAfederateType.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAfederateTypeBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAfederateHostAttributeHandle())
    {
      mHLAfederateHost.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAfederateHostBit;
    }
    else if (attributeHandle == mObjectClass->GetHLARTIversionAttributeHandle())
    {
      mHLARTIversion.decode(attributeHandleValue.second);
      mLastUpdated |= kHLARTIversionBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAFOMmoduleDesignatorListAttributeHandle())
    {
      mHLAFOMmoduleDesignatorList.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAFOMmoduleDesignatorListBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAtimeConstrainedAttributeHandle())
    {
      mHLAtimeConstrained.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAtimeConstrainedBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAtimeRegulatingAttributeHandle())
    {
      mHLAtimeRegulating.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAtimeRegulatingBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAasynchronousDeliveryAttributeHandle())
    {
      mHLAasynchronousDelivery.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAasynchronousDeliveryBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAfederateStateAttributeHandle())
    {
      mHLAfederateState.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAfederateStateBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAtimeManagerStateAttributeHandle())
    {
      mHLAtimeManagerState.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAtimeManagerStateBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAlogicalTimeAttributeHandle())
    {
      mHLAlogicalTime.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAlogicalTimeBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAlookaheadAttributeHandle())
    {
      mHLAlookahead.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAlookaheadBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAGALTAttributeHandle())
    {
      mHLAGALT.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAGALTBit;
    }
    else if (attributeHandle == mObjectClass->GetHLALITSAttributeHandle())
    {
      mHLALITS.decode(attributeHandleValue.second);
      mLastUpdated |= kHLALITSBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAROlengthAttributeHandle())
    {
      mHLAROlength.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAROlengthBit;
    }
    else if (attributeHandle == mObjectClass->GetHLATSOlengthAttributeHandle())
    {
      mHLATSOlength.decode(attributeHandleValue.second);
      mLastUpdated |= kHLATSOlengthBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAreflectionsReceivedAttributeHandle())
    {
      mHLAreflectionsReceived.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAreflectionsReceivedBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAupdatesSentAttributeHandle())
    {
      mHLAupdatesSent.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAupdatesSentBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAinteractionsReceivedAttributeHandle())
    {
      mHLAinteractionsReceived.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAinteractionsReceivedBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAinteractionsSentAttributeHandle())
    {
      mHLAinteractionsSent.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAinteractionsSentBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAobjectInstancesThatCanBeDeletedAttributeHandle())
    {
      mHLAobjectInstancesThatCanBeDeleted.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAobjectInstancesThatCanBeDeletedBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAobjectInstancesUpdatedAttributeHandle())
    {
      mHLAobjectInstancesUpdated.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAobjectInstancesUpdatedBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAobjectInstancesReflectedAttributeHandle())
    {
      mHLAobjectInstancesReflected.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAobjectInstancesReflectedBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAobjectInstancesDeletedAttributeHandle())
    {
      mHLAobjectInstancesDeleted.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAobjectInstancesDeletedBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAobjectInstancesRemovedAttributeHandle())
    {
      mHLAobjectInstancesRemoved.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAobjectInstancesRemovedBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAobjectInstancesRegisteredAttributeHandle())
    {
      mHLAobjectInstancesRegistered.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAobjectInstancesRegisteredBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAobjectInstancesDiscoveredAttributeHandle())
    {
      mHLAobjectInstancesDiscovered.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAobjectInstancesDiscoveredBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAtimeGrantedTimeAttributeHandle())
    {
      mHLAtimeGrantedTime.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAtimeGrantedTimeBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAtimeAdvancingTimeAttributeHandle())
    {
      mHLAtimeAdvancingTime.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAtimeAdvancingTimeBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAconveyRegionDesignatorSetsAttributeHandle())
    {
      mHLAconveyRegionDesignatorSets.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAconveyRegionDesignatorSetsBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAconveyProducingFederateAttributeHandle())
    {
      mHLAconveyProducingFederate.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAconveyProducingFederateBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(optional<int64_t>(), optional<OrderType>());
  mLastUpdated = kNone;
} // HLAfederate::ReflectAttributeValues

void HLAfederate::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& time, OrderType orderType)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetHLAprivilegeToDeleteObjectAttributeHandle())
    {
      mHLAprivilegeToDeleteObject.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAprivilegeToDeleteObjectBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAfederateHandleAttributeHandle())
    {
      mHLAfederateHandle.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAfederateHandleBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAfederateNameAttributeHandle())
    {
      mHLAfederateName.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAfederateNameBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAfederateTypeAttributeHandle())
    {
      mHLAfederateType.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAfederateTypeBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAfederateHostAttributeHandle())
    {
      mHLAfederateHost.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAfederateHostBit;
    }
    else if (attributeHandle == mObjectClass->GetHLARTIversionAttributeHandle())
    {
      mHLARTIversion.decode(attributeHandleValue.second);
      mLastUpdated |= kHLARTIversionBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAFOMmoduleDesignatorListAttributeHandle())
    {
      mHLAFOMmoduleDesignatorList.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAFOMmoduleDesignatorListBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAtimeConstrainedAttributeHandle())
    {
      mHLAtimeConstrained.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAtimeConstrainedBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAtimeRegulatingAttributeHandle())
    {
      mHLAtimeRegulating.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAtimeRegulatingBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAasynchronousDeliveryAttributeHandle())
    {
      mHLAasynchronousDelivery.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAasynchronousDeliveryBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAfederateStateAttributeHandle())
    {
      mHLAfederateState.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAfederateStateBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAtimeManagerStateAttributeHandle())
    {
      mHLAtimeManagerState.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAtimeManagerStateBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAlogicalTimeAttributeHandle())
    {
      mHLAlogicalTime.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAlogicalTimeBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAlookaheadAttributeHandle())
    {
      mHLAlookahead.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAlookaheadBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAGALTAttributeHandle())
    {
      mHLAGALT.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAGALTBit;
    }
    else if (attributeHandle == mObjectClass->GetHLALITSAttributeHandle())
    {
      mHLALITS.decode(attributeHandleValue.second);
      mLastUpdated |= kHLALITSBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAROlengthAttributeHandle())
    {
      mHLAROlength.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAROlengthBit;
    }
    else if (attributeHandle == mObjectClass->GetHLATSOlengthAttributeHandle())
    {
      mHLATSOlength.decode(attributeHandleValue.second);
      mLastUpdated |= kHLATSOlengthBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAreflectionsReceivedAttributeHandle())
    {
      mHLAreflectionsReceived.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAreflectionsReceivedBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAupdatesSentAttributeHandle())
    {
      mHLAupdatesSent.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAupdatesSentBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAinteractionsReceivedAttributeHandle())
    {
      mHLAinteractionsReceived.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAinteractionsReceivedBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAinteractionsSentAttributeHandle())
    {
      mHLAinteractionsSent.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAinteractionsSentBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAobjectInstancesThatCanBeDeletedAttributeHandle())
    {
      mHLAobjectInstancesThatCanBeDeleted.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAobjectInstancesThatCanBeDeletedBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAobjectInstancesUpdatedAttributeHandle())
    {
      mHLAobjectInstancesUpdated.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAobjectInstancesUpdatedBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAobjectInstancesReflectedAttributeHandle())
    {
      mHLAobjectInstancesReflected.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAobjectInstancesReflectedBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAobjectInstancesDeletedAttributeHandle())
    {
      mHLAobjectInstancesDeleted.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAobjectInstancesDeletedBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAobjectInstancesRemovedAttributeHandle())
    {
      mHLAobjectInstancesRemoved.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAobjectInstancesRemovedBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAobjectInstancesRegisteredAttributeHandle())
    {
      mHLAobjectInstancesRegistered.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAobjectInstancesRegisteredBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAobjectInstancesDiscoveredAttributeHandle())
    {
      mHLAobjectInstancesDiscovered.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAobjectInstancesDiscoveredBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAtimeGrantedTimeAttributeHandle())
    {
      mHLAtimeGrantedTime.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAtimeGrantedTimeBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAtimeAdvancingTimeAttributeHandle())
    {
      mHLAtimeAdvancingTime.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAtimeAdvancingTimeBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAconveyRegionDesignatorSetsAttributeHandle())
    {
      mHLAconveyRegionDesignatorSets.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAconveyRegionDesignatorSetsBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAconveyProducingFederateAttributeHandle())
    {
      mHLAconveyProducingFederate.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAconveyProducingFederateBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  mLastUpdated = kNone;
} // HLAfederate::ReflectAttributeValues

// request attributes not being part of the last update
void HLAfederate::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    if ((mLastUpdated & kHLAprivilegeToDeleteObjectBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAprivilegeToDeleteObjectAttributeHandle());
    }
    if ((mLastUpdated & kHLAfederateHandleBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAfederateHandleAttributeHandle());
    }
    if ((mLastUpdated & kHLAfederateNameBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAfederateNameAttributeHandle());
    }
    if ((mLastUpdated & kHLAfederateTypeBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAfederateTypeAttributeHandle());
    }
    if ((mLastUpdated & kHLAfederateHostBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAfederateHostAttributeHandle());
    }
    if ((mLastUpdated & kHLARTIversionBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLARTIversionAttributeHandle());
    }
    if ((mLastUpdated & kHLAFOMmoduleDesignatorListBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAFOMmoduleDesignatorListAttributeHandle());
    }
    if ((mLastUpdated & kHLAtimeConstrainedBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAtimeConstrainedAttributeHandle());
    }
    if ((mLastUpdated & kHLAtimeRegulatingBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAtimeRegulatingAttributeHandle());
    }
    if ((mLastUpdated & kHLAasynchronousDeliveryBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAasynchronousDeliveryAttributeHandle());
    }
    if ((mLastUpdated & kHLAfederateStateBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAfederateStateAttributeHandle());
    }
    if ((mLastUpdated & kHLAtimeManagerStateBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAtimeManagerStateAttributeHandle());
    }
    if ((mLastUpdated & kHLAlogicalTimeBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAlogicalTimeAttributeHandle());
    }
    if ((mLastUpdated & kHLAlookaheadBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAlookaheadAttributeHandle());
    }
    if ((mLastUpdated & kHLAGALTBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAGALTAttributeHandle());
    }
    if ((mLastUpdated & kHLALITSBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLALITSAttributeHandle());
    }
    if ((mLastUpdated & kHLAROlengthBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAROlengthAttributeHandle());
    }
    if ((mLastUpdated & kHLATSOlengthBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLATSOlengthAttributeHandle());
    }
    if ((mLastUpdated & kHLAreflectionsReceivedBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAreflectionsReceivedAttributeHandle());
    }
    if ((mLastUpdated & kHLAupdatesSentBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAupdatesSentAttributeHandle());
    }
    if ((mLastUpdated & kHLAinteractionsReceivedBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAinteractionsReceivedAttributeHandle());
    }
    if ((mLastUpdated & kHLAinteractionsSentBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAinteractionsSentAttributeHandle());
    }
    if ((mLastUpdated & kHLAobjectInstancesThatCanBeDeletedBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAobjectInstancesThatCanBeDeletedAttributeHandle());
    }
    if ((mLastUpdated & kHLAobjectInstancesUpdatedBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAobjectInstancesUpdatedAttributeHandle());
    }
    if ((mLastUpdated & kHLAobjectInstancesReflectedBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAobjectInstancesReflectedAttributeHandle());
    }
    if ((mLastUpdated & kHLAobjectInstancesDeletedBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAobjectInstancesDeletedAttributeHandle());
    }
    if ((mLastUpdated & kHLAobjectInstancesRemovedBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAobjectInstancesRemovedAttributeHandle());
    }
    if ((mLastUpdated & kHLAobjectInstancesRegisteredBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAobjectInstancesRegisteredAttributeHandle());
    }
    if ((mLastUpdated & kHLAobjectInstancesDiscoveredBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAobjectInstancesDiscoveredAttributeHandle());
    }
    if ((mLastUpdated & kHLAtimeGrantedTimeBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAtimeGrantedTimeAttributeHandle());
    }
    if ((mLastUpdated & kHLAtimeAdvancingTimeBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAtimeAdvancingTimeAttributeHandle());
    }
    if ((mLastUpdated & kHLAconveyRegionDesignatorSetsBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAconveyRegionDesignatorSetsAttributeHandle());
    }
    if ((mLastUpdated & kHLAconveyProducingFederateBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAconveyProducingFederateAttributeHandle());
    }
  } // scope of lock_guard
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// request all attributes, regardless of current state
void HLAfederate::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetHLAprivilegeToDeleteObjectAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAfederateHandleAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAfederateNameAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAfederateTypeAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAfederateHostAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLARTIversionAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAFOMmoduleDesignatorListAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAtimeConstrainedAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAtimeRegulatingAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAasynchronousDeliveryAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAfederateStateAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAtimeManagerStateAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAlogicalTimeAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAlookaheadAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAGALTAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLALITSAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAROlengthAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLATSOlengthAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAreflectionsReceivedAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAupdatesSentAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAinteractionsReceivedAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAinteractionsSentAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAobjectInstancesThatCanBeDeletedAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAobjectInstancesUpdatedAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAobjectInstancesReflectedAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAobjectInstancesDeletedAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAobjectInstancesRemovedAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAobjectInstancesRegisteredAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAobjectInstancesDiscoveredAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAtimeGrantedTimeAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAtimeAdvancingTimeAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAconveyRegionDesignatorSetsAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAconveyProducingFederateAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// provide requested attributes set since last sent update
void HLAfederate::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    for (auto& attributeHandle : attributeHandles)
    {
      if (attributeHandle == mObjectClass->GetHLAprivilegeToDeleteObjectAttributeHandle() && (mValuesSet & kHLAprivilegeToDeleteObjectBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAprivilegeToDeleteObject.encode()));
        mDirty &= ~kHLAprivilegeToDeleteObjectBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAfederateHandleAttributeHandle() && (mValuesSet & kHLAfederateHandleBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAfederateHandle.encode()));
        mDirty &= ~kHLAfederateHandleBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAfederateNameAttributeHandle() && (mValuesSet & kHLAfederateNameBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAfederateName.encode()));
        mDirty &= ~kHLAfederateNameBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAfederateTypeAttributeHandle() && (mValuesSet & kHLAfederateTypeBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAfederateType.encode()));
        mDirty &= ~kHLAfederateTypeBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAfederateHostAttributeHandle() && (mValuesSet & kHLAfederateHostBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAfederateHost.encode()));
        mDirty &= ~kHLAfederateHostBit;
      }
      else if (attributeHandle == mObjectClass->GetHLARTIversionAttributeHandle() && (mValuesSet & kHLARTIversionBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLARTIversion.encode()));
        mDirty &= ~kHLARTIversionBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAFOMmoduleDesignatorListAttributeHandle() && (mValuesSet & kHLAFOMmoduleDesignatorListBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAFOMmoduleDesignatorList.encode()));
        mDirty &= ~kHLAFOMmoduleDesignatorListBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAtimeConstrainedAttributeHandle() && (mValuesSet & kHLAtimeConstrainedBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAtimeConstrained.encode()));
        mDirty &= ~kHLAtimeConstrainedBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAtimeRegulatingAttributeHandle() && (mValuesSet & kHLAtimeRegulatingBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAtimeRegulating.encode()));
        mDirty &= ~kHLAtimeRegulatingBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAasynchronousDeliveryAttributeHandle() && (mValuesSet & kHLAasynchronousDeliveryBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAasynchronousDelivery.encode()));
        mDirty &= ~kHLAasynchronousDeliveryBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAfederateStateAttributeHandle() && (mValuesSet & kHLAfederateStateBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAfederateState.encode()));
        mDirty &= ~kHLAfederateStateBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAtimeManagerStateAttributeHandle() && (mValuesSet & kHLAtimeManagerStateBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAtimeManagerState.encode()));
        mDirty &= ~kHLAtimeManagerStateBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAlogicalTimeAttributeHandle() && (mValuesSet & kHLAlogicalTimeBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAlogicalTime.encode()));
        mDirty &= ~kHLAlogicalTimeBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAlookaheadAttributeHandle() && (mValuesSet & kHLAlookaheadBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAlookahead.encode()));
        mDirty &= ~kHLAlookaheadBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAGALTAttributeHandle() && (mValuesSet & kHLAGALTBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAGALT.encode()));
        mDirty &= ~kHLAGALTBit;
      }
      else if (attributeHandle == mObjectClass->GetHLALITSAttributeHandle() && (mValuesSet & kHLALITSBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLALITS.encode()));
        mDirty &= ~kHLALITSBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAROlengthAttributeHandle() && (mValuesSet & kHLAROlengthBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAROlength.encode()));
        mDirty &= ~kHLAROlengthBit;
      }
      else if (attributeHandle == mObjectClass->GetHLATSOlengthAttributeHandle() && (mValuesSet & kHLATSOlengthBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLATSOlength.encode()));
        mDirty &= ~kHLATSOlengthBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAreflectionsReceivedAttributeHandle() && (mValuesSet & kHLAreflectionsReceivedBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAreflectionsReceived.encode()));
        mDirty &= ~kHLAreflectionsReceivedBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAupdatesSentAttributeHandle() && (mValuesSet & kHLAupdatesSentBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAupdatesSent.encode()));
        mDirty &= ~kHLAupdatesSentBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAinteractionsReceivedAttributeHandle() && (mValuesSet & kHLAinteractionsReceivedBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAinteractionsReceived.encode()));
        mDirty &= ~kHLAinteractionsReceivedBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAinteractionsSentAttributeHandle() && (mValuesSet & kHLAinteractionsSentBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAinteractionsSent.encode()));
        mDirty &= ~kHLAinteractionsSentBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAobjectInstancesThatCanBeDeletedAttributeHandle() && (mValuesSet & kHLAobjectInstancesThatCanBeDeletedBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAobjectInstancesThatCanBeDeleted.encode()));
        mDirty &= ~kHLAobjectInstancesThatCanBeDeletedBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAobjectInstancesUpdatedAttributeHandle() && (mValuesSet & kHLAobjectInstancesUpdatedBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAobjectInstancesUpdated.encode()));
        mDirty &= ~kHLAobjectInstancesUpdatedBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAobjectInstancesReflectedAttributeHandle() && (mValuesSet & kHLAobjectInstancesReflectedBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAobjectInstancesReflected.encode()));
        mDirty &= ~kHLAobjectInstancesReflectedBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAobjectInstancesDeletedAttributeHandle() && (mValuesSet & kHLAobjectInstancesDeletedBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAobjectInstancesDeleted.encode()));
        mDirty &= ~kHLAobjectInstancesDeletedBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAobjectInstancesRemovedAttributeHandle() && (mValuesSet & kHLAobjectInstancesRemovedBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAobjectInstancesRemoved.encode()));
        mDirty &= ~kHLAobjectInstancesRemovedBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAobjectInstancesRegisteredAttributeHandle() && (mValuesSet & kHLAobjectInstancesRegisteredBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAobjectInstancesRegistered.encode()));
        mDirty &= ~kHLAobjectInstancesRegisteredBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAobjectInstancesDiscoveredAttributeHandle() && (mValuesSet & kHLAobjectInstancesDiscoveredBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAobjectInstancesDiscovered.encode()));
        mDirty &= ~kHLAobjectInstancesDiscoveredBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAtimeGrantedTimeAttributeHandle() && (mValuesSet & kHLAtimeGrantedTimeBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAtimeGrantedTime.encode()));
        mDirty &= ~kHLAtimeGrantedTimeBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAtimeAdvancingTimeAttributeHandle() && (mValuesSet & kHLAtimeAdvancingTimeBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAtimeAdvancingTime.encode()));
        mDirty &= ~kHLAtimeAdvancingTimeBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAconveyRegionDesignatorSetsAttributeHandle() && (mValuesSet & kHLAconveyRegionDesignatorSetsBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAconveyRegionDesignatorSets.encode()));
        mDirty &= ~kHLAconveyRegionDesignatorSetsBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAconveyProducingFederateAttributeHandle() && (mValuesSet & kHLAconveyProducingFederateBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAconveyProducingFederate.encode()));
        mDirty &= ~kHLAconveyProducingFederateBit;
      }
    } // for (auto& attributeHandleValue : attributes)
  } // scope of lock_guard
  if (time)
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(*time));
  else
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // HLAfederate::ReflectAttributeValues

uint32_t HLAfederate::RegisterUpdateCallback(UpdateCallback callback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void HLAfederate::UnregisterUpdateCallback(uint32_t callbackToken)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mUpdateCallbacks.erase(callbackToken);
}

void HLAfederate::ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(std::static_pointer_cast<IHLAfederate>(shared_from_this()), time, orderType);
  }
}
// object class type 'HLAfederation'
HLAfederationObjectClass::HLAfederationObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, HLAmanagerObjectClass* baseClass)
{
  mRegistry = registry;
  mRtiAmbassador = rtiAmbassador;
  mBaseClass = baseClass;
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"HLAobjectRoot.HLAmanager.HLAfederation");
  // attribute HLAfederationName : HLAunicodeString
  mHLAfederationNameAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAfederationName");
  // attribute HLAfederatesInFederation : HLAhandleList
  mHLAfederatesInFederationAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAfederatesInFederation");
  // attribute HLARTIversion : HLAunicodeString
  mHLARTIversionAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLARTIversion");
  // attribute HLAMIMdesignator : HLAunicodeString
  mHLAMIMdesignatorAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAMIMdesignator");
  // attribute HLAFOMmoduleDesignatorList : HLAmoduleDesignatorList
  mHLAFOMmoduleDesignatorListAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAFOMmoduleDesignatorList");
  // attribute HLAcurrentFDD : HLAunicodeString
  mHLAcurrentFDDAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAcurrentFDD");
  // attribute HLAtimeImplementationName : HLAunicodeString
  mHLAtimeImplementationNameAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAtimeImplementationName");
  // attribute HLAlastSaveName : HLAunicodeString
  mHLAlastSaveNameAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAlastSaveName");
  // attribute HLAlastSaveTime : HLAlogicalTime
  mHLAlastSaveTimeAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAlastSaveTime");
  // attribute HLAnextSaveName : HLAunicodeString
  mHLAnextSaveNameAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAnextSaveName");
  // attribute HLAnextSaveTime : HLAlogicalTime
  mHLAnextSaveTimeAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAnextSaveTime");
  // attribute HLAautoProvide : HLAswitch
  mHLAautoProvideAttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"HLAautoProvide");
  SetObjectInstanceCreator([](HLAfederationObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador) -> HLAfederation* {
    return new HLAfederation(objectClass, instanceName, rtiAmbassador);
  });
}

HLAfederationObjectClass::~HLAfederationObjectClass()
{
  //std::lock_guard<std::recursive_mutex> lock(mMutex);
  while (!mObjectInstancesByHandle.empty())
  {
    // careful - hold the reference to the object instance until it has been removed from the maps,
    // otherwise it's mutex will be destroyed while held
    auto objectInstance = mObjectInstancesByHandle.begin()->second;
    objectInstance->Release();
  }
  assert(mObjectInstancesByHandle.empty());
  assert(mObjectInstancesByName.empty());
}

void HLAfederationObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void HLAfederationObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void HLAfederationObjectClass::Subscribe(bool deliverToSelf)
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    if (deliverToSelf) mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void HLAfederationObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

rti1516ev::AttributeHandleSet HLAfederationObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
  result.insert(GetHLAprivilegeToDeleteObjectAttributeHandle());
  result.insert(GetHLAfederationNameAttributeHandle());
  result.insert(GetHLAfederatesInFederationAttributeHandle());
  result.insert(GetHLARTIversionAttributeHandle());
  result.insert(GetHLAMIMdesignatorAttributeHandle());
  result.insert(GetHLAFOMmoduleDesignatorListAttributeHandle());
  result.insert(GetHLAcurrentFDDAttributeHandle());
  result.insert(GetHLAtimeImplementationNameAttributeHandle());
  result.insert(GetHLAlastSaveNameAttributeHandle());
  result.insert(GetHLAlastSaveTimeAttributeHandle());
  result.insert(GetHLAnextSaveNameAttributeHandle());
  result.insert(GetHLAnextSaveTimeAttributeHandle());
  result.insert(GetHLAautoProvideAttributeHandle());
  return result;
}

void HLAfederationObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  assert(mObjectInstancesByHandle.find(objectInstanceHandle) == mObjectInstancesByHandle.end());
  std::shared_ptr<HLAfederation> discoveredObject;
  auto objectInstanceIter = mObjectInstancesByName.find(objectInstanceName);
  if (objectInstanceIter == mObjectInstancesByName.end())
  {
    discoveredObject = std::shared_ptr<HLAfederation>(mCreatorFunction(this, objectInstanceName, mRtiAmbassador));
    InsertObjectInstanceName(discoveredObject, objectInstanceName);
  }
  else
  {
    // Federate currently tries to reserve an object that was already created by another federate
    discoveredObject = std::dynamic_pointer_cast<HLAfederation>(objectInstanceIter->second);
  }
  discoveredObject->mObjectInstanceHandle = objectInstanceHandle;
  discoveredObject->mIsOwner = false;
  InsertObjectInstanceHandle(discoveredObject, objectInstanceHandle);
  ExecuteDiscoverObjectInstanceCallbacks(discoveredObject);
}

void HLAfederationObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring objectInstanceName = mRtiAmbassador->getObjectInstanceName(objectInstanceHandle);
  auto iter = mObjectInstancesByName.find(objectInstanceName);
  assert(iter != mObjectInstancesByName.end());
  auto objectInstance = std::dynamic_pointer_cast<HLAfederation>(iter->second);
  ExecuteRemoveObjectInstanceCallbacks(objectInstance);
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  EraseObjectInstance(objectInstanceHandle, objectInstanceName);
}

std::shared_ptr<IHLAfederation> HLAfederationObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IHLAmanager> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceName);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IHLAfederation>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IHLAfederation> HLAfederationObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
  else
  {
    std::shared_ptr<IHLAmanager> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceHandle);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<IHLAfederation>(baseClassObjectInterface);
    }
  }
  return nullptr;
}

std::shared_ptr<IHLAfederation> HLAfederationObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"HLAfederation");
  }
  try {
    /* auto existingObjectInstance =*/ mRtiAmbassador->getObjectInstanceHandle(instanceName);
    return nullptr;
  }
  catch (const rti1516ev::ObjectInstanceNotKnown&)
  {
    // continue
  }
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  std::shared_ptr<HLAfederation> newObject = std::shared_ptr<HLAfederation>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  newObject->mCreatedPromise = std::promise<bool>();
  newObject->mCreatedFuture = newObject->mCreatedPromise.get_future();
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
    }
    newObject->mCreatedPromise.set_value(success);
  });
  return newObject;
}

std::shared_ptr<IHLAfederation> HLAfederationObjectClass::CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"HLAfederation");
  }
  std::shared_ptr<HLAfederation> newObject = std::shared_ptr<HLAfederation>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  newObject->mCreatedPromise = std::promise<bool>();
  newObject->mCreatedFuture = newObject->mCreatedPromise.get_future();
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
      createdCallback(newObject, true);
    }
    else
    {
      createdCallback(newObject, false);
    }
    newObject->mCreatedPromise.set_value(success);
  });
  return newObject;
}

std::shared_ptr<IHLAfederation> HLAfederationObjectClass::RestoreObjectInstance(std::shared_ptr<IHLAfederation> deadObject)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring instanceName = deadObject->GetObjectInstanceName();
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    // object already exists
    return nullptr;
  }
  if (!mPublished)
  {
    Publish();
  }
  try {
    /* auto existingObjectInstance =*/ mRtiAmbassador->getObjectInstanceHandle(instanceName);
    // object already exists, but has not been created by the class registry - indicate failure
    return nullptr;
  }
  catch (const rti1516ev::ObjectInstanceNotKnown&)
  {
    // continue
  }
  auto deadObjectImpl = std::dynamic_pointer_cast<HLAfederation>(deadObject);
  deadObjectImpl->mRtiAmbassador = mRtiAmbassador;
  deadObjectImpl->mObjectClass = this;
  deadObjectImpl->mCreatedPromise = std::promise<bool>();
  deadObjectImpl->mCreatedFuture = deadObjectImpl->mCreatedPromise.get_future();
  InsertObjectInstanceName(deadObjectImpl, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, deadObjectImpl, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      deadObjectImpl->mObjectInstanceHandle = instanceHandle;
      deadObjectImpl->mIsOwner = true;
      InsertObjectInstanceHandle(deadObjectImpl, instanceHandle);
    }
    deadObjectImpl->mCreatedPromise.set_value(success);
  });
  return deadObject;
}

std::shared_ptr<IHLAfederation> HLAfederationObjectClass::RestoreObjectInstance(std::shared_ptr<IHLAfederation> deadObject, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring instanceName = deadObject->GetObjectInstanceName();
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    // object already exists
    return nullptr;
  }
  if (!mPublished)
  {
    Publish();
  }
  try {
    /* auto existingObjectInstance =*/ mRtiAmbassador->getObjectInstanceHandle(instanceName);
    // object already exists, but has not been created by the class registry - indicate failure
    return nullptr;
  }
  catch (const rti1516ev::ObjectInstanceNotKnown&)
  {
    // continue
  }
  auto deadObjectImpl = std::dynamic_pointer_cast<HLAfederation>(deadObject);
  deadObjectImpl->mRtiAmbassador = mRtiAmbassador;
  deadObjectImpl->mObjectClass = this;
  deadObjectImpl->mCreatedPromise = std::promise<bool>();
  deadObjectImpl->mCreatedFuture = deadObjectImpl->mCreatedPromise.get_future();
  InsertObjectInstanceName(deadObjectImpl, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, deadObjectImpl, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      deadObjectImpl->mObjectInstanceHandle = instanceHandle;
      deadObjectImpl->mIsOwner = true;
      InsertObjectInstanceHandle(deadObjectImpl, instanceHandle);
      createdCallback(deadObjectImpl, true);
    }
    else
    {
      createdCallback(deadObjectImpl, false);
    }
    deadObjectImpl->mCreatedPromise.set_value(success);
  });
  return deadObject;
}

uint32_t HLAfederationObjectClass::RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastDiscoverObjectInstanceCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastDiscoverObjectInstanceCallbackToken, callback));
  return mLastDiscoverObjectInstanceCallbackToken;
}

void HLAfederationObjectClass::UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mDiscoverCallbacks.erase(callbackToken);
}

void HLAfederationObjectClass::ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<IHLAfederation> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

uint32_t HLAfederationObjectClass::RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastRemoveObjectInstanceCallbackToken++;
  mRemoveObjectInstanceCallbacks.insert(std::make_pair(mLastRemoveObjectInstanceCallbackToken, callback));
  return mLastRemoveObjectInstanceCallbackToken;
}

void HLAfederationObjectClass::UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mRemoveObjectInstanceCallbacks.erase(callbackToken);
}

void HLAfederationObjectClass::ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<IHLAfederation> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mRemoveObjectInstanceCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

void HLAfederationObjectClass::InsertObjectInstanceName(std::shared_ptr<IHLAfederation> objectInstance, const std::wstring& objectInstanceName)
{
  // prerequisite: mMutex must be locked
  mObjectInstancesByName.insert(std::make_pair(objectInstanceName, objectInstance));
  mBaseClass->InsertObjectInstanceName(objectInstance, objectInstanceName);
}

void HLAfederationObjectClass::InsertObjectInstanceHandle(std::shared_ptr<IHLAfederation> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByHandle.insert(std::make_pair(objectInstanceHandle, objectInstance));
  mBaseClass->InsertObjectInstanceHandle(objectInstance, objectInstanceHandle);
}

void HLAfederationObjectClass::EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mBaseClass->EraseObjectInstance(objectInstanceHandle, objectInstanceName);
  mObjectInstancesByName.erase(objectInstanceName);
  mObjectInstancesByHandle.erase(objectInstanceHandle);
}


// object instances of type 'HLAfederation'
HLAfederation::HLAfederation()
  : mRtiAmbassador()
  , mObjectClass()
  , mObjectInstanceName()
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

HLAfederation::HLAfederation(HLAfederationObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mRtiAmbassador(rtiAmbassador)
  , mObjectClass(objectClass)
  , mObjectInstanceName(instanceName)
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

HLAfederation::~HLAfederation()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    try
    {
      mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    }
    catch (const rti1516ev::Exception&)
    {
    }
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

bool HLAfederation::IsValid() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mObjectInstanceHandle.isValid();
}

bool HLAfederation::WaitForObjectValid()
{
  return mCreatedFuture.get();
}

bool HLAfederation::IsOwner() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mIsOwner;
}

void HLAfederation::Release()
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (mObjectInstanceHandle.isValid())
  {
    if (mIsOwner)
    {
      try
      {
        mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
      }
      catch (const rti1516ev::Exception&)
      {
        // ignore - must execute rest of function
      }
      mIsOwner = false;
    }
    mObjectClass->EraseObjectInstance(mObjectInstanceHandle, mObjectInstanceName);
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mObjectClass = nullptr;
    mRtiAmbassador = nullptr;
  }
}

// attribute HLAprivilegeToDeleteObject : HLAtoken
const std::vector<uint8_t>& HLAfederation::GetHLAprivilegeToDeleteObject() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAprivilegeToDeleteObject.get();
}

void HLAfederation::SetHLAprivilegeToDeleteObject(const std::vector<uint8_t>& newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAprivilegeToDeleteObject.set(newValue);
  mDirty |= kHLAprivilegeToDeleteObjectBit;
  mValuesSet |= kHLAprivilegeToDeleteObjectBit;
}

// attribute HLAfederationName : HLAunicodeString
std::wstring HLAfederation::GetHLAfederationName() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAfederationName.get();
}

void HLAfederation::SetHLAfederationName(std::wstring newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAfederationName.set(newValue);
  mDirty |= kHLAfederationNameBit;
  mValuesSet |= kHLAfederationNameBit;
}

// attribute HLAfederatesInFederation : HLAhandleList
const std::vector<rti1516ev::HLAhandle>& HLAfederation::GetHLAfederatesInFederation() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAfederatesInFederation.get();
}

void HLAfederation::SetHLAfederatesInFederation(const std::vector<rti1516ev::HLAhandle>& newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAfederatesInFederation.set(newValue);
  mDirty |= kHLAfederatesInFederationBit;
  mValuesSet |= kHLAfederatesInFederationBit;
}

// attribute HLARTIversion : HLAunicodeString
std::wstring HLAfederation::GetHLARTIversion() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLARTIversion.get();
}

void HLAfederation::SetHLARTIversion(std::wstring newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLARTIversion.set(newValue);
  mDirty |= kHLARTIversionBit;
  mValuesSet |= kHLARTIversionBit;
}

// attribute HLAMIMdesignator : HLAunicodeString
std::wstring HLAfederation::GetHLAMIMdesignator() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAMIMdesignator.get();
}

void HLAfederation::SetHLAMIMdesignator(std::wstring newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAMIMdesignator.set(newValue);
  mDirty |= kHLAMIMdesignatorBit;
  mValuesSet |= kHLAMIMdesignatorBit;
}

// attribute HLAFOMmoduleDesignatorList : HLAmoduleDesignatorList
const std::vector<std::wstring>& HLAfederation::GetHLAFOMmoduleDesignatorList() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAFOMmoduleDesignatorList.get();
}

void HLAfederation::SetHLAFOMmoduleDesignatorList(const std::vector<std::wstring>& newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAFOMmoduleDesignatorList.set(newValue);
  mDirty |= kHLAFOMmoduleDesignatorListBit;
  mValuesSet |= kHLAFOMmoduleDesignatorListBit;
}

// attribute HLAcurrentFDD : HLAunicodeString
std::wstring HLAfederation::GetHLAcurrentFDD() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAcurrentFDD.get();
}

void HLAfederation::SetHLAcurrentFDD(std::wstring newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAcurrentFDD.set(newValue);
  mDirty |= kHLAcurrentFDDBit;
  mValuesSet |= kHLAcurrentFDDBit;
}

// attribute HLAtimeImplementationName : HLAunicodeString
std::wstring HLAfederation::GetHLAtimeImplementationName() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAtimeImplementationName.get();
}

void HLAfederation::SetHLAtimeImplementationName(std::wstring newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAtimeImplementationName.set(newValue);
  mDirty |= kHLAtimeImplementationNameBit;
  mValuesSet |= kHLAtimeImplementationNameBit;
}

// attribute HLAlastSaveName : HLAunicodeString
std::wstring HLAfederation::GetHLAlastSaveName() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAlastSaveName.get();
}

void HLAfederation::SetHLAlastSaveName(std::wstring newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAlastSaveName.set(newValue);
  mDirty |= kHLAlastSaveNameBit;
  mValuesSet |= kHLAlastSaveNameBit;
}

// attribute HLAlastSaveTime : HLAlogicalTime
const std::vector<uint8_t>& HLAfederation::GetHLAlastSaveTime() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAlastSaveTime.get();
}

void HLAfederation::SetHLAlastSaveTime(const std::vector<uint8_t>& newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAlastSaveTime.set(newValue);
  mDirty |= kHLAlastSaveTimeBit;
  mValuesSet |= kHLAlastSaveTimeBit;
}

// attribute HLAnextSaveName : HLAunicodeString
std::wstring HLAfederation::GetHLAnextSaveName() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAnextSaveName.get();
}

void HLAfederation::SetHLAnextSaveName(std::wstring newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAnextSaveName.set(newValue);
  mDirty |= kHLAnextSaveNameBit;
  mValuesSet |= kHLAnextSaveNameBit;
}

// attribute HLAnextSaveTime : HLAlogicalTime
const std::vector<uint8_t>& HLAfederation::GetHLAnextSaveTime() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mHLAnextSaveTime.get();
}

void HLAfederation::SetHLAnextSaveTime(const std::vector<uint8_t>& newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAnextSaveTime.set(newValue);
  mDirty |= kHLAnextSaveTimeBit;
  mValuesSet |= kHLAnextSaveTimeBit;
}

// attribute HLAautoProvide : HLAswitch
HLAswitch HLAfederation::GetHLAautoProvide() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return static_cast<HLAswitch>(mHLAautoProvide.get());
}

void HLAfederation::SetHLAautoProvide(HLAswitch newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=True
  mHLAautoProvide.set(static_cast<int32_t>(newValue));
  mDirty |= kHLAautoProvideBit;
  mValuesSet |= kHLAautoProvideBit;
}

rti1516ev::AttributeHandleValueMap HLAfederation::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  result[mObjectClass->GetHLAprivilegeToDeleteObjectAttributeHandle()] = mHLAprivilegeToDeleteObject.encode();
  result[mObjectClass->GetHLAfederationNameAttributeHandle()] = mHLAfederationName.encode();
  result[mObjectClass->GetHLAfederatesInFederationAttributeHandle()] = mHLAfederatesInFederation.encode();
  result[mObjectClass->GetHLARTIversionAttributeHandle()] = mHLARTIversion.encode();
  result[mObjectClass->GetHLAMIMdesignatorAttributeHandle()] = mHLAMIMdesignator.encode();
  result[mObjectClass->GetHLAFOMmoduleDesignatorListAttributeHandle()] = mHLAFOMmoduleDesignatorList.encode();
  result[mObjectClass->GetHLAcurrentFDDAttributeHandle()] = mHLAcurrentFDD.encode();
  result[mObjectClass->GetHLAtimeImplementationNameAttributeHandle()] = mHLAtimeImplementationName.encode();
  result[mObjectClass->GetHLAlastSaveNameAttributeHandle()] = mHLAlastSaveName.encode();
  result[mObjectClass->GetHLAlastSaveTimeAttributeHandle()] = mHLAlastSaveTime.encode();
  result[mObjectClass->GetHLAnextSaveNameAttributeHandle()] = mHLAnextSaveName.encode();
  result[mObjectClass->GetHLAnextSaveTimeAttributeHandle()] = mHLAnextSaveTime.encode();
  result[mObjectClass->GetHLAautoProvideAttributeHandle()] = mHLAautoProvide.encode();
  return result;
}

rti1516ev::AttributeHandleValueMap HLAfederation::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
  if (mDirty & kHLAprivilegeToDeleteObjectBit)
  {
    result[mObjectClass->GetHLAprivilegeToDeleteObjectAttributeHandle()] = mHLAprivilegeToDeleteObject.encode();
  }
  if (mDirty & kHLAfederationNameBit)
  {
    result[mObjectClass->GetHLAfederationNameAttributeHandle()] = mHLAfederationName.encode();
  }
  if (mDirty & kHLAfederatesInFederationBit)
  {
    result[mObjectClass->GetHLAfederatesInFederationAttributeHandle()] = mHLAfederatesInFederation.encode();
  }
  if (mDirty & kHLARTIversionBit)
  {
    result[mObjectClass->GetHLARTIversionAttributeHandle()] = mHLARTIversion.encode();
  }
  if (mDirty & kHLAMIMdesignatorBit)
  {
    result[mObjectClass->GetHLAMIMdesignatorAttributeHandle()] = mHLAMIMdesignator.encode();
  }
  if (mDirty & kHLAFOMmoduleDesignatorListBit)
  {
    result[mObjectClass->GetHLAFOMmoduleDesignatorListAttributeHandle()] = mHLAFOMmoduleDesignatorList.encode();
  }
  if (mDirty & kHLAcurrentFDDBit)
  {
    result[mObjectClass->GetHLAcurrentFDDAttributeHandle()] = mHLAcurrentFDD.encode();
  }
  if (mDirty & kHLAtimeImplementationNameBit)
  {
    result[mObjectClass->GetHLAtimeImplementationNameAttributeHandle()] = mHLAtimeImplementationName.encode();
  }
  if (mDirty & kHLAlastSaveNameBit)
  {
    result[mObjectClass->GetHLAlastSaveNameAttributeHandle()] = mHLAlastSaveName.encode();
  }
  if (mDirty & kHLAlastSaveTimeBit)
  {
    result[mObjectClass->GetHLAlastSaveTimeAttributeHandle()] = mHLAlastSaveTime.encode();
  }
  if (mDirty & kHLAnextSaveNameBit)
  {
    result[mObjectClass->GetHLAnextSaveNameAttributeHandle()] = mHLAnextSaveName.encode();
  }
  if (mDirty & kHLAnextSaveTimeBit)
  {
    result[mObjectClass->GetHLAnextSaveTimeAttributeHandle()] = mHLAnextSaveTime.encode();
  }
  if (mDirty & kHLAautoProvideBit)
  {
    result[mObjectClass->GetHLAautoProvideAttributeHandle()] = mHLAautoProvide.encode();
  }
  return result;
}

HLAfederation::AttributeBits HLAfederation::GetReceivedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesReceived;
}

HLAfederation::AttributeBits HLAfederation::GetUpdatedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mLastUpdated;
}

HLAfederation::AttributeBits HLAfederation::GetInitializedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesSet;
}

HLAfederation::AttributeBits HLAfederation::GetModifiedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDirty;
}

void HLAfederation::UpdateAllAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void HLAfederation::UpdateAllAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    try {
      mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
      mDirty = kNone;
    }
    catch (const rti1516ev::InvalidLogicalTime& e)
    {
      throw InvalidLogicalTime(to_string(e.what()));
    }
    catch (const rti1516ev::Exception& e)
    {
      throw std::runtime_error(to_string(e.what()));
    }
  }
}

void HLAfederation::UpdateModifiedAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
        mDirty = kNone;
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void HLAfederation::UpdateModifiedAttributeValues(int64_t time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    if (!attributes.empty())
    {
      try {
        mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(time));
        mDirty = kNone;
      }
      catch (const rti1516ev::InvalidLogicalTime& e)
      {
        throw InvalidLogicalTime(to_string(e.what()));
      }
      catch (const rti1516ev::Exception& e)
      {
        throw std::runtime_error(to_string(e.what()));
      }
    }
  }
}

void HLAfederation::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetHLAprivilegeToDeleteObjectAttributeHandle())
    {
      mHLAprivilegeToDeleteObject.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAprivilegeToDeleteObjectBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAfederationNameAttributeHandle())
    {
      mHLAfederationName.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAfederationNameBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAfederatesInFederationAttributeHandle())
    {
      mHLAfederatesInFederation.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAfederatesInFederationBit;
    }
    else if (attributeHandle == mObjectClass->GetHLARTIversionAttributeHandle())
    {
      mHLARTIversion.decode(attributeHandleValue.second);
      mLastUpdated |= kHLARTIversionBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAMIMdesignatorAttributeHandle())
    {
      mHLAMIMdesignator.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAMIMdesignatorBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAFOMmoduleDesignatorListAttributeHandle())
    {
      mHLAFOMmoduleDesignatorList.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAFOMmoduleDesignatorListBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAcurrentFDDAttributeHandle())
    {
      mHLAcurrentFDD.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAcurrentFDDBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAtimeImplementationNameAttributeHandle())
    {
      mHLAtimeImplementationName.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAtimeImplementationNameBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAlastSaveNameAttributeHandle())
    {
      mHLAlastSaveName.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAlastSaveNameBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAlastSaveTimeAttributeHandle())
    {
      mHLAlastSaveTime.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAlastSaveTimeBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAnextSaveNameAttributeHandle())
    {
      mHLAnextSaveName.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAnextSaveNameBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAnextSaveTimeAttributeHandle())
    {
      mHLAnextSaveTime.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAnextSaveTimeBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAautoProvideAttributeHandle())
    {
      mHLAautoProvide.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAautoProvideBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(optional<int64_t>(), optional<OrderType>());
  mLastUpdated = kNone;
} // HLAfederation::ReflectAttributeValues

void HLAfederation::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& time, OrderType orderType)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
    if (attributeHandle == mObjectClass->GetHLAprivilegeToDeleteObjectAttributeHandle())
    {
      mHLAprivilegeToDeleteObject.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAprivilegeToDeleteObjectBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAfederationNameAttributeHandle())
    {
      mHLAfederationName.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAfederationNameBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAfederatesInFederationAttributeHandle())
    {
      mHLAfederatesInFederation.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAfederatesInFederationBit;
    }
    else if (attributeHandle == mObjectClass->GetHLARTIversionAttributeHandle())
    {
      mHLARTIversion.decode(attributeHandleValue.second);
      mLastUpdated |= kHLARTIversionBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAMIMdesignatorAttributeHandle())
    {
      mHLAMIMdesignator.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAMIMdesignatorBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAFOMmoduleDesignatorListAttributeHandle())
    {
      mHLAFOMmoduleDesignatorList.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAFOMmoduleDesignatorListBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAcurrentFDDAttributeHandle())
    {
      mHLAcurrentFDD.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAcurrentFDDBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAtimeImplementationNameAttributeHandle())
    {
      mHLAtimeImplementationName.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAtimeImplementationNameBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAlastSaveNameAttributeHandle())
    {
      mHLAlastSaveName.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAlastSaveNameBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAlastSaveTimeAttributeHandle())
    {
      mHLAlastSaveTime.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAlastSaveTimeBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAnextSaveNameAttributeHandle())
    {
      mHLAnextSaveName.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAnextSaveNameBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAnextSaveTimeAttributeHandle())
    {
      mHLAnextSaveTime.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAnextSaveTimeBit;
    }
    else if (attributeHandle == mObjectClass->GetHLAautoProvideAttributeHandle())
    {
      mHLAautoProvide.decode(attributeHandleValue.second);
      mLastUpdated |= kHLAautoProvideBit;
    }
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
  ExecuteUpdateCallbacks(static_cast<const rti1516ev::HLAinteger64Time&>(time).getTime(), orderType);
  mLastUpdated = kNone;
} // HLAfederation::ReflectAttributeValues

// request attributes not being part of the last update
void HLAfederation::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    if ((mLastUpdated & kHLAprivilegeToDeleteObjectBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAprivilegeToDeleteObjectAttributeHandle());
    }
    if ((mLastUpdated & kHLAfederationNameBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAfederationNameAttributeHandle());
    }
    if ((mLastUpdated & kHLAfederatesInFederationBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAfederatesInFederationAttributeHandle());
    }
    if ((mLastUpdated & kHLARTIversionBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLARTIversionAttributeHandle());
    }
    if ((mLastUpdated & kHLAMIMdesignatorBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAMIMdesignatorAttributeHandle());
    }
    if ((mLastUpdated & kHLAFOMmoduleDesignatorListBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAFOMmoduleDesignatorListAttributeHandle());
    }
    if ((mLastUpdated & kHLAcurrentFDDBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAcurrentFDDAttributeHandle());
    }
    if ((mLastUpdated & kHLAtimeImplementationNameBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAtimeImplementationNameAttributeHandle());
    }
    if ((mLastUpdated & kHLAlastSaveNameBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAlastSaveNameAttributeHandle());
    }
    if ((mLastUpdated & kHLAlastSaveTimeBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAlastSaveTimeAttributeHandle());
    }
    if ((mLastUpdated & kHLAnextSaveNameBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAnextSaveNameAttributeHandle());
    }
    if ((mLastUpdated & kHLAnextSaveTimeBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAnextSaveTimeAttributeHandle());
    }
    if ((mLastUpdated & kHLAautoProvideBit) == 0)
    {
      requestAttributes.insert(mObjectClass->GetHLAautoProvideAttributeHandle());
    }
  } // scope of lock_guard
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// request all attributes, regardless of current state
void HLAfederation::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  requestAttributes.insert(mObjectClass->GetHLAprivilegeToDeleteObjectAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAfederationNameAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAfederatesInFederationAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLARTIversionAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAMIMdesignatorAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAFOMmoduleDesignatorListAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAcurrentFDDAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAtimeImplementationNameAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAlastSaveNameAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAlastSaveTimeAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAnextSaveNameAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAnextSaveTimeAttributeHandle());
  requestAttributes.insert(mObjectClass->GetHLAautoProvideAttributeHandle());
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// provide requested attributes set since last sent update
void HLAfederation::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    for (auto& attributeHandle : attributeHandles)
    {
      if (attributeHandle == mObjectClass->GetHLAprivilegeToDeleteObjectAttributeHandle() && (mValuesSet & kHLAprivilegeToDeleteObjectBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAprivilegeToDeleteObject.encode()));
        mDirty &= ~kHLAprivilegeToDeleteObjectBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAfederationNameAttributeHandle() && (mValuesSet & kHLAfederationNameBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAfederationName.encode()));
        mDirty &= ~kHLAfederationNameBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAfederatesInFederationAttributeHandle() && (mValuesSet & kHLAfederatesInFederationBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAfederatesInFederation.encode()));
        mDirty &= ~kHLAfederatesInFederationBit;
      }
      else if (attributeHandle == mObjectClass->GetHLARTIversionAttributeHandle() && (mValuesSet & kHLARTIversionBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLARTIversion.encode()));
        mDirty &= ~kHLARTIversionBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAMIMdesignatorAttributeHandle() && (mValuesSet & kHLAMIMdesignatorBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAMIMdesignator.encode()));
        mDirty &= ~kHLAMIMdesignatorBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAFOMmoduleDesignatorListAttributeHandle() && (mValuesSet & kHLAFOMmoduleDesignatorListBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAFOMmoduleDesignatorList.encode()));
        mDirty &= ~kHLAFOMmoduleDesignatorListBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAcurrentFDDAttributeHandle() && (mValuesSet & kHLAcurrentFDDBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAcurrentFDD.encode()));
        mDirty &= ~kHLAcurrentFDDBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAtimeImplementationNameAttributeHandle() && (mValuesSet & kHLAtimeImplementationNameBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAtimeImplementationName.encode()));
        mDirty &= ~kHLAtimeImplementationNameBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAlastSaveNameAttributeHandle() && (mValuesSet & kHLAlastSaveNameBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAlastSaveName.encode()));
        mDirty &= ~kHLAlastSaveNameBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAlastSaveTimeAttributeHandle() && (mValuesSet & kHLAlastSaveTimeBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAlastSaveTime.encode()));
        mDirty &= ~kHLAlastSaveTimeBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAnextSaveNameAttributeHandle() && (mValuesSet & kHLAnextSaveNameBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAnextSaveName.encode()));
        mDirty &= ~kHLAnextSaveNameBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAnextSaveTimeAttributeHandle() && (mValuesSet & kHLAnextSaveTimeBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAnextSaveTime.encode()));
        mDirty &= ~kHLAnextSaveTimeBit;
      }
      else if (attributeHandle == mObjectClass->GetHLAautoProvideAttributeHandle() && (mValuesSet & kHLAautoProvideBit) != 0)
      {
        updateAttributes.insert(std::make_pair(attributeHandle, mHLAautoProvide.encode()));
        mDirty &= ~kHLAautoProvideBit;
      }
    } // for (auto& attributeHandleValue : attributes)
  } // scope of lock_guard
  if (time)
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData(), rti1516ev::HLAinteger64Time(*time));
  else
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // HLAfederation::ReflectAttributeValues

uint32_t HLAfederation::RegisterUpdateCallback(UpdateCallback callback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void HLAfederation::UnregisterUpdateCallback(uint32_t callbackToken)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mUpdateCallbacks.erase(callbackToken);
}

void HLAfederation::ExecuteUpdateCallbacks(optional<int64_t> time, optional<OrderType> orderType)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(std::static_pointer_cast<IHLAfederation>(shared_from_this()), time, orderType);
  }
}

ObjectClassRegistry::ObjectClassRegistry()
  : mRtiAmbassador(nullptr)
{
}

ObjectClassRegistry::~ObjectClassRegistry()
{
}

void ObjectClassRegistry::Initialize(rti1516ev::RTIambassador* rtiAmbassador)
{
  mRtiAmbassador = rtiAmbassador;
  try
  {
    mHLAobjectRootObjectClass = std::unique_ptr<HLAobjectRootObjectClass>(new HLAobjectRootObjectClass(mRtiAmbassador, this));
    mDiscoverCallbacks.insert(std::make_pair(
      mHLAobjectRootObjectClass->GetObjectClassHandle(),
      [this](rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName) {
        mHLAobjectRootObjectClass->DiscoverObjectInstance(objectInstanceHandle, objectInstanceName);
      }));
    mRemoveCallbacks.insert(std::make_pair(
      mHLAobjectRootObjectClass->GetObjectClassHandle(),
      [this](rti1516ev::ObjectInstanceHandle objectInstanceHandle) {
        mHLAobjectRootObjectClass->RemoveObjectInstance(objectInstanceHandle);
      }));
    mReflectCallbacks.insert(std::make_pair(
      mHLAobjectRootObjectClass->GetObjectClassHandle(),
      [this](rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes) {
        auto objectInstance = std::dynamic_pointer_cast<HLAobjectRoot>(mHLAobjectRootObjectClass->GetObjectInstance(theObject));
        if (objectInstance != nullptr) {
          objectInstance->ReflectAttributeValues(attributes);
        }
      }));
    mReflectWithTimeCallbacks.insert(std::make_pair(
      mHLAobjectRootObjectClass->GetObjectClassHandle(),
      [this](rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes, const rti1516ev::LogicalTime& time, OrderType orderType) {
        auto objectInstance = std::dynamic_pointer_cast<HLAobjectRoot>(mHLAobjectRootObjectClass->GetObjectInstance(theObject));
        objectInstance->ReflectAttributeValues(attributes, time, orderType);
      }));
    mProvideCallbacks.insert(std::make_pair(
      mHLAobjectRootObjectClass->GetObjectClassHandle(),
      [this](rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time) {
        auto objectInstance = std::dynamic_pointer_cast<HLAobjectRoot>(mHLAobjectRootObjectClass->GetObjectInstance(theObject));
        if (objectInstance != nullptr) {
          objectInstance->ProvideAttributeValues(attributeHandles, time);
        }
      }));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mHLAobjectRootObjectClass.get() != nullptr);
    mHLAmanagerObjectClass = std::unique_ptr<HLAmanagerObjectClass>(new HLAmanagerObjectClass(mRtiAmbassador, this, mHLAobjectRootObjectClass.get()));
    mDiscoverCallbacks.insert(std::make_pair(
      mHLAmanagerObjectClass->GetObjectClassHandle(),
      [this](rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName) {
        mHLAmanagerObjectClass->DiscoverObjectInstance(objectInstanceHandle, objectInstanceName);
      }));
    mRemoveCallbacks.insert(std::make_pair(
      mHLAmanagerObjectClass->GetObjectClassHandle(),
      [this](rti1516ev::ObjectInstanceHandle objectInstanceHandle) {
        mHLAmanagerObjectClass->RemoveObjectInstance(objectInstanceHandle);
      }));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mHLAmanagerObjectClass.get() != nullptr);
    mHLAfederateObjectClass = std::unique_ptr<HLAfederateObjectClass>(new HLAfederateObjectClass(mRtiAmbassador, this, mHLAmanagerObjectClass.get()));
    mDiscoverCallbacks.insert(std::make_pair(
      mHLAfederateObjectClass->GetObjectClassHandle(),
      [this](rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName) {
        mHLAfederateObjectClass->DiscoverObjectInstance(objectInstanceHandle, objectInstanceName);
      }));
    mRemoveCallbacks.insert(std::make_pair(
      mHLAfederateObjectClass->GetObjectClassHandle(),
      [this](rti1516ev::ObjectInstanceHandle objectInstanceHandle) {
        mHLAfederateObjectClass->RemoveObjectInstance(objectInstanceHandle);
      }));
    mReflectCallbacks.insert(std::make_pair(
      mHLAfederateObjectClass->GetObjectClassHandle(),
      [this](rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes) {
        auto objectInstance = std::dynamic_pointer_cast<HLAfederate>(mHLAfederateObjectClass->GetObjectInstance(theObject));
        if (objectInstance != nullptr) {
          objectInstance->ReflectAttributeValues(attributes);
        }
      }));
    mReflectWithTimeCallbacks.insert(std::make_pair(
      mHLAfederateObjectClass->GetObjectClassHandle(),
      [this](rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes, const rti1516ev::LogicalTime& time, OrderType orderType) {
        auto objectInstance = std::dynamic_pointer_cast<HLAfederate>(mHLAfederateObjectClass->GetObjectInstance(theObject));
        objectInstance->ReflectAttributeValues(attributes, time, orderType);
      }));
    mProvideCallbacks.insert(std::make_pair(
      mHLAfederateObjectClass->GetObjectClassHandle(),
      [this](rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time) {
        auto objectInstance = std::dynamic_pointer_cast<HLAfederate>(mHLAfederateObjectClass->GetObjectInstance(theObject));
        if (objectInstance != nullptr) {
          objectInstance->ProvideAttributeValues(attributeHandles, time);
        }
      }));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
  try
  {
    assert(mHLAmanagerObjectClass.get() != nullptr);
    mHLAfederationObjectClass = std::unique_ptr<HLAfederationObjectClass>(new HLAfederationObjectClass(mRtiAmbassador, this, mHLAmanagerObjectClass.get()));
    mDiscoverCallbacks.insert(std::make_pair(
      mHLAfederationObjectClass->GetObjectClassHandle(),
      [this](rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName) {
        mHLAfederationObjectClass->DiscoverObjectInstance(objectInstanceHandle, objectInstanceName);
      }));
    mRemoveCallbacks.insert(std::make_pair(
      mHLAfederationObjectClass->GetObjectClassHandle(),
      [this](rti1516ev::ObjectInstanceHandle objectInstanceHandle) {
        mHLAfederationObjectClass->RemoveObjectInstance(objectInstanceHandle);
      }));
    mReflectCallbacks.insert(std::make_pair(
      mHLAfederationObjectClass->GetObjectClassHandle(),
      [this](rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes) {
        auto objectInstance = std::dynamic_pointer_cast<HLAfederation>(mHLAfederationObjectClass->GetObjectInstance(theObject));
        if (objectInstance != nullptr) {
          objectInstance->ReflectAttributeValues(attributes);
        }
      }));
    mReflectWithTimeCallbacks.insert(std::make_pair(
      mHLAfederationObjectClass->GetObjectClassHandle(),
      [this](rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes, const rti1516ev::LogicalTime& time, OrderType orderType) {
        auto objectInstance = std::dynamic_pointer_cast<HLAfederation>(mHLAfederationObjectClass->GetObjectInstance(theObject));
        objectInstance->ReflectAttributeValues(attributes, time, orderType);
      }));
    mProvideCallbacks.insert(std::make_pair(
      mHLAfederationObjectClass->GetObjectClassHandle(),
      [this](rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time) {
        auto objectInstance = std::dynamic_pointer_cast<HLAfederation>(mHLAfederationObjectClass->GetObjectInstance(theObject));
        if (objectInstance != nullptr) {
          objectInstance->ProvideAttributeValues(attributeHandles, time);
        }
      }));
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
} // Initialize

void ObjectClassRegistry::Finalize()
{
  mDiscoverCallbacks.clear();
  mRemoveCallbacks.clear();
  mReflectCallbacks.clear();
  mReflectWithTimeCallbacks.clear();
  mProvideCallbacks.clear();
  mHLAfederationObjectClass.reset();
  mHLAfederateObjectClass.reset();
  mHLAmanagerObjectClass.reset();
  mHLAobjectRootObjectClass.reset();
  mRtiAmbassador = nullptr;
} // Initialize

void ObjectClassRegistry::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  rti1516ev::ObjectClassHandle theObjectClass = mRtiAmbassador->getKnownObjectClassHandle(theObject);
  auto iter = mDiscoverCallbacks.find(theObjectClass);
  if (iter != mDiscoverCallbacks.end())
  {
    iter->second(theObject, theObjectInstanceName);
  }
}

void ObjectClassRegistry::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  rti1516ev::ObjectClassHandle theObjectClass = mRtiAmbassador->getKnownObjectClassHandle(theObject);
  auto iter = mRemoveCallbacks.find(theObjectClass);
  if (iter != mRemoveCallbacks.end())
  {
    iter->second(theObject);
  }
}

void ObjectClassRegistry::ReflectAttributeValues(rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  rti1516ev::ObjectClassHandle theObjectClass = mRtiAmbassador->getKnownObjectClassHandle(theObject);
  auto iter = mReflectCallbacks.find(theObjectClass);
  if (iter != mReflectCallbacks.end())
  {
    iter->second(theObject, attributes);
  }
}

void ObjectClassRegistry::ReflectAttributeValues(rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes, const rti1516ev::LogicalTime& time, OrderType orderType)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  rti1516ev::ObjectClassHandle theObjectClass = mRtiAmbassador->getKnownObjectClassHandle(theObject);
  auto iter = mReflectWithTimeCallbacks.find(theObjectClass);
  if (iter != mReflectWithTimeCallbacks.end())
  {
    iter->second(theObject, attributes, time, orderType);
  }
}

void ObjectClassRegistry::ProvideAttributeValues(rti1516ev::ObjectClassHandle theObjectClass, rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleSet& attributeHandles, optional<int64_t> time)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  auto iter = mProvideCallbacks.find(theObjectClass);
  if (iter != mProvideCallbacks.end())
  {
    iter->second(theObject, attributeHandles, time);
  }
}

void ObjectClassRegistry::RegisterObjectInstanceName(const std::wstring& theObjectInstanceName, std::function<void(bool)> completionCallback)
{
  mObjectInstanceNameReservationCallbacks.insert(std::make_pair(theObjectInstanceName, completionCallback));
  mRtiAmbassador->reserveObjectInstanceName(theObjectInstanceName);
}

void ObjectClassRegistry::ObjectInstanceNameReservationSucceeded(const std::wstring& theObjectInstanceName)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  auto iter = mObjectInstanceNameReservationCallbacks.find(theObjectInstanceName);
  if (iter != mObjectInstanceNameReservationCallbacks.end())
  {
    iter->second(true);
    mObjectInstanceNameReservationCallbacks.erase(iter);
  }
}

void ObjectClassRegistry::ObjectInstanceNameReservationFailed(const std::wstring& theObjectInstanceName)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
  auto iter = mObjectInstanceNameReservationCallbacks.find(theObjectInstanceName);
  if (iter != mObjectInstanceNameReservationCallbacks.end())
  {
    iter->second(false);
    mObjectInstanceNameReservationCallbacks.erase(iter);
  }
}

} // namespace OpenRTI
} // namespace Mom
