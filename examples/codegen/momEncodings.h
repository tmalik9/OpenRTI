
// Code automatically generated by FOMCodeGen version 2.1.0.0 from mom.xml, do not edit

#pragma once

#include <vector>
#include <cstring>

#include "RTI/encoding/BasicDataElements.h"
#include "RTI/encoding/HLAfixedRecord.h"
#include "RTI/encoding/HLAfixedArray.h"
#include "RTI/encoding/HLAvariableArray.h"

#include "D:\vfs\OpenRTI-private\examples\codegen/momDataTypes.h"

namespace OpenRTI {
namespace Mom {

class HLAinteractionSubscriptionEncoding;
class HLAobjectClassBasedCountEncoding;
class HLAinteractionCountEncoding;
class HLAsynchPointFederateEncoding;

// simple data type HLAcount
using HLAcountEncoding=rti1516ev::HLAinteger32BE;
// simple data type HLAseconds
using HLAsecondsEncoding=rti1516ev::HLAinteger32BE;
// simple data type HLAmsec
using HLAmsecEncoding=rti1516ev::HLAinteger32BE;
// simple data type HLAnormalizedFederateHandle
using HLAnormalizedFederateHandleEncoding=rti1516ev::HLAinteger32BE;
// simple data type HLAindex
using HLAindexEncoding=rti1516ev::HLAinteger32BE;
// simple data type HLAinteger64Time
using HLAinteger64TimeEncoding=rti1516ev::HLAinteger64BE;
// simple data type HLAfloat64Time
using HLAfloat64TimeEncoding=rti1516ev::HLAfloat64BE;
// enumerated data type HLAfederateState
class HLAfederateStateEncoding : public rti1516ev::HLAinteger32BE
{
  public:
    HLAfederateStateEncoding() : rti1516ev::HLAinteger32BE() {}
    HLAfederateStateEncoding(HLAfederateState value) : rti1516ev::HLAinteger32BE(static_cast<int32_t>(value)) {}
    HLAfederateStateEncoding(const HLAfederateStateEncoding& ref) : rti1516ev::HLAinteger32BE(ref) {}
    using rti1516ev::HLAinteger32BE::get;
    HLAfederateState get() const { return static_cast<HLAfederateState>(rti1516ev::HLAinteger32BE::get()); }
    using rti1516ev::HLAinteger32BE::set;
    void set(HLAfederateState value) { rti1516ev::HLAinteger32BE::set(static_cast<int32_t>(value)); }
};

// enumerated data type HLAtimeState
class HLAtimeStateEncoding : public rti1516ev::HLAinteger32BE
{
  public:
    HLAtimeStateEncoding() : rti1516ev::HLAinteger32BE() {}
    HLAtimeStateEncoding(HLAtimeState value) : rti1516ev::HLAinteger32BE(static_cast<int32_t>(value)) {}
    HLAtimeStateEncoding(const HLAtimeStateEncoding& ref) : rti1516ev::HLAinteger32BE(ref) {}
    using rti1516ev::HLAinteger32BE::get;
    HLAtimeState get() const { return static_cast<HLAtimeState>(rti1516ev::HLAinteger32BE::get()); }
    using rti1516ev::HLAinteger32BE::set;
    void set(HLAtimeState value) { rti1516ev::HLAinteger32BE::set(static_cast<int32_t>(value)); }
};

// enumerated data type HLAownership
class HLAownershipEncoding : public rti1516ev::HLAinteger32BE
{
  public:
    HLAownershipEncoding() : rti1516ev::HLAinteger32BE() {}
    HLAownershipEncoding(HLAownership value) : rti1516ev::HLAinteger32BE(static_cast<int32_t>(value)) {}
    HLAownershipEncoding(const HLAownershipEncoding& ref) : rti1516ev::HLAinteger32BE(ref) {}
    using rti1516ev::HLAinteger32BE::get;
    HLAownership get() const { return static_cast<HLAownership>(rti1516ev::HLAinteger32BE::get()); }
    using rti1516ev::HLAinteger32BE::set;
    void set(HLAownership value) { rti1516ev::HLAinteger32BE::set(static_cast<int32_t>(value)); }
};

// enumerated data type HLAresignAction
class HLAresignActionEncoding : public rti1516ev::HLAinteger32BE
{
  public:
    HLAresignActionEncoding() : rti1516ev::HLAinteger32BE() {}
    HLAresignActionEncoding(HLAresignAction value) : rti1516ev::HLAinteger32BE(static_cast<int32_t>(value)) {}
    HLAresignActionEncoding(const HLAresignActionEncoding& ref) : rti1516ev::HLAinteger32BE(ref) {}
    using rti1516ev::HLAinteger32BE::get;
    HLAresignAction get() const { return static_cast<HLAresignAction>(rti1516ev::HLAinteger32BE::get()); }
    using rti1516ev::HLAinteger32BE::set;
    void set(HLAresignAction value) { rti1516ev::HLAinteger32BE::set(static_cast<int32_t>(value)); }
};

// enumerated data type HLAorderType
class HLAorderTypeEncoding : public rti1516ev::HLAinteger32BE
{
  public:
    HLAorderTypeEncoding() : rti1516ev::HLAinteger32BE() {}
    HLAorderTypeEncoding(HLAorderType value) : rti1516ev::HLAinteger32BE(static_cast<int32_t>(value)) {}
    HLAorderTypeEncoding(const HLAorderTypeEncoding& ref) : rti1516ev::HLAinteger32BE(ref) {}
    using rti1516ev::HLAinteger32BE::get;
    HLAorderType get() const { return static_cast<HLAorderType>(rti1516ev::HLAinteger32BE::get()); }
    using rti1516ev::HLAinteger32BE::set;
    void set(HLAorderType value) { rti1516ev::HLAinteger32BE::set(static_cast<int32_t>(value)); }
};

// enumerated data type HLAswitch
class HLAswitchEncoding : public rti1516ev::HLAinteger32BE
{
  public:
    HLAswitchEncoding() : rti1516ev::HLAinteger32BE() {}
    HLAswitchEncoding(HLAswitch value) : rti1516ev::HLAinteger32BE(static_cast<int32_t>(value)) {}
    HLAswitchEncoding(const HLAswitchEncoding& ref) : rti1516ev::HLAinteger32BE(ref) {}
    using rti1516ev::HLAinteger32BE::get;
    HLAswitch get() const { return static_cast<HLAswitch>(rti1516ev::HLAinteger32BE::get()); }
    using rti1516ev::HLAinteger32BE::set;
    void set(HLAswitch value) { rti1516ev::HLAinteger32BE::set(static_cast<int32_t>(value)); }
};

// enumerated data type HLAsynchPointStatus
class HLAsynchPointStatusEncoding : public rti1516ev::HLAinteger32BE
{
  public:
    HLAsynchPointStatusEncoding() : rti1516ev::HLAinteger32BE() {}
    HLAsynchPointStatusEncoding(HLAsynchPointStatus value) : rti1516ev::HLAinteger32BE(static_cast<int32_t>(value)) {}
    HLAsynchPointStatusEncoding(const HLAsynchPointStatusEncoding& ref) : rti1516ev::HLAinteger32BE(ref) {}
    using rti1516ev::HLAinteger32BE::get;
    HLAsynchPointStatus get() const { return static_cast<HLAsynchPointStatus>(rti1516ev::HLAinteger32BE::get()); }
    using rti1516ev::HLAinteger32BE::set;
    void set(HLAsynchPointStatus value) { rti1516ev::HLAinteger32BE::set(static_cast<int32_t>(value)); }
};

// enumerated data type HLAnormalizedServiceGroup
class HLAnormalizedServiceGroupEncoding : public rti1516ev::HLAinteger32BE
{
  public:
    HLAnormalizedServiceGroupEncoding() : rti1516ev::HLAinteger32BE() {}
    HLAnormalizedServiceGroupEncoding(HLAnormalizedServiceGroup value) : rti1516ev::HLAinteger32BE(static_cast<int32_t>(value)) {}
    HLAnormalizedServiceGroupEncoding(const HLAnormalizedServiceGroupEncoding& ref) : rti1516ev::HLAinteger32BE(ref) {}
    using rti1516ev::HLAinteger32BE::get;
    HLAnormalizedServiceGroup get() const { return static_cast<HLAnormalizedServiceGroup>(rti1516ev::HLAinteger32BE::get()); }
    using rti1516ev::HLAinteger32BE::set;
    void set(HLAnormalizedServiceGroup value) { rti1516ev::HLAinteger32BE::set(static_cast<int32_t>(value)); }
};

// fixed array of simple type HLAbyte
class HLAtokenEncoding : public rti1516ev::HLAfixedArray
{
  public:
    HLAtokenEncoding();
    HLAtokenEncoding(const HLAtokenEncoding& rhs);
    // cardinality is 0, no settable contents
  private:
}; // class HLAtoken
// simple data type HLAtransportationName
using HLAtransportationNameEncoding=rti1516ev::HLAunicodeString;
// simple data type HLAupdateRateName
using HLAupdateRateNameEncoding=rti1516ev::HLAunicodeString;
// An encoded logical time. An empty array shall indicate that the values is not defined
//             
// variable array of simple type HLAbyte
class HLAlogicalTimeEncoding : public rti1516ev::HLAvariableArray
{
  public:
    HLAlogicalTimeEncoding();
    HLAlogicalTimeEncoding(const HLAlogicalTimeEncoding& rhs);
    HLAlogicalTimeEncoding(const std::vector<uint8_t>& data);
    using rti1516ev::HLAvariableArray::set;
    void set(const std::vector<uint8_t>& data);
    void set(const uint8_t* data, size_t size);
    using rti1516ev::HLAvariableArray::get;
    const std::vector<uint8_t>& get() const;
    void resize(size_t size);
    using rti1516ev::HLAvariableArray::decodeFrom;
    virtual size_t decodeFrom(const rti1516ev::Octet* buffer, size_t bufferSize, size_t index) override;
  private:
    void update();
    std::vector<uint8_t> mData;
    std::vector<rti1516ev::HLAbyte> mEncoding;
}; // class HLAlogicalTime

// An encoded logical time interval. An empty array shall indicate that the values is not defined
//             
// variable array of simple type HLAbyte
class HLAtimeIntervalEncoding : public rti1516ev::HLAvariableArray
{
  public:
    HLAtimeIntervalEncoding();
    HLAtimeIntervalEncoding(const HLAtimeIntervalEncoding& rhs);
    HLAtimeIntervalEncoding(const std::vector<uint8_t>& data);
    using rti1516ev::HLAvariableArray::set;
    void set(const std::vector<uint8_t>& data);
    void set(const uint8_t* data, size_t size);
    using rti1516ev::HLAvariableArray::get;
    const std::vector<uint8_t>& get() const;
    void resize(size_t size);
    using rti1516ev::HLAvariableArray::decodeFrom;
    virtual size_t decodeFrom(const rti1516ev::Octet* buffer, size_t bufferSize, size_t index) override;
  private:
    void update();
    std::vector<uint8_t> mData;
    std::vector<rti1516ev::HLAbyte> mEncoding;
}; // class HLAtimeInterval

// List of encoded handles
// variable array of complex type HLAhandle
class HLAhandleListEncoding : public rti1516ev::HLAvariableArray
{
  public:
    HLAhandleListEncoding();
    HLAhandleListEncoding(const HLAhandleListEncoding& rhs);
    HLAhandleListEncoding(const std::vector<rti1516ev::HLAhandle>& data);
    using rti1516ev::HLAvariableArray::set;
    void set(const std::vector<rti1516ev::HLAhandle>& data);
    void set(std::vector<rti1516ev::HLAhandle>& data);
    void set(const rti1516ev::HLAhandle* data, size_t size);
    void set(rti1516ev::HLAhandle* data, size_t size);
    virtual size_t decodeFrom(const rti1516ev::Octet* buffer, size_t bufferSize, size_t index) override;
}; // class HLAhandleList

// List of interaction subscription indicators
// variable array of complex type HLAinteractionSubscription
class HLAinteractionSubListEncoding : public rti1516ev::HLAvariableArray
{
  public:
    HLAinteractionSubListEncoding();
    HLAinteractionSubListEncoding(const HLAinteractionSubListEncoding& rhs);
    HLAinteractionSubListEncoding(const std::vector<HLAinteractionSubscriptionEncoding>& data);
    using rti1516ev::HLAvariableArray::set;
    void set(const std::vector<HLAinteractionSubscriptionEncoding>& data);
    void set(std::vector<HLAinteractionSubscriptionEncoding>& data);
    void set(const HLAinteractionSubscriptionEncoding* data, size_t size);
    void set(HLAinteractionSubscriptionEncoding* data, size_t size);
    virtual size_t decodeFrom(const rti1516ev::Octet* buffer, size_t bufferSize, size_t index) override;
}; // class HLAinteractionSubList

// List of arguments
// variable array of simple type HLAunicodeString
class HLAargumentListEncoding : public rti1516ev::HLAvariableArray
{
  public:
    HLAargumentListEncoding();
    HLAargumentListEncoding(const HLAargumentListEncoding& rhs);
    HLAargumentListEncoding(const std::vector<std::wstring>& data);
    using rti1516ev::HLAvariableArray::set;
    void set(const std::vector<std::wstring>& data);
    void set(const std::wstring* data, size_t size);
    using rti1516ev::HLAvariableArray::get;
    const std::vector<std::wstring>& get() const;
    void resize(size_t size);
    using rti1516ev::HLAvariableArray::decodeFrom;
    virtual size_t decodeFrom(const rti1516ev::Octet* buffer, size_t bufferSize, size_t index) override;
  private:
    void update();
    std::vector<std::wstring> mData;
    std::vector<rti1516ev::HLAunicodeString> mEncoding;
}; // class HLAargumentList

// List of counts of various items based on object class. In all MOM interactions that have a
//                parameter of datatype HLAobjectClassBased- Counts, if an HLAobjectClassBasedCount element of the
//                HLAobjectClassBasedCounts array would have a value (object class, 0), the HLAobjectClassBasedCount
//                element shall not be present in the HLAobjectClassBasedCounts array. In other words, only HLAobject-
//                ClassBasedCount elements that have positive counts shall be present in an HLAobjectClassBasedCounts
//                array. From this, it follows that if all object class counts have a zero value, then the HLAobjectClass-
//                BasedCounts array shall not have any elements in it; it shall be an empty HLAobjectClassBasedCounts
//                array.
//             
// variable array of complex type HLAobjectClassBasedCount
class HLAobjectClassBasedCountsEncoding : public rti1516ev::HLAvariableArray
{
  public:
    HLAobjectClassBasedCountsEncoding();
    HLAobjectClassBasedCountsEncoding(const HLAobjectClassBasedCountsEncoding& rhs);
    HLAobjectClassBasedCountsEncoding(const std::vector<HLAobjectClassBasedCountEncoding>& data);
    using rti1516ev::HLAvariableArray::set;
    void set(const std::vector<HLAobjectClassBasedCountEncoding>& data);
    void set(std::vector<HLAobjectClassBasedCountEncoding>& data);
    void set(const HLAobjectClassBasedCountEncoding* data, size_t size);
    void set(HLAobjectClassBasedCountEncoding* data, size_t size);
    virtual size_t decodeFrom(const rti1516ev::Octet* buffer, size_t bufferSize, size_t index) override;
}; // class HLAobjectClassBasedCounts

// List of interaction counts. In all MOM interactions that have a parameter of datatype
//                HLAinteractionCounts, if an HLAinteractionCount element of the HLAinteractionCounts array would have a
//                value (interaction class, 0), the HLAinteractionCount element shall not be present in the
//                HLAinteractionCounts array. In other words, only HLAinteractionCount elements that have positive counts
//                shall be present in an HLAinteractionCounts array. From this, it follows that if all interaction class
//                counts have a zero value, then the HLAinteractionCounts array shall not have any elements in it; it shall
//                be an empty HLAinteractionCounts array.
//             
// variable array of complex type HLAinteractionCount
class HLAinteractionCountsEncoding : public rti1516ev::HLAvariableArray
{
  public:
    HLAinteractionCountsEncoding();
    HLAinteractionCountsEncoding(const HLAinteractionCountsEncoding& rhs);
    HLAinteractionCountsEncoding(const std::vector<HLAinteractionCountEncoding>& data);
    using rti1516ev::HLAvariableArray::set;
    void set(const std::vector<HLAinteractionCountEncoding>& data);
    void set(std::vector<HLAinteractionCountEncoding>& data);
    void set(const HLAinteractionCountEncoding* data, size_t size);
    void set(HLAinteractionCountEncoding* data, size_t size);
    virtual size_t decodeFrom(const rti1516ev::Octet* buffer, size_t bufferSize, size_t index) override;
}; // class HLAinteractionCounts

// List of names of synchronization points.
// variable array of simple type HLAunicodeString
class HLAsynchPointListEncoding : public rti1516ev::HLAvariableArray
{
  public:
    HLAsynchPointListEncoding();
    HLAsynchPointListEncoding(const HLAsynchPointListEncoding& rhs);
    HLAsynchPointListEncoding(const std::vector<std::wstring>& data);
    using rti1516ev::HLAvariableArray::set;
    void set(const std::vector<std::wstring>& data);
    void set(const std::wstring* data, size_t size);
    using rti1516ev::HLAvariableArray::get;
    const std::vector<std::wstring>& get() const;
    void resize(size_t size);
    using rti1516ev::HLAvariableArray::decodeFrom;
    virtual size_t decodeFrom(const rti1516ev::Octet* buffer, size_t bufferSize, size_t index) override;
  private:
    void update();
    std::vector<std::wstring> mData;
    std::vector<rti1516ev::HLAunicodeString> mEncoding;
}; // class HLAsynchPointList

// List of joined federates and the synchronization status of each.
// variable array of complex type HLAsynchPointFederate
class HLAsynchPointFederateListEncoding : public rti1516ev::HLAvariableArray
{
  public:
    HLAsynchPointFederateListEncoding();
    HLAsynchPointFederateListEncoding(const HLAsynchPointFederateListEncoding& rhs);
    HLAsynchPointFederateListEncoding(const std::vector<HLAsynchPointFederateEncoding>& data);
    using rti1516ev::HLAvariableArray::set;
    void set(const std::vector<HLAsynchPointFederateEncoding>& data);
    void set(std::vector<HLAsynchPointFederateEncoding>& data);
    void set(const HLAsynchPointFederateEncoding* data, size_t size);
    void set(HLAsynchPointFederateEncoding* data, size_t size);
    virtual size_t decodeFrom(const rti1516ev::Octet* buffer, size_t bufferSize, size_t index) override;
}; // class HLAsynchPointFederateList

// List of designators of FOM modules.
// variable array of simple type HLAunicodeString
class HLAmoduleDesignatorListEncoding : public rti1516ev::HLAvariableArray
{
  public:
    HLAmoduleDesignatorListEncoding();
    HLAmoduleDesignatorListEncoding(const HLAmoduleDesignatorListEncoding& rhs);
    HLAmoduleDesignatorListEncoding(const std::vector<std::wstring>& data);
    using rti1516ev::HLAvariableArray::set;
    void set(const std::vector<std::wstring>& data);
    void set(const std::wstring* data, size_t size);
    using rti1516ev::HLAvariableArray::get;
    const std::vector<std::wstring>& get() const;
    void resize(size_t size);
    using rti1516ev::HLAvariableArray::decodeFrom;
    virtual size_t decodeFrom(const rti1516ev::Octet* buffer, size_t bufferSize, size_t index) override;
  private:
    void update();
    std::vector<std::wstring> mData;
    std::vector<rti1516ev::HLAunicodeString> mEncoding;
}; // class HLAmoduleDesignatorList

// Interaction subscription information
class HLAinteractionSubscriptionEncoding : public HLAinteractionSubscription, public rti1516ev::HLAfixedRecord
{
  public:
    HLAinteractionSubscriptionEncoding();
    HLAinteractionSubscriptionEncoding(const HLAinteractionSubscriptionEncoding& ref);
    virtual ~HLAinteractionSubscriptionEncoding();
    uint32_t getVersion() const override;
    void SetHLAinteractionClass(rti1516ev::HLAhandle value) override;
    rti1516ev::HLAhandle GetHLAinteractionClass() const override;
    bool IsHLAinteractionClassAvailable() const override;
    void SetHLAactive(bool value) override;
    bool GetHLAactive() const override;
    bool IsHLAactiveAvailable() const override;
    HLAinteractionSubscriptionEncoding& operator=(const HLAinteractionSubscription& ref);
  private:
    rti1516ev::HLAhandle mHLAinteractionClass;
    rti1516ev::HLAboolean mHLAactive;
}; // class HLAinteractionSubscriptionEncoding

// Test.
// fixed array of complex type HLAinteractionSubscription
class HLAinteractionSubscriptionFixedListEncoding : public rti1516ev::HLAfixedArray
{
  public:
    HLAinteractionSubscriptionFixedListEncoding();
    HLAinteractionSubscriptionFixedListEncoding(const HLAinteractionSubscriptionFixedListEncoding& rhs);
    HLAinteractionSubscriptionFixedListEncoding(const std::vector<HLAinteractionSubscriptionEncoding>& data);
    using rti1516ev::HLAfixedArray::set;
    void set(const std::vector<HLAinteractionSubscriptionEncoding>& data);
    void set(const HLAinteractionSubscription* data, size_t size);
    // not yet supported: const std::vector<HLAinteractionSubscriptionEncoding>& get() const;
  private:
}; // class HLAinteractionSubscriptionFixedList
// Object class and count of associated items
class HLAobjectClassBasedCountEncoding : public HLAobjectClassBasedCount, public rti1516ev::HLAfixedRecord
{
  public:
    HLAobjectClassBasedCountEncoding();
    HLAobjectClassBasedCountEncoding(const HLAobjectClassBasedCountEncoding& ref);
    virtual ~HLAobjectClassBasedCountEncoding();
    uint32_t getVersion() const override;
    void SetHLAobjectClass(rti1516ev::HLAhandle value) override;
    rti1516ev::HLAhandle GetHLAobjectClass() const override;
    bool IsHLAobjectClassAvailable() const override;
    void SetHLAcount(HLAcount value) override;
    HLAcount GetHLAcount() const override;
    bool IsHLAcountAvailable() const override;
    HLAobjectClassBasedCountEncoding& operator=(const HLAobjectClassBasedCount& ref);
  private:
    rti1516ev::HLAhandle mHLAobjectClass;
    rti1516ev::HLAinteger32BE mHLAcount;
}; // class HLAobjectClassBasedCountEncoding

// Count of interactions of a class
class HLAinteractionCountEncoding : public HLAinteractionCount, public rti1516ev::HLAfixedRecord
{
  public:
    HLAinteractionCountEncoding();
    HLAinteractionCountEncoding(const HLAinteractionCountEncoding& ref);
    virtual ~HLAinteractionCountEncoding();
    uint32_t getVersion() const override;
    void SetHLAinteractionClass(rti1516ev::HLAhandle value) override;
    rti1516ev::HLAhandle GetHLAinteractionClass() const override;
    bool IsHLAinteractionClassAvailable() const override;
    void SetHLAinteractionCount(HLAcount value) override;
    HLAcount GetHLAinteractionCount() const override;
    bool IsHLAinteractionCountAvailable() const override;
    HLAinteractionCountEncoding& operator=(const HLAinteractionCount& ref);
  private:
    rti1516ev::HLAhandle mHLAinteractionClass;
    rti1516ev::HLAinteger32BE mHLAinteractionCount;
}; // class HLAinteractionCountEncoding

// A particular joined federate and its synchronization point status
class HLAsynchPointFederateEncoding : public HLAsynchPointFederate, public rti1516ev::HLAfixedRecord
{
  public:
    HLAsynchPointFederateEncoding();
    HLAsynchPointFederateEncoding(const HLAsynchPointFederateEncoding& ref);
    virtual ~HLAsynchPointFederateEncoding();
    uint32_t getVersion() const override;
    void SetHLAfederate(rti1516ev::HLAhandle value) override;
    rti1516ev::HLAhandle GetHLAfederate() const override;
    bool IsHLAfederateAvailable() const override;
    void SetHLAfederateSynchStatus(HLAsynchPointStatus value) override;
    HLAsynchPointStatus GetHLAfederateSynchStatus() const override;
    bool IsHLAfederateSynchStatusAvailable() const override;
    HLAsynchPointFederateEncoding& operator=(const HLAsynchPointFederate& ref);
  private:
    rti1516ev::HLAhandle mHLAfederate;
    rti1516ev::HLAinteger32BE mHLAfederateSynchStatus;
}; // class HLAsynchPointFederateEncoding

} // namespace OpenRTI
} // namespace Mom

