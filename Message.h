/* -*-c++-*- OpenRTI - Copyright (C) 2009-2013 Mathias Froehlich
 *
 *
 * This file is part of OpenRTI.
 *
 * OpenRTI is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * OpenRTI is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with OpenRTI.  If not, see <http://www.gnu.org/licenses/>.
 *
 * This file is autogenerated by messagegen.py. Do not edit!
 *
 */

#ifndef OpenRTI_Message_h
#define OpenRTI_Message_h

#include <map>
#include <set>
#include <vector>
#include "AbstractMessage.h"
#include "AbstractMessageDispatcher.h"
#include "Handle.h"
#include "VariableLengthData.h"

#ifndef __CPlusPlusStd
#error "must include OpenRTIConfig.h!"
#endif

namespace OpenRTI {

enum CallbackModel {
  HLA_IMMEDIATE,
  HLA_EVOKED
};

enum OrderType {
  RECEIVE,
  TIMESTAMP
};

enum TransportationType {
  RELIABLE,
  BEST_EFFORT
};

enum SubscriptionType {
  Unsubscribed,
  SubscribedPassive,
  SubscribedActive
};

enum PublicationType {
  Unpublished,
  Published
};

enum ResignAction {
  UNCONDITIONALLY_DIVEST_ATTRIBUTES,
  DELETE_OBJECTS,
  CANCEL_PENDING_OWNERSHIP_ACQUISITIONS,
  DELETE_OBJECTS_THEN_DIVEST,
  CANCEL_THEN_DELETE_THEN_DIVEST,
  NO_ACTION
};

enum RestoreFailureReason {
  RTI_UNABLE_TO_RESTORE,
  FEDERATE_REPORTED_FAILURE_DURING_RESTORE,
  FEDERATE_RESIGNED_DURING_RESTORE,
  RTI_DETECTED_FAILURE_DURING_RESTORE
};

enum RestoreStatus {
  NO_RESTORE_IN_PROGRESS,
  FEDERATE_RESTORE_REQUEST_PENDING,
  FEDERATE_WAITING_FOR_RESTORE_TO_BEGIN,
  FEDERATE_PREPARED_TO_RESTORE,
  FEDERATE_RESTORING,
  FEDERATE_WAITING_FOR_FEDERATION_TO_RESTORE
};

enum SaveFailureReason {
  RTI_UNABLE_TO_SAVE,
  FEDERATE_REPORTED_FAILURE_DURING_SAVE,
  FEDERATE_RESIGNED_DURING_SAVE,
  RTI_DETECTED_FAILURE_DURING_SAVE,
  SAVE_TIME_CANNOT_BE_HONORED
};

enum SaveStatus {
  NO_SAVE_IN_PROGRESS,
  FEDERATE_INSTRUCTED_TO_SAVE,
  FEDERATE_SAVING,
  FEDERATE_WAITING_FOR_FEDERATION_TO_SAVE
};

enum ServiceGroupIndicator {
  FEDERATION_MANAGEMENT,
  DECLARATION_MANAGEMENT,
  OBJECT_MANAGEMENT,
  OWNERSHIP_MANAGEMENT,
  TIME_MANAGEMENT,
  DATA_DISTRIBUTION_MANAGEMENT,
  SUPPORT_SERVICES
};

enum LowerBoundTimeStampCommitType {
  TimeAdvanceCommit = 1,
  NextMessageCommit = 2,
  TimeAdvanceAndNextMessageCommit = 3
};

enum SwitchesType {
  InteractionRelevanceAdvisorySwitchesType,
  ObjectClassRelevanceAdvisorySwitchesType,
  AttributeRelevanceAdvisorySwitchesType,
  AttributeScopeAdvisorySwitchesType,
  AutoProvideSwitchesType,
  ConveyRegionDesignatorSetsSwitchesType,
  ServiceReportingSwitchesType
};

typedef bool Bool;

typedef std::string String;

typedef uint32_t Unsigned;

typedef double Double;

typedef std::vector<AttributeHandle> AttributeHandleVector;

typedef std::vector<FederateHandle> FederateHandleVector;

typedef std::vector<ParameterHandle> ParameterHandleVector;

typedef std::vector<DimensionHandle> DimensionHandleVector;

typedef std::set<DimensionHandle> DimensionHandleSet;

typedef std::vector<ObjectInstanceHandle> ObjectInstanceHandleVector;

typedef std::vector<RegionHandle> RegionHandleVector;

typedef std::vector<ModuleHandle> ModuleHandleVector;

typedef std::vector<String> StringVector;

typedef std::set<String> StringSet;

typedef std::pair<FederateHandle, Bool> FederateHandleBoolPair;

typedef std::vector<FederateHandleBoolPair> FederateHandleBoolPairVector;

class RangeBoundsValue;
typedef std::pair<DimensionHandle, RangeBoundsValue> DimensionHandleRangeBoundsValuePair;

typedef std::vector<DimensionHandleRangeBoundsValuePair> RegionValue;

typedef std::vector<RegionValue> RegionValueList;

typedef std::pair<RegionHandle, DimensionHandleSet> RegionHandleDimensionHandleSetPair;

typedef std::vector<RegionHandleDimensionHandleSetPair> RegionHandleDimensionHandleSetPairVector;

typedef std::pair<RegionHandle, SpaceHandle> RegionHandleSpaceHandlePair;

typedef std::vector<RegionHandleSpaceHandlePair> RegionHandleSpaceHandlePairVector;

typedef std::pair<RegionHandle, RegionValue> RegionHandleRegionValuePair;

typedef std::vector<RegionHandleRegionValuePair> RegionHandleRegionValuePairVector;

typedef std::pair<InteractionClassHandle, RegionValueList> InteractionClassHandleRegionValueListPair;

typedef std::pair<AttributeHandle, RegionValueList> AttributeHandleRegionValueListPair;

class AttributeState;
typedef std::vector<AttributeState> AttributeStateVector;

class ParameterValue;
typedef std::vector<ParameterValue> ParameterValueVector;

class AttributeValue;
typedef std::vector<AttributeValue> AttributeValueVector;

typedef std::pair<FederateHandle, SaveStatus> FederateHandleSaveStatusPair;

typedef std::vector<FederateHandleSaveStatusPair> FederateHandleSaveStatusPairVector;

typedef std::pair<FederateHandle, RestoreStatus> FederateHandleRestoreStatusPair;

typedef std::vector<FederateHandleRestoreStatusPair> FederateHandleRestoreStatusPairVector;

class FederationExecutionInformation;
typedef std::vector<FederationExecutionInformation> FederationExecutionInformationVector;

typedef std::pair<ObjectInstanceHandle, String> ObjectInstanceHandleNamePair;

typedef std::vector<ObjectInstanceHandleNamePair> ObjectInstanceHandleNamePairVector;

enum CreateFederationExecutionResponseType {
  CreateFederationExecutionResponseSuccess,
  CreateFederationExecutionResponseFederationExecutionAlreadyExists,
  CreateFederationExecutionResponseCouldNotOpenFDD,
  CreateFederationExecutionResponseErrorReadingFDD,
  CreateFederationExecutionResponseCouldNotCreateLogicalTimeFactory,
  CreateFederationExecutionResponseInconsistentFDD,
  CreateFederationExecutionResponseRTIinternalError
};

enum DestroyFederationExecutionResponseType {
  DestroyFederationExecutionResponseSuccess,
  DestroyFederationExecutionResponseFederatesCurrentlyJoined,
  DestroyFederationExecutionResponseFederationExecutionDoesNotExist,
  DestroyFederationExecutionResponseRTIinternalError
};

enum JoinFederationExecutionResponseType {
  JoinFederationExecutionResponseSuccess,
  JoinFederationExecutionResponseFederateNameAlreadyInUse,
  JoinFederationExecutionResponseFederationExecutionDoesNotExist,
  JoinFederationExecutionResponseSaveInProgress,
  JoinFederationExecutionResponseRestoreInProgress,
  JoinFederationExecutionResponseInconsistentFDD
};

enum RegisterFederationSynchronizationPointResponseType {
  RegisterFederationSynchronizationPointResponseSuccess,
  RegisterFederationSynchronizationPointResponseLabelNotUnique,
  RegisterFederationSynchronizationPointResponseMemberNotJoined
};

typedef std::map<String, StringVector> ConfigurationParameterMap;

class FOMStringSimpleDataType;
typedef std::vector<FOMStringSimpleDataType> FOMStringSimpleDataTypeList;

class FOMStringEnumerator;
typedef std::vector<FOMStringEnumerator> FOMStringEnumeratorList;

class FOMStringEnumeratedDataType;
typedef std::vector<FOMStringEnumeratedDataType> FOMStringEnumeratedDataTypeList;

class FOMStringArrayDataType;
typedef std::vector<FOMStringArrayDataType> FOMStringArrayDataTypeList;

class FOMStringFixedRecordField;
typedef std::vector<FOMStringFixedRecordField> FOMStringFixedRecordFieldList;

class FOMStringFixedRecordDataType;
typedef std::vector<FOMStringFixedRecordDataType> FOMStringFixedRecordDataTypeList;

class FOMStringVariantRecordAlternative;
typedef std::vector<FOMStringVariantRecordAlternative> FOMStringVariantRecordAlternativeList;

class FOMStringVariantRecordDataType;
typedef std::vector<FOMStringVariantRecordDataType> FOMStringVariantRecordDataTypeList;

class FOMStringTransportationType;
typedef std::vector<FOMStringTransportationType> FOMStringTransportationTypeList;

class FOMStringDimension;
typedef std::vector<FOMStringDimension> FOMStringDimensionList;

class FOMStringRoutingSpace;
typedef std::vector<FOMStringRoutingSpace> FOMStringRoutingSpaceList;

class FOMStringParameter;
typedef std::vector<FOMStringParameter> FOMStringParameterList;

class FOMStringInteractionClass;
typedef std::vector<FOMStringInteractionClass> FOMStringInteractionClassList;

class FOMStringAttribute;
typedef std::vector<FOMStringAttribute> FOMStringAttributeList;

class FOMStringObjectClass;
typedef std::vector<FOMStringObjectClass> FOMStringObjectClassList;

class FOMStringUpdateRate;
typedef std::vector<FOMStringUpdateRate> FOMStringUpdateRateList;

class FOMStringSwitch;
typedef std::vector<FOMStringSwitch> FOMStringSwitchList;

class FOMStringModule;
typedef std::vector<FOMStringModule> FOMStringModuleList;

class FOMTransportationType;
typedef std::vector<FOMTransportationType> FOMTransportationTypeList;

class FOMDimension;
typedef std::vector<FOMDimension> FOMDimensionList;

class FOMRoutingSpace;
typedef std::vector<FOMRoutingSpace> FOMRoutingSpaceList;

class FOMParameter;
typedef std::vector<FOMParameter> FOMParameterList;

class FOMInteractionClass;
typedef std::vector<FOMInteractionClass> FOMInteractionClassList;

class FOMAttribute;
typedef std::vector<FOMAttribute> FOMAttributeList;

class FOMObjectClass;
typedef std::vector<FOMObjectClass> FOMObjectClassList;

class FOMUpdateRate;
typedef std::vector<FOMUpdateRate> FOMUpdateRateList;

class FOMSwitch;
typedef std::vector<FOMSwitch> FOMSwitchList;

class FOMModule;
typedef std::vector<FOMModule> FOMModuleList;

class ConnectionLostMessage;
class CreateFederationExecutionRequestMessage;
class CreateFederationExecutionResponseMessage;
class DestroyFederationExecutionRequestMessage;
class DestroyFederationExecutionResponseMessage;
class EnumerateFederationExecutionsRequestMessage;
class EnumerateFederationExecutionsResponseMessage;
class InsertFederationExecutionMessage;
class ShutdownFederationExecutionMessage;
class EraseFederationExecutionMessage;
class ReleaseFederationHandleMessage;
class InsertModulesMessage;
class JoinFederationExecutionRequestMessage;
class JoinFederationExecutionResponseMessage;
class ResignFederationExecutionLeafRequestMessage;
class ResignFederationExecutionRequestMessage;
class JoinFederateNotifyMessage;
class ResignFederateNotifyMessage;
class ChangeAutomaticResignDirectiveMessage;
class RegisterFederationSynchronizationPointMessage;
class RegisterFederationSynchronizationPointResponseMessage;
class AnnounceSynchronizationPointMessage;
class SynchronizationPointAchievedMessage;
class FederationSynchronizedMessage;
class EnableTimeRegulationRequestMessage;
class EnableTimeRegulationResponseMessage;
class DisableTimeRegulationRequestMessage;
class EnableTimeConstrainedNotifyMessage;
class DisableTimeConstrainedNotifyMessage;
class CommitLowerBoundTimeStampMessage;
class CommitLowerBoundTimeStampResponseMessage;
class LockedByNextMessageRequestMessage;
class TimeConstrainedEnabledMessage;
class TimeRegulationEnabledMessage;
class TimeAdvanceGrantedMessage;
class InsertRegionMessage;
class CommitRegionMessage;
class EraseRegionMessage;
class ChangeInteractionClassPublicationMessage;
class ChangeObjectClassPublicationMessage;
class ChangeInteractionClassSubscriptionMessage;
class ChangeObjectClassSubscriptionMessage;
class ChangeObjectInstanceSubscriptionMessage;
class RegistrationForObjectClassMessage;
class AttributesInScopeMessage;
class TurnUpdatesOnForInstanceMessage;
class TurnInteractionsOnMessage;
class InteractionMessage;
class TimeStampedInteractionMessage;
class ObjectInstanceHandlesRequestMessage;
class ObjectInstanceHandlesResponseMessage;
class ReleaseMultipleObjectInstanceNameHandlePairsMessage;
class ReserveObjectInstanceNameRequestMessage;
class ReserveObjectInstanceNameResponseMessage;
class ReserveMultipleObjectInstanceNameRequestMessage;
class ReserveMultipleObjectInstanceNameResponseMessage;
class InsertObjectInstanceMessage;
class DeleteObjectInstanceMessage;
class TimeStampedDeleteObjectInstanceMessage;
class AttributeUpdateMessage;
class TimeStampedAttributeUpdateMessage;
class RequestAttributeUpdateMessage;
class RequestClassAttributeUpdateMessage;
class QueryAttributeOwnershipRequestMessage;
class QueryAttributeOwnershipResponseMessage;

typedef bool Bool;

typedef std::string String;

typedef uint32_t Unsigned;

typedef double Double;

typedef std::vector<AttributeHandle> AttributeHandleVector;

typedef std::vector<FederateHandle> FederateHandleVector;

typedef std::vector<ParameterHandle> ParameterHandleVector;

typedef std::vector<DimensionHandle> DimensionHandleVector;

typedef std::set<DimensionHandle> DimensionHandleSet;

typedef std::vector<ObjectInstanceHandle> ObjectInstanceHandleVector;

typedef std::vector<RegionHandle> RegionHandleVector;

typedef std::vector<ModuleHandle> ModuleHandleVector;

typedef std::vector<String> StringVector;

typedef std::set<String> StringSet;

typedef std::pair<FederateHandle, Bool> FederateHandleBoolPair;

typedef std::vector<FederateHandleBoolPair> FederateHandleBoolPairVector;

class OPENRTI_API RangeBoundsValue {
public:
  RangeBoundsValue() { }
  RangeBoundsValue(
    Unsigned lowerBound,
    Unsigned upperBound)
      : _lowerBound(lowerBound)
      , _upperBound(upperBound)
    { }
  void setLowerBound(const Unsigned& value) noexcept
  { _lowerBound = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setLowerBound(Unsigned&& value) noexcept
  { _lowerBound = std::move(value); }
#endif
  Unsigned& getLowerBound() noexcept
  { return _lowerBound; }
  const Unsigned& getLowerBound() const noexcept
  { return _lowerBound; }

  void setUpperBound(const Unsigned& value) noexcept
  { _upperBound = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setUpperBound(Unsigned&& value) noexcept
  { _upperBound = std::move(value); }
#endif
  Unsigned& getUpperBound() noexcept
  { return _upperBound; }
  const Unsigned& getUpperBound() const noexcept
  { return _upperBound; }

  RangeBoundsValue& swap(RangeBoundsValue& rhs)
  {
    std::swap(_lowerBound, rhs._lowerBound);
    std::swap(_upperBound, rhs._upperBound);
    return *this;
  }
  bool operator==(const RangeBoundsValue& rhs) const noexcept
  {
    if (getLowerBound() != rhs.getLowerBound()) return false;
    if (getUpperBound() != rhs.getUpperBound()) return false;
    return true;
  }
  bool operator<(const RangeBoundsValue& rhs) const noexcept
  {
    if (getLowerBound() < rhs.getLowerBound()) return true;
    if (rhs.getLowerBound() < getLowerBound()) return false;
    if (getUpperBound() < rhs.getUpperBound()) return true;
    if (rhs.getUpperBound() < getUpperBound()) return false;
    return false;
  }
  bool operator>(const RangeBoundsValue& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const RangeBoundsValue& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const RangeBoundsValue& rhs) const noexcept
  { return !operator>(rhs); }
private:
  Unsigned _lowerBound;
  Unsigned _upperBound;
};

typedef std::pair<DimensionHandle, RangeBoundsValue> DimensionHandleRangeBoundsValuePair;

typedef std::vector<DimensionHandleRangeBoundsValuePair> RegionValue;

typedef std::vector<RegionValue> RegionValueList;

typedef std::pair<RegionHandle, DimensionHandleSet> RegionHandleDimensionHandleSetPair;

typedef std::vector<RegionHandleDimensionHandleSetPair> RegionHandleDimensionHandleSetPairVector;

typedef std::pair<RegionHandle, SpaceHandle> RegionHandleSpaceHandlePair;

typedef std::vector<RegionHandleSpaceHandlePair> RegionHandleSpaceHandlePairVector;

typedef std::pair<RegionHandle, RegionValue> RegionHandleRegionValuePair;

typedef std::vector<RegionHandleRegionValuePair> RegionHandleRegionValuePairVector;

typedef std::pair<InteractionClassHandle, RegionValueList> InteractionClassHandleRegionValueListPair;

typedef std::pair<AttributeHandle, RegionValueList> AttributeHandleRegionValueListPair;

class OPENRTI_API AttributeState {
public:
  AttributeState() { }
  AttributeState(
    AttributeHandle attributeHandle,
    FederateHandle ownerFederate)
      : _attributeHandle(attributeHandle)
      , _ownerFederate(ownerFederate)
    { }
  void setAttributeHandle(const AttributeHandle& value) noexcept
  { _attributeHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setAttributeHandle(AttributeHandle&& value) noexcept
  { _attributeHandle = std::move(value); }
#endif
  AttributeHandle& getAttributeHandle() noexcept
  { return _attributeHandle; }
  const AttributeHandle& getAttributeHandle() const noexcept
  { return _attributeHandle; }

  void setOwnerFederate(const FederateHandle& value) noexcept
  { _ownerFederate = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setOwnerFederate(FederateHandle&& value) noexcept
  { _ownerFederate = std::move(value); }
#endif
  FederateHandle& getOwnerFederate() noexcept
  { return _ownerFederate; }
  const FederateHandle& getOwnerFederate() const noexcept
  { return _ownerFederate; }

  AttributeState& swap(AttributeState& rhs)
  {
    std::swap(_attributeHandle, rhs._attributeHandle);
    std::swap(_ownerFederate, rhs._ownerFederate);
    return *this;
  }
  bool operator==(const AttributeState& rhs) const noexcept
  {
    if (getAttributeHandle() != rhs.getAttributeHandle()) return false;
    if (getOwnerFederate() != rhs.getOwnerFederate()) return false;
    return true;
  }
  bool operator<(const AttributeState& rhs) const noexcept
  {
    if (getAttributeHandle() < rhs.getAttributeHandle()) return true;
    if (rhs.getAttributeHandle() < getAttributeHandle()) return false;
    if (getOwnerFederate() < rhs.getOwnerFederate()) return true;
    if (rhs.getOwnerFederate() < getOwnerFederate()) return false;
    return false;
  }
  bool operator>(const AttributeState& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const AttributeState& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const AttributeState& rhs) const noexcept
  { return !operator>(rhs); }
private:
  AttributeHandle _attributeHandle;
  FederateHandle _ownerFederate;
};

typedef std::vector<AttributeState> AttributeStateVector;

class OPENRTI_API ParameterValue {
public:
  ParameterValue() { }
  ParameterValue(
    ParameterHandle parameterHandle,
    VariableLengthData value)
      : _parameterHandle(parameterHandle)
      , _value(value)
    { }
  void setParameterHandle(const ParameterHandle& value) noexcept
  { _parameterHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setParameterHandle(ParameterHandle&& value) noexcept
  { _parameterHandle = std::move(value); }
#endif
  ParameterHandle& getParameterHandle() noexcept
  { return _parameterHandle; }
  const ParameterHandle& getParameterHandle() const noexcept
  { return _parameterHandle; }

  void setValue(const VariableLengthData& value) noexcept
  { _value = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setValue(VariableLengthData&& value) noexcept
  { _value = std::move(value); }
#endif
  VariableLengthData& getValue() noexcept
  { return _value; }
  const VariableLengthData& getValue() const noexcept
  { return _value; }

  ParameterValue& swap(ParameterValue& rhs)
  {
    std::swap(_parameterHandle, rhs._parameterHandle);
    _value.swap(rhs._value);
    return *this;
  }
  bool operator==(const ParameterValue& rhs) const noexcept
  {
    if (getParameterHandle() != rhs.getParameterHandle()) return false;
    if (getValue() != rhs.getValue()) return false;
    return true;
  }
  bool operator<(const ParameterValue& rhs) const noexcept
  {
    if (getParameterHandle() < rhs.getParameterHandle()) return true;
    if (rhs.getParameterHandle() < getParameterHandle()) return false;
    if (getValue() < rhs.getValue()) return true;
    if (rhs.getValue() < getValue()) return false;
    return false;
  }
  bool operator>(const ParameterValue& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const ParameterValue& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const ParameterValue& rhs) const noexcept
  { return !operator>(rhs); }
private:
  ParameterHandle _parameterHandle;
  VariableLengthData _value;
};

typedef std::vector<ParameterValue> ParameterValueVector;

class OPENRTI_API AttributeValue {
public:
  AttributeValue() { }
  AttributeValue(
    AttributeHandle attributeHandle,
    VariableLengthData value)
      : _attributeHandle(attributeHandle)
      , _value(value)
    { }
  void setAttributeHandle(const AttributeHandle& value) noexcept
  { _attributeHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setAttributeHandle(AttributeHandle&& value) noexcept
  { _attributeHandle = std::move(value); }
#endif
  AttributeHandle& getAttributeHandle() noexcept
  { return _attributeHandle; }
  const AttributeHandle& getAttributeHandle() const noexcept
  { return _attributeHandle; }

  void setValue(const VariableLengthData& value) noexcept
  { _value = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setValue(VariableLengthData&& value) noexcept
  { _value = std::move(value); }
#endif
  VariableLengthData& getValue() noexcept
  { return _value; }
  const VariableLengthData& getValue() const noexcept
  { return _value; }

  AttributeValue& swap(AttributeValue& rhs)
  {
    std::swap(_attributeHandle, rhs._attributeHandle);
    _value.swap(rhs._value);
    return *this;
  }
  bool operator==(const AttributeValue& rhs) const noexcept
  {
    if (getAttributeHandle() != rhs.getAttributeHandle()) return false;
    if (getValue() != rhs.getValue()) return false;
    return true;
  }
  bool operator<(const AttributeValue& rhs) const noexcept
  {
    if (getAttributeHandle() < rhs.getAttributeHandle()) return true;
    if (rhs.getAttributeHandle() < getAttributeHandle()) return false;
    if (getValue() < rhs.getValue()) return true;
    if (rhs.getValue() < getValue()) return false;
    return false;
  }
  bool operator>(const AttributeValue& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const AttributeValue& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const AttributeValue& rhs) const noexcept
  { return !operator>(rhs); }
private:
  AttributeHandle _attributeHandle;
  VariableLengthData _value;
};

typedef std::vector<AttributeValue> AttributeValueVector;

typedef std::pair<FederateHandle, SaveStatus> FederateHandleSaveStatusPair;

typedef std::vector<FederateHandleSaveStatusPair> FederateHandleSaveStatusPairVector;

typedef std::pair<FederateHandle, RestoreStatus> FederateHandleRestoreStatusPair;

typedef std::vector<FederateHandleRestoreStatusPair> FederateHandleRestoreStatusPairVector;

class OPENRTI_API FederationExecutionInformation {
public:
  FederationExecutionInformation() { }
  FederationExecutionInformation(
    String federationExecutionName,
    String logicalTimeFactoryName)
      : _federationExecutionName(federationExecutionName)
      , _logicalTimeFactoryName(logicalTimeFactoryName)
    { }
  void setFederationExecutionName(const String& value) noexcept
  { _federationExecutionName = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationExecutionName(String&& value) noexcept
  { _federationExecutionName = std::move(value); }
#endif
  String& getFederationExecutionName() noexcept
  { return _federationExecutionName; }
  const String& getFederationExecutionName() const noexcept
  { return _federationExecutionName; }

  void setLogicalTimeFactoryName(const String& value) noexcept
  { _logicalTimeFactoryName = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setLogicalTimeFactoryName(String&& value) noexcept
  { _logicalTimeFactoryName = std::move(value); }
#endif
  String& getLogicalTimeFactoryName() noexcept
  { return _logicalTimeFactoryName; }
  const String& getLogicalTimeFactoryName() const noexcept
  { return _logicalTimeFactoryName; }

  FederationExecutionInformation& swap(FederationExecutionInformation& rhs)
  {
    _federationExecutionName.swap(rhs._federationExecutionName);
    _logicalTimeFactoryName.swap(rhs._logicalTimeFactoryName);
    return *this;
  }
  bool operator==(const FederationExecutionInformation& rhs) const noexcept
  {
    if (getFederationExecutionName() != rhs.getFederationExecutionName()) return false;
    if (getLogicalTimeFactoryName() != rhs.getLogicalTimeFactoryName()) return false;
    return true;
  }
  bool operator<(const FederationExecutionInformation& rhs) const noexcept
  {
    if (getFederationExecutionName() < rhs.getFederationExecutionName()) return true;
    if (rhs.getFederationExecutionName() < getFederationExecutionName()) return false;
    if (getLogicalTimeFactoryName() < rhs.getLogicalTimeFactoryName()) return true;
    if (rhs.getLogicalTimeFactoryName() < getLogicalTimeFactoryName()) return false;
    return false;
  }
  bool operator>(const FederationExecutionInformation& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FederationExecutionInformation& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FederationExecutionInformation& rhs) const noexcept
  { return !operator>(rhs); }
private:
  String _federationExecutionName;
  String _logicalTimeFactoryName;
};

typedef std::vector<FederationExecutionInformation> FederationExecutionInformationVector;

typedef std::pair<ObjectInstanceHandle, String> ObjectInstanceHandleNamePair;

typedef std::vector<ObjectInstanceHandleNamePair> ObjectInstanceHandleNamePairVector;

typedef std::map<String, StringVector> ConfigurationParameterMap;

class OPENRTI_API FOMStringSimpleDataType {
public:
  FOMStringSimpleDataType() : 
    _impl(new Implementation())
  { }
  void setName(const String& value) noexcept
  { getImpl()._name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(String&& value) noexcept
  { getImpl()._name = std::move(value); }
#endif
  String& getName() noexcept
  { return getImpl()._name; }
  const String& getName() const noexcept
  { return getConstImpl()._name; }

  void setRepresentation(const String& value) noexcept
  { getImpl()._representation = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setRepresentation(String&& value) noexcept
  { getImpl()._representation = std::move(value); }
#endif
  String& getRepresentation() noexcept
  { return getImpl()._representation; }
  const String& getRepresentation() const noexcept
  { return getConstImpl()._representation; }

  FOMStringSimpleDataType& swap(FOMStringSimpleDataType& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMStringSimpleDataType& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getName() != rhs.getName()) return false;
    if (getRepresentation() != rhs.getRepresentation()) return false;
    return true;
  }
  bool operator<(const FOMStringSimpleDataType& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getName() < rhs.getName()) return true;
    if (rhs.getName() < getName()) return false;
    if (getRepresentation() < rhs.getRepresentation()) return true;
    if (rhs.getRepresentation() < getRepresentation()) return false;
    return false;
  }
  bool operator>(const FOMStringSimpleDataType& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMStringSimpleDataType& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMStringSimpleDataType& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _name(),
      _representation()
    { }
    String _name;
    String _representation;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMStringSimpleDataType> FOMStringSimpleDataTypeList;

class OPENRTI_API FOMStringEnumerator {
public:
  FOMStringEnumerator() : 
    _impl(new Implementation())
  { }
  void setName(const String& value) noexcept
  { getImpl()._name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(String&& value) noexcept
  { getImpl()._name = std::move(value); }
#endif
  String& getName() noexcept
  { return getImpl()._name; }
  const String& getName() const noexcept
  { return getConstImpl()._name; }

  void setValue(const Unsigned& value) noexcept
  { getImpl()._value = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setValue(Unsigned&& value) noexcept
  { getImpl()._value = std::move(value); }
#endif
  Unsigned& getValue() noexcept
  { return getImpl()._value; }
  const Unsigned& getValue() const noexcept
  { return getConstImpl()._value; }

  FOMStringEnumerator& swap(FOMStringEnumerator& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMStringEnumerator& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getName() != rhs.getName()) return false;
    if (getValue() != rhs.getValue()) return false;
    return true;
  }
  bool operator<(const FOMStringEnumerator& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getName() < rhs.getName()) return true;
    if (rhs.getName() < getName()) return false;
    if (getValue() < rhs.getValue()) return true;
    if (rhs.getValue() < getValue()) return false;
    return false;
  }
  bool operator>(const FOMStringEnumerator& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMStringEnumerator& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMStringEnumerator& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _name(),
      _value()
    { }
    String _name;
    Unsigned _value;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMStringEnumerator> FOMStringEnumeratorList;

class OPENRTI_API FOMStringEnumeratedDataType {
public:
  FOMStringEnumeratedDataType() : 
    _impl(new Implementation())
  { }
  void setName(const String& value) noexcept
  { getImpl()._name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(String&& value) noexcept
  { getImpl()._name = std::move(value); }
#endif
  String& getName() noexcept
  { return getImpl()._name; }
  const String& getName() const noexcept
  { return getConstImpl()._name; }

  void setRepresentation(const String& value) noexcept
  { getImpl()._representation = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setRepresentation(String&& value) noexcept
  { getImpl()._representation = std::move(value); }
#endif
  String& getRepresentation() noexcept
  { return getImpl()._representation; }
  const String& getRepresentation() const noexcept
  { return getConstImpl()._representation; }

  void setEnumerators(const FOMStringEnumeratorList& value) noexcept
  { getImpl()._enumerators = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setEnumerators(FOMStringEnumeratorList&& value) noexcept
  { getImpl()._enumerators = std::move(value); }
#endif
  FOMStringEnumeratorList& getEnumerators() noexcept
  { return getImpl()._enumerators; }
  const FOMStringEnumeratorList& getEnumerators() const noexcept
  { return getConstImpl()._enumerators; }

  FOMStringEnumeratedDataType& swap(FOMStringEnumeratedDataType& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMStringEnumeratedDataType& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getName() != rhs.getName()) return false;
    if (getRepresentation() != rhs.getRepresentation()) return false;
    if (getEnumerators() != rhs.getEnumerators()) return false;
    return true;
  }
  bool operator<(const FOMStringEnumeratedDataType& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getName() < rhs.getName()) return true;
    if (rhs.getName() < getName()) return false;
    if (getRepresentation() < rhs.getRepresentation()) return true;
    if (rhs.getRepresentation() < getRepresentation()) return false;
    if (getEnumerators() < rhs.getEnumerators()) return true;
    if (rhs.getEnumerators() < getEnumerators()) return false;
    return false;
  }
  bool operator>(const FOMStringEnumeratedDataType& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMStringEnumeratedDataType& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMStringEnumeratedDataType& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _name(),
      _representation(),
      _enumerators()
    { }
    String _name;
    String _representation;
    FOMStringEnumeratorList _enumerators;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMStringEnumeratedDataType> FOMStringEnumeratedDataTypeList;

class OPENRTI_API FOMStringArrayDataType {
public:
  FOMStringArrayDataType() : 
    _impl(new Implementation())
  { }
  void setName(const String& value) noexcept
  { getImpl()._name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(String&& value) noexcept
  { getImpl()._name = std::move(value); }
#endif
  String& getName() noexcept
  { return getImpl()._name; }
  const String& getName() const noexcept
  { return getConstImpl()._name; }

  void setDataType(const String& value) noexcept
  { getImpl()._dataType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setDataType(String&& value) noexcept
  { getImpl()._dataType = std::move(value); }
#endif
  String& getDataType() noexcept
  { return getImpl()._dataType; }
  const String& getDataType() const noexcept
  { return getConstImpl()._dataType; }

  void setCardinality(const String& value) noexcept
  { getImpl()._cardinality = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setCardinality(String&& value) noexcept
  { getImpl()._cardinality = std::move(value); }
#endif
  String& getCardinality() noexcept
  { return getImpl()._cardinality; }
  const String& getCardinality() const noexcept
  { return getConstImpl()._cardinality; }

  void setEncoding(const String& value) noexcept
  { getImpl()._encoding = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setEncoding(String&& value) noexcept
  { getImpl()._encoding = std::move(value); }
#endif
  String& getEncoding() noexcept
  { return getImpl()._encoding; }
  const String& getEncoding() const noexcept
  { return getConstImpl()._encoding; }

  FOMStringArrayDataType& swap(FOMStringArrayDataType& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMStringArrayDataType& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getName() != rhs.getName()) return false;
    if (getDataType() != rhs.getDataType()) return false;
    if (getCardinality() != rhs.getCardinality()) return false;
    if (getEncoding() != rhs.getEncoding()) return false;
    return true;
  }
  bool operator<(const FOMStringArrayDataType& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getName() < rhs.getName()) return true;
    if (rhs.getName() < getName()) return false;
    if (getDataType() < rhs.getDataType()) return true;
    if (rhs.getDataType() < getDataType()) return false;
    if (getCardinality() < rhs.getCardinality()) return true;
    if (rhs.getCardinality() < getCardinality()) return false;
    if (getEncoding() < rhs.getEncoding()) return true;
    if (rhs.getEncoding() < getEncoding()) return false;
    return false;
  }
  bool operator>(const FOMStringArrayDataType& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMStringArrayDataType& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMStringArrayDataType& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _name(),
      _dataType(),
      _cardinality(),
      _encoding()
    { }
    String _name;
    String _dataType;
    String _cardinality;
    String _encoding;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMStringArrayDataType> FOMStringArrayDataTypeList;

class OPENRTI_API FOMStringFixedRecordField {
public:
  FOMStringFixedRecordField() : 
    _impl(new Implementation())
  { }
  void setName(const String& value) noexcept
  { getImpl()._name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(String&& value) noexcept
  { getImpl()._name = std::move(value); }
#endif
  String& getName() noexcept
  { return getImpl()._name; }
  const String& getName() const noexcept
  { return getConstImpl()._name; }

  void setDataType(const Unsigned& value) noexcept
  { getImpl()._dataType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setDataType(Unsigned&& value) noexcept
  { getImpl()._dataType = std::move(value); }
#endif
  Unsigned& getDataType() noexcept
  { return getImpl()._dataType; }
  const Unsigned& getDataType() const noexcept
  { return getConstImpl()._dataType; }

  FOMStringFixedRecordField& swap(FOMStringFixedRecordField& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMStringFixedRecordField& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getName() != rhs.getName()) return false;
    if (getDataType() != rhs.getDataType()) return false;
    return true;
  }
  bool operator<(const FOMStringFixedRecordField& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getName() < rhs.getName()) return true;
    if (rhs.getName() < getName()) return false;
    if (getDataType() < rhs.getDataType()) return true;
    if (rhs.getDataType() < getDataType()) return false;
    return false;
  }
  bool operator>(const FOMStringFixedRecordField& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMStringFixedRecordField& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMStringFixedRecordField& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _name(),
      _dataType()
    { }
    String _name;
    Unsigned _dataType;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMStringFixedRecordField> FOMStringFixedRecordFieldList;

class OPENRTI_API FOMStringFixedRecordDataType {
public:
  FOMStringFixedRecordDataType() : 
    _impl(new Implementation())
  { }
  void setName(const String& value) noexcept
  { getImpl()._name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(String&& value) noexcept
  { getImpl()._name = std::move(value); }
#endif
  String& getName() noexcept
  { return getImpl()._name; }
  const String& getName() const noexcept
  { return getConstImpl()._name; }

  void setEncoding(const String& value) noexcept
  { getImpl()._encoding = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setEncoding(String&& value) noexcept
  { getImpl()._encoding = std::move(value); }
#endif
  String& getEncoding() noexcept
  { return getImpl()._encoding; }
  const String& getEncoding() const noexcept
  { return getConstImpl()._encoding; }

  void setFields(const FOMStringFixedRecordFieldList& value) noexcept
  { getImpl()._fields = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFields(FOMStringFixedRecordFieldList&& value) noexcept
  { getImpl()._fields = std::move(value); }
#endif
  FOMStringFixedRecordFieldList& getFields() noexcept
  { return getImpl()._fields; }
  const FOMStringFixedRecordFieldList& getFields() const noexcept
  { return getConstImpl()._fields; }

  FOMStringFixedRecordDataType& swap(FOMStringFixedRecordDataType& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMStringFixedRecordDataType& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getName() != rhs.getName()) return false;
    if (getEncoding() != rhs.getEncoding()) return false;
    if (getFields() != rhs.getFields()) return false;
    return true;
  }
  bool operator<(const FOMStringFixedRecordDataType& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getName() < rhs.getName()) return true;
    if (rhs.getName() < getName()) return false;
    if (getEncoding() < rhs.getEncoding()) return true;
    if (rhs.getEncoding() < getEncoding()) return false;
    if (getFields() < rhs.getFields()) return true;
    if (rhs.getFields() < getFields()) return false;
    return false;
  }
  bool operator>(const FOMStringFixedRecordDataType& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMStringFixedRecordDataType& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMStringFixedRecordDataType& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _name(),
      _encoding(),
      _fields()
    { }
    String _name;
    String _encoding;
    FOMStringFixedRecordFieldList _fields;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMStringFixedRecordDataType> FOMStringFixedRecordDataTypeList;

class OPENRTI_API FOMStringVariantRecordAlternative {
public:
  FOMStringVariantRecordAlternative() : 
    _impl(new Implementation())
  { }
  void setEnumerator(const String& value) noexcept
  { getImpl()._enumerator = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setEnumerator(String&& value) noexcept
  { getImpl()._enumerator = std::move(value); }
#endif
  String& getEnumerator() noexcept
  { return getImpl()._enumerator; }
  const String& getEnumerator() const noexcept
  { return getConstImpl()._enumerator; }

  void setName(const String& value) noexcept
  { getImpl()._name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(String&& value) noexcept
  { getImpl()._name = std::move(value); }
#endif
  String& getName() noexcept
  { return getImpl()._name; }
  const String& getName() const noexcept
  { return getConstImpl()._name; }

  void setDataType(const Unsigned& value) noexcept
  { getImpl()._dataType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setDataType(Unsigned&& value) noexcept
  { getImpl()._dataType = std::move(value); }
#endif
  Unsigned& getDataType() noexcept
  { return getImpl()._dataType; }
  const Unsigned& getDataType() const noexcept
  { return getConstImpl()._dataType; }

  FOMStringVariantRecordAlternative& swap(FOMStringVariantRecordAlternative& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMStringVariantRecordAlternative& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getEnumerator() != rhs.getEnumerator()) return false;
    if (getName() != rhs.getName()) return false;
    if (getDataType() != rhs.getDataType()) return false;
    return true;
  }
  bool operator<(const FOMStringVariantRecordAlternative& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getEnumerator() < rhs.getEnumerator()) return true;
    if (rhs.getEnumerator() < getEnumerator()) return false;
    if (getName() < rhs.getName()) return true;
    if (rhs.getName() < getName()) return false;
    if (getDataType() < rhs.getDataType()) return true;
    if (rhs.getDataType() < getDataType()) return false;
    return false;
  }
  bool operator>(const FOMStringVariantRecordAlternative& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMStringVariantRecordAlternative& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMStringVariantRecordAlternative& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _enumerator(),
      _name(),
      _dataType()
    { }
    String _enumerator;
    String _name;
    Unsigned _dataType;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMStringVariantRecordAlternative> FOMStringVariantRecordAlternativeList;

class OPENRTI_API FOMStringVariantRecordDataType {
public:
  FOMStringVariantRecordDataType() : 
    _impl(new Implementation())
  { }
  void setName(const String& value) noexcept
  { getImpl()._name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(String&& value) noexcept
  { getImpl()._name = std::move(value); }
#endif
  String& getName() noexcept
  { return getImpl()._name; }
  const String& getName() const noexcept
  { return getConstImpl()._name; }

  void setDiscriminant(const String& value) noexcept
  { getImpl()._discriminant = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setDiscriminant(String&& value) noexcept
  { getImpl()._discriminant = std::move(value); }
#endif
  String& getDiscriminant() noexcept
  { return getImpl()._discriminant; }
  const String& getDiscriminant() const noexcept
  { return getConstImpl()._discriminant; }

  void setDataType(const String& value) noexcept
  { getImpl()._dataType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setDataType(String&& value) noexcept
  { getImpl()._dataType = std::move(value); }
#endif
  String& getDataType() noexcept
  { return getImpl()._dataType; }
  const String& getDataType() const noexcept
  { return getConstImpl()._dataType; }

  void setAlternatives(const FOMStringVariantRecordAlternativeList& value) noexcept
  { getImpl()._alternatives = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setAlternatives(FOMStringVariantRecordAlternativeList&& value) noexcept
  { getImpl()._alternatives = std::move(value); }
#endif
  FOMStringVariantRecordAlternativeList& getAlternatives() noexcept
  { return getImpl()._alternatives; }
  const FOMStringVariantRecordAlternativeList& getAlternatives() const noexcept
  { return getConstImpl()._alternatives; }

  void setEncoding(const String& value) noexcept
  { getImpl()._encoding = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setEncoding(String&& value) noexcept
  { getImpl()._encoding = std::move(value); }
#endif
  String& getEncoding() noexcept
  { return getImpl()._encoding; }
  const String& getEncoding() const noexcept
  { return getConstImpl()._encoding; }

  FOMStringVariantRecordDataType& swap(FOMStringVariantRecordDataType& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMStringVariantRecordDataType& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getName() != rhs.getName()) return false;
    if (getDiscriminant() != rhs.getDiscriminant()) return false;
    if (getDataType() != rhs.getDataType()) return false;
    if (getAlternatives() != rhs.getAlternatives()) return false;
    if (getEncoding() != rhs.getEncoding()) return false;
    return true;
  }
  bool operator<(const FOMStringVariantRecordDataType& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getName() < rhs.getName()) return true;
    if (rhs.getName() < getName()) return false;
    if (getDiscriminant() < rhs.getDiscriminant()) return true;
    if (rhs.getDiscriminant() < getDiscriminant()) return false;
    if (getDataType() < rhs.getDataType()) return true;
    if (rhs.getDataType() < getDataType()) return false;
    if (getAlternatives() < rhs.getAlternatives()) return true;
    if (rhs.getAlternatives() < getAlternatives()) return false;
    if (getEncoding() < rhs.getEncoding()) return true;
    if (rhs.getEncoding() < getEncoding()) return false;
    return false;
  }
  bool operator>(const FOMStringVariantRecordDataType& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMStringVariantRecordDataType& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMStringVariantRecordDataType& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _name(),
      _discriminant(),
      _dataType(),
      _alternatives(),
      _encoding()
    { }
    String _name;
    String _discriminant;
    String _dataType;
    FOMStringVariantRecordAlternativeList _alternatives;
    String _encoding;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMStringVariantRecordDataType> FOMStringVariantRecordDataTypeList;

class OPENRTI_API FOMStringTransportationType {
public:
  FOMStringTransportationType() : 
    _impl(new Implementation())
  { }
  void setName(const String& value) noexcept
  { getImpl()._name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(String&& value) noexcept
  { getImpl()._name = std::move(value); }
#endif
  String& getName() noexcept
  { return getImpl()._name; }
  const String& getName() const noexcept
  { return getConstImpl()._name; }

  FOMStringTransportationType& swap(FOMStringTransportationType& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMStringTransportationType& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getName() != rhs.getName()) return false;
    return true;
  }
  bool operator<(const FOMStringTransportationType& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getName() < rhs.getName()) return true;
    if (rhs.getName() < getName()) return false;
    return false;
  }
  bool operator>(const FOMStringTransportationType& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMStringTransportationType& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMStringTransportationType& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _name()
    { }
    String _name;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMStringTransportationType> FOMStringTransportationTypeList;

class OPENRTI_API FOMStringDimension {
public:
  FOMStringDimension() : 
    _impl(new Implementation())
  { }
  void setName(const String& value) noexcept
  { getImpl()._name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(String&& value) noexcept
  { getImpl()._name = std::move(value); }
#endif
  String& getName() noexcept
  { return getImpl()._name; }
  const String& getName() const noexcept
  { return getConstImpl()._name; }

  void setUpperBound(const Unsigned& value) noexcept
  { getImpl()._upperBound = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setUpperBound(Unsigned&& value) noexcept
  { getImpl()._upperBound = std::move(value); }
#endif
  Unsigned& getUpperBound() noexcept
  { return getImpl()._upperBound; }
  const Unsigned& getUpperBound() const noexcept
  { return getConstImpl()._upperBound; }

  FOMStringDimension& swap(FOMStringDimension& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMStringDimension& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getName() != rhs.getName()) return false;
    if (getUpperBound() != rhs.getUpperBound()) return false;
    return true;
  }
  bool operator<(const FOMStringDimension& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getName() < rhs.getName()) return true;
    if (rhs.getName() < getName()) return false;
    if (getUpperBound() < rhs.getUpperBound()) return true;
    if (rhs.getUpperBound() < getUpperBound()) return false;
    return false;
  }
  bool operator>(const FOMStringDimension& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMStringDimension& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMStringDimension& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _name(),
      _upperBound()
    { }
    String _name;
    Unsigned _upperBound;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMStringDimension> FOMStringDimensionList;

class OPENRTI_API FOMStringRoutingSpace {
public:
  FOMStringRoutingSpace() : 
    _impl(new Implementation())
  { }
  void setName(const String& value) noexcept
  { getImpl()._name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(String&& value) noexcept
  { getImpl()._name = std::move(value); }
#endif
  String& getName() noexcept
  { return getImpl()._name; }
  const String& getName() const noexcept
  { return getConstImpl()._name; }

  void setDimensionSet(const StringSet& value) noexcept
  { getImpl()._dimensionSet = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setDimensionSet(StringSet&& value) noexcept
  { getImpl()._dimensionSet = std::move(value); }
#endif
  StringSet& getDimensionSet() noexcept
  { return getImpl()._dimensionSet; }
  const StringSet& getDimensionSet() const noexcept
  { return getConstImpl()._dimensionSet; }

  FOMStringRoutingSpace& swap(FOMStringRoutingSpace& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMStringRoutingSpace& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getName() != rhs.getName()) return false;
    if (getDimensionSet() != rhs.getDimensionSet()) return false;
    return true;
  }
  bool operator<(const FOMStringRoutingSpace& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getName() < rhs.getName()) return true;
    if (rhs.getName() < getName()) return false;
    if (getDimensionSet() < rhs.getDimensionSet()) return true;
    if (rhs.getDimensionSet() < getDimensionSet()) return false;
    return false;
  }
  bool operator>(const FOMStringRoutingSpace& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMStringRoutingSpace& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMStringRoutingSpace& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _name(),
      _dimensionSet()
    { }
    String _name;
    StringSet _dimensionSet;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMStringRoutingSpace> FOMStringRoutingSpaceList;

class OPENRTI_API FOMStringParameter {
public:
  FOMStringParameter() : 
    _impl(new Implementation())
  { }
  void setName(const String& value) noexcept
  { getImpl()._name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(String&& value) noexcept
  { getImpl()._name = std::move(value); }
#endif
  String& getName() noexcept
  { return getImpl()._name; }
  const String& getName() const noexcept
  { return getConstImpl()._name; }

  void setDataType(const String& value) noexcept
  { getImpl()._dataType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setDataType(String&& value) noexcept
  { getImpl()._dataType = std::move(value); }
#endif
  String& getDataType() noexcept
  { return getImpl()._dataType; }
  const String& getDataType() const noexcept
  { return getConstImpl()._dataType; }

  FOMStringParameter& swap(FOMStringParameter& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMStringParameter& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getName() != rhs.getName()) return false;
    if (getDataType() != rhs.getDataType()) return false;
    return true;
  }
  bool operator<(const FOMStringParameter& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getName() < rhs.getName()) return true;
    if (rhs.getName() < getName()) return false;
    if (getDataType() < rhs.getDataType()) return true;
    if (rhs.getDataType() < getDataType()) return false;
    return false;
  }
  bool operator>(const FOMStringParameter& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMStringParameter& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMStringParameter& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _name(),
      _dataType()
    { }
    String _name;
    String _dataType;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMStringParameter> FOMStringParameterList;

class OPENRTI_API FOMStringInteractionClass {
public:
  FOMStringInteractionClass() : 
    _impl(new Implementation())
  { }
  void setName(const StringVector& value) noexcept
  { getImpl()._name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(StringVector&& value) noexcept
  { getImpl()._name = std::move(value); }
#endif
  StringVector& getName() noexcept
  { return getImpl()._name; }
  const StringVector& getName() const noexcept
  { return getConstImpl()._name; }

  void setOrderType(const String& value) noexcept
  { getImpl()._orderType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setOrderType(String&& value) noexcept
  { getImpl()._orderType = std::move(value); }
#endif
  String& getOrderType() noexcept
  { return getImpl()._orderType; }
  const String& getOrderType() const noexcept
  { return getConstImpl()._orderType; }

  void setTransportationType(const String& value) noexcept
  { getImpl()._transportationType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTransportationType(String&& value) noexcept
  { getImpl()._transportationType = std::move(value); }
#endif
  String& getTransportationType() noexcept
  { return getImpl()._transportationType; }
  const String& getTransportationType() const noexcept
  { return getConstImpl()._transportationType; }

  void setRoutingSpace(const String& value) noexcept
  { getImpl()._routingSpace = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setRoutingSpace(String&& value) noexcept
  { getImpl()._routingSpace = std::move(value); }
#endif
  String& getRoutingSpace() noexcept
  { return getImpl()._routingSpace; }
  const String& getRoutingSpace() const noexcept
  { return getConstImpl()._routingSpace; }

  void setDimensionSet(const StringSet& value) noexcept
  { getImpl()._dimensionSet = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setDimensionSet(StringSet&& value) noexcept
  { getImpl()._dimensionSet = std::move(value); }
#endif
  StringSet& getDimensionSet() noexcept
  { return getImpl()._dimensionSet; }
  const StringSet& getDimensionSet() const noexcept
  { return getConstImpl()._dimensionSet; }

  void setParameterList(const FOMStringParameterList& value) noexcept
  { getImpl()._parameterList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setParameterList(FOMStringParameterList&& value) noexcept
  { getImpl()._parameterList = std::move(value); }
#endif
  FOMStringParameterList& getParameterList() noexcept
  { return getImpl()._parameterList; }
  const FOMStringParameterList& getParameterList() const noexcept
  { return getConstImpl()._parameterList; }

  FOMStringInteractionClass& swap(FOMStringInteractionClass& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMStringInteractionClass& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getName() != rhs.getName()) return false;
    if (getOrderType() != rhs.getOrderType()) return false;
    if (getTransportationType() != rhs.getTransportationType()) return false;
    if (getRoutingSpace() != rhs.getRoutingSpace()) return false;
    if (getDimensionSet() != rhs.getDimensionSet()) return false;
    if (getParameterList() != rhs.getParameterList()) return false;
    return true;
  }
  bool operator<(const FOMStringInteractionClass& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getName() < rhs.getName()) return true;
    if (rhs.getName() < getName()) return false;
    if (getOrderType() < rhs.getOrderType()) return true;
    if (rhs.getOrderType() < getOrderType()) return false;
    if (getTransportationType() < rhs.getTransportationType()) return true;
    if (rhs.getTransportationType() < getTransportationType()) return false;
    if (getRoutingSpace() < rhs.getRoutingSpace()) return true;
    if (rhs.getRoutingSpace() < getRoutingSpace()) return false;
    if (getDimensionSet() < rhs.getDimensionSet()) return true;
    if (rhs.getDimensionSet() < getDimensionSet()) return false;
    if (getParameterList() < rhs.getParameterList()) return true;
    if (rhs.getParameterList() < getParameterList()) return false;
    return false;
  }
  bool operator>(const FOMStringInteractionClass& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMStringInteractionClass& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMStringInteractionClass& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _name(),
      _orderType(),
      _transportationType(),
      _routingSpace(),
      _dimensionSet(),
      _parameterList()
    { }
    StringVector _name;
    String _orderType;
    String _transportationType;
    String _routingSpace;
    StringSet _dimensionSet;
    FOMStringParameterList _parameterList;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMStringInteractionClass> FOMStringInteractionClassList;

class OPENRTI_API FOMStringAttribute {
public:
  FOMStringAttribute() : 
    _impl(new Implementation())
  { }
  void setName(const String& value) noexcept
  { getImpl()._name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(String&& value) noexcept
  { getImpl()._name = std::move(value); }
#endif
  String& getName() noexcept
  { return getImpl()._name; }
  const String& getName() const noexcept
  { return getConstImpl()._name; }

  void setDataType(const String& value) noexcept
  { getImpl()._dataType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setDataType(String&& value) noexcept
  { getImpl()._dataType = std::move(value); }
#endif
  String& getDataType() noexcept
  { return getImpl()._dataType; }
  const String& getDataType() const noexcept
  { return getConstImpl()._dataType; }

  void setOrderType(const String& value) noexcept
  { getImpl()._orderType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setOrderType(String&& value) noexcept
  { getImpl()._orderType = std::move(value); }
#endif
  String& getOrderType() noexcept
  { return getImpl()._orderType; }
  const String& getOrderType() const noexcept
  { return getConstImpl()._orderType; }

  void setTransportationType(const String& value) noexcept
  { getImpl()._transportationType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTransportationType(String&& value) noexcept
  { getImpl()._transportationType = std::move(value); }
#endif
  String& getTransportationType() noexcept
  { return getImpl()._transportationType; }
  const String& getTransportationType() const noexcept
  { return getConstImpl()._transportationType; }

  void setRoutingSpace(const String& value) noexcept
  { getImpl()._routingSpace = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setRoutingSpace(String&& value) noexcept
  { getImpl()._routingSpace = std::move(value); }
#endif
  String& getRoutingSpace() noexcept
  { return getImpl()._routingSpace; }
  const String& getRoutingSpace() const noexcept
  { return getConstImpl()._routingSpace; }

  void setDimensionSet(const StringSet& value) noexcept
  { getImpl()._dimensionSet = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setDimensionSet(StringSet&& value) noexcept
  { getImpl()._dimensionSet = std::move(value); }
#endif
  StringSet& getDimensionSet() noexcept
  { return getImpl()._dimensionSet; }
  const StringSet& getDimensionSet() const noexcept
  { return getConstImpl()._dimensionSet; }

  FOMStringAttribute& swap(FOMStringAttribute& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMStringAttribute& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getName() != rhs.getName()) return false;
    if (getDataType() != rhs.getDataType()) return false;
    if (getOrderType() != rhs.getOrderType()) return false;
    if (getTransportationType() != rhs.getTransportationType()) return false;
    if (getRoutingSpace() != rhs.getRoutingSpace()) return false;
    if (getDimensionSet() != rhs.getDimensionSet()) return false;
    return true;
  }
  bool operator<(const FOMStringAttribute& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getName() < rhs.getName()) return true;
    if (rhs.getName() < getName()) return false;
    if (getDataType() < rhs.getDataType()) return true;
    if (rhs.getDataType() < getDataType()) return false;
    if (getOrderType() < rhs.getOrderType()) return true;
    if (rhs.getOrderType() < getOrderType()) return false;
    if (getTransportationType() < rhs.getTransportationType()) return true;
    if (rhs.getTransportationType() < getTransportationType()) return false;
    if (getRoutingSpace() < rhs.getRoutingSpace()) return true;
    if (rhs.getRoutingSpace() < getRoutingSpace()) return false;
    if (getDimensionSet() < rhs.getDimensionSet()) return true;
    if (rhs.getDimensionSet() < getDimensionSet()) return false;
    return false;
  }
  bool operator>(const FOMStringAttribute& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMStringAttribute& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMStringAttribute& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _name(),
      _dataType(),
      _orderType(),
      _transportationType(),
      _routingSpace(),
      _dimensionSet()
    { }
    String _name;
    String _dataType;
    String _orderType;
    String _transportationType;
    String _routingSpace;
    StringSet _dimensionSet;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMStringAttribute> FOMStringAttributeList;

class OPENRTI_API FOMStringObjectClass {
public:
  FOMStringObjectClass() : 
    _impl(new Implementation())
  { }
  void setName(const StringVector& value) noexcept
  { getImpl()._name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(StringVector&& value) noexcept
  { getImpl()._name = std::move(value); }
#endif
  StringVector& getName() noexcept
  { return getImpl()._name; }
  const StringVector& getName() const noexcept
  { return getConstImpl()._name; }

  void setAttributeList(const FOMStringAttributeList& value) noexcept
  { getImpl()._attributeList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setAttributeList(FOMStringAttributeList&& value) noexcept
  { getImpl()._attributeList = std::move(value); }
#endif
  FOMStringAttributeList& getAttributeList() noexcept
  { return getImpl()._attributeList; }
  const FOMStringAttributeList& getAttributeList() const noexcept
  { return getConstImpl()._attributeList; }

  FOMStringObjectClass& swap(FOMStringObjectClass& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMStringObjectClass& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getName() != rhs.getName()) return false;
    if (getAttributeList() != rhs.getAttributeList()) return false;
    return true;
  }
  bool operator<(const FOMStringObjectClass& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getName() < rhs.getName()) return true;
    if (rhs.getName() < getName()) return false;
    if (getAttributeList() < rhs.getAttributeList()) return true;
    if (rhs.getAttributeList() < getAttributeList()) return false;
    return false;
  }
  bool operator>(const FOMStringObjectClass& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMStringObjectClass& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMStringObjectClass& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _name(),
      _attributeList()
    { }
    StringVector _name;
    FOMStringAttributeList _attributeList;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMStringObjectClass> FOMStringObjectClassList;

class OPENRTI_API FOMStringUpdateRate {
public:
  FOMStringUpdateRate() : 
    _impl(new Implementation())
  { }
  void setName(const String& value) noexcept
  { getImpl()._name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(String&& value) noexcept
  { getImpl()._name = std::move(value); }
#endif
  String& getName() noexcept
  { return getImpl()._name; }
  const String& getName() const noexcept
  { return getConstImpl()._name; }

  void setRate(const Double& value) noexcept
  { getImpl()._rate = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setRate(Double&& value) noexcept
  { getImpl()._rate = std::move(value); }
#endif
  Double& getRate() noexcept
  { return getImpl()._rate; }
  const Double& getRate() const noexcept
  { return getConstImpl()._rate; }

  FOMStringUpdateRate& swap(FOMStringUpdateRate& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMStringUpdateRate& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getName() != rhs.getName()) return false;
    if (getRate() != rhs.getRate()) return false;
    return true;
  }
  bool operator<(const FOMStringUpdateRate& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getName() < rhs.getName()) return true;
    if (rhs.getName() < getName()) return false;
    if (getRate() < rhs.getRate()) return true;
    if (rhs.getRate() < getRate()) return false;
    return false;
  }
  bool operator>(const FOMStringUpdateRate& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMStringUpdateRate& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMStringUpdateRate& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _name(),
      _rate()
    { }
    String _name;
    Double _rate;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMStringUpdateRate> FOMStringUpdateRateList;

class OPENRTI_API FOMStringSwitch {
public:
  FOMStringSwitch() : 
    _impl(new Implementation())
  { }
  void setSwitchesType(const SwitchesType& value) noexcept
  { getImpl()._switchesType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setSwitchesType(SwitchesType&& value) noexcept
  { getImpl()._switchesType = std::move(value); }
#endif
  SwitchesType& getSwitchesType() noexcept
  { return getImpl()._switchesType; }
  const SwitchesType& getSwitchesType() const noexcept
  { return getConstImpl()._switchesType; }

  void setEnabled(const Bool& value) noexcept
  { getImpl()._enabled = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setEnabled(Bool&& value) noexcept
  { getImpl()._enabled = std::move(value); }
#endif
  Bool& getEnabled() noexcept
  { return getImpl()._enabled; }
  const Bool& getEnabled() const noexcept
  { return getConstImpl()._enabled; }

  FOMStringSwitch& swap(FOMStringSwitch& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMStringSwitch& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getSwitchesType() != rhs.getSwitchesType()) return false;
    if (getEnabled() != rhs.getEnabled()) return false;
    return true;
  }
  bool operator<(const FOMStringSwitch& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getSwitchesType() < rhs.getSwitchesType()) return true;
    if (rhs.getSwitchesType() < getSwitchesType()) return false;
    if (getEnabled() < rhs.getEnabled()) return true;
    if (rhs.getEnabled() < getEnabled()) return false;
    return false;
  }
  bool operator>(const FOMStringSwitch& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMStringSwitch& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMStringSwitch& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _switchesType(),
      _enabled()
    { }
    SwitchesType _switchesType;
    Bool _enabled;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMStringSwitch> FOMStringSwitchList;

class OPENRTI_API FOMStringModule {
public:
  FOMStringModule() : 
    _impl(new Implementation())
  { }
  void setDesignator(const String& value) noexcept
  { getImpl()._designator = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setDesignator(String&& value) noexcept
  { getImpl()._designator = std::move(value); }
#endif
  String& getDesignator() noexcept
  { return getImpl()._designator; }
  const String& getDesignator() const noexcept
  { return getConstImpl()._designator; }

  void setTransportationTypeList(const FOMStringTransportationTypeList& value) noexcept
  { getImpl()._transportationTypeList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTransportationTypeList(FOMStringTransportationTypeList&& value) noexcept
  { getImpl()._transportationTypeList = std::move(value); }
#endif
  FOMStringTransportationTypeList& getTransportationTypeList() noexcept
  { return getImpl()._transportationTypeList; }
  const FOMStringTransportationTypeList& getTransportationTypeList() const noexcept
  { return getConstImpl()._transportationTypeList; }

  void setDimensionList(const FOMStringDimensionList& value) noexcept
  { getImpl()._dimensionList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setDimensionList(FOMStringDimensionList&& value) noexcept
  { getImpl()._dimensionList = std::move(value); }
#endif
  FOMStringDimensionList& getDimensionList() noexcept
  { return getImpl()._dimensionList; }
  const FOMStringDimensionList& getDimensionList() const noexcept
  { return getConstImpl()._dimensionList; }

  void setRoutingSpaceList(const FOMStringRoutingSpaceList& value) noexcept
  { getImpl()._routingSpaceList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setRoutingSpaceList(FOMStringRoutingSpaceList&& value) noexcept
  { getImpl()._routingSpaceList = std::move(value); }
#endif
  FOMStringRoutingSpaceList& getRoutingSpaceList() noexcept
  { return getImpl()._routingSpaceList; }
  const FOMStringRoutingSpaceList& getRoutingSpaceList() const noexcept
  { return getConstImpl()._routingSpaceList; }

  void setInteractionClassList(const FOMStringInteractionClassList& value) noexcept
  { getImpl()._interactionClassList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setInteractionClassList(FOMStringInteractionClassList&& value) noexcept
  { getImpl()._interactionClassList = std::move(value); }
#endif
  FOMStringInteractionClassList& getInteractionClassList() noexcept
  { return getImpl()._interactionClassList; }
  const FOMStringInteractionClassList& getInteractionClassList() const noexcept
  { return getConstImpl()._interactionClassList; }

  void setObjectClassList(const FOMStringObjectClassList& value) noexcept
  { getImpl()._objectClassList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setObjectClassList(FOMStringObjectClassList&& value) noexcept
  { getImpl()._objectClassList = std::move(value); }
#endif
  FOMStringObjectClassList& getObjectClassList() noexcept
  { return getImpl()._objectClassList; }
  const FOMStringObjectClassList& getObjectClassList() const noexcept
  { return getConstImpl()._objectClassList; }

  void setUpdateRateList(const FOMStringUpdateRateList& value) noexcept
  { getImpl()._updateRateList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setUpdateRateList(FOMStringUpdateRateList&& value) noexcept
  { getImpl()._updateRateList = std::move(value); }
#endif
  FOMStringUpdateRateList& getUpdateRateList() noexcept
  { return getImpl()._updateRateList; }
  const FOMStringUpdateRateList& getUpdateRateList() const noexcept
  { return getConstImpl()._updateRateList; }

  void setSwitchList(const FOMStringSwitchList& value) noexcept
  { getImpl()._switchList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setSwitchList(FOMStringSwitchList&& value) noexcept
  { getImpl()._switchList = std::move(value); }
#endif
  FOMStringSwitchList& getSwitchList() noexcept
  { return getImpl()._switchList; }
  const FOMStringSwitchList& getSwitchList() const noexcept
  { return getConstImpl()._switchList; }

  void setSimpleDataTypeList(const FOMStringSimpleDataTypeList& value) noexcept
  { getImpl()._simpleDataTypeList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setSimpleDataTypeList(FOMStringSimpleDataTypeList&& value) noexcept
  { getImpl()._simpleDataTypeList = std::move(value); }
#endif
  FOMStringSimpleDataTypeList& getSimpleDataTypeList() noexcept
  { return getImpl()._simpleDataTypeList; }
  const FOMStringSimpleDataTypeList& getSimpleDataTypeList() const noexcept
  { return getConstImpl()._simpleDataTypeList; }

  void setEnumeratedDataTypeList(const FOMStringEnumeratedDataTypeList& value) noexcept
  { getImpl()._enumeratedDataTypeList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setEnumeratedDataTypeList(FOMStringEnumeratedDataTypeList&& value) noexcept
  { getImpl()._enumeratedDataTypeList = std::move(value); }
#endif
  FOMStringEnumeratedDataTypeList& getEnumeratedDataTypeList() noexcept
  { return getImpl()._enumeratedDataTypeList; }
  const FOMStringEnumeratedDataTypeList& getEnumeratedDataTypeList() const noexcept
  { return getConstImpl()._enumeratedDataTypeList; }

  void setArrayDataTypeList(const FOMStringArrayDataTypeList& value) noexcept
  { getImpl()._arrayDataTypeList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setArrayDataTypeList(FOMStringArrayDataTypeList&& value) noexcept
  { getImpl()._arrayDataTypeList = std::move(value); }
#endif
  FOMStringArrayDataTypeList& getArrayDataTypeList() noexcept
  { return getImpl()._arrayDataTypeList; }
  const FOMStringArrayDataTypeList& getArrayDataTypeList() const noexcept
  { return getConstImpl()._arrayDataTypeList; }

  void setFixedRecordDataTypeList(const FOMStringFixedRecordDataTypeList& value) noexcept
  { getImpl()._fixedRecordDataTypeList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFixedRecordDataTypeList(FOMStringFixedRecordDataTypeList&& value) noexcept
  { getImpl()._fixedRecordDataTypeList = std::move(value); }
#endif
  FOMStringFixedRecordDataTypeList& getFixedRecordDataTypeList() noexcept
  { return getImpl()._fixedRecordDataTypeList; }
  const FOMStringFixedRecordDataTypeList& getFixedRecordDataTypeList() const noexcept
  { return getConstImpl()._fixedRecordDataTypeList; }

  void setVariantRecordDataTypeList(const FOMStringVariantRecordDataTypeList& value) noexcept
  { getImpl()._variantRecordDataTypeList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setVariantRecordDataTypeList(FOMStringVariantRecordDataTypeList&& value) noexcept
  { getImpl()._variantRecordDataTypeList = std::move(value); }
#endif
  FOMStringVariantRecordDataTypeList& getVariantRecordDataTypeList() noexcept
  { return getImpl()._variantRecordDataTypeList; }
  const FOMStringVariantRecordDataTypeList& getVariantRecordDataTypeList() const noexcept
  { return getConstImpl()._variantRecordDataTypeList; }

  void setArtificialInteractionRoot(const Bool& value) noexcept
  { getImpl()._artificialInteractionRoot = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setArtificialInteractionRoot(Bool&& value) noexcept
  { getImpl()._artificialInteractionRoot = std::move(value); }
#endif
  Bool& getArtificialInteractionRoot() noexcept
  { return getImpl()._artificialInteractionRoot; }
  const Bool& getArtificialInteractionRoot() const noexcept
  { return getConstImpl()._artificialInteractionRoot; }

  void setArtificialObjectRoot(const Bool& value) noexcept
  { getImpl()._artificialObjectRoot = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setArtificialObjectRoot(Bool&& value) noexcept
  { getImpl()._artificialObjectRoot = std::move(value); }
#endif
  Bool& getArtificialObjectRoot() noexcept
  { return getImpl()._artificialObjectRoot; }
  const Bool& getArtificialObjectRoot() const noexcept
  { return getConstImpl()._artificialObjectRoot; }

  FOMStringModule& swap(FOMStringModule& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMStringModule& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getDesignator() != rhs.getDesignator()) return false;
    if (getTransportationTypeList() != rhs.getTransportationTypeList()) return false;
    if (getDimensionList() != rhs.getDimensionList()) return false;
    if (getRoutingSpaceList() != rhs.getRoutingSpaceList()) return false;
    if (getInteractionClassList() != rhs.getInteractionClassList()) return false;
    if (getObjectClassList() != rhs.getObjectClassList()) return false;
    if (getUpdateRateList() != rhs.getUpdateRateList()) return false;
    if (getSwitchList() != rhs.getSwitchList()) return false;
    if (getSimpleDataTypeList() != rhs.getSimpleDataTypeList()) return false;
    if (getEnumeratedDataTypeList() != rhs.getEnumeratedDataTypeList()) return false;
    if (getArrayDataTypeList() != rhs.getArrayDataTypeList()) return false;
    if (getFixedRecordDataTypeList() != rhs.getFixedRecordDataTypeList()) return false;
    if (getVariantRecordDataTypeList() != rhs.getVariantRecordDataTypeList()) return false;
    if (getArtificialInteractionRoot() != rhs.getArtificialInteractionRoot()) return false;
    if (getArtificialObjectRoot() != rhs.getArtificialObjectRoot()) return false;
    return true;
  }
  bool operator<(const FOMStringModule& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getDesignator() < rhs.getDesignator()) return true;
    if (rhs.getDesignator() < getDesignator()) return false;
    if (getTransportationTypeList() < rhs.getTransportationTypeList()) return true;
    if (rhs.getTransportationTypeList() < getTransportationTypeList()) return false;
    if (getDimensionList() < rhs.getDimensionList()) return true;
    if (rhs.getDimensionList() < getDimensionList()) return false;
    if (getRoutingSpaceList() < rhs.getRoutingSpaceList()) return true;
    if (rhs.getRoutingSpaceList() < getRoutingSpaceList()) return false;
    if (getInteractionClassList() < rhs.getInteractionClassList()) return true;
    if (rhs.getInteractionClassList() < getInteractionClassList()) return false;
    if (getObjectClassList() < rhs.getObjectClassList()) return true;
    if (rhs.getObjectClassList() < getObjectClassList()) return false;
    if (getUpdateRateList() < rhs.getUpdateRateList()) return true;
    if (rhs.getUpdateRateList() < getUpdateRateList()) return false;
    if (getSwitchList() < rhs.getSwitchList()) return true;
    if (rhs.getSwitchList() < getSwitchList()) return false;
    if (getSimpleDataTypeList() < rhs.getSimpleDataTypeList()) return true;
    if (rhs.getSimpleDataTypeList() < getSimpleDataTypeList()) return false;
    if (getEnumeratedDataTypeList() < rhs.getEnumeratedDataTypeList()) return true;
    if (rhs.getEnumeratedDataTypeList() < getEnumeratedDataTypeList()) return false;
    if (getArrayDataTypeList() < rhs.getArrayDataTypeList()) return true;
    if (rhs.getArrayDataTypeList() < getArrayDataTypeList()) return false;
    if (getFixedRecordDataTypeList() < rhs.getFixedRecordDataTypeList()) return true;
    if (rhs.getFixedRecordDataTypeList() < getFixedRecordDataTypeList()) return false;
    if (getVariantRecordDataTypeList() < rhs.getVariantRecordDataTypeList()) return true;
    if (rhs.getVariantRecordDataTypeList() < getVariantRecordDataTypeList()) return false;
    if (getArtificialInteractionRoot() < rhs.getArtificialInteractionRoot()) return true;
    if (rhs.getArtificialInteractionRoot() < getArtificialInteractionRoot()) return false;
    if (getArtificialObjectRoot() < rhs.getArtificialObjectRoot()) return true;
    if (rhs.getArtificialObjectRoot() < getArtificialObjectRoot()) return false;
    return false;
  }
  bool operator>(const FOMStringModule& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMStringModule& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMStringModule& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _designator(),
      _transportationTypeList(),
      _dimensionList(),
      _routingSpaceList(),
      _interactionClassList(),
      _objectClassList(),
      _updateRateList(),
      _switchList(),
      _simpleDataTypeList(),
      _enumeratedDataTypeList(),
      _arrayDataTypeList(),
      _fixedRecordDataTypeList(),
      _variantRecordDataTypeList(),
      _artificialInteractionRoot(),
      _artificialObjectRoot()
    { }
    String _designator;
    FOMStringTransportationTypeList _transportationTypeList;
    FOMStringDimensionList _dimensionList;
    FOMStringRoutingSpaceList _routingSpaceList;
    FOMStringInteractionClassList _interactionClassList;
    FOMStringObjectClassList _objectClassList;
    FOMStringUpdateRateList _updateRateList;
    FOMStringSwitchList _switchList;
    FOMStringSimpleDataTypeList _simpleDataTypeList;
    FOMStringEnumeratedDataTypeList _enumeratedDataTypeList;
    FOMStringArrayDataTypeList _arrayDataTypeList;
    FOMStringFixedRecordDataTypeList _fixedRecordDataTypeList;
    FOMStringVariantRecordDataTypeList _variantRecordDataTypeList;
    Bool _artificialInteractionRoot;
    Bool _artificialObjectRoot;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMStringModule> FOMStringModuleList;

class OPENRTI_API FOMTransportationType {
public:
  FOMTransportationType() : 
    _impl(new Implementation())
  { }
  void setName(const String& value) noexcept
  { getImpl()._name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(String&& value) noexcept
  { getImpl()._name = std::move(value); }
#endif
  String& getName() noexcept
  { return getImpl()._name; }
  const String& getName() const noexcept
  { return getConstImpl()._name; }

  void setTransportationType(const TransportationType& value) noexcept
  { getImpl()._transportationType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTransportationType(TransportationType&& value) noexcept
  { getImpl()._transportationType = std::move(value); }
#endif
  TransportationType& getTransportationType() noexcept
  { return getImpl()._transportationType; }
  const TransportationType& getTransportationType() const noexcept
  { return getConstImpl()._transportationType; }

  FOMTransportationType& swap(FOMTransportationType& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMTransportationType& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getName() != rhs.getName()) return false;
    if (getTransportationType() != rhs.getTransportationType()) return false;
    return true;
  }
  bool operator<(const FOMTransportationType& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getName() < rhs.getName()) return true;
    if (rhs.getName() < getName()) return false;
    if (getTransportationType() < rhs.getTransportationType()) return true;
    if (rhs.getTransportationType() < getTransportationType()) return false;
    return false;
  }
  bool operator>(const FOMTransportationType& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMTransportationType& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMTransportationType& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _name(),
      _transportationType()
    { }
    String _name;
    TransportationType _transportationType;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMTransportationType> FOMTransportationTypeList;

class OPENRTI_API FOMDimension {
public:
  FOMDimension() : 
    _impl(new Implementation())
  { }
  void setName(const String& value) noexcept
  { getImpl()._name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(String&& value) noexcept
  { getImpl()._name = std::move(value); }
#endif
  String& getName() noexcept
  { return getImpl()._name; }
  const String& getName() const noexcept
  { return getConstImpl()._name; }

  void setDimensionHandle(const DimensionHandle& value) noexcept
  { getImpl()._dimensionHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setDimensionHandle(DimensionHandle&& value) noexcept
  { getImpl()._dimensionHandle = std::move(value); }
#endif
  DimensionHandle& getDimensionHandle() noexcept
  { return getImpl()._dimensionHandle; }
  const DimensionHandle& getDimensionHandle() const noexcept
  { return getConstImpl()._dimensionHandle; }

  void setUpperBound(const Unsigned& value) noexcept
  { getImpl()._upperBound = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setUpperBound(Unsigned&& value) noexcept
  { getImpl()._upperBound = std::move(value); }
#endif
  Unsigned& getUpperBound() noexcept
  { return getImpl()._upperBound; }
  const Unsigned& getUpperBound() const noexcept
  { return getConstImpl()._upperBound; }

  FOMDimension& swap(FOMDimension& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMDimension& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getName() != rhs.getName()) return false;
    if (getDimensionHandle() != rhs.getDimensionHandle()) return false;
    if (getUpperBound() != rhs.getUpperBound()) return false;
    return true;
  }
  bool operator<(const FOMDimension& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getName() < rhs.getName()) return true;
    if (rhs.getName() < getName()) return false;
    if (getDimensionHandle() < rhs.getDimensionHandle()) return true;
    if (rhs.getDimensionHandle() < getDimensionHandle()) return false;
    if (getUpperBound() < rhs.getUpperBound()) return true;
    if (rhs.getUpperBound() < getUpperBound()) return false;
    return false;
  }
  bool operator>(const FOMDimension& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMDimension& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMDimension& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _name(),
      _dimensionHandle(),
      _upperBound()
    { }
    String _name;
    DimensionHandle _dimensionHandle;
    Unsigned _upperBound;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMDimension> FOMDimensionList;

class OPENRTI_API FOMRoutingSpace {
public:
  FOMRoutingSpace() : 
    _impl(new Implementation())
  { }
  void setName(const String& value) noexcept
  { getImpl()._name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(String&& value) noexcept
  { getImpl()._name = std::move(value); }
#endif
  String& getName() noexcept
  { return getImpl()._name; }
  const String& getName() const noexcept
  { return getConstImpl()._name; }

  void setSpaceHandle(const SpaceHandle& value) noexcept
  { getImpl()._spaceHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setSpaceHandle(SpaceHandle&& value) noexcept
  { getImpl()._spaceHandle = std::move(value); }
#endif
  SpaceHandle& getSpaceHandle() noexcept
  { return getImpl()._spaceHandle; }
  const SpaceHandle& getSpaceHandle() const noexcept
  { return getConstImpl()._spaceHandle; }

  void setDimensionHandleSet(const DimensionHandleSet& value) noexcept
  { getImpl()._dimensionHandleSet = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setDimensionHandleSet(DimensionHandleSet&& value) noexcept
  { getImpl()._dimensionHandleSet = std::move(value); }
#endif
  DimensionHandleSet& getDimensionHandleSet() noexcept
  { return getImpl()._dimensionHandleSet; }
  const DimensionHandleSet& getDimensionHandleSet() const noexcept
  { return getConstImpl()._dimensionHandleSet; }

  FOMRoutingSpace& swap(FOMRoutingSpace& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMRoutingSpace& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getName() != rhs.getName()) return false;
    if (getSpaceHandle() != rhs.getSpaceHandle()) return false;
    if (getDimensionHandleSet() != rhs.getDimensionHandleSet()) return false;
    return true;
  }
  bool operator<(const FOMRoutingSpace& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getName() < rhs.getName()) return true;
    if (rhs.getName() < getName()) return false;
    if (getSpaceHandle() < rhs.getSpaceHandle()) return true;
    if (rhs.getSpaceHandle() < getSpaceHandle()) return false;
    if (getDimensionHandleSet() < rhs.getDimensionHandleSet()) return true;
    if (rhs.getDimensionHandleSet() < getDimensionHandleSet()) return false;
    return false;
  }
  bool operator>(const FOMRoutingSpace& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMRoutingSpace& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMRoutingSpace& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _name(),
      _spaceHandle(),
      _dimensionHandleSet()
    { }
    String _name;
    SpaceHandle _spaceHandle;
    DimensionHandleSet _dimensionHandleSet;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMRoutingSpace> FOMRoutingSpaceList;

class OPENRTI_API FOMParameter {
public:
  FOMParameter() : 
    _impl(new Implementation())
  { }
  void setName(const String& value) noexcept
  { getImpl()._name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(String&& value) noexcept
  { getImpl()._name = std::move(value); }
#endif
  String& getName() noexcept
  { return getImpl()._name; }
  const String& getName() const noexcept
  { return getConstImpl()._name; }

  void setDataType(const String& value) noexcept
  { getImpl()._dataType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setDataType(String&& value) noexcept
  { getImpl()._dataType = std::move(value); }
#endif
  String& getDataType() noexcept
  { return getImpl()._dataType; }
  const String& getDataType() const noexcept
  { return getConstImpl()._dataType; }

  void setParameterHandle(const ParameterHandle& value) noexcept
  { getImpl()._parameterHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setParameterHandle(ParameterHandle&& value) noexcept
  { getImpl()._parameterHandle = std::move(value); }
#endif
  ParameterHandle& getParameterHandle() noexcept
  { return getImpl()._parameterHandle; }
  const ParameterHandle& getParameterHandle() const noexcept
  { return getConstImpl()._parameterHandle; }

  FOMParameter& swap(FOMParameter& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMParameter& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getName() != rhs.getName()) return false;
    if (getDataType() != rhs.getDataType()) return false;
    if (getParameterHandle() != rhs.getParameterHandle()) return false;
    return true;
  }
  bool operator<(const FOMParameter& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getName() < rhs.getName()) return true;
    if (rhs.getName() < getName()) return false;
    if (getDataType() < rhs.getDataType()) return true;
    if (rhs.getDataType() < getDataType()) return false;
    if (getParameterHandle() < rhs.getParameterHandle()) return true;
    if (rhs.getParameterHandle() < getParameterHandle()) return false;
    return false;
  }
  bool operator>(const FOMParameter& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMParameter& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMParameter& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _name(),
      _dataType(),
      _parameterHandle()
    { }
    String _name;
    String _dataType;
    ParameterHandle _parameterHandle;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMParameter> FOMParameterList;

class OPENRTI_API FOMInteractionClass {
public:
  FOMInteractionClass() : 
    _impl(new Implementation())
  { }
  void setName(const String& value) noexcept
  { getImpl()._name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(String&& value) noexcept
  { getImpl()._name = std::move(value); }
#endif
  String& getName() noexcept
  { return getImpl()._name; }
  const String& getName() const noexcept
  { return getConstImpl()._name; }

  void setInteractionClassHandle(const InteractionClassHandle& value) noexcept
  { getImpl()._interactionClassHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setInteractionClassHandle(InteractionClassHandle&& value) noexcept
  { getImpl()._interactionClassHandle = std::move(value); }
#endif
  InteractionClassHandle& getInteractionClassHandle() noexcept
  { return getImpl()._interactionClassHandle; }
  const InteractionClassHandle& getInteractionClassHandle() const noexcept
  { return getConstImpl()._interactionClassHandle; }

  void setParentInteractionClassHandle(const InteractionClassHandle& value) noexcept
  { getImpl()._parentInteractionClassHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setParentInteractionClassHandle(InteractionClassHandle&& value) noexcept
  { getImpl()._parentInteractionClassHandle = std::move(value); }
#endif
  InteractionClassHandle& getParentInteractionClassHandle() noexcept
  { return getImpl()._parentInteractionClassHandle; }
  const InteractionClassHandle& getParentInteractionClassHandle() const noexcept
  { return getConstImpl()._parentInteractionClassHandle; }

  void setOrderType(const OrderType& value) noexcept
  { getImpl()._orderType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setOrderType(OrderType&& value) noexcept
  { getImpl()._orderType = std::move(value); }
#endif
  OrderType& getOrderType() noexcept
  { return getImpl()._orderType; }
  const OrderType& getOrderType() const noexcept
  { return getConstImpl()._orderType; }

  void setTransportationType(const TransportationType& value) noexcept
  { getImpl()._transportationType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTransportationType(TransportationType&& value) noexcept
  { getImpl()._transportationType = std::move(value); }
#endif
  TransportationType& getTransportationType() noexcept
  { return getImpl()._transportationType; }
  const TransportationType& getTransportationType() const noexcept
  { return getConstImpl()._transportationType; }

  void setDimensionHandleSet(const DimensionHandleSet& value) noexcept
  { getImpl()._dimensionHandleSet = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setDimensionHandleSet(DimensionHandleSet&& value) noexcept
  { getImpl()._dimensionHandleSet = std::move(value); }
#endif
  DimensionHandleSet& getDimensionHandleSet() noexcept
  { return getImpl()._dimensionHandleSet; }
  const DimensionHandleSet& getDimensionHandleSet() const noexcept
  { return getConstImpl()._dimensionHandleSet; }

  void setParameterList(const FOMParameterList& value) noexcept
  { getImpl()._parameterList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setParameterList(FOMParameterList&& value) noexcept
  { getImpl()._parameterList = std::move(value); }
#endif
  FOMParameterList& getParameterList() noexcept
  { return getImpl()._parameterList; }
  const FOMParameterList& getParameterList() const noexcept
  { return getConstImpl()._parameterList; }

  FOMInteractionClass& swap(FOMInteractionClass& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMInteractionClass& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getName() != rhs.getName()) return false;
    if (getInteractionClassHandle() != rhs.getInteractionClassHandle()) return false;
    if (getParentInteractionClassHandle() != rhs.getParentInteractionClassHandle()) return false;
    if (getOrderType() != rhs.getOrderType()) return false;
    if (getTransportationType() != rhs.getTransportationType()) return false;
    if (getDimensionHandleSet() != rhs.getDimensionHandleSet()) return false;
    if (getParameterList() != rhs.getParameterList()) return false;
    return true;
  }
  bool operator<(const FOMInteractionClass& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getName() < rhs.getName()) return true;
    if (rhs.getName() < getName()) return false;
    if (getInteractionClassHandle() < rhs.getInteractionClassHandle()) return true;
    if (rhs.getInteractionClassHandle() < getInteractionClassHandle()) return false;
    if (getParentInteractionClassHandle() < rhs.getParentInteractionClassHandle()) return true;
    if (rhs.getParentInteractionClassHandle() < getParentInteractionClassHandle()) return false;
    if (getOrderType() < rhs.getOrderType()) return true;
    if (rhs.getOrderType() < getOrderType()) return false;
    if (getTransportationType() < rhs.getTransportationType()) return true;
    if (rhs.getTransportationType() < getTransportationType()) return false;
    if (getDimensionHandleSet() < rhs.getDimensionHandleSet()) return true;
    if (rhs.getDimensionHandleSet() < getDimensionHandleSet()) return false;
    if (getParameterList() < rhs.getParameterList()) return true;
    if (rhs.getParameterList() < getParameterList()) return false;
    return false;
  }
  bool operator>(const FOMInteractionClass& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMInteractionClass& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMInteractionClass& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _name(),
      _interactionClassHandle(),
      _parentInteractionClassHandle(),
      _orderType(),
      _transportationType(),
      _dimensionHandleSet(),
      _parameterList()
    { }
    String _name;
    InteractionClassHandle _interactionClassHandle;
    InteractionClassHandle _parentInteractionClassHandle;
    OrderType _orderType;
    TransportationType _transportationType;
    DimensionHandleSet _dimensionHandleSet;
    FOMParameterList _parameterList;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMInteractionClass> FOMInteractionClassList;

class OPENRTI_API FOMAttribute {
public:
  FOMAttribute() : 
    _impl(new Implementation())
  { }
  void setName(const String& value) noexcept
  { getImpl()._name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(String&& value) noexcept
  { getImpl()._name = std::move(value); }
#endif
  String& getName() noexcept
  { return getImpl()._name; }
  const String& getName() const noexcept
  { return getConstImpl()._name; }

  void setDataType(const String& value) noexcept
  { getImpl()._dataType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setDataType(String&& value) noexcept
  { getImpl()._dataType = std::move(value); }
#endif
  String& getDataType() noexcept
  { return getImpl()._dataType; }
  const String& getDataType() const noexcept
  { return getConstImpl()._dataType; }

  void setAttributeHandle(const AttributeHandle& value) noexcept
  { getImpl()._attributeHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setAttributeHandle(AttributeHandle&& value) noexcept
  { getImpl()._attributeHandle = std::move(value); }
#endif
  AttributeHandle& getAttributeHandle() noexcept
  { return getImpl()._attributeHandle; }
  const AttributeHandle& getAttributeHandle() const noexcept
  { return getConstImpl()._attributeHandle; }

  void setOrderType(const OrderType& value) noexcept
  { getImpl()._orderType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setOrderType(OrderType&& value) noexcept
  { getImpl()._orderType = std::move(value); }
#endif
  OrderType& getOrderType() noexcept
  { return getImpl()._orderType; }
  const OrderType& getOrderType() const noexcept
  { return getConstImpl()._orderType; }

  void setTransportationType(const TransportationType& value) noexcept
  { getImpl()._transportationType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTransportationType(TransportationType&& value) noexcept
  { getImpl()._transportationType = std::move(value); }
#endif
  TransportationType& getTransportationType() noexcept
  { return getImpl()._transportationType; }
  const TransportationType& getTransportationType() const noexcept
  { return getConstImpl()._transportationType; }

  void setDimensionHandleSet(const DimensionHandleSet& value) noexcept
  { getImpl()._dimensionHandleSet = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setDimensionHandleSet(DimensionHandleSet&& value) noexcept
  { getImpl()._dimensionHandleSet = std::move(value); }
#endif
  DimensionHandleSet& getDimensionHandleSet() noexcept
  { return getImpl()._dimensionHandleSet; }
  const DimensionHandleSet& getDimensionHandleSet() const noexcept
  { return getConstImpl()._dimensionHandleSet; }

  FOMAttribute& swap(FOMAttribute& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMAttribute& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getName() != rhs.getName()) return false;
    if (getDataType() != rhs.getDataType()) return false;
    if (getAttributeHandle() != rhs.getAttributeHandle()) return false;
    if (getOrderType() != rhs.getOrderType()) return false;
    if (getTransportationType() != rhs.getTransportationType()) return false;
    if (getDimensionHandleSet() != rhs.getDimensionHandleSet()) return false;
    return true;
  }
  bool operator<(const FOMAttribute& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getName() < rhs.getName()) return true;
    if (rhs.getName() < getName()) return false;
    if (getDataType() < rhs.getDataType()) return true;
    if (rhs.getDataType() < getDataType()) return false;
    if (getAttributeHandle() < rhs.getAttributeHandle()) return true;
    if (rhs.getAttributeHandle() < getAttributeHandle()) return false;
    if (getOrderType() < rhs.getOrderType()) return true;
    if (rhs.getOrderType() < getOrderType()) return false;
    if (getTransportationType() < rhs.getTransportationType()) return true;
    if (rhs.getTransportationType() < getTransportationType()) return false;
    if (getDimensionHandleSet() < rhs.getDimensionHandleSet()) return true;
    if (rhs.getDimensionHandleSet() < getDimensionHandleSet()) return false;
    return false;
  }
  bool operator>(const FOMAttribute& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMAttribute& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMAttribute& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _name(),
      _dataType(),
      _attributeHandle(),
      _orderType(),
      _transportationType(),
      _dimensionHandleSet()
    { }
    String _name;
    String _dataType;
    AttributeHandle _attributeHandle;
    OrderType _orderType;
    TransportationType _transportationType;
    DimensionHandleSet _dimensionHandleSet;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMAttribute> FOMAttributeList;

class OPENRTI_API FOMObjectClass {
public:
  FOMObjectClass() : 
    _impl(new Implementation())
  { }
  void setName(const String& value) noexcept
  { getImpl()._name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(String&& value) noexcept
  { getImpl()._name = std::move(value); }
#endif
  String& getName() noexcept
  { return getImpl()._name; }
  const String& getName() const noexcept
  { return getConstImpl()._name; }

  void setObjectClassHandle(const ObjectClassHandle& value) noexcept
  { getImpl()._objectClassHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setObjectClassHandle(ObjectClassHandle&& value) noexcept
  { getImpl()._objectClassHandle = std::move(value); }
#endif
  ObjectClassHandle& getObjectClassHandle() noexcept
  { return getImpl()._objectClassHandle; }
  const ObjectClassHandle& getObjectClassHandle() const noexcept
  { return getConstImpl()._objectClassHandle; }

  void setParentObjectClassHandle(const ObjectClassHandle& value) noexcept
  { getImpl()._parentObjectClassHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setParentObjectClassHandle(ObjectClassHandle&& value) noexcept
  { getImpl()._parentObjectClassHandle = std::move(value); }
#endif
  ObjectClassHandle& getParentObjectClassHandle() noexcept
  { return getImpl()._parentObjectClassHandle; }
  const ObjectClassHandle& getParentObjectClassHandle() const noexcept
  { return getConstImpl()._parentObjectClassHandle; }

  void setAttributeList(const FOMAttributeList& value) noexcept
  { getImpl()._attributeList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setAttributeList(FOMAttributeList&& value) noexcept
  { getImpl()._attributeList = std::move(value); }
#endif
  FOMAttributeList& getAttributeList() noexcept
  { return getImpl()._attributeList; }
  const FOMAttributeList& getAttributeList() const noexcept
  { return getConstImpl()._attributeList; }

  FOMObjectClass& swap(FOMObjectClass& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMObjectClass& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getName() != rhs.getName()) return false;
    if (getObjectClassHandle() != rhs.getObjectClassHandle()) return false;
    if (getParentObjectClassHandle() != rhs.getParentObjectClassHandle()) return false;
    if (getAttributeList() != rhs.getAttributeList()) return false;
    return true;
  }
  bool operator<(const FOMObjectClass& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getName() < rhs.getName()) return true;
    if (rhs.getName() < getName()) return false;
    if (getObjectClassHandle() < rhs.getObjectClassHandle()) return true;
    if (rhs.getObjectClassHandle() < getObjectClassHandle()) return false;
    if (getParentObjectClassHandle() < rhs.getParentObjectClassHandle()) return true;
    if (rhs.getParentObjectClassHandle() < getParentObjectClassHandle()) return false;
    if (getAttributeList() < rhs.getAttributeList()) return true;
    if (rhs.getAttributeList() < getAttributeList()) return false;
    return false;
  }
  bool operator>(const FOMObjectClass& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMObjectClass& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMObjectClass& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _name(),
      _objectClassHandle(),
      _parentObjectClassHandle(),
      _attributeList()
    { }
    String _name;
    ObjectClassHandle _objectClassHandle;
    ObjectClassHandle _parentObjectClassHandle;
    FOMAttributeList _attributeList;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMObjectClass> FOMObjectClassList;

class OPENRTI_API FOMUpdateRate {
public:
  FOMUpdateRate() : 
    _impl(new Implementation())
  { }
  void setName(const String& value) noexcept
  { getImpl()._name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(String&& value) noexcept
  { getImpl()._name = std::move(value); }
#endif
  String& getName() noexcept
  { return getImpl()._name; }
  const String& getName() const noexcept
  { return getConstImpl()._name; }

  void setUpdateRateHandle(const UpdateRateHandle& value) noexcept
  { getImpl()._updateRateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setUpdateRateHandle(UpdateRateHandle&& value) noexcept
  { getImpl()._updateRateHandle = std::move(value); }
#endif
  UpdateRateHandle& getUpdateRateHandle() noexcept
  { return getImpl()._updateRateHandle; }
  const UpdateRateHandle& getUpdateRateHandle() const noexcept
  { return getConstImpl()._updateRateHandle; }

  void setRate(const Double& value) noexcept
  { getImpl()._rate = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setRate(Double&& value) noexcept
  { getImpl()._rate = std::move(value); }
#endif
  Double& getRate() noexcept
  { return getImpl()._rate; }
  const Double& getRate() const noexcept
  { return getConstImpl()._rate; }

  FOMUpdateRate& swap(FOMUpdateRate& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMUpdateRate& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getName() != rhs.getName()) return false;
    if (getUpdateRateHandle() != rhs.getUpdateRateHandle()) return false;
    if (getRate() != rhs.getRate()) return false;
    return true;
  }
  bool operator<(const FOMUpdateRate& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getName() < rhs.getName()) return true;
    if (rhs.getName() < getName()) return false;
    if (getUpdateRateHandle() < rhs.getUpdateRateHandle()) return true;
    if (rhs.getUpdateRateHandle() < getUpdateRateHandle()) return false;
    if (getRate() < rhs.getRate()) return true;
    if (rhs.getRate() < getRate()) return false;
    return false;
  }
  bool operator>(const FOMUpdateRate& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMUpdateRate& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMUpdateRate& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _name(),
      _updateRateHandle(),
      _rate()
    { }
    String _name;
    UpdateRateHandle _updateRateHandle;
    Double _rate;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMUpdateRate> FOMUpdateRateList;

class OPENRTI_API FOMSwitch {
public:
  FOMSwitch() : 
    _impl(new Implementation())
  { }
  void setSwitchesType(const SwitchesType& value) noexcept
  { getImpl()._switchesType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setSwitchesType(SwitchesType&& value) noexcept
  { getImpl()._switchesType = std::move(value); }
#endif
  SwitchesType& getSwitchesType() noexcept
  { return getImpl()._switchesType; }
  const SwitchesType& getSwitchesType() const noexcept
  { return getConstImpl()._switchesType; }

  void setEnabled(const Bool& value) noexcept
  { getImpl()._enabled = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setEnabled(Bool&& value) noexcept
  { getImpl()._enabled = std::move(value); }
#endif
  Bool& getEnabled() noexcept
  { return getImpl()._enabled; }
  const Bool& getEnabled() const noexcept
  { return getConstImpl()._enabled; }

  FOMSwitch& swap(FOMSwitch& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMSwitch& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getSwitchesType() != rhs.getSwitchesType()) return false;
    if (getEnabled() != rhs.getEnabled()) return false;
    return true;
  }
  bool operator<(const FOMSwitch& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getSwitchesType() < rhs.getSwitchesType()) return true;
    if (rhs.getSwitchesType() < getSwitchesType()) return false;
    if (getEnabled() < rhs.getEnabled()) return true;
    if (rhs.getEnabled() < getEnabled()) return false;
    return false;
  }
  bool operator>(const FOMSwitch& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMSwitch& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMSwitch& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _switchesType(),
      _enabled()
    { }
    SwitchesType _switchesType;
    Bool _enabled;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMSwitch> FOMSwitchList;

class OPENRTI_API FOMModule {
public:
  FOMModule() : 
    _impl(new Implementation())
  { }
  void setModuleHandle(const ModuleHandle& value) noexcept
  { getImpl()._moduleHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setModuleHandle(ModuleHandle&& value) noexcept
  { getImpl()._moduleHandle = std::move(value); }
#endif
  ModuleHandle& getModuleHandle() noexcept
  { return getImpl()._moduleHandle; }
  const ModuleHandle& getModuleHandle() const noexcept
  { return getConstImpl()._moduleHandle; }

  void setTransportationTypeList(const FOMTransportationTypeList& value) noexcept
  { getImpl()._transportationTypeList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTransportationTypeList(FOMTransportationTypeList&& value) noexcept
  { getImpl()._transportationTypeList = std::move(value); }
#endif
  FOMTransportationTypeList& getTransportationTypeList() noexcept
  { return getImpl()._transportationTypeList; }
  const FOMTransportationTypeList& getTransportationTypeList() const noexcept
  { return getConstImpl()._transportationTypeList; }

  void setDimensionList(const FOMDimensionList& value) noexcept
  { getImpl()._dimensionList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setDimensionList(FOMDimensionList&& value) noexcept
  { getImpl()._dimensionList = std::move(value); }
#endif
  FOMDimensionList& getDimensionList() noexcept
  { return getImpl()._dimensionList; }
  const FOMDimensionList& getDimensionList() const noexcept
  { return getConstImpl()._dimensionList; }

  void setRoutingSpaceList(const FOMRoutingSpaceList& value) noexcept
  { getImpl()._routingSpaceList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setRoutingSpaceList(FOMRoutingSpaceList&& value) noexcept
  { getImpl()._routingSpaceList = std::move(value); }
#endif
  FOMRoutingSpaceList& getRoutingSpaceList() noexcept
  { return getImpl()._routingSpaceList; }
  const FOMRoutingSpaceList& getRoutingSpaceList() const noexcept
  { return getConstImpl()._routingSpaceList; }

  void setInteractionClassList(const FOMInteractionClassList& value) noexcept
  { getImpl()._interactionClassList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setInteractionClassList(FOMInteractionClassList&& value) noexcept
  { getImpl()._interactionClassList = std::move(value); }
#endif
  FOMInteractionClassList& getInteractionClassList() noexcept
  { return getImpl()._interactionClassList; }
  const FOMInteractionClassList& getInteractionClassList() const noexcept
  { return getConstImpl()._interactionClassList; }

  void setObjectClassList(const FOMObjectClassList& value) noexcept
  { getImpl()._objectClassList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setObjectClassList(FOMObjectClassList&& value) noexcept
  { getImpl()._objectClassList = std::move(value); }
#endif
  FOMObjectClassList& getObjectClassList() noexcept
  { return getImpl()._objectClassList; }
  const FOMObjectClassList& getObjectClassList() const noexcept
  { return getConstImpl()._objectClassList; }

  void setUpdateRateList(const FOMUpdateRateList& value) noexcept
  { getImpl()._updateRateList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setUpdateRateList(FOMUpdateRateList&& value) noexcept
  { getImpl()._updateRateList = std::move(value); }
#endif
  FOMUpdateRateList& getUpdateRateList() noexcept
  { return getImpl()._updateRateList; }
  const FOMUpdateRateList& getUpdateRateList() const noexcept
  { return getConstImpl()._updateRateList; }

  void setSwitchList(const FOMSwitchList& value) noexcept
  { getImpl()._switchList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setSwitchList(FOMSwitchList&& value) noexcept
  { getImpl()._switchList = std::move(value); }
#endif
  FOMSwitchList& getSwitchList() noexcept
  { return getImpl()._switchList; }
  const FOMSwitchList& getSwitchList() const noexcept
  { return getConstImpl()._switchList; }

  void setArtificialInteractionRoot(const Bool& value) noexcept
  { getImpl()._artificialInteractionRoot = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setArtificialInteractionRoot(Bool&& value) noexcept
  { getImpl()._artificialInteractionRoot = std::move(value); }
#endif
  Bool& getArtificialInteractionRoot() noexcept
  { return getImpl()._artificialInteractionRoot; }
  const Bool& getArtificialInteractionRoot() const noexcept
  { return getConstImpl()._artificialInteractionRoot; }

  void setArtificialObjectRoot(const Bool& value) noexcept
  { getImpl()._artificialObjectRoot = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setArtificialObjectRoot(Bool&& value) noexcept
  { getImpl()._artificialObjectRoot = std::move(value); }
#endif
  Bool& getArtificialObjectRoot() noexcept
  { return getImpl()._artificialObjectRoot; }
  const Bool& getArtificialObjectRoot() const noexcept
  { return getConstImpl()._artificialObjectRoot; }

  void setDesignator(const String& value) noexcept
  { getImpl()._designator = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setDesignator(String&& value) noexcept
  { getImpl()._designator = std::move(value); }
#endif
  String& getDesignator() noexcept
  { return getImpl()._designator; }
  const String& getDesignator() const noexcept
  { return getConstImpl()._designator; }

  FOMModule& swap(FOMModule& rhs)
  {
    _impl.swap(rhs._impl);
    return *this;
  }
  bool operator==(const FOMModule& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return true;
    if (getModuleHandle() != rhs.getModuleHandle()) return false;
    if (getTransportationTypeList() != rhs.getTransportationTypeList()) return false;
    if (getDimensionList() != rhs.getDimensionList()) return false;
    if (getRoutingSpaceList() != rhs.getRoutingSpaceList()) return false;
    if (getInteractionClassList() != rhs.getInteractionClassList()) return false;
    if (getObjectClassList() != rhs.getObjectClassList()) return false;
    if (getUpdateRateList() != rhs.getUpdateRateList()) return false;
    if (getSwitchList() != rhs.getSwitchList()) return false;
    if (getArtificialInteractionRoot() != rhs.getArtificialInteractionRoot()) return false;
    if (getArtificialObjectRoot() != rhs.getArtificialObjectRoot()) return false;
    if (getDesignator() != rhs.getDesignator()) return false;
    return true;
  }
  bool operator<(const FOMModule& rhs) const noexcept
  {
    if (_impl.get() == rhs._impl.get())
      return false;
    if (getModuleHandle() < rhs.getModuleHandle()) return true;
    if (rhs.getModuleHandle() < getModuleHandle()) return false;
    if (getTransportationTypeList() < rhs.getTransportationTypeList()) return true;
    if (rhs.getTransportationTypeList() < getTransportationTypeList()) return false;
    if (getDimensionList() < rhs.getDimensionList()) return true;
    if (rhs.getDimensionList() < getDimensionList()) return false;
    if (getRoutingSpaceList() < rhs.getRoutingSpaceList()) return true;
    if (rhs.getRoutingSpaceList() < getRoutingSpaceList()) return false;
    if (getInteractionClassList() < rhs.getInteractionClassList()) return true;
    if (rhs.getInteractionClassList() < getInteractionClassList()) return false;
    if (getObjectClassList() < rhs.getObjectClassList()) return true;
    if (rhs.getObjectClassList() < getObjectClassList()) return false;
    if (getUpdateRateList() < rhs.getUpdateRateList()) return true;
    if (rhs.getUpdateRateList() < getUpdateRateList()) return false;
    if (getSwitchList() < rhs.getSwitchList()) return true;
    if (rhs.getSwitchList() < getSwitchList()) return false;
    if (getArtificialInteractionRoot() < rhs.getArtificialInteractionRoot()) return true;
    if (rhs.getArtificialInteractionRoot() < getArtificialInteractionRoot()) return false;
    if (getArtificialObjectRoot() < rhs.getArtificialObjectRoot()) return true;
    if (rhs.getArtificialObjectRoot() < getArtificialObjectRoot()) return false;
    if (getDesignator() < rhs.getDesignator()) return true;
    if (rhs.getDesignator() < getDesignator()) return false;
    return false;
  }
  bool operator>(const FOMModule& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FOMModule& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FOMModule& rhs) const noexcept
  { return !operator>(rhs); }
private:
  struct OPENRTI_API Implementation final : public Referenced {
    Implementation() noexcept :
      _moduleHandle(),
      _transportationTypeList(),
      _dimensionList(),
      _routingSpaceList(),
      _interactionClassList(),
      _objectClassList(),
      _updateRateList(),
      _switchList(),
      _artificialInteractionRoot(),
      _artificialObjectRoot(),
      _designator()
    { }
    ModuleHandle _moduleHandle;
    FOMTransportationTypeList _transportationTypeList;
    FOMDimensionList _dimensionList;
    FOMRoutingSpaceList _routingSpaceList;
    FOMInteractionClassList _interactionClassList;
    FOMObjectClassList _objectClassList;
    FOMUpdateRateList _updateRateList;
    FOMSwitchList _switchList;
    Bool _artificialInteractionRoot;
    Bool _artificialObjectRoot;
    String _designator;
  };

  const Implementation& getConstImpl() const
  {
    return *_impl;
  }

  Implementation& getImpl()
  {
    if (1 < Referenced::count(_impl.get()))
      _impl = MakeShared<Implementation>(*_impl);
    return *_impl;
  }

  SharedPtr<Implementation> _impl;
};

typedef std::vector<FOMModule> FOMModuleList;

class OPENRTI_API ConnectionLostMessage final : public AbstractMessage {
public:
  ConnectionLostMessage() noexcept;
  virtual ~ConnectionLostMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const ConnectionLostMessage& rhs) const noexcept;
  bool operator<(const ConnectionLostMessage& rhs) const noexcept;
  bool operator!=(const ConnectionLostMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const ConnectionLostMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const ConnectionLostMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const ConnectionLostMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFaultDescription(const String& value) noexcept
  { _faultDescription = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFaultDescription(String&& value) noexcept
  { _faultDescription = std::move(value); }
#endif
  String& getFaultDescription() noexcept
  { return _faultDescription; }
  const String& getFaultDescription() const noexcept
  { return _faultDescription; }

private:
  String _faultDescription;
};

class OPENRTI_API CreateFederationExecutionRequestMessage final : public AbstractMessage {
public:
  CreateFederationExecutionRequestMessage() noexcept;
  virtual ~CreateFederationExecutionRequestMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const CreateFederationExecutionRequestMessage& rhs) const noexcept;
  bool operator<(const CreateFederationExecutionRequestMessage& rhs) const noexcept;
  bool operator!=(const CreateFederationExecutionRequestMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const CreateFederationExecutionRequestMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const CreateFederationExecutionRequestMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const CreateFederationExecutionRequestMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationExecution(const String& value) noexcept
  { _federationExecution = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationExecution(String&& value) noexcept
  { _federationExecution = std::move(value); }
#endif
  String& getFederationExecution() noexcept
  { return _federationExecution; }
  const String& getFederationExecution() const noexcept
  { return _federationExecution; }

  void setLogicalTimeFactoryName(const String& value) noexcept
  { _logicalTimeFactoryName = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setLogicalTimeFactoryName(String&& value) noexcept
  { _logicalTimeFactoryName = std::move(value); }
#endif
  String& getLogicalTimeFactoryName() noexcept
  { return _logicalTimeFactoryName; }
  const String& getLogicalTimeFactoryName() const noexcept
  { return _logicalTimeFactoryName; }

  void setFOMStringModuleList(const FOMStringModuleList& value) noexcept
  { _fOMStringModuleList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFOMStringModuleList(FOMStringModuleList&& value) noexcept
  { _fOMStringModuleList = std::move(value); }
#endif
  FOMStringModuleList& getFOMStringModuleList() noexcept
  { return _fOMStringModuleList; }
  const FOMStringModuleList& getFOMStringModuleList() const noexcept
  { return _fOMStringModuleList; }

private:
  String _federationExecution;
  String _logicalTimeFactoryName;
  FOMStringModuleList _fOMStringModuleList;
};

class OPENRTI_API CreateFederationExecutionResponseMessage final : public AbstractMessage {
public:
  CreateFederationExecutionResponseMessage() noexcept;
  virtual ~CreateFederationExecutionResponseMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const CreateFederationExecutionResponseMessage& rhs) const noexcept;
  bool operator<(const CreateFederationExecutionResponseMessage& rhs) const noexcept;
  bool operator!=(const CreateFederationExecutionResponseMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const CreateFederationExecutionResponseMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const CreateFederationExecutionResponseMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const CreateFederationExecutionResponseMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setCreateFederationExecutionResponseType(const CreateFederationExecutionResponseType& value) noexcept
  { _createFederationExecutionResponseType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setCreateFederationExecutionResponseType(CreateFederationExecutionResponseType&& value) noexcept
  { _createFederationExecutionResponseType = std::move(value); }
#endif
  CreateFederationExecutionResponseType& getCreateFederationExecutionResponseType() noexcept
  { return _createFederationExecutionResponseType; }
  const CreateFederationExecutionResponseType& getCreateFederationExecutionResponseType() const noexcept
  { return _createFederationExecutionResponseType; }

  void setExceptionString(const String& value) noexcept
  { _exceptionString = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setExceptionString(String&& value) noexcept
  { _exceptionString = std::move(value); }
#endif
  String& getExceptionString() noexcept
  { return _exceptionString; }
  const String& getExceptionString() const noexcept
  { return _exceptionString; }

private:
  CreateFederationExecutionResponseType _createFederationExecutionResponseType;
  String _exceptionString;
};

class OPENRTI_API DestroyFederationExecutionRequestMessage final : public AbstractMessage {
public:
  DestroyFederationExecutionRequestMessage() noexcept;
  virtual ~DestroyFederationExecutionRequestMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const DestroyFederationExecutionRequestMessage& rhs) const noexcept;
  bool operator<(const DestroyFederationExecutionRequestMessage& rhs) const noexcept;
  bool operator!=(const DestroyFederationExecutionRequestMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const DestroyFederationExecutionRequestMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const DestroyFederationExecutionRequestMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const DestroyFederationExecutionRequestMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationExecution(const String& value) noexcept
  { _federationExecution = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationExecution(String&& value) noexcept
  { _federationExecution = std::move(value); }
#endif
  String& getFederationExecution() noexcept
  { return _federationExecution; }
  const String& getFederationExecution() const noexcept
  { return _federationExecution; }

private:
  String _federationExecution;
};

class OPENRTI_API DestroyFederationExecutionResponseMessage final : public AbstractMessage {
public:
  DestroyFederationExecutionResponseMessage() noexcept;
  virtual ~DestroyFederationExecutionResponseMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const DestroyFederationExecutionResponseMessage& rhs) const noexcept;
  bool operator<(const DestroyFederationExecutionResponseMessage& rhs) const noexcept;
  bool operator!=(const DestroyFederationExecutionResponseMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const DestroyFederationExecutionResponseMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const DestroyFederationExecutionResponseMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const DestroyFederationExecutionResponseMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setDestroyFederationExecutionResponseType(const DestroyFederationExecutionResponseType& value) noexcept
  { _destroyFederationExecutionResponseType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setDestroyFederationExecutionResponseType(DestroyFederationExecutionResponseType&& value) noexcept
  { _destroyFederationExecutionResponseType = std::move(value); }
#endif
  DestroyFederationExecutionResponseType& getDestroyFederationExecutionResponseType() noexcept
  { return _destroyFederationExecutionResponseType; }
  const DestroyFederationExecutionResponseType& getDestroyFederationExecutionResponseType() const noexcept
  { return _destroyFederationExecutionResponseType; }

private:
  DestroyFederationExecutionResponseType _destroyFederationExecutionResponseType;
};

class OPENRTI_API EnumerateFederationExecutionsRequestMessage final : public AbstractMessage {
public:
  EnumerateFederationExecutionsRequestMessage() noexcept;
  virtual ~EnumerateFederationExecutionsRequestMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const EnumerateFederationExecutionsRequestMessage& rhs) const noexcept;
  bool operator<(const EnumerateFederationExecutionsRequestMessage& rhs) const noexcept;
  bool operator!=(const EnumerateFederationExecutionsRequestMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const EnumerateFederationExecutionsRequestMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const EnumerateFederationExecutionsRequestMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const EnumerateFederationExecutionsRequestMessage& rhs) const noexcept
  { return !operator>(rhs); }

private:
};

class OPENRTI_API EnumerateFederationExecutionsResponseMessage final : public AbstractMessage {
public:
  EnumerateFederationExecutionsResponseMessage() noexcept;
  virtual ~EnumerateFederationExecutionsResponseMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const EnumerateFederationExecutionsResponseMessage& rhs) const noexcept;
  bool operator<(const EnumerateFederationExecutionsResponseMessage& rhs) const noexcept;
  bool operator!=(const EnumerateFederationExecutionsResponseMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const EnumerateFederationExecutionsResponseMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const EnumerateFederationExecutionsResponseMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const EnumerateFederationExecutionsResponseMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationExecutionInformationVector(const FederationExecutionInformationVector& value) noexcept
  { _federationExecutionInformationVector = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationExecutionInformationVector(FederationExecutionInformationVector&& value) noexcept
  { _federationExecutionInformationVector = std::move(value); }
#endif
  FederationExecutionInformationVector& getFederationExecutionInformationVector() noexcept
  { return _federationExecutionInformationVector; }
  const FederationExecutionInformationVector& getFederationExecutionInformationVector() const noexcept
  { return _federationExecutionInformationVector; }

private:
  FederationExecutionInformationVector _federationExecutionInformationVector;
};

class OPENRTI_API InsertFederationExecutionMessage final : public AbstractMessage {
public:
  InsertFederationExecutionMessage() noexcept;
  virtual ~InsertFederationExecutionMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const InsertFederationExecutionMessage& rhs) const noexcept;
  bool operator<(const InsertFederationExecutionMessage& rhs) const noexcept;
  bool operator!=(const InsertFederationExecutionMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const InsertFederationExecutionMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const InsertFederationExecutionMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const InsertFederationExecutionMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederationName(const String& value) noexcept
  { _federationName = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationName(String&& value) noexcept
  { _federationName = std::move(value); }
#endif
  String& getFederationName() noexcept
  { return _federationName; }
  const String& getFederationName() const noexcept
  { return _federationName; }

  void setLogicalTimeFactoryName(const String& value) noexcept
  { _logicalTimeFactoryName = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setLogicalTimeFactoryName(String&& value) noexcept
  { _logicalTimeFactoryName = std::move(value); }
#endif
  String& getLogicalTimeFactoryName() noexcept
  { return _logicalTimeFactoryName; }
  const String& getLogicalTimeFactoryName() const noexcept
  { return _logicalTimeFactoryName; }

  void setConfigurationParameterMap(const ConfigurationParameterMap& value) noexcept
  { _configurationParameterMap = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setConfigurationParameterMap(ConfigurationParameterMap&& value) noexcept
  { _configurationParameterMap = std::move(value); }
#endif
  ConfigurationParameterMap& getConfigurationParameterMap() noexcept
  { return _configurationParameterMap; }
  const ConfigurationParameterMap& getConfigurationParameterMap() const noexcept
  { return _configurationParameterMap; }

private:
  FederationHandle _federationHandle;
  String _federationName;
  String _logicalTimeFactoryName;
  ConfigurationParameterMap _configurationParameterMap;
};

class OPENRTI_API ShutdownFederationExecutionMessage final : public AbstractMessage {
public:
  ShutdownFederationExecutionMessage() noexcept;
  virtual ~ShutdownFederationExecutionMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const ShutdownFederationExecutionMessage& rhs) const noexcept;
  bool operator<(const ShutdownFederationExecutionMessage& rhs) const noexcept;
  bool operator!=(const ShutdownFederationExecutionMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const ShutdownFederationExecutionMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const ShutdownFederationExecutionMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const ShutdownFederationExecutionMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

private:
  FederationHandle _federationHandle;
};

class OPENRTI_API EraseFederationExecutionMessage final : public AbstractMessage {
public:
  EraseFederationExecutionMessage() noexcept;
  virtual ~EraseFederationExecutionMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const EraseFederationExecutionMessage& rhs) const noexcept;
  bool operator<(const EraseFederationExecutionMessage& rhs) const noexcept;
  bool operator!=(const EraseFederationExecutionMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const EraseFederationExecutionMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const EraseFederationExecutionMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const EraseFederationExecutionMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

private:
  FederationHandle _federationHandle;
};

class OPENRTI_API ReleaseFederationHandleMessage final : public AbstractMessage {
public:
  ReleaseFederationHandleMessage() noexcept;
  virtual ~ReleaseFederationHandleMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const ReleaseFederationHandleMessage& rhs) const noexcept;
  bool operator<(const ReleaseFederationHandleMessage& rhs) const noexcept;
  bool operator!=(const ReleaseFederationHandleMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const ReleaseFederationHandleMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const ReleaseFederationHandleMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const ReleaseFederationHandleMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

private:
  FederationHandle _federationHandle;
};

class OPENRTI_API InsertModulesMessage final : public AbstractMessage {
public:
  InsertModulesMessage() noexcept;
  virtual ~InsertModulesMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const InsertModulesMessage& rhs) const noexcept;
  bool operator<(const InsertModulesMessage& rhs) const noexcept;
  bool operator!=(const InsertModulesMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const InsertModulesMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const InsertModulesMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const InsertModulesMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFOMModuleList(const FOMModuleList& value) noexcept
  { _fOMModuleList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFOMModuleList(FOMModuleList&& value) noexcept
  { _fOMModuleList = std::move(value); }
#endif
  FOMModuleList& getFOMModuleList() noexcept
  { return _fOMModuleList; }
  const FOMModuleList& getFOMModuleList() const noexcept
  { return _fOMModuleList; }

private:
  FederationHandle _federationHandle;
  FOMModuleList _fOMModuleList;
};

class OPENRTI_API JoinFederationExecutionRequestMessage final : public AbstractMessage {
public:
  JoinFederationExecutionRequestMessage() noexcept;
  virtual ~JoinFederationExecutionRequestMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const JoinFederationExecutionRequestMessage& rhs) const noexcept;
  bool operator<(const JoinFederationExecutionRequestMessage& rhs) const noexcept;
  bool operator!=(const JoinFederationExecutionRequestMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const JoinFederationExecutionRequestMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const JoinFederationExecutionRequestMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const JoinFederationExecutionRequestMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationExecution(const String& value) noexcept
  { _federationExecution = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationExecution(String&& value) noexcept
  { _federationExecution = std::move(value); }
#endif
  String& getFederationExecution() noexcept
  { return _federationExecution; }
  const String& getFederationExecution() const noexcept
  { return _federationExecution; }

  void setFederateType(const String& value) noexcept
  { _federateType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateType(String&& value) noexcept
  { _federateType = std::move(value); }
#endif
  String& getFederateType() noexcept
  { return _federateType; }
  const String& getFederateType() const noexcept
  { return _federateType; }

  void setFederateName(const String& value) noexcept
  { _federateName = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateName(String&& value) noexcept
  { _federateName = std::move(value); }
#endif
  String& getFederateName() noexcept
  { return _federateName; }
  const String& getFederateName() const noexcept
  { return _federateName; }

  void setFOMStringModuleList(const FOMStringModuleList& value) noexcept
  { _fOMStringModuleList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFOMStringModuleList(FOMStringModuleList&& value) noexcept
  { _fOMStringModuleList = std::move(value); }
#endif
  FOMStringModuleList& getFOMStringModuleList() noexcept
  { return _fOMStringModuleList; }
  const FOMStringModuleList& getFOMStringModuleList() const noexcept
  { return _fOMStringModuleList; }

  void setConfigurationParameterMap(const ConfigurationParameterMap& value) noexcept
  { _configurationParameterMap = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setConfigurationParameterMap(ConfigurationParameterMap&& value) noexcept
  { _configurationParameterMap = std::move(value); }
#endif
  ConfigurationParameterMap& getConfigurationParameterMap() noexcept
  { return _configurationParameterMap; }
  const ConfigurationParameterMap& getConfigurationParameterMap() const noexcept
  { return _configurationParameterMap; }

  void setIsInternal(const Bool& value) noexcept
  { _isInternal = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setIsInternal(Bool&& value) noexcept
  { _isInternal = std::move(value); }
#endif
  Bool& getIsInternal() noexcept
  { return _isInternal; }
  const Bool& getIsInternal() const noexcept
  { return _isInternal; }

private:
  String _federationExecution;
  String _federateType;
  String _federateName;
  FOMStringModuleList _fOMStringModuleList;
  ConfigurationParameterMap _configurationParameterMap;
  Bool _isInternal;
};

class OPENRTI_API JoinFederationExecutionResponseMessage final : public AbstractMessage {
public:
  JoinFederationExecutionResponseMessage() noexcept;
  virtual ~JoinFederationExecutionResponseMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const JoinFederationExecutionResponseMessage& rhs) const noexcept;
  bool operator<(const JoinFederationExecutionResponseMessage& rhs) const noexcept;
  bool operator!=(const JoinFederationExecutionResponseMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const JoinFederationExecutionResponseMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const JoinFederationExecutionResponseMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const JoinFederationExecutionResponseMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setJoinFederationExecutionResponseType(const JoinFederationExecutionResponseType& value) noexcept
  { _joinFederationExecutionResponseType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setJoinFederationExecutionResponseType(JoinFederationExecutionResponseType&& value) noexcept
  { _joinFederationExecutionResponseType = std::move(value); }
#endif
  JoinFederationExecutionResponseType& getJoinFederationExecutionResponseType() noexcept
  { return _joinFederationExecutionResponseType; }
  const JoinFederationExecutionResponseType& getJoinFederationExecutionResponseType() const noexcept
  { return _joinFederationExecutionResponseType; }

  void setExceptionString(const String& value) noexcept
  { _exceptionString = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setExceptionString(String&& value) noexcept
  { _exceptionString = std::move(value); }
#endif
  String& getExceptionString() noexcept
  { return _exceptionString; }
  const String& getExceptionString() const noexcept
  { return _exceptionString; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

  void setFederateType(const String& value) noexcept
  { _federateType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateType(String&& value) noexcept
  { _federateType = std::move(value); }
#endif
  String& getFederateType() noexcept
  { return _federateType; }
  const String& getFederateType() const noexcept
  { return _federateType; }

  void setFederateName(const String& value) noexcept
  { _federateName = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateName(String&& value) noexcept
  { _federateName = std::move(value); }
#endif
  String& getFederateName() noexcept
  { return _federateName; }
  const String& getFederateName() const noexcept
  { return _federateName; }

private:
  FederationHandle _federationHandle;
  JoinFederationExecutionResponseType _joinFederationExecutionResponseType;
  String _exceptionString;
  FederateHandle _federateHandle;
  String _federateType;
  String _federateName;
};

class OPENRTI_API ResignFederationExecutionLeafRequestMessage final : public AbstractMessage {
public:
  ResignFederationExecutionLeafRequestMessage() noexcept;
  virtual ~ResignFederationExecutionLeafRequestMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const ResignFederationExecutionLeafRequestMessage& rhs) const noexcept;
  bool operator<(const ResignFederationExecutionLeafRequestMessage& rhs) const noexcept;
  bool operator!=(const ResignFederationExecutionLeafRequestMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const ResignFederationExecutionLeafRequestMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const ResignFederationExecutionLeafRequestMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const ResignFederationExecutionLeafRequestMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

  void setResignAction(const ResignAction& value) noexcept
  { _resignAction = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setResignAction(ResignAction&& value) noexcept
  { _resignAction = std::move(value); }
#endif
  ResignAction& getResignAction() noexcept
  { return _resignAction; }
  const ResignAction& getResignAction() const noexcept
  { return _resignAction; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
  ResignAction _resignAction;
};

class OPENRTI_API ResignFederationExecutionRequestMessage final : public AbstractMessage {
public:
  ResignFederationExecutionRequestMessage() noexcept;
  virtual ~ResignFederationExecutionRequestMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const ResignFederationExecutionRequestMessage& rhs) const noexcept;
  bool operator<(const ResignFederationExecutionRequestMessage& rhs) const noexcept;
  bool operator!=(const ResignFederationExecutionRequestMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const ResignFederationExecutionRequestMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const ResignFederationExecutionRequestMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const ResignFederationExecutionRequestMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
};

class OPENRTI_API JoinFederateNotifyMessage final : public AbstractMessage {
public:
  JoinFederateNotifyMessage() noexcept;
  virtual ~JoinFederateNotifyMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const JoinFederateNotifyMessage& rhs) const noexcept;
  bool operator<(const JoinFederateNotifyMessage& rhs) const noexcept;
  bool operator!=(const JoinFederateNotifyMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const JoinFederateNotifyMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const JoinFederateNotifyMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const JoinFederateNotifyMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

  void setFederateType(const String& value) noexcept
  { _federateType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateType(String&& value) noexcept
  { _federateType = std::move(value); }
#endif
  String& getFederateType() noexcept
  { return _federateType; }
  const String& getFederateType() const noexcept
  { return _federateType; }

  void setFederateName(const String& value) noexcept
  { _federateName = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateName(String&& value) noexcept
  { _federateName = std::move(value); }
#endif
  String& getFederateName() noexcept
  { return _federateName; }
  const String& getFederateName() const noexcept
  { return _federateName; }

  void setIsInternal(const Bool& value) noexcept
  { _isInternal = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setIsInternal(Bool&& value) noexcept
  { _isInternal = std::move(value); }
#endif
  Bool& getIsInternal() noexcept
  { return _isInternal; }
  const Bool& getIsInternal() const noexcept
  { return _isInternal; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
  String _federateType;
  String _federateName;
  Bool _isInternal;
};

class OPENRTI_API ResignFederateNotifyMessage final : public AbstractMessage {
public:
  ResignFederateNotifyMessage() noexcept;
  virtual ~ResignFederateNotifyMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const ResignFederateNotifyMessage& rhs) const noexcept;
  bool operator<(const ResignFederateNotifyMessage& rhs) const noexcept;
  bool operator!=(const ResignFederateNotifyMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const ResignFederateNotifyMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const ResignFederateNotifyMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const ResignFederateNotifyMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
};

class OPENRTI_API ChangeAutomaticResignDirectiveMessage final : public AbstractMessage {
public:
  ChangeAutomaticResignDirectiveMessage() noexcept;
  virtual ~ChangeAutomaticResignDirectiveMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const ChangeAutomaticResignDirectiveMessage& rhs) const noexcept;
  bool operator<(const ChangeAutomaticResignDirectiveMessage& rhs) const noexcept;
  bool operator!=(const ChangeAutomaticResignDirectiveMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const ChangeAutomaticResignDirectiveMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const ChangeAutomaticResignDirectiveMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const ChangeAutomaticResignDirectiveMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

  void setResignAction(const ResignAction& value) noexcept
  { _resignAction = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setResignAction(ResignAction&& value) noexcept
  { _resignAction = std::move(value); }
#endif
  ResignAction& getResignAction() noexcept
  { return _resignAction; }
  const ResignAction& getResignAction() const noexcept
  { return _resignAction; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
  ResignAction _resignAction;
};

class OPENRTI_API RegisterFederationSynchronizationPointMessage final : public AbstractMessage {
public:
  RegisterFederationSynchronizationPointMessage() noexcept;
  virtual ~RegisterFederationSynchronizationPointMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const RegisterFederationSynchronizationPointMessage& rhs) const noexcept;
  bool operator<(const RegisterFederationSynchronizationPointMessage& rhs) const noexcept;
  bool operator!=(const RegisterFederationSynchronizationPointMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const RegisterFederationSynchronizationPointMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const RegisterFederationSynchronizationPointMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const RegisterFederationSynchronizationPointMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

  void setLabel(const String& value) noexcept
  { _label = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setLabel(String&& value) noexcept
  { _label = std::move(value); }
#endif
  String& getLabel() noexcept
  { return _label; }
  const String& getLabel() const noexcept
  { return _label; }

  void setTag(const VariableLengthData& value) noexcept
  { _tag = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTag(VariableLengthData&& value) noexcept
  { _tag = std::move(value); }
#endif
  VariableLengthData& getTag() noexcept
  { return _tag; }
  const VariableLengthData& getTag() const noexcept
  { return _tag; }

  void setFederateHandleVector(const FederateHandleVector& value) noexcept
  { _federateHandleVector = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandleVector(FederateHandleVector&& value) noexcept
  { _federateHandleVector = std::move(value); }
#endif
  FederateHandleVector& getFederateHandleVector() noexcept
  { return _federateHandleVector; }
  const FederateHandleVector& getFederateHandleVector() const noexcept
  { return _federateHandleVector; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
  String _label;
  VariableLengthData _tag;
  FederateHandleVector _federateHandleVector;
};

class OPENRTI_API RegisterFederationSynchronizationPointResponseMessage final : public AbstractMessage {
public:
  RegisterFederationSynchronizationPointResponseMessage() noexcept;
  virtual ~RegisterFederationSynchronizationPointResponseMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const RegisterFederationSynchronizationPointResponseMessage& rhs) const noexcept;
  bool operator<(const RegisterFederationSynchronizationPointResponseMessage& rhs) const noexcept;
  bool operator!=(const RegisterFederationSynchronizationPointResponseMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const RegisterFederationSynchronizationPointResponseMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const RegisterFederationSynchronizationPointResponseMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const RegisterFederationSynchronizationPointResponseMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

  void setLabel(const String& value) noexcept
  { _label = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setLabel(String&& value) noexcept
  { _label = std::move(value); }
#endif
  String& getLabel() noexcept
  { return _label; }
  const String& getLabel() const noexcept
  { return _label; }

  void setRegisterFederationSynchronizationPointResponseType(const RegisterFederationSynchronizationPointResponseType& value) noexcept
  { _registerFederationSynchronizationPointResponseType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setRegisterFederationSynchronizationPointResponseType(RegisterFederationSynchronizationPointResponseType&& value) noexcept
  { _registerFederationSynchronizationPointResponseType = std::move(value); }
#endif
  RegisterFederationSynchronizationPointResponseType& getRegisterFederationSynchronizationPointResponseType() noexcept
  { return _registerFederationSynchronizationPointResponseType; }
  const RegisterFederationSynchronizationPointResponseType& getRegisterFederationSynchronizationPointResponseType() const noexcept
  { return _registerFederationSynchronizationPointResponseType; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
  String _label;
  RegisterFederationSynchronizationPointResponseType _registerFederationSynchronizationPointResponseType;
};

class OPENRTI_API AnnounceSynchronizationPointMessage final : public AbstractMessage {
public:
  AnnounceSynchronizationPointMessage() noexcept;
  virtual ~AnnounceSynchronizationPointMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const AnnounceSynchronizationPointMessage& rhs) const noexcept;
  bool operator<(const AnnounceSynchronizationPointMessage& rhs) const noexcept;
  bool operator!=(const AnnounceSynchronizationPointMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const AnnounceSynchronizationPointMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const AnnounceSynchronizationPointMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const AnnounceSynchronizationPointMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setLabel(const String& value) noexcept
  { _label = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setLabel(String&& value) noexcept
  { _label = std::move(value); }
#endif
  String& getLabel() noexcept
  { return _label; }
  const String& getLabel() const noexcept
  { return _label; }

  void setTag(const VariableLengthData& value) noexcept
  { _tag = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTag(VariableLengthData&& value) noexcept
  { _tag = std::move(value); }
#endif
  VariableLengthData& getTag() noexcept
  { return _tag; }
  const VariableLengthData& getTag() const noexcept
  { return _tag; }

  void setAddJoiningFederates(const Bool& value) noexcept
  { _addJoiningFederates = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setAddJoiningFederates(Bool&& value) noexcept
  { _addJoiningFederates = std::move(value); }
#endif
  Bool& getAddJoiningFederates() noexcept
  { return _addJoiningFederates; }
  const Bool& getAddJoiningFederates() const noexcept
  { return _addJoiningFederates; }

  void setFederateHandleVector(const FederateHandleVector& value) noexcept
  { _federateHandleVector = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandleVector(FederateHandleVector&& value) noexcept
  { _federateHandleVector = std::move(value); }
#endif
  FederateHandleVector& getFederateHandleVector() noexcept
  { return _federateHandleVector; }
  const FederateHandleVector& getFederateHandleVector() const noexcept
  { return _federateHandleVector; }

private:
  FederationHandle _federationHandle;
  String _label;
  VariableLengthData _tag;
  Bool _addJoiningFederates;
  FederateHandleVector _federateHandleVector;
};

class OPENRTI_API SynchronizationPointAchievedMessage final : public AbstractMessage {
public:
  SynchronizationPointAchievedMessage() noexcept;
  virtual ~SynchronizationPointAchievedMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const SynchronizationPointAchievedMessage& rhs) const noexcept;
  bool operator<(const SynchronizationPointAchievedMessage& rhs) const noexcept;
  bool operator!=(const SynchronizationPointAchievedMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const SynchronizationPointAchievedMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const SynchronizationPointAchievedMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const SynchronizationPointAchievedMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setLabel(const String& value) noexcept
  { _label = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setLabel(String&& value) noexcept
  { _label = std::move(value); }
#endif
  String& getLabel() noexcept
  { return _label; }
  const String& getLabel() const noexcept
  { return _label; }

  void setFederateHandleBoolPairVector(const FederateHandleBoolPairVector& value) noexcept
  { _federateHandleBoolPairVector = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandleBoolPairVector(FederateHandleBoolPairVector&& value) noexcept
  { _federateHandleBoolPairVector = std::move(value); }
#endif
  FederateHandleBoolPairVector& getFederateHandleBoolPairVector() noexcept
  { return _federateHandleBoolPairVector; }
  const FederateHandleBoolPairVector& getFederateHandleBoolPairVector() const noexcept
  { return _federateHandleBoolPairVector; }

private:
  FederationHandle _federationHandle;
  String _label;
  FederateHandleBoolPairVector _federateHandleBoolPairVector;
};

class OPENRTI_API FederationSynchronizedMessage final : public AbstractMessage {
public:
  FederationSynchronizedMessage() noexcept;
  virtual ~FederationSynchronizedMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const FederationSynchronizedMessage& rhs) const noexcept;
  bool operator<(const FederationSynchronizedMessage& rhs) const noexcept;
  bool operator!=(const FederationSynchronizedMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const FederationSynchronizedMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const FederationSynchronizedMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const FederationSynchronizedMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setLabel(const String& value) noexcept
  { _label = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setLabel(String&& value) noexcept
  { _label = std::move(value); }
#endif
  String& getLabel() noexcept
  { return _label; }
  const String& getLabel() const noexcept
  { return _label; }

  void setFederateHandleBoolPairVector(const FederateHandleBoolPairVector& value) noexcept
  { _federateHandleBoolPairVector = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandleBoolPairVector(FederateHandleBoolPairVector&& value) noexcept
  { _federateHandleBoolPairVector = std::move(value); }
#endif
  FederateHandleBoolPairVector& getFederateHandleBoolPairVector() noexcept
  { return _federateHandleBoolPairVector; }
  const FederateHandleBoolPairVector& getFederateHandleBoolPairVector() const noexcept
  { return _federateHandleBoolPairVector; }

private:
  FederationHandle _federationHandle;
  String _label;
  FederateHandleBoolPairVector _federateHandleBoolPairVector;
};

class OPENRTI_API EnableTimeRegulationRequestMessage final : public AbstractMessage {
public:
  EnableTimeRegulationRequestMessage() noexcept;
  virtual ~EnableTimeRegulationRequestMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const EnableTimeRegulationRequestMessage& rhs) const noexcept;
  bool operator<(const EnableTimeRegulationRequestMessage& rhs) const noexcept;
  bool operator!=(const EnableTimeRegulationRequestMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const EnableTimeRegulationRequestMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const EnableTimeRegulationRequestMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const EnableTimeRegulationRequestMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

  void setTimeStamp(const VariableLengthData& value) noexcept
  { _timeStamp = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTimeStamp(VariableLengthData&& value) noexcept
  { _timeStamp = std::move(value); }
#endif
  VariableLengthData& getTimeStamp() noexcept
  { return _timeStamp; }
  const VariableLengthData& getTimeStamp() const noexcept
  { return _timeStamp; }

  void setCommitId(const Unsigned& value) noexcept
  { _commitId = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setCommitId(Unsigned&& value) noexcept
  { _commitId = std::move(value); }
#endif
  Unsigned& getCommitId() noexcept
  { return _commitId; }
  const Unsigned& getCommitId() const noexcept
  { return _commitId; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
  VariableLengthData _timeStamp;
  Unsigned _commitId;
};

class OPENRTI_API EnableTimeRegulationResponseMessage final : public AbstractMessage {
public:
  EnableTimeRegulationResponseMessage() noexcept;
  virtual ~EnableTimeRegulationResponseMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const EnableTimeRegulationResponseMessage& rhs) const noexcept;
  bool operator<(const EnableTimeRegulationResponseMessage& rhs) const noexcept;
  bool operator!=(const EnableTimeRegulationResponseMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const EnableTimeRegulationResponseMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const EnableTimeRegulationResponseMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const EnableTimeRegulationResponseMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

  void setRespondingFederateHandle(const FederateHandle& value) noexcept
  { _respondingFederateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setRespondingFederateHandle(FederateHandle&& value) noexcept
  { _respondingFederateHandle = std::move(value); }
#endif
  FederateHandle& getRespondingFederateHandle() noexcept
  { return _respondingFederateHandle; }
  const FederateHandle& getRespondingFederateHandle() const noexcept
  { return _respondingFederateHandle; }

  void setTimeStampValid(const Bool& value) noexcept
  { _timeStampValid = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTimeStampValid(Bool&& value) noexcept
  { _timeStampValid = std::move(value); }
#endif
  Bool& getTimeStampValid() noexcept
  { return _timeStampValid; }
  const Bool& getTimeStampValid() const noexcept
  { return _timeStampValid; }

  void setTimeStamp(const VariableLengthData& value) noexcept
  { _timeStamp = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTimeStamp(VariableLengthData&& value) noexcept
  { _timeStamp = std::move(value); }
#endif
  VariableLengthData& getTimeStamp() noexcept
  { return _timeStamp; }
  const VariableLengthData& getTimeStamp() const noexcept
  { return _timeStamp; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
  FederateHandle _respondingFederateHandle;
  Bool _timeStampValid;
  VariableLengthData _timeStamp;
};

class OPENRTI_API DisableTimeRegulationRequestMessage final : public AbstractMessage {
public:
  DisableTimeRegulationRequestMessage() noexcept;
  virtual ~DisableTimeRegulationRequestMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const DisableTimeRegulationRequestMessage& rhs) const noexcept;
  bool operator<(const DisableTimeRegulationRequestMessage& rhs) const noexcept;
  bool operator!=(const DisableTimeRegulationRequestMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const DisableTimeRegulationRequestMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const DisableTimeRegulationRequestMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const DisableTimeRegulationRequestMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
};

class OPENRTI_API EnableTimeConstrainedNotifyMessage final : public AbstractMessage {
public:
  EnableTimeConstrainedNotifyMessage() noexcept;
  virtual ~EnableTimeConstrainedNotifyMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const EnableTimeConstrainedNotifyMessage& rhs) const noexcept;
  bool operator<(const EnableTimeConstrainedNotifyMessage& rhs) const noexcept;
  bool operator!=(const EnableTimeConstrainedNotifyMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const EnableTimeConstrainedNotifyMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const EnableTimeConstrainedNotifyMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const EnableTimeConstrainedNotifyMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
};

class OPENRTI_API DisableTimeConstrainedNotifyMessage final : public AbstractMessage {
public:
  DisableTimeConstrainedNotifyMessage() noexcept;
  virtual ~DisableTimeConstrainedNotifyMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const DisableTimeConstrainedNotifyMessage& rhs) const noexcept;
  bool operator<(const DisableTimeConstrainedNotifyMessage& rhs) const noexcept;
  bool operator!=(const DisableTimeConstrainedNotifyMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const DisableTimeConstrainedNotifyMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const DisableTimeConstrainedNotifyMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const DisableTimeConstrainedNotifyMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
};

class OPENRTI_API CommitLowerBoundTimeStampMessage final : public AbstractMessage {
public:
  CommitLowerBoundTimeStampMessage() noexcept;
  virtual ~CommitLowerBoundTimeStampMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const CommitLowerBoundTimeStampMessage& rhs) const noexcept;
  bool operator<(const CommitLowerBoundTimeStampMessage& rhs) const noexcept;
  bool operator!=(const CommitLowerBoundTimeStampMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const CommitLowerBoundTimeStampMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const CommitLowerBoundTimeStampMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const CommitLowerBoundTimeStampMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

  void setTimeStamp(const VariableLengthData& value) noexcept
  { _timeStamp = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTimeStamp(VariableLengthData&& value) noexcept
  { _timeStamp = std::move(value); }
#endif
  VariableLengthData& getTimeStamp() noexcept
  { return _timeStamp; }
  const VariableLengthData& getTimeStamp() const noexcept
  { return _timeStamp; }

  void setCommitType(const LowerBoundTimeStampCommitType& value) noexcept
  { _commitType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setCommitType(LowerBoundTimeStampCommitType&& value) noexcept
  { _commitType = std::move(value); }
#endif
  LowerBoundTimeStampCommitType& getCommitType() noexcept
  { return _commitType; }
  const LowerBoundTimeStampCommitType& getCommitType() const noexcept
  { return _commitType; }

  void setCommitId(const Unsigned& value) noexcept
  { _commitId = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setCommitId(Unsigned&& value) noexcept
  { _commitId = std::move(value); }
#endif
  Unsigned& getCommitId() noexcept
  { return _commitId; }
  const Unsigned& getCommitId() const noexcept
  { return _commitId; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
  VariableLengthData _timeStamp;
  LowerBoundTimeStampCommitType _commitType;
  Unsigned _commitId;
};

class OPENRTI_API CommitLowerBoundTimeStampResponseMessage final : public AbstractMessage {
public:
  CommitLowerBoundTimeStampResponseMessage() noexcept;
  virtual ~CommitLowerBoundTimeStampResponseMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const CommitLowerBoundTimeStampResponseMessage& rhs) const noexcept;
  bool operator<(const CommitLowerBoundTimeStampResponseMessage& rhs) const noexcept;
  bool operator!=(const CommitLowerBoundTimeStampResponseMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const CommitLowerBoundTimeStampResponseMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const CommitLowerBoundTimeStampResponseMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const CommitLowerBoundTimeStampResponseMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

  void setSendingFederateHandle(const FederateHandle& value) noexcept
  { _sendingFederateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setSendingFederateHandle(FederateHandle&& value) noexcept
  { _sendingFederateHandle = std::move(value); }
#endif
  FederateHandle& getSendingFederateHandle() noexcept
  { return _sendingFederateHandle; }
  const FederateHandle& getSendingFederateHandle() const noexcept
  { return _sendingFederateHandle; }

  void setCommitId(const Unsigned& value) noexcept
  { _commitId = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setCommitId(Unsigned&& value) noexcept
  { _commitId = std::move(value); }
#endif
  Unsigned& getCommitId() noexcept
  { return _commitId; }
  const Unsigned& getCommitId() const noexcept
  { return _commitId; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
  FederateHandle _sendingFederateHandle;
  Unsigned _commitId;
};

class OPENRTI_API LockedByNextMessageRequestMessage final : public AbstractMessage {
public:
  LockedByNextMessageRequestMessage() noexcept;
  virtual ~LockedByNextMessageRequestMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const LockedByNextMessageRequestMessage& rhs) const noexcept;
  bool operator<(const LockedByNextMessageRequestMessage& rhs) const noexcept;
  bool operator!=(const LockedByNextMessageRequestMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const LockedByNextMessageRequestMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const LockedByNextMessageRequestMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const LockedByNextMessageRequestMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setSendingFederateHandle(const FederateHandle& value) noexcept
  { _sendingFederateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setSendingFederateHandle(FederateHandle&& value) noexcept
  { _sendingFederateHandle = std::move(value); }
#endif
  FederateHandle& getSendingFederateHandle() noexcept
  { return _sendingFederateHandle; }
  const FederateHandle& getSendingFederateHandle() const noexcept
  { return _sendingFederateHandle; }

  void setLockedByNextMessage(const Bool& value) noexcept
  { _lockedByNextMessage = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setLockedByNextMessage(Bool&& value) noexcept
  { _lockedByNextMessage = std::move(value); }
#endif
  Bool& getLockedByNextMessage() noexcept
  { return _lockedByNextMessage; }
  const Bool& getLockedByNextMessage() const noexcept
  { return _lockedByNextMessage; }

private:
  FederationHandle _federationHandle;
  FederateHandle _sendingFederateHandle;
  Bool _lockedByNextMessage;
};

class OPENRTI_API TimeConstrainedEnabledMessage final : public AbstractMessage {
public:
  TimeConstrainedEnabledMessage() noexcept;
  virtual ~TimeConstrainedEnabledMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const TimeConstrainedEnabledMessage& rhs) const noexcept;
  bool operator<(const TimeConstrainedEnabledMessage& rhs) const noexcept;
  bool operator!=(const TimeConstrainedEnabledMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const TimeConstrainedEnabledMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const TimeConstrainedEnabledMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const TimeConstrainedEnabledMessage& rhs) const noexcept
  { return !operator>(rhs); }

private:
};

class OPENRTI_API TimeRegulationEnabledMessage final : public AbstractMessage {
public:
  TimeRegulationEnabledMessage() noexcept;
  virtual ~TimeRegulationEnabledMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const TimeRegulationEnabledMessage& rhs) const noexcept;
  bool operator<(const TimeRegulationEnabledMessage& rhs) const noexcept;
  bool operator!=(const TimeRegulationEnabledMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const TimeRegulationEnabledMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const TimeRegulationEnabledMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const TimeRegulationEnabledMessage& rhs) const noexcept
  { return !operator>(rhs); }

private:
};

class OPENRTI_API TimeAdvanceGrantedMessage final : public AbstractMessage {
public:
  TimeAdvanceGrantedMessage() noexcept;
  virtual ~TimeAdvanceGrantedMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const TimeAdvanceGrantedMessage& rhs) const noexcept;
  bool operator<(const TimeAdvanceGrantedMessage& rhs) const noexcept;
  bool operator!=(const TimeAdvanceGrantedMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const TimeAdvanceGrantedMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const TimeAdvanceGrantedMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const TimeAdvanceGrantedMessage& rhs) const noexcept
  { return !operator>(rhs); }

private:
};

class OPENRTI_API InsertRegionMessage final : public AbstractMessage {
public:
  InsertRegionMessage() noexcept;
  virtual ~InsertRegionMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const InsertRegionMessage& rhs) const noexcept;
  bool operator<(const InsertRegionMessage& rhs) const noexcept;
  bool operator!=(const InsertRegionMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const InsertRegionMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const InsertRegionMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const InsertRegionMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setRegionHandleDimensionHandleSetPairVector(const RegionHandleDimensionHandleSetPairVector& value) noexcept
  { _regionHandleDimensionHandleSetPairVector = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setRegionHandleDimensionHandleSetPairVector(RegionHandleDimensionHandleSetPairVector&& value) noexcept
  { _regionHandleDimensionHandleSetPairVector = std::move(value); }
#endif
  RegionHandleDimensionHandleSetPairVector& getRegionHandleDimensionHandleSetPairVector() noexcept
  { return _regionHandleDimensionHandleSetPairVector; }
  const RegionHandleDimensionHandleSetPairVector& getRegionHandleDimensionHandleSetPairVector() const noexcept
  { return _regionHandleDimensionHandleSetPairVector; }

private:
  FederationHandle _federationHandle;
  RegionHandleDimensionHandleSetPairVector _regionHandleDimensionHandleSetPairVector;
};

class OPENRTI_API CommitRegionMessage final : public AbstractMessage {
public:
  CommitRegionMessage() noexcept;
  virtual ~CommitRegionMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const CommitRegionMessage& rhs) const noexcept;
  bool operator<(const CommitRegionMessage& rhs) const noexcept;
  bool operator!=(const CommitRegionMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const CommitRegionMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const CommitRegionMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const CommitRegionMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setRegionHandleRegionValuePairVector(const RegionHandleRegionValuePairVector& value) noexcept
  { _regionHandleRegionValuePairVector = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setRegionHandleRegionValuePairVector(RegionHandleRegionValuePairVector&& value) noexcept
  { _regionHandleRegionValuePairVector = std::move(value); }
#endif
  RegionHandleRegionValuePairVector& getRegionHandleRegionValuePairVector() noexcept
  { return _regionHandleRegionValuePairVector; }
  const RegionHandleRegionValuePairVector& getRegionHandleRegionValuePairVector() const noexcept
  { return _regionHandleRegionValuePairVector; }

private:
  FederationHandle _federationHandle;
  RegionHandleRegionValuePairVector _regionHandleRegionValuePairVector;
};

class OPENRTI_API EraseRegionMessage final : public AbstractMessage {
public:
  EraseRegionMessage() noexcept;
  virtual ~EraseRegionMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const EraseRegionMessage& rhs) const noexcept;
  bool operator<(const EraseRegionMessage& rhs) const noexcept;
  bool operator!=(const EraseRegionMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const EraseRegionMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const EraseRegionMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const EraseRegionMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setRegionHandleVector(const RegionHandleVector& value) noexcept
  { _regionHandleVector = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setRegionHandleVector(RegionHandleVector&& value) noexcept
  { _regionHandleVector = std::move(value); }
#endif
  RegionHandleVector& getRegionHandleVector() noexcept
  { return _regionHandleVector; }
  const RegionHandleVector& getRegionHandleVector() const noexcept
  { return _regionHandleVector; }

private:
  FederationHandle _federationHandle;
  RegionHandleVector _regionHandleVector;
};

class OPENRTI_API ChangeInteractionClassPublicationMessage final : public AbstractMessage {
public:
  ChangeInteractionClassPublicationMessage() noexcept;
  virtual ~ChangeInteractionClassPublicationMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const ChangeInteractionClassPublicationMessage& rhs) const noexcept;
  bool operator<(const ChangeInteractionClassPublicationMessage& rhs) const noexcept;
  bool operator!=(const ChangeInteractionClassPublicationMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const ChangeInteractionClassPublicationMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const ChangeInteractionClassPublicationMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const ChangeInteractionClassPublicationMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setPublicationType(const PublicationType& value) noexcept
  { _publicationType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setPublicationType(PublicationType&& value) noexcept
  { _publicationType = std::move(value); }
#endif
  PublicationType& getPublicationType() noexcept
  { return _publicationType; }
  const PublicationType& getPublicationType() const noexcept
  { return _publicationType; }

  void setInteractionClassHandle(const InteractionClassHandle& value) noexcept
  { _interactionClassHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setInteractionClassHandle(InteractionClassHandle&& value) noexcept
  { _interactionClassHandle = std::move(value); }
#endif
  InteractionClassHandle& getInteractionClassHandle() noexcept
  { return _interactionClassHandle; }
  const InteractionClassHandle& getInteractionClassHandle() const noexcept
  { return _interactionClassHandle; }

private:
  FederationHandle _federationHandle;
  PublicationType _publicationType;
  InteractionClassHandle _interactionClassHandle;
};

class OPENRTI_API ChangeObjectClassPublicationMessage final : public AbstractMessage {
public:
  ChangeObjectClassPublicationMessage() noexcept;
  virtual ~ChangeObjectClassPublicationMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const ChangeObjectClassPublicationMessage& rhs) const noexcept;
  bool operator<(const ChangeObjectClassPublicationMessage& rhs) const noexcept;
  bool operator!=(const ChangeObjectClassPublicationMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const ChangeObjectClassPublicationMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const ChangeObjectClassPublicationMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const ChangeObjectClassPublicationMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setPublicationType(const PublicationType& value) noexcept
  { _publicationType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setPublicationType(PublicationType&& value) noexcept
  { _publicationType = std::move(value); }
#endif
  PublicationType& getPublicationType() noexcept
  { return _publicationType; }
  const PublicationType& getPublicationType() const noexcept
  { return _publicationType; }

  void setObjectClassHandle(const ObjectClassHandle& value) noexcept
  { _objectClassHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setObjectClassHandle(ObjectClassHandle&& value) noexcept
  { _objectClassHandle = std::move(value); }
#endif
  ObjectClassHandle& getObjectClassHandle() noexcept
  { return _objectClassHandle; }
  const ObjectClassHandle& getObjectClassHandle() const noexcept
  { return _objectClassHandle; }

  void setAttributeHandles(const AttributeHandleVector& value) noexcept
  { _attributeHandles = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setAttributeHandles(AttributeHandleVector&& value) noexcept
  { _attributeHandles = std::move(value); }
#endif
  AttributeHandleVector& getAttributeHandles() noexcept
  { return _attributeHandles; }
  const AttributeHandleVector& getAttributeHandles() const noexcept
  { return _attributeHandles; }

private:
  FederationHandle _federationHandle;
  PublicationType _publicationType;
  ObjectClassHandle _objectClassHandle;
  AttributeHandleVector _attributeHandles;
};

class OPENRTI_API ChangeInteractionClassSubscriptionMessage final : public AbstractMessage {
public:
  ChangeInteractionClassSubscriptionMessage() noexcept;
  virtual ~ChangeInteractionClassSubscriptionMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const ChangeInteractionClassSubscriptionMessage& rhs) const noexcept;
  bool operator<(const ChangeInteractionClassSubscriptionMessage& rhs) const noexcept;
  bool operator!=(const ChangeInteractionClassSubscriptionMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const ChangeInteractionClassSubscriptionMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const ChangeInteractionClassSubscriptionMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const ChangeInteractionClassSubscriptionMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setSubscriptionType(const SubscriptionType& value) noexcept
  { _subscriptionType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setSubscriptionType(SubscriptionType&& value) noexcept
  { _subscriptionType = std::move(value); }
#endif
  SubscriptionType& getSubscriptionType() noexcept
  { return _subscriptionType; }
  const SubscriptionType& getSubscriptionType() const noexcept
  { return _subscriptionType; }

  void setInteractionClassHandle(const InteractionClassHandle& value) noexcept
  { _interactionClassHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setInteractionClassHandle(InteractionClassHandle&& value) noexcept
  { _interactionClassHandle = std::move(value); }
#endif
  InteractionClassHandle& getInteractionClassHandle() noexcept
  { return _interactionClassHandle; }
  const InteractionClassHandle& getInteractionClassHandle() const noexcept
  { return _interactionClassHandle; }

  void setParameterFilterValues(const ParameterValueVector& value) noexcept
  { _parameterFilterValues = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setParameterFilterValues(ParameterValueVector&& value) noexcept
  { _parameterFilterValues = std::move(value); }
#endif
  ParameterValueVector& getParameterFilterValues() noexcept
  { return _parameterFilterValues; }
  const ParameterValueVector& getParameterFilterValues() const noexcept
  { return _parameterFilterValues; }

private:
  FederationHandle _federationHandle;
  SubscriptionType _subscriptionType;
  InteractionClassHandle _interactionClassHandle;
  ParameterValueVector _parameterFilterValues;
};

class OPENRTI_API ChangeObjectClassSubscriptionMessage final : public AbstractMessage {
public:
  ChangeObjectClassSubscriptionMessage() noexcept;
  virtual ~ChangeObjectClassSubscriptionMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const ChangeObjectClassSubscriptionMessage& rhs) const noexcept;
  bool operator<(const ChangeObjectClassSubscriptionMessage& rhs) const noexcept;
  bool operator!=(const ChangeObjectClassSubscriptionMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const ChangeObjectClassSubscriptionMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const ChangeObjectClassSubscriptionMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const ChangeObjectClassSubscriptionMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setSubscriptionType(const SubscriptionType& value) noexcept
  { _subscriptionType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setSubscriptionType(SubscriptionType&& value) noexcept
  { _subscriptionType = std::move(value); }
#endif
  SubscriptionType& getSubscriptionType() noexcept
  { return _subscriptionType; }
  const SubscriptionType& getSubscriptionType() const noexcept
  { return _subscriptionType; }

  void setObjectClassHandle(const ObjectClassHandle& value) noexcept
  { _objectClassHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setObjectClassHandle(ObjectClassHandle&& value) noexcept
  { _objectClassHandle = std::move(value); }
#endif
  ObjectClassHandle& getObjectClassHandle() noexcept
  { return _objectClassHandle; }
  const ObjectClassHandle& getObjectClassHandle() const noexcept
  { return _objectClassHandle; }

  void setAttributeHandles(const AttributeHandleVector& value) noexcept
  { _attributeHandles = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setAttributeHandles(AttributeHandleVector&& value) noexcept
  { _attributeHandles = std::move(value); }
#endif
  AttributeHandleVector& getAttributeHandles() noexcept
  { return _attributeHandles; }
  const AttributeHandleVector& getAttributeHandles() const noexcept
  { return _attributeHandles; }

private:
  FederationHandle _federationHandle;
  SubscriptionType _subscriptionType;
  ObjectClassHandle _objectClassHandle;
  AttributeHandleVector _attributeHandles;
};

class OPENRTI_API ChangeObjectInstanceSubscriptionMessage final : public AbstractMessage {
public:
  ChangeObjectInstanceSubscriptionMessage() noexcept;
  virtual ~ChangeObjectInstanceSubscriptionMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const ChangeObjectInstanceSubscriptionMessage& rhs) const noexcept;
  bool operator<(const ChangeObjectInstanceSubscriptionMessage& rhs) const noexcept;
  bool operator!=(const ChangeObjectInstanceSubscriptionMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const ChangeObjectInstanceSubscriptionMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const ChangeObjectInstanceSubscriptionMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const ChangeObjectInstanceSubscriptionMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setSubscriptionType(const SubscriptionType& value) noexcept
  { _subscriptionType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setSubscriptionType(SubscriptionType&& value) noexcept
  { _subscriptionType = std::move(value); }
#endif
  SubscriptionType& getSubscriptionType() noexcept
  { return _subscriptionType; }
  const SubscriptionType& getSubscriptionType() const noexcept
  { return _subscriptionType; }

  void setObjectClassHandle(const ObjectClassHandle& value) noexcept
  { _objectClassHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setObjectClassHandle(ObjectClassHandle&& value) noexcept
  { _objectClassHandle = std::move(value); }
#endif
  ObjectClassHandle& getObjectClassHandle() noexcept
  { return _objectClassHandle; }
  const ObjectClassHandle& getObjectClassHandle() const noexcept
  { return _objectClassHandle; }

  void setObjectInstanceHandle(const ObjectInstanceHandle& value) noexcept
  { _objectInstanceHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setObjectInstanceHandle(ObjectInstanceHandle&& value) noexcept
  { _objectInstanceHandle = std::move(value); }
#endif
  ObjectInstanceHandle& getObjectInstanceHandle() noexcept
  { return _objectInstanceHandle; }
  const ObjectInstanceHandle& getObjectInstanceHandle() const noexcept
  { return _objectInstanceHandle; }

private:
  FederationHandle _federationHandle;
  SubscriptionType _subscriptionType;
  ObjectClassHandle _objectClassHandle;
  ObjectInstanceHandle _objectInstanceHandle;
};

class OPENRTI_API RegistrationForObjectClassMessage final : public AbstractMessage {
public:
  RegistrationForObjectClassMessage() noexcept;
  virtual ~RegistrationForObjectClassMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const RegistrationForObjectClassMessage& rhs) const noexcept;
  bool operator<(const RegistrationForObjectClassMessage& rhs) const noexcept;
  bool operator!=(const RegistrationForObjectClassMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const RegistrationForObjectClassMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const RegistrationForObjectClassMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const RegistrationForObjectClassMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setObjectClassHandle(const ObjectClassHandle& value) noexcept
  { _objectClassHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setObjectClassHandle(ObjectClassHandle&& value) noexcept
  { _objectClassHandle = std::move(value); }
#endif
  ObjectClassHandle& getObjectClassHandle() noexcept
  { return _objectClassHandle; }
  const ObjectClassHandle& getObjectClassHandle() const noexcept
  { return _objectClassHandle; }

  void setStart(const Bool& value) noexcept
  { _start = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setStart(Bool&& value) noexcept
  { _start = std::move(value); }
#endif
  Bool& getStart() noexcept
  { return _start; }
  const Bool& getStart() const noexcept
  { return _start; }

private:
  ObjectClassHandle _objectClassHandle;
  Bool _start;
};

class OPENRTI_API AttributesInScopeMessage final : public AbstractMessage {
public:
  AttributesInScopeMessage() noexcept;
  virtual ~AttributesInScopeMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const AttributesInScopeMessage& rhs) const noexcept;
  bool operator<(const AttributesInScopeMessage& rhs) const noexcept;
  bool operator!=(const AttributesInScopeMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const AttributesInScopeMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const AttributesInScopeMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const AttributesInScopeMessage& rhs) const noexcept
  { return !operator>(rhs); }

  virtual ObjectInstanceHandle getObjectInstanceHandleForMessage() const noexcept override;

  void setObjectInstanceHandle(const ObjectInstanceHandle& value) noexcept
  { _objectInstanceHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setObjectInstanceHandle(ObjectInstanceHandle&& value) noexcept
  { _objectInstanceHandle = std::move(value); }
#endif
  ObjectInstanceHandle& getObjectInstanceHandle() noexcept
  { return _objectInstanceHandle; }
  const ObjectInstanceHandle& getObjectInstanceHandle() const noexcept
  { return _objectInstanceHandle; }

  void setAttributeHandles(const AttributeHandleVector& value) noexcept
  { _attributeHandles = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setAttributeHandles(AttributeHandleVector&& value) noexcept
  { _attributeHandles = std::move(value); }
#endif
  AttributeHandleVector& getAttributeHandles() noexcept
  { return _attributeHandles; }
  const AttributeHandleVector& getAttributeHandles() const noexcept
  { return _attributeHandles; }

  void setInScope(const Bool& value) noexcept
  { _inScope = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setInScope(Bool&& value) noexcept
  { _inScope = std::move(value); }
#endif
  Bool& getInScope() noexcept
  { return _inScope; }
  const Bool& getInScope() const noexcept
  { return _inScope; }

private:
  ObjectInstanceHandle _objectInstanceHandle;
  AttributeHandleVector _attributeHandles;
  Bool _inScope;
};

class OPENRTI_API TurnUpdatesOnForInstanceMessage final : public AbstractMessage {
public:
  TurnUpdatesOnForInstanceMessage() noexcept;
  virtual ~TurnUpdatesOnForInstanceMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const TurnUpdatesOnForInstanceMessage& rhs) const noexcept;
  bool operator<(const TurnUpdatesOnForInstanceMessage& rhs) const noexcept;
  bool operator!=(const TurnUpdatesOnForInstanceMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const TurnUpdatesOnForInstanceMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const TurnUpdatesOnForInstanceMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const TurnUpdatesOnForInstanceMessage& rhs) const noexcept
  { return !operator>(rhs); }

  virtual ObjectInstanceHandle getObjectInstanceHandleForMessage() const noexcept override;

  void setObjectInstanceHandle(const ObjectInstanceHandle& value) noexcept
  { _objectInstanceHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setObjectInstanceHandle(ObjectInstanceHandle&& value) noexcept
  { _objectInstanceHandle = std::move(value); }
#endif
  ObjectInstanceHandle& getObjectInstanceHandle() noexcept
  { return _objectInstanceHandle; }
  const ObjectInstanceHandle& getObjectInstanceHandle() const noexcept
  { return _objectInstanceHandle; }

  void setAttributeHandles(const AttributeHandleVector& value) noexcept
  { _attributeHandles = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setAttributeHandles(AttributeHandleVector&& value) noexcept
  { _attributeHandles = std::move(value); }
#endif
  AttributeHandleVector& getAttributeHandles() noexcept
  { return _attributeHandles; }
  const AttributeHandleVector& getAttributeHandles() const noexcept
  { return _attributeHandles; }

  void setUpdateRate(const String& value) noexcept
  { _updateRate = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setUpdateRate(String&& value) noexcept
  { _updateRate = std::move(value); }
#endif
  String& getUpdateRate() noexcept
  { return _updateRate; }
  const String& getUpdateRate() const noexcept
  { return _updateRate; }

  void setOn(const Bool& value) noexcept
  { _on = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setOn(Bool&& value) noexcept
  { _on = std::move(value); }
#endif
  Bool& getOn() noexcept
  { return _on; }
  const Bool& getOn() const noexcept
  { return _on; }

private:
  ObjectInstanceHandle _objectInstanceHandle;
  AttributeHandleVector _attributeHandles;
  String _updateRate;
  Bool _on;
};

class OPENRTI_API TurnInteractionsOnMessage final : public AbstractMessage {
public:
  TurnInteractionsOnMessage() noexcept;
  virtual ~TurnInteractionsOnMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const TurnInteractionsOnMessage& rhs) const noexcept;
  bool operator<(const TurnInteractionsOnMessage& rhs) const noexcept;
  bool operator!=(const TurnInteractionsOnMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const TurnInteractionsOnMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const TurnInteractionsOnMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const TurnInteractionsOnMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setInteractionClassHandle(const InteractionClassHandle& value) noexcept
  { _interactionClassHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setInteractionClassHandle(InteractionClassHandle&& value) noexcept
  { _interactionClassHandle = std::move(value); }
#endif
  InteractionClassHandle& getInteractionClassHandle() noexcept
  { return _interactionClassHandle; }
  const InteractionClassHandle& getInteractionClassHandle() const noexcept
  { return _interactionClassHandle; }

  void setOn(const Bool& value) noexcept
  { _on = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setOn(Bool&& value) noexcept
  { _on = std::move(value); }
#endif
  Bool& getOn() noexcept
  { return _on; }
  const Bool& getOn() const noexcept
  { return _on; }

private:
  InteractionClassHandle _interactionClassHandle;
  Bool _on;
};

class OPENRTI_API InteractionMessage final : public AbstractMessage {
public:
  InteractionMessage() noexcept;
  virtual ~InteractionMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const InteractionMessage& rhs) const noexcept;
  bool operator<(const InteractionMessage& rhs) const noexcept;
  bool operator!=(const InteractionMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const InteractionMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const InteractionMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const InteractionMessage& rhs) const noexcept
  { return !operator>(rhs); }

  bool getReliable() const noexcept override;

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

  void setInteractionClassHandle(const InteractionClassHandle& value) noexcept
  { _interactionClassHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setInteractionClassHandle(InteractionClassHandle&& value) noexcept
  { _interactionClassHandle = std::move(value); }
#endif
  InteractionClassHandle& getInteractionClassHandle() noexcept
  { return _interactionClassHandle; }
  const InteractionClassHandle& getInteractionClassHandle() const noexcept
  { return _interactionClassHandle; }

  void setTransportationType(const TransportationType& value) noexcept
  { _transportationType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTransportationType(TransportationType&& value) noexcept
  { _transportationType = std::move(value); }
#endif
  TransportationType& getTransportationType() noexcept
  { return _transportationType; }
  const TransportationType& getTransportationType() const noexcept
  { return _transportationType; }

  void setTag(const VariableLengthData& value) noexcept
  { _tag = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTag(VariableLengthData&& value) noexcept
  { _tag = std::move(value); }
#endif
  VariableLengthData& getTag() noexcept
  { return _tag; }
  const VariableLengthData& getTag() const noexcept
  { return _tag; }

  void setParameterValues(const ParameterValueVector& value) noexcept
  { _parameterValues = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setParameterValues(ParameterValueVector&& value) noexcept
  { _parameterValues = std::move(value); }
#endif
  ParameterValueVector& getParameterValues() noexcept
  { return _parameterValues; }
  const ParameterValueVector& getParameterValues() const noexcept
  { return _parameterValues; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
  InteractionClassHandle _interactionClassHandle;
  TransportationType _transportationType;
  VariableLengthData _tag;
  ParameterValueVector _parameterValues;
};

class OPENRTI_API TimeStampedInteractionMessage final : public AbstractMessage {
public:
  TimeStampedInteractionMessage() noexcept;
  virtual ~TimeStampedInteractionMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const TimeStampedInteractionMessage& rhs) const noexcept;
  bool operator<(const TimeStampedInteractionMessage& rhs) const noexcept;
  bool operator!=(const TimeStampedInteractionMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const TimeStampedInteractionMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const TimeStampedInteractionMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const TimeStampedInteractionMessage& rhs) const noexcept
  { return !operator>(rhs); }

  bool getReliable() const noexcept override;

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

  void setInteractionClassHandle(const InteractionClassHandle& value) noexcept
  { _interactionClassHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setInteractionClassHandle(InteractionClassHandle&& value) noexcept
  { _interactionClassHandle = std::move(value); }
#endif
  InteractionClassHandle& getInteractionClassHandle() noexcept
  { return _interactionClassHandle; }
  const InteractionClassHandle& getInteractionClassHandle() const noexcept
  { return _interactionClassHandle; }

  void setOrderType(const OrderType& value) noexcept
  { _orderType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setOrderType(OrderType&& value) noexcept
  { _orderType = std::move(value); }
#endif
  OrderType& getOrderType() noexcept
  { return _orderType; }
  const OrderType& getOrderType() const noexcept
  { return _orderType; }

  void setTransportationType(const TransportationType& value) noexcept
  { _transportationType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTransportationType(TransportationType&& value) noexcept
  { _transportationType = std::move(value); }
#endif
  TransportationType& getTransportationType() noexcept
  { return _transportationType; }
  const TransportationType& getTransportationType() const noexcept
  { return _transportationType; }

  void setTag(const VariableLengthData& value) noexcept
  { _tag = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTag(VariableLengthData&& value) noexcept
  { _tag = std::move(value); }
#endif
  VariableLengthData& getTag() noexcept
  { return _tag; }
  const VariableLengthData& getTag() const noexcept
  { return _tag; }

  void setTimeStamp(const VariableLengthData& value) noexcept
  { _timeStamp = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTimeStamp(VariableLengthData&& value) noexcept
  { _timeStamp = std::move(value); }
#endif
  VariableLengthData& getTimeStamp() noexcept
  { return _timeStamp; }
  const VariableLengthData& getTimeStamp() const noexcept
  { return _timeStamp; }

  void setMessageRetractionHandle(const MessageRetractionHandle& value) noexcept
  { _messageRetractionHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setMessageRetractionHandle(MessageRetractionHandle&& value) noexcept
  { _messageRetractionHandle = std::move(value); }
#endif
  MessageRetractionHandle& getMessageRetractionHandle() noexcept
  { return _messageRetractionHandle; }
  const MessageRetractionHandle& getMessageRetractionHandle() const noexcept
  { return _messageRetractionHandle; }

  void setParameterValues(const ParameterValueVector& value) noexcept
  { _parameterValues = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setParameterValues(ParameterValueVector&& value) noexcept
  { _parameterValues = std::move(value); }
#endif
  ParameterValueVector& getParameterValues() noexcept
  { return _parameterValues; }
  const ParameterValueVector& getParameterValues() const noexcept
  { return _parameterValues; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
  InteractionClassHandle _interactionClassHandle;
  OrderType _orderType;
  TransportationType _transportationType;
  VariableLengthData _tag;
  VariableLengthData _timeStamp;
  MessageRetractionHandle _messageRetractionHandle;
  ParameterValueVector _parameterValues;
};

class OPENRTI_API ObjectInstanceHandlesRequestMessage final : public AbstractMessage {
public:
  ObjectInstanceHandlesRequestMessage() noexcept;
  virtual ~ObjectInstanceHandlesRequestMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const ObjectInstanceHandlesRequestMessage& rhs) const noexcept;
  bool operator<(const ObjectInstanceHandlesRequestMessage& rhs) const noexcept;
  bool operator!=(const ObjectInstanceHandlesRequestMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const ObjectInstanceHandlesRequestMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const ObjectInstanceHandlesRequestMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const ObjectInstanceHandlesRequestMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

  void setCount(const Unsigned& value) noexcept
  { _count = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setCount(Unsigned&& value) noexcept
  { _count = std::move(value); }
#endif
  Unsigned& getCount() noexcept
  { return _count; }
  const Unsigned& getCount() const noexcept
  { return _count; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
  Unsigned _count;
};

class OPENRTI_API ObjectInstanceHandlesResponseMessage final : public AbstractMessage {
public:
  ObjectInstanceHandlesResponseMessage() noexcept;
  virtual ~ObjectInstanceHandlesResponseMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const ObjectInstanceHandlesResponseMessage& rhs) const noexcept;
  bool operator<(const ObjectInstanceHandlesResponseMessage& rhs) const noexcept;
  bool operator!=(const ObjectInstanceHandlesResponseMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const ObjectInstanceHandlesResponseMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const ObjectInstanceHandlesResponseMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const ObjectInstanceHandlesResponseMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

  void setObjectInstanceHandleNamePairVector(const ObjectInstanceHandleNamePairVector& value) noexcept
  { _objectInstanceHandleNamePairVector = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setObjectInstanceHandleNamePairVector(ObjectInstanceHandleNamePairVector&& value) noexcept
  { _objectInstanceHandleNamePairVector = std::move(value); }
#endif
  ObjectInstanceHandleNamePairVector& getObjectInstanceHandleNamePairVector() noexcept
  { return _objectInstanceHandleNamePairVector; }
  const ObjectInstanceHandleNamePairVector& getObjectInstanceHandleNamePairVector() const noexcept
  { return _objectInstanceHandleNamePairVector; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
  ObjectInstanceHandleNamePairVector _objectInstanceHandleNamePairVector;
};

class OPENRTI_API ReleaseMultipleObjectInstanceNameHandlePairsMessage final : public AbstractMessage {
public:
  ReleaseMultipleObjectInstanceNameHandlePairsMessage() noexcept;
  virtual ~ReleaseMultipleObjectInstanceNameHandlePairsMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const ReleaseMultipleObjectInstanceNameHandlePairsMessage& rhs) const noexcept;
  bool operator<(const ReleaseMultipleObjectInstanceNameHandlePairsMessage& rhs) const noexcept;
  bool operator!=(const ReleaseMultipleObjectInstanceNameHandlePairsMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const ReleaseMultipleObjectInstanceNameHandlePairsMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const ReleaseMultipleObjectInstanceNameHandlePairsMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const ReleaseMultipleObjectInstanceNameHandlePairsMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setObjectInstanceHandleVector(const ObjectInstanceHandleVector& value) noexcept
  { _objectInstanceHandleVector = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setObjectInstanceHandleVector(ObjectInstanceHandleVector&& value) noexcept
  { _objectInstanceHandleVector = std::move(value); }
#endif
  ObjectInstanceHandleVector& getObjectInstanceHandleVector() noexcept
  { return _objectInstanceHandleVector; }
  const ObjectInstanceHandleVector& getObjectInstanceHandleVector() const noexcept
  { return _objectInstanceHandleVector; }

private:
  FederationHandle _federationHandle;
  ObjectInstanceHandleVector _objectInstanceHandleVector;
};

class OPENRTI_API ReserveObjectInstanceNameRequestMessage final : public AbstractMessage {
public:
  ReserveObjectInstanceNameRequestMessage() noexcept;
  virtual ~ReserveObjectInstanceNameRequestMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const ReserveObjectInstanceNameRequestMessage& rhs) const noexcept;
  bool operator<(const ReserveObjectInstanceNameRequestMessage& rhs) const noexcept;
  bool operator!=(const ReserveObjectInstanceNameRequestMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const ReserveObjectInstanceNameRequestMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const ReserveObjectInstanceNameRequestMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const ReserveObjectInstanceNameRequestMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

  void setName(const String& value) noexcept
  { _name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(String&& value) noexcept
  { _name = std::move(value); }
#endif
  String& getName() noexcept
  { return _name; }
  const String& getName() const noexcept
  { return _name; }

  void setIsInternal(const Bool& value) noexcept
  { _isInternal = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setIsInternal(Bool&& value) noexcept
  { _isInternal = std::move(value); }
#endif
  Bool& getIsInternal() noexcept
  { return _isInternal; }
  const Bool& getIsInternal() const noexcept
  { return _isInternal; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
  String _name;
  Bool _isInternal;
};

class OPENRTI_API ReserveObjectInstanceNameResponseMessage final : public AbstractMessage {
public:
  ReserveObjectInstanceNameResponseMessage() noexcept;
  virtual ~ReserveObjectInstanceNameResponseMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const ReserveObjectInstanceNameResponseMessage& rhs) const noexcept;
  bool operator<(const ReserveObjectInstanceNameResponseMessage& rhs) const noexcept;
  bool operator!=(const ReserveObjectInstanceNameResponseMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const ReserveObjectInstanceNameResponseMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const ReserveObjectInstanceNameResponseMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const ReserveObjectInstanceNameResponseMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

  void setObjectInstanceHandleNamePair(const ObjectInstanceHandleNamePair& value) noexcept
  { _objectInstanceHandleNamePair = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setObjectInstanceHandleNamePair(ObjectInstanceHandleNamePair&& value) noexcept
  { _objectInstanceHandleNamePair = std::move(value); }
#endif
  ObjectInstanceHandleNamePair& getObjectInstanceHandleNamePair() noexcept
  { return _objectInstanceHandleNamePair; }
  const ObjectInstanceHandleNamePair& getObjectInstanceHandleNamePair() const noexcept
  { return _objectInstanceHandleNamePair; }

  void setSuccess(const Bool& value) noexcept
  { _success = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setSuccess(Bool&& value) noexcept
  { _success = std::move(value); }
#endif
  Bool& getSuccess() noexcept
  { return _success; }
  const Bool& getSuccess() const noexcept
  { return _success; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
  ObjectInstanceHandleNamePair _objectInstanceHandleNamePair;
  Bool _success;
};

class OPENRTI_API ReserveMultipleObjectInstanceNameRequestMessage final : public AbstractMessage {
public:
  ReserveMultipleObjectInstanceNameRequestMessage() noexcept;
  virtual ~ReserveMultipleObjectInstanceNameRequestMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const ReserveMultipleObjectInstanceNameRequestMessage& rhs) const noexcept;
  bool operator<(const ReserveMultipleObjectInstanceNameRequestMessage& rhs) const noexcept;
  bool operator!=(const ReserveMultipleObjectInstanceNameRequestMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const ReserveMultipleObjectInstanceNameRequestMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const ReserveMultipleObjectInstanceNameRequestMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const ReserveMultipleObjectInstanceNameRequestMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

  void setNameList(const StringVector& value) noexcept
  { _nameList = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setNameList(StringVector&& value) noexcept
  { _nameList = std::move(value); }
#endif
  StringVector& getNameList() noexcept
  { return _nameList; }
  const StringVector& getNameList() const noexcept
  { return _nameList; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
  StringVector _nameList;
};

class OPENRTI_API ReserveMultipleObjectInstanceNameResponseMessage final : public AbstractMessage {
public:
  ReserveMultipleObjectInstanceNameResponseMessage() noexcept;
  virtual ~ReserveMultipleObjectInstanceNameResponseMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const ReserveMultipleObjectInstanceNameResponseMessage& rhs) const noexcept;
  bool operator<(const ReserveMultipleObjectInstanceNameResponseMessage& rhs) const noexcept;
  bool operator!=(const ReserveMultipleObjectInstanceNameResponseMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const ReserveMultipleObjectInstanceNameResponseMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const ReserveMultipleObjectInstanceNameResponseMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const ReserveMultipleObjectInstanceNameResponseMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

  void setObjectInstanceHandleNamePairVector(const ObjectInstanceHandleNamePairVector& value) noexcept
  { _objectInstanceHandleNamePairVector = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setObjectInstanceHandleNamePairVector(ObjectInstanceHandleNamePairVector&& value) noexcept
  { _objectInstanceHandleNamePairVector = std::move(value); }
#endif
  ObjectInstanceHandleNamePairVector& getObjectInstanceHandleNamePairVector() noexcept
  { return _objectInstanceHandleNamePairVector; }
  const ObjectInstanceHandleNamePairVector& getObjectInstanceHandleNamePairVector() const noexcept
  { return _objectInstanceHandleNamePairVector; }

  void setSuccess(const Bool& value) noexcept
  { _success = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setSuccess(Bool&& value) noexcept
  { _success = std::move(value); }
#endif
  Bool& getSuccess() noexcept
  { return _success; }
  const Bool& getSuccess() const noexcept
  { return _success; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
  ObjectInstanceHandleNamePairVector _objectInstanceHandleNamePairVector;
  Bool _success;
};

class OPENRTI_API InsertObjectInstanceMessage final : public AbstractMessage {
public:
  InsertObjectInstanceMessage() noexcept;
  virtual ~InsertObjectInstanceMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const InsertObjectInstanceMessage& rhs) const noexcept;
  bool operator<(const InsertObjectInstanceMessage& rhs) const noexcept;
  bool operator!=(const InsertObjectInstanceMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const InsertObjectInstanceMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const InsertObjectInstanceMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const InsertObjectInstanceMessage& rhs) const noexcept
  { return !operator>(rhs); }

  virtual ObjectInstanceHandle getObjectInstanceHandleForMessage() const noexcept override;

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setObjectClassHandle(const ObjectClassHandle& value) noexcept
  { _objectClassHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setObjectClassHandle(ObjectClassHandle&& value) noexcept
  { _objectClassHandle = std::move(value); }
#endif
  ObjectClassHandle& getObjectClassHandle() noexcept
  { return _objectClassHandle; }
  const ObjectClassHandle& getObjectClassHandle() const noexcept
  { return _objectClassHandle; }

  void setObjectInstanceHandle(const ObjectInstanceHandle& value) noexcept
  { _objectInstanceHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setObjectInstanceHandle(ObjectInstanceHandle&& value) noexcept
  { _objectInstanceHandle = std::move(value); }
#endif
  ObjectInstanceHandle& getObjectInstanceHandle() noexcept
  { return _objectInstanceHandle; }
  const ObjectInstanceHandle& getObjectInstanceHandle() const noexcept
  { return _objectInstanceHandle; }

  void setName(const String& value) noexcept
  { _name = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setName(String&& value) noexcept
  { _name = std::move(value); }
#endif
  String& getName() noexcept
  { return _name; }
  const String& getName() const noexcept
  { return _name; }

  void setAttributeStateVector(const AttributeStateVector& value) noexcept
  { _attributeStateVector = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setAttributeStateVector(AttributeStateVector&& value) noexcept
  { _attributeStateVector = std::move(value); }
#endif
  AttributeStateVector& getAttributeStateVector() noexcept
  { return _attributeStateVector; }
  const AttributeStateVector& getAttributeStateVector() const noexcept
  { return _attributeStateVector; }

private:
  FederationHandle _federationHandle;
  ObjectClassHandle _objectClassHandle;
  ObjectInstanceHandle _objectInstanceHandle;
  String _name;
  AttributeStateVector _attributeStateVector;
};

class OPENRTI_API DeleteObjectInstanceMessage final : public AbstractMessage {
public:
  DeleteObjectInstanceMessage() noexcept;
  virtual ~DeleteObjectInstanceMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const DeleteObjectInstanceMessage& rhs) const noexcept;
  bool operator<(const DeleteObjectInstanceMessage& rhs) const noexcept;
  bool operator!=(const DeleteObjectInstanceMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const DeleteObjectInstanceMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const DeleteObjectInstanceMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const DeleteObjectInstanceMessage& rhs) const noexcept
  { return !operator>(rhs); }

  virtual ObjectInstanceHandle getObjectInstanceHandleForMessage() const noexcept override;

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

  void setObjectInstanceHandle(const ObjectInstanceHandle& value) noexcept
  { _objectInstanceHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setObjectInstanceHandle(ObjectInstanceHandle&& value) noexcept
  { _objectInstanceHandle = std::move(value); }
#endif
  ObjectInstanceHandle& getObjectInstanceHandle() noexcept
  { return _objectInstanceHandle; }
  const ObjectInstanceHandle& getObjectInstanceHandle() const noexcept
  { return _objectInstanceHandle; }

  void setTag(const VariableLengthData& value) noexcept
  { _tag = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTag(VariableLengthData&& value) noexcept
  { _tag = std::move(value); }
#endif
  VariableLengthData& getTag() noexcept
  { return _tag; }
  const VariableLengthData& getTag() const noexcept
  { return _tag; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
  ObjectInstanceHandle _objectInstanceHandle;
  VariableLengthData _tag;
};

class OPENRTI_API TimeStampedDeleteObjectInstanceMessage final : public AbstractMessage {
public:
  TimeStampedDeleteObjectInstanceMessage() noexcept;
  virtual ~TimeStampedDeleteObjectInstanceMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const TimeStampedDeleteObjectInstanceMessage& rhs) const noexcept;
  bool operator<(const TimeStampedDeleteObjectInstanceMessage& rhs) const noexcept;
  bool operator!=(const TimeStampedDeleteObjectInstanceMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const TimeStampedDeleteObjectInstanceMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const TimeStampedDeleteObjectInstanceMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const TimeStampedDeleteObjectInstanceMessage& rhs) const noexcept
  { return !operator>(rhs); }

  virtual ObjectInstanceHandle getObjectInstanceHandleForMessage() const noexcept override;

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

  void setObjectInstanceHandle(const ObjectInstanceHandle& value) noexcept
  { _objectInstanceHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setObjectInstanceHandle(ObjectInstanceHandle&& value) noexcept
  { _objectInstanceHandle = std::move(value); }
#endif
  ObjectInstanceHandle& getObjectInstanceHandle() noexcept
  { return _objectInstanceHandle; }
  const ObjectInstanceHandle& getObjectInstanceHandle() const noexcept
  { return _objectInstanceHandle; }

  void setOrderType(const OrderType& value) noexcept
  { _orderType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setOrderType(OrderType&& value) noexcept
  { _orderType = std::move(value); }
#endif
  OrderType& getOrderType() noexcept
  { return _orderType; }
  const OrderType& getOrderType() const noexcept
  { return _orderType; }

  void setTag(const VariableLengthData& value) noexcept
  { _tag = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTag(VariableLengthData&& value) noexcept
  { _tag = std::move(value); }
#endif
  VariableLengthData& getTag() noexcept
  { return _tag; }
  const VariableLengthData& getTag() const noexcept
  { return _tag; }

  void setTimeStamp(const VariableLengthData& value) noexcept
  { _timeStamp = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTimeStamp(VariableLengthData&& value) noexcept
  { _timeStamp = std::move(value); }
#endif
  VariableLengthData& getTimeStamp() noexcept
  { return _timeStamp; }
  const VariableLengthData& getTimeStamp() const noexcept
  { return _timeStamp; }

  void setMessageRetractionHandle(const MessageRetractionHandle& value) noexcept
  { _messageRetractionHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setMessageRetractionHandle(MessageRetractionHandle&& value) noexcept
  { _messageRetractionHandle = std::move(value); }
#endif
  MessageRetractionHandle& getMessageRetractionHandle() noexcept
  { return _messageRetractionHandle; }
  const MessageRetractionHandle& getMessageRetractionHandle() const noexcept
  { return _messageRetractionHandle; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
  ObjectInstanceHandle _objectInstanceHandle;
  OrderType _orderType;
  VariableLengthData _tag;
  VariableLengthData _timeStamp;
  MessageRetractionHandle _messageRetractionHandle;
};

class OPENRTI_API AttributeUpdateMessage final : public AbstractMessage {
public:
  AttributeUpdateMessage() noexcept;
  virtual ~AttributeUpdateMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const AttributeUpdateMessage& rhs) const noexcept;
  bool operator<(const AttributeUpdateMessage& rhs) const noexcept;
  bool operator!=(const AttributeUpdateMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const AttributeUpdateMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const AttributeUpdateMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const AttributeUpdateMessage& rhs) const noexcept
  { return !operator>(rhs); }

  bool getReliable() const noexcept override;

  virtual ObjectInstanceHandle getObjectInstanceHandleForMessage() const noexcept override;

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

  void setObjectInstanceHandle(const ObjectInstanceHandle& value) noexcept
  { _objectInstanceHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setObjectInstanceHandle(ObjectInstanceHandle&& value) noexcept
  { _objectInstanceHandle = std::move(value); }
#endif
  ObjectInstanceHandle& getObjectInstanceHandle() noexcept
  { return _objectInstanceHandle; }
  const ObjectInstanceHandle& getObjectInstanceHandle() const noexcept
  { return _objectInstanceHandle; }

  void setTag(const VariableLengthData& value) noexcept
  { _tag = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTag(VariableLengthData&& value) noexcept
  { _tag = std::move(value); }
#endif
  VariableLengthData& getTag() noexcept
  { return _tag; }
  const VariableLengthData& getTag() const noexcept
  { return _tag; }

  void setTransportationType(const TransportationType& value) noexcept
  { _transportationType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTransportationType(TransportationType&& value) noexcept
  { _transportationType = std::move(value); }
#endif
  TransportationType& getTransportationType() noexcept
  { return _transportationType; }
  const TransportationType& getTransportationType() const noexcept
  { return _transportationType; }

  void setAttributeValues(const AttributeValueVector& value) noexcept
  { _attributeValues = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setAttributeValues(AttributeValueVector&& value) noexcept
  { _attributeValues = std::move(value); }
#endif
  AttributeValueVector& getAttributeValues() noexcept
  { return _attributeValues; }
  const AttributeValueVector& getAttributeValues() const noexcept
  { return _attributeValues; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
  ObjectInstanceHandle _objectInstanceHandle;
  VariableLengthData _tag;
  TransportationType _transportationType;
  AttributeValueVector _attributeValues;
};

class OPENRTI_API TimeStampedAttributeUpdateMessage final : public AbstractMessage {
public:
  TimeStampedAttributeUpdateMessage() noexcept;
  virtual ~TimeStampedAttributeUpdateMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const TimeStampedAttributeUpdateMessage& rhs) const noexcept;
  bool operator<(const TimeStampedAttributeUpdateMessage& rhs) const noexcept;
  bool operator!=(const TimeStampedAttributeUpdateMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const TimeStampedAttributeUpdateMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const TimeStampedAttributeUpdateMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const TimeStampedAttributeUpdateMessage& rhs) const noexcept
  { return !operator>(rhs); }

  bool getReliable() const noexcept override;

  virtual ObjectInstanceHandle getObjectInstanceHandleForMessage() const noexcept override;

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setFederateHandle(const FederateHandle& value) noexcept
  { _federateHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederateHandle(FederateHandle&& value) noexcept
  { _federateHandle = std::move(value); }
#endif
  FederateHandle& getFederateHandle() noexcept
  { return _federateHandle; }
  const FederateHandle& getFederateHandle() const noexcept
  { return _federateHandle; }

  void setObjectInstanceHandle(const ObjectInstanceHandle& value) noexcept
  { _objectInstanceHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setObjectInstanceHandle(ObjectInstanceHandle&& value) noexcept
  { _objectInstanceHandle = std::move(value); }
#endif
  ObjectInstanceHandle& getObjectInstanceHandle() noexcept
  { return _objectInstanceHandle; }
  const ObjectInstanceHandle& getObjectInstanceHandle() const noexcept
  { return _objectInstanceHandle; }

  void setTag(const VariableLengthData& value) noexcept
  { _tag = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTag(VariableLengthData&& value) noexcept
  { _tag = std::move(value); }
#endif
  VariableLengthData& getTag() noexcept
  { return _tag; }
  const VariableLengthData& getTag() const noexcept
  { return _tag; }

  void setTimeStamp(const VariableLengthData& value) noexcept
  { _timeStamp = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTimeStamp(VariableLengthData&& value) noexcept
  { _timeStamp = std::move(value); }
#endif
  VariableLengthData& getTimeStamp() noexcept
  { return _timeStamp; }
  const VariableLengthData& getTimeStamp() const noexcept
  { return _timeStamp; }

  void setMessageRetractionHandle(const MessageRetractionHandle& value) noexcept
  { _messageRetractionHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setMessageRetractionHandle(MessageRetractionHandle&& value) noexcept
  { _messageRetractionHandle = std::move(value); }
#endif
  MessageRetractionHandle& getMessageRetractionHandle() noexcept
  { return _messageRetractionHandle; }
  const MessageRetractionHandle& getMessageRetractionHandle() const noexcept
  { return _messageRetractionHandle; }

  void setOrderType(const OrderType& value) noexcept
  { _orderType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setOrderType(OrderType&& value) noexcept
  { _orderType = std::move(value); }
#endif
  OrderType& getOrderType() noexcept
  { return _orderType; }
  const OrderType& getOrderType() const noexcept
  { return _orderType; }

  void setTransportationType(const TransportationType& value) noexcept
  { _transportationType = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTransportationType(TransportationType&& value) noexcept
  { _transportationType = std::move(value); }
#endif
  TransportationType& getTransportationType() noexcept
  { return _transportationType; }
  const TransportationType& getTransportationType() const noexcept
  { return _transportationType; }

  void setAttributeValues(const AttributeValueVector& value) noexcept
  { _attributeValues = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setAttributeValues(AttributeValueVector&& value) noexcept
  { _attributeValues = std::move(value); }
#endif
  AttributeValueVector& getAttributeValues() noexcept
  { return _attributeValues; }
  const AttributeValueVector& getAttributeValues() const noexcept
  { return _attributeValues; }

private:
  FederationHandle _federationHandle;
  FederateHandle _federateHandle;
  ObjectInstanceHandle _objectInstanceHandle;
  VariableLengthData _tag;
  VariableLengthData _timeStamp;
  MessageRetractionHandle _messageRetractionHandle;
  OrderType _orderType;
  TransportationType _transportationType;
  AttributeValueVector _attributeValues;
};

class OPENRTI_API RequestAttributeUpdateMessage final : public AbstractMessage {
public:
  RequestAttributeUpdateMessage() noexcept;
  virtual ~RequestAttributeUpdateMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const RequestAttributeUpdateMessage& rhs) const noexcept;
  bool operator<(const RequestAttributeUpdateMessage& rhs) const noexcept;
  bool operator!=(const RequestAttributeUpdateMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const RequestAttributeUpdateMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const RequestAttributeUpdateMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const RequestAttributeUpdateMessage& rhs) const noexcept
  { return !operator>(rhs); }

  virtual ObjectInstanceHandle getObjectInstanceHandleForMessage() const noexcept override;

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setObjectInstanceHandle(const ObjectInstanceHandle& value) noexcept
  { _objectInstanceHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setObjectInstanceHandle(ObjectInstanceHandle&& value) noexcept
  { _objectInstanceHandle = std::move(value); }
#endif
  ObjectInstanceHandle& getObjectInstanceHandle() noexcept
  { return _objectInstanceHandle; }
  const ObjectInstanceHandle& getObjectInstanceHandle() const noexcept
  { return _objectInstanceHandle; }

  void setAttributeHandles(const AttributeHandleVector& value) noexcept
  { _attributeHandles = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setAttributeHandles(AttributeHandleVector&& value) noexcept
  { _attributeHandles = std::move(value); }
#endif
  AttributeHandleVector& getAttributeHandles() noexcept
  { return _attributeHandles; }
  const AttributeHandleVector& getAttributeHandles() const noexcept
  { return _attributeHandles; }

  void setTag(const VariableLengthData& value) noexcept
  { _tag = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTag(VariableLengthData&& value) noexcept
  { _tag = std::move(value); }
#endif
  VariableLengthData& getTag() noexcept
  { return _tag; }
  const VariableLengthData& getTag() const noexcept
  { return _tag; }

private:
  FederationHandle _federationHandle;
  ObjectInstanceHandle _objectInstanceHandle;
  AttributeHandleVector _attributeHandles;
  VariableLengthData _tag;
};

class OPENRTI_API RequestClassAttributeUpdateMessage final : public AbstractMessage {
public:
  RequestClassAttributeUpdateMessage() noexcept;
  virtual ~RequestClassAttributeUpdateMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const RequestClassAttributeUpdateMessage& rhs) const noexcept;
  bool operator<(const RequestClassAttributeUpdateMessage& rhs) const noexcept;
  bool operator!=(const RequestClassAttributeUpdateMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const RequestClassAttributeUpdateMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const RequestClassAttributeUpdateMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const RequestClassAttributeUpdateMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setObjectClassHandle(const ObjectClassHandle& value) noexcept
  { _objectClassHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setObjectClassHandle(ObjectClassHandle&& value) noexcept
  { _objectClassHandle = std::move(value); }
#endif
  ObjectClassHandle& getObjectClassHandle() noexcept
  { return _objectClassHandle; }
  const ObjectClassHandle& getObjectClassHandle() const noexcept
  { return _objectClassHandle; }

  void setAttributeHandles(const AttributeHandleVector& value) noexcept
  { _attributeHandles = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setAttributeHandles(AttributeHandleVector&& value) noexcept
  { _attributeHandles = std::move(value); }
#endif
  AttributeHandleVector& getAttributeHandles() noexcept
  { return _attributeHandles; }
  const AttributeHandleVector& getAttributeHandles() const noexcept
  { return _attributeHandles; }

  void setTag(const VariableLengthData& value) noexcept
  { _tag = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setTag(VariableLengthData&& value) noexcept
  { _tag = std::move(value); }
#endif
  VariableLengthData& getTag() noexcept
  { return _tag; }
  const VariableLengthData& getTag() const noexcept
  { return _tag; }

private:
  FederationHandle _federationHandle;
  ObjectClassHandle _objectClassHandle;
  AttributeHandleVector _attributeHandles;
  VariableLengthData _tag;
};

class OPENRTI_API QueryAttributeOwnershipRequestMessage final : public AbstractMessage {
public:
  QueryAttributeOwnershipRequestMessage() noexcept;
  virtual ~QueryAttributeOwnershipRequestMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const QueryAttributeOwnershipRequestMessage& rhs) const noexcept;
  bool operator<(const QueryAttributeOwnershipRequestMessage& rhs) const noexcept;
  bool operator!=(const QueryAttributeOwnershipRequestMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const QueryAttributeOwnershipRequestMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const QueryAttributeOwnershipRequestMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const QueryAttributeOwnershipRequestMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setObjectInstanceHandle(const ObjectInstanceHandle& value) noexcept
  { _objectInstanceHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setObjectInstanceHandle(ObjectInstanceHandle&& value) noexcept
  { _objectInstanceHandle = std::move(value); }
#endif
  ObjectInstanceHandle& getObjectInstanceHandle() noexcept
  { return _objectInstanceHandle; }
  const ObjectInstanceHandle& getObjectInstanceHandle() const noexcept
  { return _objectInstanceHandle; }

  void setAttributeHandle(const AttributeHandle& value) noexcept
  { _attributeHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setAttributeHandle(AttributeHandle&& value) noexcept
  { _attributeHandle = std::move(value); }
#endif
  AttributeHandle& getAttributeHandle() noexcept
  { return _attributeHandle; }
  const AttributeHandle& getAttributeHandle() const noexcept
  { return _attributeHandle; }

private:
  FederationHandle _federationHandle;
  ObjectInstanceHandle _objectInstanceHandle;
  AttributeHandle _attributeHandle;
};

class OPENRTI_API QueryAttributeOwnershipResponseMessage final : public AbstractMessage {
public:
  QueryAttributeOwnershipResponseMessage() noexcept;
  virtual ~QueryAttributeOwnershipResponseMessage() noexcept;

  virtual const char* getTypeName() const override;
  virtual void out(std::ostream& os) const override;
  virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;

  bool operator==(const AbstractMessage& rhs) const noexcept override;
  bool operator==(const QueryAttributeOwnershipResponseMessage& rhs) const noexcept;
  bool operator<(const QueryAttributeOwnershipResponseMessage& rhs) const noexcept;
  bool operator!=(const QueryAttributeOwnershipResponseMessage& rhs) const noexcept
  { return !operator==(rhs); }
  bool operator>(const QueryAttributeOwnershipResponseMessage& rhs) const noexcept
  { return rhs.operator<(*this); }
  bool operator>=(const QueryAttributeOwnershipResponseMessage& rhs) const noexcept
  { return !operator<(rhs); }
  bool operator<=(const QueryAttributeOwnershipResponseMessage& rhs) const noexcept
  { return !operator>(rhs); }

  void setFederationHandle(const FederationHandle& value) noexcept
  { _federationHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setFederationHandle(FederationHandle&& value) noexcept
  { _federationHandle = std::move(value); }
#endif
  FederationHandle& getFederationHandle() noexcept
  { return _federationHandle; }
  const FederationHandle& getFederationHandle() const noexcept
  { return _federationHandle; }

  void setObjectInstanceHandle(const ObjectInstanceHandle& value) noexcept
  { _objectInstanceHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setObjectInstanceHandle(ObjectInstanceHandle&& value) noexcept
  { _objectInstanceHandle = std::move(value); }
#endif
  ObjectInstanceHandle& getObjectInstanceHandle() noexcept
  { return _objectInstanceHandle; }
  const ObjectInstanceHandle& getObjectInstanceHandle() const noexcept
  { return _objectInstanceHandle; }

  void setAttributeHandle(const AttributeHandle& value) noexcept
  { _attributeHandle = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setAttributeHandle(AttributeHandle&& value) noexcept
  { _attributeHandle = std::move(value); }
#endif
  AttributeHandle& getAttributeHandle() noexcept
  { return _attributeHandle; }
  const AttributeHandle& getAttributeHandle() const noexcept
  { return _attributeHandle; }

  void setOwner(const FederateHandle& value) noexcept
  { _owner = value; }
#if 201103L <= __CPlusPlusStd || 200610L <= __cpp_rvalue_reference
  void setOwner(FederateHandle&& value) noexcept
  { _owner = std::move(value); }
#endif
  FederateHandle& getOwner() noexcept
  { return _owner; }
  const FederateHandle& getOwner() const noexcept
  { return _owner; }

private:
  FederationHandle _federationHandle;
  ObjectInstanceHandle _objectInstanceHandle;
  AttributeHandle _attributeHandle;
  FederateHandle _owner;
};


// EnumDataType CallbackModel
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const CallbackModel& value)
{
  switch (value) {
  case HLA_IMMEDIATE: os << "HLA_IMMEDIATE"; break;
  case HLA_EVOKED: os << "HLA_EVOKED"; break;
  }
  return os;
}

inline std::string to_string(const CallbackModel& value)
{
  switch (value) {
  case HLA_IMMEDIATE: return "HLA_IMMEDIATE";
  case HLA_EVOKED: return "HLA_EVOKED";
  default: return "<Invalid CallbackModel>";
  }
}

// EnumDataType OrderType
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const OrderType& value)
{
  switch (value) {
  case RECEIVE: os << "RECEIVE"; break;
  case TIMESTAMP: os << "TIMESTAMP"; break;
  }
  return os;
}

inline std::string to_string(const OrderType& value)
{
  switch (value) {
  case RECEIVE: return "RECEIVE";
  case TIMESTAMP: return "TIMESTAMP";
  default: return "<Invalid OrderType>";
  }
}

// EnumDataType TransportationType
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const TransportationType& value)
{
  switch (value) {
  case RELIABLE: os << "RELIABLE"; break;
  case BEST_EFFORT: os << "BEST_EFFORT"; break;
  }
  return os;
}

inline std::string to_string(const TransportationType& value)
{
  switch (value) {
  case RELIABLE: return "RELIABLE";
  case BEST_EFFORT: return "BEST_EFFORT";
  default: return "<Invalid TransportationType>";
  }
}

// EnumDataType SubscriptionType
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const SubscriptionType& value)
{
  switch (value) {
  case Unsubscribed: os << "Unsubscribed"; break;
  case SubscribedPassive: os << "SubscribedPassive"; break;
  case SubscribedActive: os << "SubscribedActive"; break;
  }
  return os;
}

inline std::string to_string(const SubscriptionType& value)
{
  switch (value) {
  case Unsubscribed: return "Unsubscribed";
  case SubscribedPassive: return "SubscribedPassive";
  case SubscribedActive: return "SubscribedActive";
  default: return "<Invalid SubscriptionType>";
  }
}

// EnumDataType PublicationType
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const PublicationType& value)
{
  switch (value) {
  case Unpublished: os << "Unpublished"; break;
  case Published: os << "Published"; break;
  }
  return os;
}

inline std::string to_string(const PublicationType& value)
{
  switch (value) {
  case Unpublished: return "Unpublished";
  case Published: return "Published";
  default: return "<Invalid PublicationType>";
  }
}

// EnumDataType ResignAction
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ResignAction& value)
{
  switch (value) {
  case UNCONDITIONALLY_DIVEST_ATTRIBUTES: os << "UNCONDITIONALLY_DIVEST_ATTRIBUTES"; break;
  case DELETE_OBJECTS: os << "DELETE_OBJECTS"; break;
  case CANCEL_PENDING_OWNERSHIP_ACQUISITIONS: os << "CANCEL_PENDING_OWNERSHIP_ACQUISITIONS"; break;
  case DELETE_OBJECTS_THEN_DIVEST: os << "DELETE_OBJECTS_THEN_DIVEST"; break;
  case CANCEL_THEN_DELETE_THEN_DIVEST: os << "CANCEL_THEN_DELETE_THEN_DIVEST"; break;
  case NO_ACTION: os << "NO_ACTION"; break;
  }
  return os;
}

inline std::string to_string(const ResignAction& value)
{
  switch (value) {
  case UNCONDITIONALLY_DIVEST_ATTRIBUTES: return "UNCONDITIONALLY_DIVEST_ATTRIBUTES";
  case DELETE_OBJECTS: return "DELETE_OBJECTS";
  case CANCEL_PENDING_OWNERSHIP_ACQUISITIONS: return "CANCEL_PENDING_OWNERSHIP_ACQUISITIONS";
  case DELETE_OBJECTS_THEN_DIVEST: return "DELETE_OBJECTS_THEN_DIVEST";
  case CANCEL_THEN_DELETE_THEN_DIVEST: return "CANCEL_THEN_DELETE_THEN_DIVEST";
  case NO_ACTION: return "NO_ACTION";
  default: return "<Invalid ResignAction>";
  }
}

// EnumDataType RestoreFailureReason
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const RestoreFailureReason& value)
{
  switch (value) {
  case RTI_UNABLE_TO_RESTORE: os << "RTI_UNABLE_TO_RESTORE"; break;
  case FEDERATE_REPORTED_FAILURE_DURING_RESTORE: os << "FEDERATE_REPORTED_FAILURE_DURING_RESTORE"; break;
  case FEDERATE_RESIGNED_DURING_RESTORE: os << "FEDERATE_RESIGNED_DURING_RESTORE"; break;
  case RTI_DETECTED_FAILURE_DURING_RESTORE: os << "RTI_DETECTED_FAILURE_DURING_RESTORE"; break;
  }
  return os;
}

inline std::string to_string(const RestoreFailureReason& value)
{
  switch (value) {
  case RTI_UNABLE_TO_RESTORE: return "RTI_UNABLE_TO_RESTORE";
  case FEDERATE_REPORTED_FAILURE_DURING_RESTORE: return "FEDERATE_REPORTED_FAILURE_DURING_RESTORE";
  case FEDERATE_RESIGNED_DURING_RESTORE: return "FEDERATE_RESIGNED_DURING_RESTORE";
  case RTI_DETECTED_FAILURE_DURING_RESTORE: return "RTI_DETECTED_FAILURE_DURING_RESTORE";
  default: return "<Invalid RestoreFailureReason>";
  }
}

// EnumDataType RestoreStatus
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const RestoreStatus& value)
{
  switch (value) {
  case NO_RESTORE_IN_PROGRESS: os << "NO_RESTORE_IN_PROGRESS"; break;
  case FEDERATE_RESTORE_REQUEST_PENDING: os << "FEDERATE_RESTORE_REQUEST_PENDING"; break;
  case FEDERATE_WAITING_FOR_RESTORE_TO_BEGIN: os << "FEDERATE_WAITING_FOR_RESTORE_TO_BEGIN"; break;
  case FEDERATE_PREPARED_TO_RESTORE: os << "FEDERATE_PREPARED_TO_RESTORE"; break;
  case FEDERATE_RESTORING: os << "FEDERATE_RESTORING"; break;
  case FEDERATE_WAITING_FOR_FEDERATION_TO_RESTORE: os << "FEDERATE_WAITING_FOR_FEDERATION_TO_RESTORE"; break;
  }
  return os;
}

inline std::string to_string(const RestoreStatus& value)
{
  switch (value) {
  case NO_RESTORE_IN_PROGRESS: return "NO_RESTORE_IN_PROGRESS";
  case FEDERATE_RESTORE_REQUEST_PENDING: return "FEDERATE_RESTORE_REQUEST_PENDING";
  case FEDERATE_WAITING_FOR_RESTORE_TO_BEGIN: return "FEDERATE_WAITING_FOR_RESTORE_TO_BEGIN";
  case FEDERATE_PREPARED_TO_RESTORE: return "FEDERATE_PREPARED_TO_RESTORE";
  case FEDERATE_RESTORING: return "FEDERATE_RESTORING";
  case FEDERATE_WAITING_FOR_FEDERATION_TO_RESTORE: return "FEDERATE_WAITING_FOR_FEDERATION_TO_RESTORE";
  default: return "<Invalid RestoreStatus>";
  }
}

// EnumDataType SaveFailureReason
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const SaveFailureReason& value)
{
  switch (value) {
  case RTI_UNABLE_TO_SAVE: os << "RTI_UNABLE_TO_SAVE"; break;
  case FEDERATE_REPORTED_FAILURE_DURING_SAVE: os << "FEDERATE_REPORTED_FAILURE_DURING_SAVE"; break;
  case FEDERATE_RESIGNED_DURING_SAVE: os << "FEDERATE_RESIGNED_DURING_SAVE"; break;
  case RTI_DETECTED_FAILURE_DURING_SAVE: os << "RTI_DETECTED_FAILURE_DURING_SAVE"; break;
  case SAVE_TIME_CANNOT_BE_HONORED: os << "SAVE_TIME_CANNOT_BE_HONORED"; break;
  }
  return os;
}

inline std::string to_string(const SaveFailureReason& value)
{
  switch (value) {
  case RTI_UNABLE_TO_SAVE: return "RTI_UNABLE_TO_SAVE";
  case FEDERATE_REPORTED_FAILURE_DURING_SAVE: return "FEDERATE_REPORTED_FAILURE_DURING_SAVE";
  case FEDERATE_RESIGNED_DURING_SAVE: return "FEDERATE_RESIGNED_DURING_SAVE";
  case RTI_DETECTED_FAILURE_DURING_SAVE: return "RTI_DETECTED_FAILURE_DURING_SAVE";
  case SAVE_TIME_CANNOT_BE_HONORED: return "SAVE_TIME_CANNOT_BE_HONORED";
  default: return "<Invalid SaveFailureReason>";
  }
}

// EnumDataType SaveStatus
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const SaveStatus& value)
{
  switch (value) {
  case NO_SAVE_IN_PROGRESS: os << "NO_SAVE_IN_PROGRESS"; break;
  case FEDERATE_INSTRUCTED_TO_SAVE: os << "FEDERATE_INSTRUCTED_TO_SAVE"; break;
  case FEDERATE_SAVING: os << "FEDERATE_SAVING"; break;
  case FEDERATE_WAITING_FOR_FEDERATION_TO_SAVE: os << "FEDERATE_WAITING_FOR_FEDERATION_TO_SAVE"; break;
  }
  return os;
}

inline std::string to_string(const SaveStatus& value)
{
  switch (value) {
  case NO_SAVE_IN_PROGRESS: return "NO_SAVE_IN_PROGRESS";
  case FEDERATE_INSTRUCTED_TO_SAVE: return "FEDERATE_INSTRUCTED_TO_SAVE";
  case FEDERATE_SAVING: return "FEDERATE_SAVING";
  case FEDERATE_WAITING_FOR_FEDERATION_TO_SAVE: return "FEDERATE_WAITING_FOR_FEDERATION_TO_SAVE";
  default: return "<Invalid SaveStatus>";
  }
}

// EnumDataType ServiceGroupIndicator
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ServiceGroupIndicator& value)
{
  switch (value) {
  case FEDERATION_MANAGEMENT: os << "FEDERATION_MANAGEMENT"; break;
  case DECLARATION_MANAGEMENT: os << "DECLARATION_MANAGEMENT"; break;
  case OBJECT_MANAGEMENT: os << "OBJECT_MANAGEMENT"; break;
  case OWNERSHIP_MANAGEMENT: os << "OWNERSHIP_MANAGEMENT"; break;
  case TIME_MANAGEMENT: os << "TIME_MANAGEMENT"; break;
  case DATA_DISTRIBUTION_MANAGEMENT: os << "DATA_DISTRIBUTION_MANAGEMENT"; break;
  case SUPPORT_SERVICES: os << "SUPPORT_SERVICES"; break;
  }
  return os;
}

inline std::string to_string(const ServiceGroupIndicator& value)
{
  switch (value) {
  case FEDERATION_MANAGEMENT: return "FEDERATION_MANAGEMENT";
  case DECLARATION_MANAGEMENT: return "DECLARATION_MANAGEMENT";
  case OBJECT_MANAGEMENT: return "OBJECT_MANAGEMENT";
  case OWNERSHIP_MANAGEMENT: return "OWNERSHIP_MANAGEMENT";
  case TIME_MANAGEMENT: return "TIME_MANAGEMENT";
  case DATA_DISTRIBUTION_MANAGEMENT: return "DATA_DISTRIBUTION_MANAGEMENT";
  case SUPPORT_SERVICES: return "SUPPORT_SERVICES";
  default: return "<Invalid ServiceGroupIndicator>";
  }
}

// EnumDataType LowerBoundTimeStampCommitType
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const LowerBoundTimeStampCommitType& value)
{
  switch (value) {
  case TimeAdvanceCommit: os << "TimeAdvanceCommit"; break;
  case NextMessageCommit: os << "NextMessageCommit"; break;
  case TimeAdvanceAndNextMessageCommit: os << "TimeAdvanceAndNextMessageCommit"; break;
  }
  return os;
}

inline std::string to_string(const LowerBoundTimeStampCommitType& value)
{
  switch (value) {
  case TimeAdvanceCommit: return "TimeAdvanceCommit";
  case NextMessageCommit: return "NextMessageCommit";
  case TimeAdvanceAndNextMessageCommit: return "TimeAdvanceAndNextMessageCommit";
  default: return "<Invalid LowerBoundTimeStampCommitType>";
  }
}

// EnumDataType SwitchesType
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const SwitchesType& value)
{
  switch (value) {
  case InteractionRelevanceAdvisorySwitchesType: os << "InteractionRelevanceAdvisorySwitchesType"; break;
  case ObjectClassRelevanceAdvisorySwitchesType: os << "ObjectClassRelevanceAdvisorySwitchesType"; break;
  case AttributeRelevanceAdvisorySwitchesType: os << "AttributeRelevanceAdvisorySwitchesType"; break;
  case AttributeScopeAdvisorySwitchesType: os << "AttributeScopeAdvisorySwitchesType"; break;
  case AutoProvideSwitchesType: os << "AutoProvideSwitchesType"; break;
  case ConveyRegionDesignatorSetsSwitchesType: os << "ConveyRegionDesignatorSetsSwitchesType"; break;
  case ServiceReportingSwitchesType: os << "ServiceReportingSwitchesType"; break;
  }
  return os;
}

inline std::string to_string(const SwitchesType& value)
{
  switch (value) {
  case InteractionRelevanceAdvisorySwitchesType: return "InteractionRelevanceAdvisorySwitchesType";
  case ObjectClassRelevanceAdvisorySwitchesType: return "ObjectClassRelevanceAdvisorySwitchesType";
  case AttributeRelevanceAdvisorySwitchesType: return "AttributeRelevanceAdvisorySwitchesType";
  case AttributeScopeAdvisorySwitchesType: return "AttributeScopeAdvisorySwitchesType";
  case AutoProvideSwitchesType: return "AutoProvideSwitchesType";
  case ConveyRegionDesignatorSetsSwitchesType: return "ConveyRegionDesignatorSetsSwitchesType";
  case ServiceReportingSwitchesType: return "ServiceReportingSwitchesType";
  default: return "<Invalid SwitchesType>";
  }
}

// VectorDataType AttributeHandleVector
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const AttributeHandleVector& value)
{
  os << "{ ";
  AttributeHandleVector::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// VectorDataType FederateHandleVector
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FederateHandleVector& value)
{
  os << "{ ";
  FederateHandleVector::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// VectorDataType ParameterHandleVector
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ParameterHandleVector& value)
{
  os << "{ ";
  ParameterHandleVector::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// VectorDataType DimensionHandleVector
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const DimensionHandleVector& value)
{
  os << "{ ";
  DimensionHandleVector::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// SetDataType DimensionHandleSet
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const DimensionHandleSet& value)
{
  os << "{ ";
  DimensionHandleSet::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// VectorDataType ObjectInstanceHandleVector
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ObjectInstanceHandleVector& value)
{
  os << "{ ";
  ObjectInstanceHandleVector::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// VectorDataType RegionHandleVector
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const RegionHandleVector& value)
{
  os << "{ ";
  RegionHandleVector::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// VectorDataType ModuleHandleVector
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ModuleHandleVector& value)
{
  os << "{ ";
  ModuleHandleVector::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// VectorDataType StringVector
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const StringVector& value)
{
  os << "{ ";
  StringVector::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// SetDataType StringSet
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const StringSet& value)
{
  os << "{ ";
  StringSet::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// PairDataType FederateHandleBoolPair
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FederateHandleBoolPair& value)
{
  os << "{ ";
  os << "first: " << value.first << ", ";
  os << "second: " << value.second;
  os << " }";
  return os;
}

// VectorDataType FederateHandleBoolPairVector
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FederateHandleBoolPairVector& value)
{
  os << "{ ";
  FederateHandleBoolPairVector::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType RangeBoundsValue
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const RangeBoundsValue& value)
{
  os << "{ ";
  os << "lowerBound: " << value.getLowerBound();
  os << ", ";
  os << "upperBound: " << value.getUpperBound();
  os << " }";
  return os;
}

// PairDataType DimensionHandleRangeBoundsValuePair
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const DimensionHandleRangeBoundsValuePair& value)
{
  os << "{ ";
  os << "first: " << value.first << ", ";
  os << "second: " << value.second;
  os << " }";
  return os;
}

// VectorDataType RegionValue
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const RegionValue& value)
{
  os << "{ ";
  RegionValue::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// VectorDataType RegionValueList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const RegionValueList& value)
{
  os << "{ ";
  RegionValueList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// PairDataType RegionHandleDimensionHandleSetPair
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const RegionHandleDimensionHandleSetPair& value)
{
  os << "{ ";
  os << "first: " << value.first << ", ";
  os << "second: " << value.second;
  os << " }";
  return os;
}

// VectorDataType RegionHandleDimensionHandleSetPairVector
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const RegionHandleDimensionHandleSetPairVector& value)
{
  os << "{ ";
  RegionHandleDimensionHandleSetPairVector::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// PairDataType RegionHandleSpaceHandlePair
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const RegionHandleSpaceHandlePair& value)
{
  os << "{ ";
  os << "first: " << value.first << ", ";
  os << "second: " << value.second;
  os << " }";
  return os;
}

// VectorDataType RegionHandleSpaceHandlePairVector
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const RegionHandleSpaceHandlePairVector& value)
{
  os << "{ ";
  RegionHandleSpaceHandlePairVector::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// PairDataType RegionHandleRegionValuePair
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const RegionHandleRegionValuePair& value)
{
  os << "{ ";
  os << "first: " << value.first << ", ";
  os << "second: " << value.second;
  os << " }";
  return os;
}

// VectorDataType RegionHandleRegionValuePairVector
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const RegionHandleRegionValuePairVector& value)
{
  os << "{ ";
  RegionHandleRegionValuePairVector::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// PairDataType InteractionClassHandleRegionValueListPair
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const InteractionClassHandleRegionValueListPair& value)
{
  os << "{ ";
  os << "first: " << value.first << ", ";
  os << "second: " << value.second;
  os << " }";
  return os;
}

// PairDataType AttributeHandleRegionValueListPair
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const AttributeHandleRegionValueListPair& value)
{
  os << "{ ";
  os << "first: " << value.first << ", ";
  os << "second: " << value.second;
  os << " }";
  return os;
}

// StructDataType AttributeState
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const AttributeState& value)
{
  os << "{ ";
  os << "attributeHandle: " << value.getAttributeHandle();
  os << ", ";
  os << "ownerFederate: " << value.getOwnerFederate();
  os << " }";
  return os;
}

// VectorDataType AttributeStateVector
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const AttributeStateVector& value)
{
  os << "{ ";
  AttributeStateVector::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType ParameterValue
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ParameterValue& value)
{
  os << "{ ";
  os << "parameterHandle: " << value.getParameterHandle();
  os << ", ";
  os << "value: " << value.getValue();
  os << " }";
  return os;
}

// VectorDataType ParameterValueVector
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ParameterValueVector& value)
{
  os << "{ ";
  ParameterValueVector::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType AttributeValue
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const AttributeValue& value)
{
  os << "{ ";
  os << "attributeHandle: " << value.getAttributeHandle();
  os << ", ";
  os << "value: " << value.getValue();
  os << " }";
  return os;
}

// VectorDataType AttributeValueVector
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const AttributeValueVector& value)
{
  os << "{ ";
  AttributeValueVector::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// PairDataType FederateHandleSaveStatusPair
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FederateHandleSaveStatusPair& value)
{
  os << "{ ";
  os << "first: " << value.first << ", ";
  os << "second: " << value.second;
  os << " }";
  return os;
}

// VectorDataType FederateHandleSaveStatusPairVector
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FederateHandleSaveStatusPairVector& value)
{
  os << "{ ";
  FederateHandleSaveStatusPairVector::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// PairDataType FederateHandleRestoreStatusPair
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FederateHandleRestoreStatusPair& value)
{
  os << "{ ";
  os << "first: " << value.first << ", ";
  os << "second: " << value.second;
  os << " }";
  return os;
}

// VectorDataType FederateHandleRestoreStatusPairVector
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FederateHandleRestoreStatusPairVector& value)
{
  os << "{ ";
  FederateHandleRestoreStatusPairVector::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FederationExecutionInformation
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FederationExecutionInformation& value)
{
  os << "{ ";
  os << "federationExecutionName: " << value.getFederationExecutionName();
  os << ", ";
  os << "logicalTimeFactoryName: " << value.getLogicalTimeFactoryName();
  os << " }";
  return os;
}

// VectorDataType FederationExecutionInformationVector
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FederationExecutionInformationVector& value)
{
  os << "{ ";
  FederationExecutionInformationVector::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// PairDataType ObjectInstanceHandleNamePair
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ObjectInstanceHandleNamePair& value)
{
  os << "{ ";
  os << "first: " << value.first << ", ";
  os << "second: " << value.second;
  os << " }";
  return os;
}

// VectorDataType ObjectInstanceHandleNamePairVector
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ObjectInstanceHandleNamePairVector& value)
{
  os << "{ ";
  ObjectInstanceHandleNamePairVector::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// EnumDataType CreateFederationExecutionResponseType
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const CreateFederationExecutionResponseType& value)
{
  switch (value) {
  case CreateFederationExecutionResponseSuccess: os << "CreateFederationExecutionResponseSuccess"; break;
  case CreateFederationExecutionResponseFederationExecutionAlreadyExists: os << "CreateFederationExecutionResponseFederationExecutionAlreadyExists"; break;
  case CreateFederationExecutionResponseCouldNotOpenFDD: os << "CreateFederationExecutionResponseCouldNotOpenFDD"; break;
  case CreateFederationExecutionResponseErrorReadingFDD: os << "CreateFederationExecutionResponseErrorReadingFDD"; break;
  case CreateFederationExecutionResponseCouldNotCreateLogicalTimeFactory: os << "CreateFederationExecutionResponseCouldNotCreateLogicalTimeFactory"; break;
  case CreateFederationExecutionResponseInconsistentFDD: os << "CreateFederationExecutionResponseInconsistentFDD"; break;
  case CreateFederationExecutionResponseRTIinternalError: os << "CreateFederationExecutionResponseRTIinternalError"; break;
  }
  return os;
}

inline std::string to_string(const CreateFederationExecutionResponseType& value)
{
  switch (value) {
  case CreateFederationExecutionResponseSuccess: return "CreateFederationExecutionResponseSuccess";
  case CreateFederationExecutionResponseFederationExecutionAlreadyExists: return "CreateFederationExecutionResponseFederationExecutionAlreadyExists";
  case CreateFederationExecutionResponseCouldNotOpenFDD: return "CreateFederationExecutionResponseCouldNotOpenFDD";
  case CreateFederationExecutionResponseErrorReadingFDD: return "CreateFederationExecutionResponseErrorReadingFDD";
  case CreateFederationExecutionResponseCouldNotCreateLogicalTimeFactory: return "CreateFederationExecutionResponseCouldNotCreateLogicalTimeFactory";
  case CreateFederationExecutionResponseInconsistentFDD: return "CreateFederationExecutionResponseInconsistentFDD";
  case CreateFederationExecutionResponseRTIinternalError: return "CreateFederationExecutionResponseRTIinternalError";
  default: return "<Invalid CreateFederationExecutionResponseType>";
  }
}

// EnumDataType DestroyFederationExecutionResponseType
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const DestroyFederationExecutionResponseType& value)
{
  switch (value) {
  case DestroyFederationExecutionResponseSuccess: os << "DestroyFederationExecutionResponseSuccess"; break;
  case DestroyFederationExecutionResponseFederatesCurrentlyJoined: os << "DestroyFederationExecutionResponseFederatesCurrentlyJoined"; break;
  case DestroyFederationExecutionResponseFederationExecutionDoesNotExist: os << "DestroyFederationExecutionResponseFederationExecutionDoesNotExist"; break;
  case DestroyFederationExecutionResponseRTIinternalError: os << "DestroyFederationExecutionResponseRTIinternalError"; break;
  }
  return os;
}

inline std::string to_string(const DestroyFederationExecutionResponseType& value)
{
  switch (value) {
  case DestroyFederationExecutionResponseSuccess: return "DestroyFederationExecutionResponseSuccess";
  case DestroyFederationExecutionResponseFederatesCurrentlyJoined: return "DestroyFederationExecutionResponseFederatesCurrentlyJoined";
  case DestroyFederationExecutionResponseFederationExecutionDoesNotExist: return "DestroyFederationExecutionResponseFederationExecutionDoesNotExist";
  case DestroyFederationExecutionResponseRTIinternalError: return "DestroyFederationExecutionResponseRTIinternalError";
  default: return "<Invalid DestroyFederationExecutionResponseType>";
  }
}

// EnumDataType JoinFederationExecutionResponseType
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const JoinFederationExecutionResponseType& value)
{
  switch (value) {
  case JoinFederationExecutionResponseSuccess: os << "JoinFederationExecutionResponseSuccess"; break;
  case JoinFederationExecutionResponseFederateNameAlreadyInUse: os << "JoinFederationExecutionResponseFederateNameAlreadyInUse"; break;
  case JoinFederationExecutionResponseFederationExecutionDoesNotExist: os << "JoinFederationExecutionResponseFederationExecutionDoesNotExist"; break;
  case JoinFederationExecutionResponseSaveInProgress: os << "JoinFederationExecutionResponseSaveInProgress"; break;
  case JoinFederationExecutionResponseRestoreInProgress: os << "JoinFederationExecutionResponseRestoreInProgress"; break;
  case JoinFederationExecutionResponseInconsistentFDD: os << "JoinFederationExecutionResponseInconsistentFDD"; break;
  }
  return os;
}

inline std::string to_string(const JoinFederationExecutionResponseType& value)
{
  switch (value) {
  case JoinFederationExecutionResponseSuccess: return "JoinFederationExecutionResponseSuccess";
  case JoinFederationExecutionResponseFederateNameAlreadyInUse: return "JoinFederationExecutionResponseFederateNameAlreadyInUse";
  case JoinFederationExecutionResponseFederationExecutionDoesNotExist: return "JoinFederationExecutionResponseFederationExecutionDoesNotExist";
  case JoinFederationExecutionResponseSaveInProgress: return "JoinFederationExecutionResponseSaveInProgress";
  case JoinFederationExecutionResponseRestoreInProgress: return "JoinFederationExecutionResponseRestoreInProgress";
  case JoinFederationExecutionResponseInconsistentFDD: return "JoinFederationExecutionResponseInconsistentFDD";
  default: return "<Invalid JoinFederationExecutionResponseType>";
  }
}

// EnumDataType RegisterFederationSynchronizationPointResponseType
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const RegisterFederationSynchronizationPointResponseType& value)
{
  switch (value) {
  case RegisterFederationSynchronizationPointResponseSuccess: os << "RegisterFederationSynchronizationPointResponseSuccess"; break;
  case RegisterFederationSynchronizationPointResponseLabelNotUnique: os << "RegisterFederationSynchronizationPointResponseLabelNotUnique"; break;
  case RegisterFederationSynchronizationPointResponseMemberNotJoined: os << "RegisterFederationSynchronizationPointResponseMemberNotJoined"; break;
  }
  return os;
}

inline std::string to_string(const RegisterFederationSynchronizationPointResponseType& value)
{
  switch (value) {
  case RegisterFederationSynchronizationPointResponseSuccess: return "RegisterFederationSynchronizationPointResponseSuccess";
  case RegisterFederationSynchronizationPointResponseLabelNotUnique: return "RegisterFederationSynchronizationPointResponseLabelNotUnique";
  case RegisterFederationSynchronizationPointResponseMemberNotJoined: return "RegisterFederationSynchronizationPointResponseMemberNotJoined";
  default: return "<Invalid RegisterFederationSynchronizationPointResponseType>";
  }
}

// <__main__.MapDataType object at 0x00000224EB25BDD8>
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ConfigurationParameterMap& value)
{
  os << "{ ";
  ConfigurationParameterMap::const_iterator i = value.begin();
  if (i != value.end()) {
    os << i->first << ": " << i->second;
    while (++i != value.end()) {
      os << ", " << i->first << ": " << i->second;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMStringSimpleDataType
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringSimpleDataType& value)
{
  os << "{ ";
  os << "name: " << value.getName();
  os << ", ";
  os << "representation: " << value.getRepresentation();
  os << " }";
  return os;
}

// VectorDataType FOMStringSimpleDataTypeList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringSimpleDataTypeList& value)
{
  os << "{ ";
  FOMStringSimpleDataTypeList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMStringEnumerator
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringEnumerator& value)
{
  os << "{ ";
  os << "name: " << value.getName();
  os << ", ";
  os << "value: " << value.getValue();
  os << " }";
  return os;
}

// VectorDataType FOMStringEnumeratorList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringEnumeratorList& value)
{
  os << "{ ";
  FOMStringEnumeratorList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMStringEnumeratedDataType
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringEnumeratedDataType& value)
{
  os << "{ ";
  os << "name: " << value.getName();
  os << ", ";
  os << "representation: " << value.getRepresentation();
  os << ", ";
  os << "enumerators: " << value.getEnumerators();
  os << " }";
  return os;
}

// VectorDataType FOMStringEnumeratedDataTypeList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringEnumeratedDataTypeList& value)
{
  os << "{ ";
  FOMStringEnumeratedDataTypeList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMStringArrayDataType
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringArrayDataType& value)
{
  os << "{ ";
  os << "name: " << value.getName();
  os << ", ";
  os << "dataType: " << value.getDataType();
  os << ", ";
  os << "cardinality: " << value.getCardinality();
  os << ", ";
  os << "encoding: " << value.getEncoding();
  os << " }";
  return os;
}

// VectorDataType FOMStringArrayDataTypeList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringArrayDataTypeList& value)
{
  os << "{ ";
  FOMStringArrayDataTypeList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMStringFixedRecordField
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringFixedRecordField& value)
{
  os << "{ ";
  os << "name: " << value.getName();
  os << ", ";
  os << "dataType: " << value.getDataType();
  os << " }";
  return os;
}

// VectorDataType FOMStringFixedRecordFieldList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringFixedRecordFieldList& value)
{
  os << "{ ";
  FOMStringFixedRecordFieldList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMStringFixedRecordDataType
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringFixedRecordDataType& value)
{
  os << "{ ";
  os << "name: " << value.getName();
  os << ", ";
  os << "encoding: " << value.getEncoding();
  os << ", ";
  os << "fields: " << value.getFields();
  os << " }";
  return os;
}

// VectorDataType FOMStringFixedRecordDataTypeList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringFixedRecordDataTypeList& value)
{
  os << "{ ";
  FOMStringFixedRecordDataTypeList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMStringVariantRecordAlternative
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringVariantRecordAlternative& value)
{
  os << "{ ";
  os << "enumerator: " << value.getEnumerator();
  os << ", ";
  os << "name: " << value.getName();
  os << ", ";
  os << "dataType: " << value.getDataType();
  os << " }";
  return os;
}

// VectorDataType FOMStringVariantRecordAlternativeList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringVariantRecordAlternativeList& value)
{
  os << "{ ";
  FOMStringVariantRecordAlternativeList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMStringVariantRecordDataType
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringVariantRecordDataType& value)
{
  os << "{ ";
  os << "name: " << value.getName();
  os << ", ";
  os << "discriminant: " << value.getDiscriminant();
  os << ", ";
  os << "dataType: " << value.getDataType();
  os << ", ";
  os << "alternatives: " << value.getAlternatives();
  os << ", ";
  os << "encoding: " << value.getEncoding();
  os << " }";
  return os;
}

// VectorDataType FOMStringVariantRecordDataTypeList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringVariantRecordDataTypeList& value)
{
  os << "{ ";
  FOMStringVariantRecordDataTypeList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMStringTransportationType
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringTransportationType& value)
{
  os << "{ ";
  os << "name: " << value.getName();
  os << " }";
  return os;
}

// VectorDataType FOMStringTransportationTypeList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringTransportationTypeList& value)
{
  os << "{ ";
  FOMStringTransportationTypeList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMStringDimension
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringDimension& value)
{
  os << "{ ";
  os << "name: " << value.getName();
  os << ", ";
  os << "upperBound: " << value.getUpperBound();
  os << " }";
  return os;
}

// VectorDataType FOMStringDimensionList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringDimensionList& value)
{
  os << "{ ";
  FOMStringDimensionList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMStringRoutingSpace
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringRoutingSpace& value)
{
  os << "{ ";
  os << "name: " << value.getName();
  os << ", ";
  os << "dimensionSet: " << value.getDimensionSet();
  os << " }";
  return os;
}

// VectorDataType FOMStringRoutingSpaceList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringRoutingSpaceList& value)
{
  os << "{ ";
  FOMStringRoutingSpaceList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMStringParameter
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringParameter& value)
{
  os << "{ ";
  os << "name: " << value.getName();
  os << ", ";
  os << "dataType: " << value.getDataType();
  os << " }";
  return os;
}

// VectorDataType FOMStringParameterList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringParameterList& value)
{
  os << "{ ";
  FOMStringParameterList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMStringInteractionClass
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringInteractionClass& value)
{
  os << "{ ";
  os << "name: " << value.getName();
  os << ", ";
  os << "orderType: " << value.getOrderType();
  os << ", ";
  os << "transportationType: " << value.getTransportationType();
  os << ", ";
  os << "routingSpace: " << value.getRoutingSpace();
  os << ", ";
  os << "dimensionSet: " << value.getDimensionSet();
  os << ", ";
  os << "parameterList: " << value.getParameterList();
  os << " }";
  return os;
}

// VectorDataType FOMStringInteractionClassList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringInteractionClassList& value)
{
  os << "{ ";
  FOMStringInteractionClassList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMStringAttribute
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringAttribute& value)
{
  os << "{ ";
  os << "name: " << value.getName();
  os << ", ";
  os << "dataType: " << value.getDataType();
  os << ", ";
  os << "orderType: " << value.getOrderType();
  os << ", ";
  os << "transportationType: " << value.getTransportationType();
  os << ", ";
  os << "routingSpace: " << value.getRoutingSpace();
  os << ", ";
  os << "dimensionSet: " << value.getDimensionSet();
  os << " }";
  return os;
}

// VectorDataType FOMStringAttributeList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringAttributeList& value)
{
  os << "{ ";
  FOMStringAttributeList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMStringObjectClass
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringObjectClass& value)
{
  os << "{ ";
  os << "name: " << value.getName();
  os << ", ";
  os << "attributeList: " << value.getAttributeList();
  os << " }";
  return os;
}

// VectorDataType FOMStringObjectClassList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringObjectClassList& value)
{
  os << "{ ";
  FOMStringObjectClassList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMStringUpdateRate
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringUpdateRate& value)
{
  os << "{ ";
  os << "name: " << value.getName();
  os << ", ";
  os << "rate: " << value.getRate();
  os << " }";
  return os;
}

// VectorDataType FOMStringUpdateRateList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringUpdateRateList& value)
{
  os << "{ ";
  FOMStringUpdateRateList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMStringSwitch
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringSwitch& value)
{
  os << "{ ";
  os << "switchesType: " << value.getSwitchesType();
  os << ", ";
  os << "enabled: " << value.getEnabled();
  os << " }";
  return os;
}

// VectorDataType FOMStringSwitchList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringSwitchList& value)
{
  os << "{ ";
  FOMStringSwitchList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMStringModule
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringModule& value)
{
  os << "{ ";
  os << "designator: " << value.getDesignator();
  os << ", ";
  os << "transportationTypeList: " << value.getTransportationTypeList();
  os << ", ";
  os << "dimensionList: " << value.getDimensionList();
  os << ", ";
  os << "routingSpaceList: " << value.getRoutingSpaceList();
  os << ", ";
  os << "interactionClassList: " << value.getInteractionClassList();
  os << ", ";
  os << "objectClassList: " << value.getObjectClassList();
  os << ", ";
  os << "updateRateList: " << value.getUpdateRateList();
  os << ", ";
  os << "switchList: " << value.getSwitchList();
  os << ", ";
  os << "simpleDataTypeList: " << value.getSimpleDataTypeList();
  os << ", ";
  os << "enumeratedDataTypeList: " << value.getEnumeratedDataTypeList();
  os << ", ";
  os << "arrayDataTypeList: " << value.getArrayDataTypeList();
  os << ", ";
  os << "fixedRecordDataTypeList: " << value.getFixedRecordDataTypeList();
  os << ", ";
  os << "variantRecordDataTypeList: " << value.getVariantRecordDataTypeList();
  os << ", ";
  os << "artificialInteractionRoot: " << value.getArtificialInteractionRoot();
  os << ", ";
  os << "artificialObjectRoot: " << value.getArtificialObjectRoot();
  os << " }";
  return os;
}

// VectorDataType FOMStringModuleList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMStringModuleList& value)
{
  os << "{ ";
  FOMStringModuleList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMTransportationType
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMTransportationType& value)
{
  os << "{ ";
  os << "name: " << value.getName();
  os << ", ";
  os << "transportationType: " << value.getTransportationType();
  os << " }";
  return os;
}

// VectorDataType FOMTransportationTypeList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMTransportationTypeList& value)
{
  os << "{ ";
  FOMTransportationTypeList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMDimension
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMDimension& value)
{
  os << "{ ";
  os << "name: " << value.getName();
  os << ", ";
  os << "dimensionHandle: " << value.getDimensionHandle();
  os << ", ";
  os << "upperBound: " << value.getUpperBound();
  os << " }";
  return os;
}

// VectorDataType FOMDimensionList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMDimensionList& value)
{
  os << "{ ";
  FOMDimensionList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMRoutingSpace
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMRoutingSpace& value)
{
  os << "{ ";
  os << "name: " << value.getName();
  os << ", ";
  os << "spaceHandle: " << value.getSpaceHandle();
  os << ", ";
  os << "dimensionHandleSet: " << value.getDimensionHandleSet();
  os << " }";
  return os;
}

// VectorDataType FOMRoutingSpaceList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMRoutingSpaceList& value)
{
  os << "{ ";
  FOMRoutingSpaceList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMParameter
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMParameter& value)
{
  os << "{ ";
  os << "name: " << value.getName();
  os << ", ";
  os << "dataType: " << value.getDataType();
  os << ", ";
  os << "parameterHandle: " << value.getParameterHandle();
  os << " }";
  return os;
}

// VectorDataType FOMParameterList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMParameterList& value)
{
  os << "{ ";
  FOMParameterList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMInteractionClass
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMInteractionClass& value)
{
  os << "{ ";
  os << "name: " << value.getName();
  os << ", ";
  os << "interactionClassHandle: " << value.getInteractionClassHandle();
  os << ", ";
  os << "parentInteractionClassHandle: " << value.getParentInteractionClassHandle();
  os << ", ";
  os << "orderType: " << value.getOrderType();
  os << ", ";
  os << "transportationType: " << value.getTransportationType();
  os << ", ";
  os << "dimensionHandleSet: " << value.getDimensionHandleSet();
  os << ", ";
  os << "parameterList: " << value.getParameterList();
  os << " }";
  return os;
}

// VectorDataType FOMInteractionClassList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMInteractionClassList& value)
{
  os << "{ ";
  FOMInteractionClassList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMAttribute
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMAttribute& value)
{
  os << "{ ";
  os << "name: " << value.getName();
  os << ", ";
  os << "dataType: " << value.getDataType();
  os << ", ";
  os << "attributeHandle: " << value.getAttributeHandle();
  os << ", ";
  os << "orderType: " << value.getOrderType();
  os << ", ";
  os << "transportationType: " << value.getTransportationType();
  os << ", ";
  os << "dimensionHandleSet: " << value.getDimensionHandleSet();
  os << " }";
  return os;
}

// VectorDataType FOMAttributeList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMAttributeList& value)
{
  os << "{ ";
  FOMAttributeList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMObjectClass
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMObjectClass& value)
{
  os << "{ ";
  os << "name: " << value.getName();
  os << ", ";
  os << "objectClassHandle: " << value.getObjectClassHandle();
  os << ", ";
  os << "parentObjectClassHandle: " << value.getParentObjectClassHandle();
  os << ", ";
  os << "attributeList: " << value.getAttributeList();
  os << " }";
  return os;
}

// VectorDataType FOMObjectClassList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMObjectClassList& value)
{
  os << "{ ";
  FOMObjectClassList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMUpdateRate
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMUpdateRate& value)
{
  os << "{ ";
  os << "name: " << value.getName();
  os << ", ";
  os << "updateRateHandle: " << value.getUpdateRateHandle();
  os << ", ";
  os << "rate: " << value.getRate();
  os << " }";
  return os;
}

// VectorDataType FOMUpdateRateList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMUpdateRateList& value)
{
  os << "{ ";
  FOMUpdateRateList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMSwitch
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMSwitch& value)
{
  os << "{ ";
  os << "switchesType: " << value.getSwitchesType();
  os << ", ";
  os << "enabled: " << value.getEnabled();
  os << " }";
  return os;
}

// VectorDataType FOMSwitchList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMSwitchList& value)
{
  os << "{ ";
  FOMSwitchList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// StructDataType FOMModule
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMModule& value)
{
  os << "{ ";
  os << "moduleHandle: " << value.getModuleHandle();
  os << ", ";
  os << "transportationTypeList: " << value.getTransportationTypeList();
  os << ", ";
  os << "dimensionList: " << value.getDimensionList();
  os << ", ";
  os << "routingSpaceList: " << value.getRoutingSpaceList();
  os << ", ";
  os << "interactionClassList: " << value.getInteractionClassList();
  os << ", ";
  os << "objectClassList: " << value.getObjectClassList();
  os << ", ";
  os << "updateRateList: " << value.getUpdateRateList();
  os << ", ";
  os << "switchList: " << value.getSwitchList();
  os << ", ";
  os << "artificialInteractionRoot: " << value.getArtificialInteractionRoot();
  os << ", ";
  os << "artificialObjectRoot: " << value.getArtificialObjectRoot();
  os << ", ";
  os << "designator: " << value.getDesignator();
  os << " }";
  return os;
}

// VectorDataType FOMModuleList
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FOMModuleList& value)
{
  os << "{ ";
  FOMModuleList::const_iterator i = value.begin();
  if (i != value.end()) {
    os << *i;
    while (++i != value.end()) {
      os << ", " << *i;
    }
  }
  os << " }";
  return os;
}

// MessageDataType ConnectionLostMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ConnectionLostMessage& value)
{
  os << "{ ";
  os << "faultDescription: " << value.getFaultDescription();
  os << " }";
  return os;
}

// MessageDataType CreateFederationExecutionRequestMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const CreateFederationExecutionRequestMessage& value)
{
  os << "{ ";
  os << "federationExecution: " << value.getFederationExecution();
  os << ", ";
  os << "logicalTimeFactoryName: " << value.getLogicalTimeFactoryName();
  os << ", ";
  os << "fOMStringModuleList: " << value.getFOMStringModuleList();
  os << " }";
  return os;
}

// MessageDataType CreateFederationExecutionResponseMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const CreateFederationExecutionResponseMessage& value)
{
  os << "{ ";
  os << "createFederationExecutionResponseType: " << value.getCreateFederationExecutionResponseType();
  os << ", ";
  os << "exceptionString: " << value.getExceptionString();
  os << " }";
  return os;
}

// MessageDataType DestroyFederationExecutionRequestMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const DestroyFederationExecutionRequestMessage& value)
{
  os << "{ ";
  os << "federationExecution: " << value.getFederationExecution();
  os << " }";
  return os;
}

// MessageDataType DestroyFederationExecutionResponseMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const DestroyFederationExecutionResponseMessage& value)
{
  os << "{ ";
  os << "destroyFederationExecutionResponseType: " << value.getDestroyFederationExecutionResponseType();
  os << " }";
  return os;
}

// MessageDataType EnumerateFederationExecutionsRequestMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const EnumerateFederationExecutionsRequestMessage& value)
{
  os << "{ ";
  os << " }";
  return os;
}

// MessageDataType EnumerateFederationExecutionsResponseMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const EnumerateFederationExecutionsResponseMessage& value)
{
  os << "{ ";
  os << "federationExecutionInformationVector: " << value.getFederationExecutionInformationVector();
  os << " }";
  return os;
}

// MessageDataType InsertFederationExecutionMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const InsertFederationExecutionMessage& value)
{
  os << "{ ";
  // StructField federationHandle (hidden)
  //os << "federationHandle: " << value.getFederationHandle();
  //os << ", ";
  os << "federationName: " << value.getFederationName();
  os << ", ";
  os << "logicalTimeFactoryName: " << value.getLogicalTimeFactoryName();
  os << ", ";
  os << "configurationParameterMap: " << value.getConfigurationParameterMap();
  os << " }";
  return os;
}

// MessageDataType ShutdownFederationExecutionMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ShutdownFederationExecutionMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << " }";
  return os;
}

// MessageDataType EraseFederationExecutionMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const EraseFederationExecutionMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << " }";
  return os;
}

// MessageDataType ReleaseFederationHandleMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ReleaseFederationHandleMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << " }";
  return os;
}

// MessageDataType InsertModulesMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const InsertModulesMessage& value)
{
  os << "{ ";
  // StructField federationHandle (hidden)
  //os << "federationHandle: " << value.getFederationHandle();
  //os << ", ";
  // StructField fOMModuleList (hidden)
  //os << "fOMModuleList: " << value.getFOMModuleList();
  os << " }";
  return os;
}

// MessageDataType JoinFederationExecutionRequestMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const JoinFederationExecutionRequestMessage& value)
{
  os << "{ ";
  os << "federationExecution: " << value.getFederationExecution();
  os << ", ";
  os << "federateType: " << value.getFederateType();
  os << ", ";
  os << "federateName: " << value.getFederateName();
  os << ", ";
  os << "fOMStringModuleList: " << value.getFOMStringModuleList();
  os << ", ";
  os << "configurationParameterMap: " << value.getConfigurationParameterMap();
  os << ", ";
  os << "isInternal: " << value.getIsInternal();
  os << " }";
  return os;
}

// MessageDataType JoinFederationExecutionResponseMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const JoinFederationExecutionResponseMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "joinFederationExecutionResponseType: " << value.getJoinFederationExecutionResponseType();
  os << ", ";
  os << "exceptionString: " << value.getExceptionString();
  os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << ", ";
  os << "federateType: " << value.getFederateType();
  os << ", ";
  os << "federateName: " << value.getFederateName();
  os << " }";
  return os;
}

// MessageDataType ResignFederationExecutionLeafRequestMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ResignFederationExecutionLeafRequestMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << ", ";
  os << "resignAction: " << value.getResignAction();
  os << " }";
  return os;
}

// MessageDataType ResignFederationExecutionRequestMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ResignFederationExecutionRequestMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << " }";
  return os;
}

// MessageDataType JoinFederateNotifyMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const JoinFederateNotifyMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << ", ";
  os << "federateType: " << value.getFederateType();
  os << ", ";
  os << "federateName: " << value.getFederateName();
  os << ", ";
  os << "isInternal: " << value.getIsInternal();
  os << " }";
  return os;
}

// MessageDataType ResignFederateNotifyMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ResignFederateNotifyMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << " }";
  return os;
}

// MessageDataType ChangeAutomaticResignDirectiveMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ChangeAutomaticResignDirectiveMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << ", ";
  os << "resignAction: " << value.getResignAction();
  os << " }";
  return os;
}

// MessageDataType RegisterFederationSynchronizationPointMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const RegisterFederationSynchronizationPointMessage& value)
{
  os << "{ ";
  // StructField federationHandle (hidden)
  //os << "federationHandle: " << value.getFederationHandle();
  //os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << ", ";
  os << "label: " << value.getLabel();
  os << ", ";
  os << "tag: " << value.getTag();
  os << ", ";
  os << "federateHandleVector: " << value.getFederateHandleVector();
  os << " }";
  return os;
}

// MessageDataType RegisterFederationSynchronizationPointResponseMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const RegisterFederationSynchronizationPointResponseMessage& value)
{
  os << "{ ";
  // StructField federationHandle (hidden)
  //os << "federationHandle: " << value.getFederationHandle();
  //os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << ", ";
  os << "label: " << value.getLabel();
  os << ", ";
  os << "registerFederationSynchronizationPointResponseType: " << value.getRegisterFederationSynchronizationPointResponseType();
  os << " }";
  return os;
}

// MessageDataType AnnounceSynchronizationPointMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const AnnounceSynchronizationPointMessage& value)
{
  os << "{ ";
  // StructField federationHandle (hidden)
  //os << "federationHandle: " << value.getFederationHandle();
  //os << ", ";
  os << "label: " << value.getLabel();
  os << ", ";
  os << "tag: " << value.getTag();
  os << ", ";
  os << "addJoiningFederates: " << value.getAddJoiningFederates();
  os << ", ";
  os << "federateHandleVector: " << value.getFederateHandleVector();
  os << " }";
  return os;
}

// MessageDataType SynchronizationPointAchievedMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const SynchronizationPointAchievedMessage& value)
{
  os << "{ ";
  // StructField federationHandle (hidden)
  //os << "federationHandle: " << value.getFederationHandle();
  //os << ", ";
  os << "label: " << value.getLabel();
  os << ", ";
  os << "federateHandleBoolPairVector: " << value.getFederateHandleBoolPairVector();
  os << " }";
  return os;
}

// MessageDataType FederationSynchronizedMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const FederationSynchronizedMessage& value)
{
  os << "{ ";
  // StructField federationHandle (hidden)
  //os << "federationHandle: " << value.getFederationHandle();
  //os << ", ";
  os << "label: " << value.getLabel();
  os << ", ";
  os << "federateHandleBoolPairVector: " << value.getFederateHandleBoolPairVector();
  os << " }";
  return os;
}

// MessageDataType EnableTimeRegulationRequestMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const EnableTimeRegulationRequestMessage& value)
{
  os << "{ ";
  // StructField federationHandle (hidden)
  //os << "federationHandle: " << value.getFederationHandle();
  //os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << ", ";
  os << "timeStamp: " << value.getTimeStamp();
  os << ", ";
  os << "commitId: " << value.getCommitId();
  os << " }";
  return os;
}

// MessageDataType EnableTimeRegulationResponseMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const EnableTimeRegulationResponseMessage& value)
{
  os << "{ ";
  // StructField federationHandle (hidden)
  //os << "federationHandle: " << value.getFederationHandle();
  //os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << ", ";
  os << "respondingFederateHandle: " << value.getRespondingFederateHandle();
  os << ", ";
  os << "timeStampValid: " << value.getTimeStampValid();
  os << ", ";
  os << "timeStamp: " << value.getTimeStamp();
  os << " }";
  return os;
}

// MessageDataType DisableTimeRegulationRequestMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const DisableTimeRegulationRequestMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << " }";
  return os;
}

// MessageDataType EnableTimeConstrainedNotifyMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const EnableTimeConstrainedNotifyMessage& value)
{
  os << "{ ";
  // StructField federationHandle (hidden)
  //os << "federationHandle: " << value.getFederationHandle();
  //os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << " }";
  return os;
}

// MessageDataType DisableTimeConstrainedNotifyMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const DisableTimeConstrainedNotifyMessage& value)
{
  os << "{ ";
  // StructField federationHandle (hidden)
  //os << "federationHandle: " << value.getFederationHandle();
  //os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << " }";
  return os;
}

// MessageDataType CommitLowerBoundTimeStampMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const CommitLowerBoundTimeStampMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  // StructField federateHandle (hidden)
  //os << "federateHandle: " << value.getFederateHandle();
  //os << ", ";
  os << "timeStamp: " << value.getTimeStamp();
  os << ", ";
  os << "commitType: " << value.getCommitType();
  os << ", ";
  os << "commitId: " << value.getCommitId();
  os << " }";
  return os;
}

// MessageDataType CommitLowerBoundTimeStampResponseMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const CommitLowerBoundTimeStampResponseMessage& value)
{
  os << "{ ";
  // StructField federationHandle (hidden)
  //os << "federationHandle: " << value.getFederationHandle();
  //os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << ", ";
  os << "sendingFederateHandle: " << value.getSendingFederateHandle();
  os << ", ";
  os << "commitId: " << value.getCommitId();
  os << " }";
  return os;
}

// MessageDataType LockedByNextMessageRequestMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const LockedByNextMessageRequestMessage& value)
{
  os << "{ ";
  // StructField federationHandle (hidden)
  //os << "federationHandle: " << value.getFederationHandle();
  //os << ", ";
  os << "sendingFederateHandle: " << value.getSendingFederateHandle();
  os << ", ";
  os << "lockedByNextMessage: " << value.getLockedByNextMessage();
  os << " }";
  return os;
}

// MessageDataType TimeConstrainedEnabledMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const TimeConstrainedEnabledMessage& value)
{
  os << "{ ";
  os << " }";
  return os;
}

// MessageDataType TimeRegulationEnabledMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const TimeRegulationEnabledMessage& value)
{
  os << "{ ";
  os << " }";
  return os;
}

// MessageDataType TimeAdvanceGrantedMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const TimeAdvanceGrantedMessage& value)
{
  os << "{ ";
  os << " }";
  return os;
}

// MessageDataType InsertRegionMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const InsertRegionMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "regionHandleDimensionHandleSetPairVector: " << value.getRegionHandleDimensionHandleSetPairVector();
  os << " }";
  return os;
}

// MessageDataType CommitRegionMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const CommitRegionMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "regionHandleRegionValuePairVector: " << value.getRegionHandleRegionValuePairVector();
  os << " }";
  return os;
}

// MessageDataType EraseRegionMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const EraseRegionMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "regionHandleVector: " << value.getRegionHandleVector();
  os << " }";
  return os;
}

// MessageDataType ChangeInteractionClassPublicationMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ChangeInteractionClassPublicationMessage& value)
{
  os << "{ ";
  // StructField federationHandle (hidden)
  //os << "federationHandle: " << value.getFederationHandle();
  //os << ", ";
  os << "publicationType: " << value.getPublicationType();
  os << ", ";
  os << "interactionClassHandle: " << value.getInteractionClassHandle();
  os << " }";
  return os;
}

// MessageDataType ChangeObjectClassPublicationMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ChangeObjectClassPublicationMessage& value)
{
  os << "{ ";
  // StructField federationHandle (hidden)
  //os << "federationHandle: " << value.getFederationHandle();
  //os << ", ";
  os << "publicationType: " << value.getPublicationType();
  os << ", ";
  os << "objectClassHandle: " << value.getObjectClassHandle();
  os << ", ";
  os << "attributeHandles: " << value.getAttributeHandles();
  os << " }";
  return os;
}

// MessageDataType ChangeInteractionClassSubscriptionMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ChangeInteractionClassSubscriptionMessage& value)
{
  os << "{ ";
  // StructField federationHandle (hidden)
  //os << "federationHandle: " << value.getFederationHandle();
  //os << ", ";
  os << "subscriptionType: " << value.getSubscriptionType();
  os << ", ";
  os << "interactionClassHandle: " << value.getInteractionClassHandle();
  os << ", ";
  os << "parameterFilterValues: " << value.getParameterFilterValues();
  os << " }";
  return os;
}

// MessageDataType ChangeObjectClassSubscriptionMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ChangeObjectClassSubscriptionMessage& value)
{
  os << "{ ";
  // StructField federationHandle (hidden)
  //os << "federationHandle: " << value.getFederationHandle();
  //os << ", ";
  os << "subscriptionType: " << value.getSubscriptionType();
  os << ", ";
  os << "objectClassHandle: " << value.getObjectClassHandle();
  os << ", ";
  os << "attributeHandles: " << value.getAttributeHandles();
  os << " }";
  return os;
}

// MessageDataType ChangeObjectInstanceSubscriptionMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ChangeObjectInstanceSubscriptionMessage& value)
{
  os << "{ ";
  // StructField federationHandle (hidden)
  //os << "federationHandle: " << value.getFederationHandle();
  //os << ", ";
  os << "subscriptionType: " << value.getSubscriptionType();
  os << ", ";
  os << "objectClassHandle: " << value.getObjectClassHandle();
  os << ", ";
  os << "objectInstanceHandle: " << value.getObjectInstanceHandle();
  os << " }";
  return os;
}

// MessageDataType RegistrationForObjectClassMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const RegistrationForObjectClassMessage& value)
{
  os << "{ ";
  os << "objectClassHandle: " << value.getObjectClassHandle();
  os << ", ";
  os << "start: " << value.getStart();
  os << " }";
  return os;
}

// MessageDataType AttributesInScopeMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const AttributesInScopeMessage& value)
{
  os << "{ ";
  os << "objectInstanceHandle: " << value.getObjectInstanceHandle();
  os << ", ";
  os << "attributeHandles: " << value.getAttributeHandles();
  os << ", ";
  os << "inScope: " << value.getInScope();
  os << " }";
  return os;
}

// MessageDataType TurnUpdatesOnForInstanceMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const TurnUpdatesOnForInstanceMessage& value)
{
  os << "{ ";
  os << "objectInstanceHandle: " << value.getObjectInstanceHandle();
  os << ", ";
  os << "attributeHandles: " << value.getAttributeHandles();
  os << ", ";
  os << "updateRate: " << value.getUpdateRate();
  os << ", ";
  os << "on: " << value.getOn();
  os << " }";
  return os;
}

// MessageDataType TurnInteractionsOnMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const TurnInteractionsOnMessage& value)
{
  os << "{ ";
  os << "interactionClassHandle: " << value.getInteractionClassHandle();
  os << ", ";
  os << "on: " << value.getOn();
  os << " }";
  return os;
}

// MessageDataType InteractionMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const InteractionMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << ", ";
  os << "interactionClassHandle: " << value.getInteractionClassHandle();
  os << ", ";
  os << "transportationType: " << value.getTransportationType();
  os << ", ";
  os << "tag: " << value.getTag();
  os << ", ";
  os << "parameterValues: " << value.getParameterValues();
  os << " }";
  return os;
}

// MessageDataType TimeStampedInteractionMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const TimeStampedInteractionMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << ", ";
  os << "interactionClassHandle: " << value.getInteractionClassHandle();
  os << ", ";
  os << "orderType: " << value.getOrderType();
  os << ", ";
  os << "transportationType: " << value.getTransportationType();
  os << ", ";
  os << "tag: " << value.getTag();
  os << ", ";
  os << "timeStamp: " << value.getTimeStamp();
  os << ", ";
  os << "messageRetractionHandle: " << value.getMessageRetractionHandle();
  os << ", ";
  os << "parameterValues: " << value.getParameterValues();
  os << " }";
  return os;
}

// MessageDataType ObjectInstanceHandlesRequestMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ObjectInstanceHandlesRequestMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << ", ";
  os << "count: " << value.getCount();
  os << " }";
  return os;
}

// MessageDataType ObjectInstanceHandlesResponseMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ObjectInstanceHandlesResponseMessage& value)
{
  os << "{ ";
  // StructField federationHandle (hidden)
  //os << "federationHandle: " << value.getFederationHandle();
  //os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << ", ";
  // StructField objectInstanceHandleNamePairVector (hidden)
  //os << "objectInstanceHandleNamePairVector: " << value.getObjectInstanceHandleNamePairVector();
  os << " }";
  return os;
}

// MessageDataType ReleaseMultipleObjectInstanceNameHandlePairsMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ReleaseMultipleObjectInstanceNameHandlePairsMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "objectInstanceHandleVector: " << value.getObjectInstanceHandleVector();
  os << " }";
  return os;
}

// MessageDataType ReserveObjectInstanceNameRequestMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ReserveObjectInstanceNameRequestMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << ", ";
  os << "name: " << value.getName();
  os << ", ";
  os << "isInternal: " << value.getIsInternal();
  os << " }";
  return os;
}

// MessageDataType ReserveObjectInstanceNameResponseMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ReserveObjectInstanceNameResponseMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << ", ";
  os << "objectInstanceHandleNamePair: " << value.getObjectInstanceHandleNamePair();
  os << ", ";
  os << "success: " << value.getSuccess();
  os << " }";
  return os;
}

// MessageDataType ReserveMultipleObjectInstanceNameRequestMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ReserveMultipleObjectInstanceNameRequestMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << ", ";
  os << "nameList: " << value.getNameList();
  os << " }";
  return os;
}

// MessageDataType ReserveMultipleObjectInstanceNameResponseMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const ReserveMultipleObjectInstanceNameResponseMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << ", ";
  // StructField objectInstanceHandleNamePairVector (hidden)
  //os << "objectInstanceHandleNamePairVector: " << value.getObjectInstanceHandleNamePairVector();
  //os << ", ";
  os << "success: " << value.getSuccess();
  os << " }";
  return os;
}

// MessageDataType InsertObjectInstanceMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const InsertObjectInstanceMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "objectClassHandle: " << value.getObjectClassHandle();
  os << ", ";
  os << "objectInstanceHandle: " << value.getObjectInstanceHandle();
  os << ", ";
  os << "name: " << value.getName();
  os << ", ";
  // StructField attributeStateVector (hidden)
  //os << "attributeStateVector: " << value.getAttributeStateVector();
  os << " }";
  return os;
}

// MessageDataType DeleteObjectInstanceMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const DeleteObjectInstanceMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << ", ";
  os << "objectInstanceHandle: " << value.getObjectInstanceHandle();
  os << ", ";
  os << "tag: " << value.getTag();
  os << " }";
  return os;
}

// MessageDataType TimeStampedDeleteObjectInstanceMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const TimeStampedDeleteObjectInstanceMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << ", ";
  os << "objectInstanceHandle: " << value.getObjectInstanceHandle();
  os << ", ";
  os << "orderType: " << value.getOrderType();
  os << ", ";
  os << "tag: " << value.getTag();
  os << ", ";
  os << "timeStamp: " << value.getTimeStamp();
  os << ", ";
  os << "messageRetractionHandle: " << value.getMessageRetractionHandle();
  os << " }";
  return os;
}

// MessageDataType AttributeUpdateMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const AttributeUpdateMessage& value)
{
  os << "{ ";
  // StructField federationHandle (hidden)
  //os << "federationHandle: " << value.getFederationHandle();
  //os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << ", ";
  os << "objectInstanceHandle: " << value.getObjectInstanceHandle();
  os << ", ";
  // StructField tag (hidden)
  //os << "tag: " << value.getTag();
  //os << ", ";
  // StructField transportationType (hidden)
  //os << "transportationType: " << value.getTransportationType();
  //os << ", ";
  // StructField attributeValues (hidden)
  //os << "attributeValues: " << value.getAttributeValues();
  os << " }";
  return os;
}

// MessageDataType TimeStampedAttributeUpdateMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const TimeStampedAttributeUpdateMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "federateHandle: " << value.getFederateHandle();
  os << ", ";
  os << "objectInstanceHandle: " << value.getObjectInstanceHandle();
  os << ", ";
  os << "tag: " << value.getTag();
  os << ", ";
  os << "timeStamp: " << value.getTimeStamp();
  os << ", ";
  os << "messageRetractionHandle: " << value.getMessageRetractionHandle();
  os << ", ";
  os << "orderType: " << value.getOrderType();
  os << ", ";
  os << "transportationType: " << value.getTransportationType();
  os << ", ";
  os << "attributeValues: " << value.getAttributeValues();
  os << " }";
  return os;
}

// MessageDataType RequestAttributeUpdateMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const RequestAttributeUpdateMessage& value)
{
  os << "{ ";
  // StructField federationHandle (hidden)
  //os << "federationHandle: " << value.getFederationHandle();
  //os << ", ";
  os << "objectInstanceHandle: " << value.getObjectInstanceHandle();
  os << ", ";
  // StructField attributeHandles (hidden)
  //os << "attributeHandles: " << value.getAttributeHandles();
  //os << ", ";
  os << "tag: " << value.getTag();
  os << " }";
  return os;
}

// MessageDataType RequestClassAttributeUpdateMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const RequestClassAttributeUpdateMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "objectClassHandle: " << value.getObjectClassHandle();
  os << ", ";
  os << "attributeHandles: " << value.getAttributeHandles();
  os << ", ";
  os << "tag: " << value.getTag();
  os << " }";
  return os;
}

// MessageDataType QueryAttributeOwnershipRequestMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const QueryAttributeOwnershipRequestMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "objectInstanceHandle: " << value.getObjectInstanceHandle();
  os << ", ";
  os << "attributeHandle: " << value.getAttributeHandle();
  os << " }";
  return os;
}

// MessageDataType QueryAttributeOwnershipResponseMessage
template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, const QueryAttributeOwnershipResponseMessage& value)
{
  os << "{ ";
  os << "federationHandle: " << value.getFederationHandle();
  os << ", ";
  os << "objectInstanceHandle: " << value.getObjectInstanceHandle();
  os << ", ";
  os << "attributeHandle: " << value.getAttributeHandle();
  os << ", ";
  os << "owner: " << value.getOwner();
  os << " }";
  return os;
}


// StructDataType RangeBoundsValue
inline std::string to_string(const RangeBoundsValue& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType AttributeState
inline std::string to_string(const AttributeState& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType ParameterValue
inline std::string to_string(const ParameterValue& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType AttributeValue
inline std::string to_string(const AttributeValue& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FederationExecutionInformation
inline std::string to_string(const FederationExecutionInformation& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMStringSimpleDataType
inline std::string to_string(const FOMStringSimpleDataType& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMStringEnumerator
inline std::string to_string(const FOMStringEnumerator& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMStringEnumeratedDataType
inline std::string to_string(const FOMStringEnumeratedDataType& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMStringArrayDataType
inline std::string to_string(const FOMStringArrayDataType& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMStringFixedRecordField
inline std::string to_string(const FOMStringFixedRecordField& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMStringFixedRecordDataType
inline std::string to_string(const FOMStringFixedRecordDataType& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMStringVariantRecordAlternative
inline std::string to_string(const FOMStringVariantRecordAlternative& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMStringVariantRecordDataType
inline std::string to_string(const FOMStringVariantRecordDataType& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMStringTransportationType
inline std::string to_string(const FOMStringTransportationType& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMStringDimension
inline std::string to_string(const FOMStringDimension& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMStringRoutingSpace
inline std::string to_string(const FOMStringRoutingSpace& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMStringParameter
inline std::string to_string(const FOMStringParameter& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMStringInteractionClass
inline std::string to_string(const FOMStringInteractionClass& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMStringAttribute
inline std::string to_string(const FOMStringAttribute& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMStringObjectClass
inline std::string to_string(const FOMStringObjectClass& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMStringUpdateRate
inline std::string to_string(const FOMStringUpdateRate& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMStringSwitch
inline std::string to_string(const FOMStringSwitch& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMStringModule
inline std::string to_string(const FOMStringModule& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMTransportationType
inline std::string to_string(const FOMTransportationType& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMDimension
inline std::string to_string(const FOMDimension& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMRoutingSpace
inline std::string to_string(const FOMRoutingSpace& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMParameter
inline std::string to_string(const FOMParameter& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMInteractionClass
inline std::string to_string(const FOMInteractionClass& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMAttribute
inline std::string to_string(const FOMAttribute& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMObjectClass
inline std::string to_string(const FOMObjectClass& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMUpdateRate
inline std::string to_string(const FOMUpdateRate& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMSwitch
inline std::string to_string(const FOMSwitch& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

// StructDataType FOMModule
inline std::string to_string(const FOMModule& value)
{
    std::ostringstream out;
    out << value;
    return out.str();
}

} // namespace OpenRTI

#endif
