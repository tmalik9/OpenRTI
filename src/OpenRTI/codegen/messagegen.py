#!/usr/bin/python
#
# This file is part of OpenRTI.
#
# OpenRTI is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2.1 of the License, or
# (at your option) any later version.
#
# OpenRTI is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with OpenRTI.  If not, see <http://www.gnu.org/licenses/>.
#

class SourceStream(object):
    def __init__(self, stream):
        self.__stream = stream
        self.__indent = 0

    def pushIndent(self):
        self.__indent += 1

    def popIndent(self):
        self.__indent -= 1

    def write(self, data):
        self.__stream.write(data)

    def writeline(self, line = None):
        if line is not None:
            count = self.__indent
            while 0 < count:
                self.write('  ')
                count = count - 1
            self.write(line)
        self.write('\n')

    def writelineNoIndent(self, line = None):
        self.write(line)
        self.write('\n')

    def writeCopyright(self):
        self.writeline('/* -*-c++-*- OpenRTI - Copyright (C) 2009-2013 Mathias Froehlich')
        self.writeline(' *')
        self.writeline(' *')
        self.writeline(' * This file is part of OpenRTI.')
        self.writeline(' *')
        self.writeline(' * OpenRTI is free software: you can redistribute it and/or modify')
        self.writeline(' * it under the terms of the GNU Lesser General Public License as published by')
        self.writeline(' * the Free Software Foundation, either version 2.1 of the License, or')
        self.writeline(' * (at your option) any later version.')
        self.writeline(' *')
        self.writeline(' * OpenRTI is distributed in the hope that it will be useful,')
        self.writeline(' * but WITHOUT ANY WARRANTY; without even the implied warranty of')
        self.writeline(' * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the')
        self.writeline(' * GNU Lesser General Public License for more details.')
        self.writeline(' *')
        self.writeline(' * You should have received a copy of the GNU Lesser General Public License')
        self.writeline(' * along with OpenRTI.  If not, see <http://www.gnu.org/licenses/>.')
        self.writeline(' *')
        self.writeline(' * This file is autogenerated by messagegen.py. Do not edit!')
        self.writeline(' *')
        self.writeline(' */')
        self.writeline()


###############################################################################
class DataType(object):
    def __init__(self, typeMap, name, hasSwap, parentObject=None):
        self.__name = name
        self.__hasSwap = hasSwap
        self._hasPayload = None
        self.__parentObject = parentObject
        self.__typeMap = typeMap;

    def getName(self):
        return self.__name

    def getType(self, name):
      return self.__typeMap.getType(name)

    def getParentObject(self):
        return self.__parentObject

    def getParentObjectType(self):
        return "ServerModel::" + self.__parentObject

    def getParentObjectParameter(self):
        return self.__parentObject[0].lower() + self.__parentObject[1:]

    def isMessage(self):
        return False

    def resolveHasPayloadAndHasSwap(self, typeMap):
        pass

    def hasPayload(self):
        return self._hasPayload

    def hasSwap(self):
        return self.__hasSwap

    def writeForwardDeclaration(self, sourceStream):
        pass

    def writeDeclaration(self, sourceStream):
        pass

    def writeImplementation(self, sourceStream):
        pass

    def writeComponent(self, component, sourceStream, messageEncoding):
        pass

    def writeStreamOut(self, sourceStream):
        pass

    def writeStreamOutDecl(self, sourceStream):
        pass

    def writePrettyPrint(self, sourceStream):
        pass

    def writePrettyPrintDecl(self, sourceStream):
        pass

    def writeByteSize(self, sourceStream):
        pass

    def writeByteSizeDecl(self, sourceStream):
        pass

    def writeToString(self, sourceStream):
        pass

###############################################################################
class CDataType(DataType):
    def __init__(self, typeMap, name, encoding, ctype, parentObject="Federation"):
        if ctype == 'VariableLengthData' or ctype == 'std::string':
            hasSwap = True
        else:
            hasSwap = False
        DataType.__init__(self, typeMap, name, hasSwap, parentObject)
        self.__encoding = encoding
        self.__ctype = ctype

    def getEncoding(self):
        return self.__encoding

    def getTypeName(self):
        return self.__ctype

    def resolveHasPayloadAndHasSwap(self, typeMap):
        self._hasPayload = self.getTypeName() == 'VariableLengthData'

    def writeForwardDeclaration(self, sourceStream):
        self.writeDeclaration(sourceStream)

    def writeDeclaration(self, sourceStream):
        name = self.getName()
        typeName = self.getTypeName()
        if typeName == name:
            return
        sourceStream.writeline('typedef {typeName} {name};'.format(typeName = typeName, name = name))
        sourceStream.writeline()

    def writeComponent(self, component, sourceStream, messageEncoding):
        getattr(messageEncoding, 'writeC' + component)(self, sourceStream)

###############################################################################
class EnumLabel(object):
    def __init__(self, name, value, repr):
        self.__name = name
        self.__value = value
        self.__repr = repr

    def getName(self):
        return self.__name

    def getValue(self):
        return self.__value

    def getRepr(self):
        return self.__repr

class EnumDataType(DataType):
    def __init__(self, typeMap, name):
        DataType.__init__(self, typeMap, name, False)
        self.__enumList = []

    def addEnum(self, name, value, repr=None):
        if repr is None:
            self.__enumList.append(EnumLabel(name, value, name))
        else:
            self.__enumList.append(EnumLabel(name, value, repr))

    def getEnumList(self):
        return self.__enumList

    def writeForwardDeclaration(self, sourceStream):
        # enums cannot be forward declared, so, emit the full definition
        sourceStream.writeline('enum {name} {{'.format(name = self.getName()))
        sourceStream.pushIndent()

        index = 0
        for enum in self.__enumList:
            line = '{enum}'.format(enum = enum.getName())
            value = enum.getValue()
            if value is not None:
                line += ' = {value}'.format(value = value)
            index = index + 1
            if index < len(self.__enumList):
                line += ','
            sourceStream.writeline(line)

        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()

    def writeComponent(self, component, sourceStream, messageEncoding):
        getattr(messageEncoding, 'writeEnum' + component)(self, sourceStream)

    def writeStreamOutDecl(self, sourceStream):
        sourceStream.writeline('std::ostream& operator<<(std::ostream& os, const {name}& value);'.format(name = self.getName()))

    def writeStreamOut(self, sourceStream):
        sourceStream.writeline('// ' + type(self).__name__ + " " + self.getName())
        sourceStream.writeline('std::ostream&')
        sourceStream.writeline('operator<<(std::ostream& os, const {name}& value)'.format(name = self.getName()))
        sourceStream.writeline('{')
        sourceStream.writeline('  switch (value) {')
        for enum in self.__enumList:
            sourceStream.writeline('  case {enum}: os << "{repr}"; break;'.format(enum = enum.getName(), repr=enum.getRepr()))
        sourceStream.writeline('  }')
        sourceStream.writeline('  return os;')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writePrettyPrintDecl(self, sourceStream):
        if not self.getParentObject() is None:
            parentObjectType=self.getParentObjectType()
            parentObjectParameter=self.getParentObjectParameter()
            sourceStream.writeline('std::ostream& prettyprint(std::ostream& os, const {name}& value, {parentObjectType}* {parentObjectParameter});'.format(
            name = self.getName(), parentObjectType=parentObjectType, parentObjectParameter=parentObjectParameter))
        else:
            sourceStream.writeline('std::ostream& prettyprint(std::ostream& os, const {name}& value);'.format(name = self.getName()))

    def writePrettyPrint(self, sourceStream):
        sourceStream.writeline('std::ostream&')
        sourceStream.writeline('prettyprint(std::ostream& os, const {name}& value, ServerModel::Federation* )'.format(name = self.getName()))
        sourceStream.writeline('{')
        sourceStream.writeline('  os << value;')
        sourceStream.writeline('  return os;')
        sourceStream.writeline('}')
        sourceStream.writeline()
        sourceStream.writeline('inline std::string to_string(const {name}& value)'.format(name = self.getName()))
        sourceStream.writeline('{')
        sourceStream.writeline('  switch (value) {')
        for enum in self.__enumList:
            sourceStream.writeline('  case {enum}: return "{repr}";'.format(enum = enum.getName(), repr=enum.getRepr()))
        sourceStream.writeline('  default: return "<Invalid {name}>";'.format(name = self.getName()))
        sourceStream.writeline('  }')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeByteSize(self, sourceStream):
        sourceStream.writeline('inline constexpr size_t byteSize(const {name}& value) noexcept'.format(name = self.getName()))
        sourceStream.writeline('{')
        sourceStream.writeline(' return sizeof(value); // sizeof()'.format(name = self.getName()))
        sourceStream.writeline('}')
        sourceStream.writeline()


###############################################################################
class VectorDataType(DataType):
    def __init__(self, typeMap, name, scalarTypeName, parentObject):
        DataType.__init__(self, typeMap, name, True, parentObject)
        self.__scalarTypeName = scalarTypeName

    def getScalarTypeName(self):
        return self.__scalarTypeName

    def resolveHasPayloadAndHasSwap(self, typeMap):
        t = typeMap.getType(self.getScalarTypeName())
        t.resolveHasPayloadAndHasSwap(typeMap)
        self._hasPayload = t.hasPayload()

    def writeForwardDeclaration(self, sourceStream):
        self.writeDeclaration(sourceStream)

    def writeDeclaration(self, sourceStream):
        scalar = self.__scalarTypeName
        sourceStream.writeline('typedef std::vector<{scalar}> {name};'.format(scalar = scalar, name = self.getName()))
        sourceStream.writeline()

    def writeComponent(self, component, sourceStream, messageEncoding):
        getattr(messageEncoding, 'writeVector' + component)(self, sourceStream)

    def writePrettyPrintDecl(self, sourceStream):
        if not self.getParentObject() is None:
            parentObjectType=self.getParentObjectType()
            parentObjectParameter=self.getParentObjectParameter()
            sourceStream.writeline('std::ostream& prettyprint(std::ostream& os, const {name}& value, {parentObjectType}* {parentObjectParameter});'.format(
            name = self.getName(), parentObjectType=parentObjectType, parentObjectParameter=parentObjectParameter))
        else:
            sourceStream.writeline('std::ostream& prettyprint(std::ostream& os, const {name}& value);'.format(name = self.getName()))

    def writeStreamOutDecl(self, sourceStream):
        sourceStream.writeline('std::ostream& operator<<(std::ostream& os, const {name}& value);'.format(name = self.getName()))

    def writeStreamOut(self, sourceStream):
        # FIXME, make the std::* containers with a template
        name = self.getName();
        sourceStream.writeline('// ' + type(self).__name__ + " " + self.getName())
        sourceStream.writeline('std::ostream&')
        sourceStream.writeline('operator<<(std::ostream& os, const {name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  os << "{ ";')
        sourceStream.writeline('  {name}::const_iterator i = value.begin();'.format(name = name))
        sourceStream.writeline('  if (i != value.end()) {')
        sourceStream.writeline('    os << *i;')
        sourceStream.writeline('    while (++i != value.end()) {')
        sourceStream.writeline('      os << ", " << *i;')
        sourceStream.writeline('    }')
        sourceStream.writeline('  }')
        sourceStream.writeline('  os << " }";')
        sourceStream.writeline('  return os;')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writePrettyPrint(self, sourceStream):
        name = self.getName();
        sourceStream.writeline('std::ostream&')
        parentObject=self.getParentObject()
        if parentObject is None:
            sourceStream.writeline('prettyprint(std::ostream& os, const {name}& value)'.format(name = name))
        else:
            parentObjectType=self.getParentObjectType()
            parentObjectParameter=self.getParentObjectParameter()
            sourceStream.writeline('prettyprint(std::ostream& os, const {name}& value, {parentObjectType}* {parentObjectParameter})'.format(
              name = name, parentObjectType=parentObjectType, parentObjectParameter=parentObjectParameter))

        sourceStream.writeline('{')
        sourceStream.writeline('  os << "{ ";')
        sourceStream.writeline('  {name}::const_iterator i = value.begin();'.format(name = name))
        sourceStream.writeline('  if (i != value.end()) {')
        if parentObject is None:
            sourceStream.writeline('    os << *i;')
        else:
            sourceStream.writeline('    prettyprint(os, *i, {parentObjectParameter});'.format(parentObjectParameter=parentObjectParameter))

        sourceStream.writeline('    while (++i != value.end()) {')
        if parentObject is None:
            sourceStream.writeline('      os << ", " << *i;')
        else:
            sourceStream.writeline('      os << ", "; prettyprint(os, *i, {parentObjectParameter});'.format(parentObjectParameter=parentObjectParameter))
        sourceStream.writeline('    }')
        sourceStream.writeline('  }')
        sourceStream.writeline('  os << " }";')
        sourceStream.writeline('  return os;')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeByteSize(self, sourceStream):
        sourceStream.writeline('inline size_t byteSize(const {name}& value) noexcept'.format(name = self.getName()))
        sourceStream.writeline('{')
        sourceStream.pushIndent()
        sourceStream.writeline('size_t result = 0;');
        sourceStream.writeline('for (auto& item : value)');
        sourceStream.writeline('{')
        sourceStream.pushIndent()
        sourceStream.writeline('result += byteSize(item);');
        sourceStream.popIndent()
        sourceStream.writeline('}')
        sourceStream.writeline('return result;');
        sourceStream.popIndent()
        sourceStream.writeline('}')
        sourceStream.writeline()

###############################################################################
class SetDataType(DataType):
    def __init__(self, typeMap, name, scalarTypeName):
        DataType.__init__(self, typeMap, name, True)
        self.__scalarTypeName = scalarTypeName

    def getScalarTypeName(self):
        return self.__scalarTypeName

    def resolveHasPayloadAndHasSwap(self, typeMap):
        t = typeMap.getType(self.getScalarTypeName())
        t.resolveHasPayloadAndHasSwap(typeMap)
        self._hasPayload = t.hasPayload()

    def writeForwardDeclaration(self, sourceStream):
        self.writeDeclaration(sourceStream)

    def writeDeclaration(self, sourceStream):
        scalar = self.__scalarTypeName
        sourceStream.writeline('typedef std::set<{scalar}> {name};'.format(scalar = scalar, name = self.getName()))
        sourceStream.writeline()

    def writeComponent(self, component, sourceStream, messageEncoding):
        getattr(messageEncoding, 'writeSet' + component)(self, sourceStream)

    def writePrettyPrintDecl(self, sourceStream):
        if not self.getParentObject() is None:
            parentObjectType=self.getParentObjectType()
            parentObjectParameter=self.getParentObjectParameter()
            sourceStream.writeline('std::ostream& prettyprint(std::ostream& os, const {name}& value, {parentObjectType}* {parentObjectParameter});'.format(
            name = self.getName(), parentObjectType=parentObjectType, parentObjectParameter=parentObjectParameter))
        else:
            sourceStream.writeline('std::ostream& prettyprint(std::ostream& os, const {name}& value);'.format(name = self.getName()))

    def writeStreamOutDecl(self, sourceStream):
        sourceStream.writeline('std::ostream& operator<<(std::ostream& os, const {name}& value);'.format(name = self.getName()))

    def writeStreamOut(self, sourceStream):
        # FIXME, make the std::* containers with a template
        name = self.getName();
        sourceStream.writeline('// ' + type(self).__name__ + " " + self.getName())
        sourceStream.writeline('std::ostream&')
        sourceStream.writeline('operator<<(std::ostream& os, const {name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  os << "{ ";')
        sourceStream.writeline('  {name}::const_iterator i = value.begin();'.format(name = name))
        sourceStream.writeline('  if (i != value.end()) {')
        sourceStream.writeline('    os << *i;')
        sourceStream.writeline('    while (++i != value.end()) {')
        sourceStream.writeline('      os << ", " << *i;')
        sourceStream.writeline('    }')
        sourceStream.writeline('  }')
        sourceStream.writeline('  os << " }";')
        sourceStream.writeline('  return os;')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writePrettyPrint(self, sourceStream):
        name = self.getName();
        sourceStream.writeline('std::ostream&')
        sourceStream.writeline('prettyprint(std::ostream& os, const {name}& value, ServerModel::Federation* federation)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  os << "{ ";')
        sourceStream.writeline('  {name}::const_iterator i = value.begin();'.format(name = name))
        sourceStream.writeline('  if (i != value.end()) {')
        sourceStream.writeline('    prettyprint(os, *i, federation);')
        sourceStream.writeline('    while (++i != value.end()) {')
        sourceStream.writeline('      os << ", "; prettyprint(os, *i, federation);')
        sourceStream.writeline('    }')
        sourceStream.writeline('  }')
        sourceStream.writeline('  os << " }";')
        sourceStream.writeline('  return os;')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeByteSize(self, sourceStream):
        sourceStream.writeline('inline size_t byteSize(const {name}& value) noexcept'.format(name = self.getName()))
        sourceStream.writeline('{')
        sourceStream.pushIndent()
        sourceStream.writeline('size_t result = 0;');
        sourceStream.writeline('for (auto& item : value)');
        sourceStream.writeline('{')
        sourceStream.pushIndent()
        sourceStream.writeline('result += byteSize(item);');
        sourceStream.popIndent()
        sourceStream.writeline('}')
        sourceStream.writeline('return result;');
        sourceStream.popIndent()
        sourceStream.writeline('}')
        sourceStream.writeline()


###############################################################################
class MapDataType(DataType):
    def __init__(self, typeMap, name, keyTypeName, valueTypeName):
        DataType.__init__(self, typeMap, name, True)
        self.__keyTypeName = keyTypeName
        self.__valueTypeName = valueTypeName
        self.__keyHasPayload = None
        self.__valueHasPayload = None

    def getKeyTypeName(self):
        return self.__keyTypeName

    def getValueTypeName(self):
        return self.__valueTypeName

    def resolveHasPayloadAndHasSwap(self, typeMap):
        t = typeMap.getType(self.getKeyTypeName())
        t.resolveHasPayloadAndHasSwap(typeMap)
        self.__keyHasPayload = t.hasPayload()
        t = typeMap.getType(self.getValueTypeName())
        t.resolveHasPayloadAndHasSwap(typeMap)
        self.__valueHasPayload = t.hasPayload()
        self._hasPayload = self.__keyHasPayload or self.__valueHasPayload

    def keyHasPayload(self):
        return self.__keyHasPayload

    def valueHasPayload(self):
        return self.__valueHasPayload

    def writeForwardDeclaration(self, sourceStream):
        self.writeDeclaration(sourceStream)

    def writeDeclaration(self, sourceStream):
        keyTypeName = self.__keyTypeName
        valueTypeName = self.__valueTypeName
        sourceStream.writeline('typedef std::map<{keyTypeName}, {valueTypeName}> {name};'.format(keyTypeName = keyTypeName, valueTypeName = valueTypeName, name = self.getName()))
        sourceStream.writeline()

    def writeComponent(self, component, sourceStream, messageEncoding):
        getattr(messageEncoding, 'writeMap' + component)(self, sourceStream)

    def writePrettyPrintDecl(self, sourceStream):
        if not self.getParentObject() is None:
            parentObjectType=self.getParentObjectType()
            parentObjectParameter=self.getParentObjectParameter()
            sourceStream.writeline('std::ostream& prettyprint(std::ostream& os, const {name}& value, {parentObjectType}* {parentObjectParameter});'.format(
            name = self.getName(), parentObjectType=parentObjectType, parentObjectParameter=parentObjectParameter))
        else:
            sourceStream.writeline('std::ostream& prettyprint(std::ostream& os, const {name}& value);'.format(name = self.getName()))

    def writeStreamOutDecl(self, sourceStream):
        sourceStream.writeline('std::ostream& operator<<(std::ostream& os, const {name}& value);'.format(name = self.getName()))

    def writeStreamOut(self, sourceStream):
        # FIXME, make the std::* containers with a template
        name = self.getName();
        sourceStream.writeline('// ' + type(self).__name__ + " " + self.getName())
        sourceStream.writeline('std::ostream&')
        sourceStream.writeline('operator<<(std::ostream& os, const {name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  os << "{ ";')
        sourceStream.writeline('  {name}::const_iterator i = value.begin();'.format(name = name))
        sourceStream.writeline('  if (i != value.end()) {')
        sourceStream.writeline('    os << i->first << ": " << i->second;')
        sourceStream.writeline('    while (++i != value.end()) {')
        sourceStream.writeline('      os << ", " << i->first << ": " << i->second;')
        sourceStream.writeline('    }')
        sourceStream.writeline('  }')
        sourceStream.writeline('  os << " }";')
        sourceStream.writeline('  return os;')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writePrettyPrint(self, sourceStream):
        name = self.getName();
        sourceStream.writeline('std::ostream&')
        sourceStream.writeline('prettyprint(std::ostream& os, const {name}& value, ServerModel::Federation* federation)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  os << "{ ";')
        sourceStream.writeline('  {name}::const_iterator i = value.begin();'.format(name = name))
        sourceStream.writeline('  if (i != value.end()) {')
        sourceStream.writeline('    prettyprint(os, i->first, federation); os << ": "; prettyprint(os, i->second, federation);')
        sourceStream.writeline('    while (++i != value.end()) {')
        sourceStream.writeline('      prettyprint(os, i->first, federation); os << ": "; prettyprint(os, i->second, federation);')
        sourceStream.writeline('    }')
        sourceStream.writeline('  }')
        sourceStream.writeline('  os << " }";')
        sourceStream.writeline('  return os;')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeByteSize(self, sourceStream):
        sourceStream.writeline('inline size_t byteSize(const {name}& value) noexcept'.format(name = self.getName()))
        sourceStream.writeline('{')
        sourceStream.pushIndent()
        sourceStream.writeline('size_t result = 0;');
        sourceStream.writeline('for (auto& item : value)');
        sourceStream.writeline('{')
        sourceStream.pushIndent()
        sourceStream.writeline('result += byteSize(item.first);');
        sourceStream.writeline('result += byteSize(item.second);');
        sourceStream.popIndent()
        sourceStream.writeline('}')
        sourceStream.writeline('return result;');
        sourceStream.popIndent()
        sourceStream.writeline('}')
        sourceStream.writeline()


###############################################################################
class PairDataType(DataType):
    def __init__(self, typeMap, name, firstTypeName, secondTypeName):
        DataType.__init__(self, typeMap, name, False)
        self.__firstTypeName = firstTypeName
        self.__secondTypeName = secondTypeName
        self.__firstHasPayload = None
        self.__secondHasPayload = None

    def getFirstTypeName(self):
        return self.__firstTypeName

    def getSecondTypeName(self):
        return self.__secondTypeName

    def resolveHasPayloadAndHasSwap(self, typeMap):
        t = typeMap.getType(self.getFirstTypeName())
        t.resolveHasPayloadAndHasSwap(typeMap)
        self.__firstHasPayload = t.hasPayload()
        t = typeMap.getType(self.getSecondTypeName())
        t.resolveHasPayloadAndHasSwap(typeMap)
        self.__secondHasPayload = t.hasPayload()
        self._hasPayload = self.__firstHasPayload or self.__secondHasPayload

    def firstHasPayload(self):
        return self.__firstHasPayload

    def secondHasPayload(self):
        return self.__secondHasPayload

    def writeForwardDeclaration(self, sourceStream):
        self.writeDeclaration(sourceStream)

    def writeDeclaration(self, sourceStream):
        name = self.getName()
        firstTypeName = self.__firstTypeName
        secondTypeName = self.__secondTypeName
        sourceStream.writeline('typedef std::pair<{first}, {second}> {name};'.format(first = firstTypeName, second = secondTypeName, name = name))
        sourceStream.writeline()

    def writeComponent(self, component, sourceStream, messageEncoding):
        getattr(messageEncoding, 'writePair' + component)(self, sourceStream)

    def writePrettyPrintDecl(self, sourceStream):
        if not self.getParentObject() is None:
            parentObjectType=self.getParentObjectType()
            parentObjectParameter=self.getParentObjectParameter()
            sourceStream.writeline('std::ostream& prettyprint(std::ostream& os, const {name}& value, {parentObjectType}* {parentObjectParameter});'.format(
            name = self.getName(), parentObjectType=parentObjectType, parentObjectParameter=parentObjectParameter))
        else:
            sourceStream.writeline('std::ostream& prettyprint(std::ostream& os, const {name}& value);'.format(name = self.getName()))

    def writeStreamOutDecl(self, sourceStream):
        sourceStream.writeline('std::ostream& operator<<(std::ostream& os, const {name}& value);'.format(name = self.getName()))

    def writeStreamOut(self, sourceStream):
        sourceStream.writeline('// ' + type(self).__name__ + " " + self.getName())
        sourceStream.writeline('std::ostream&')
        sourceStream.writeline('operator<<(std::ostream& os, const {name}& value)'.format(name = self.getName()))
        sourceStream.writeline('{')
        sourceStream.writeline('  os << "{ ";')
        sourceStream.writeline('  os << "first: " << value.first << ", ";')
        sourceStream.writeline('  os << "second: " << value.second;')
        sourceStream.writeline('  os << " }";')
        sourceStream.writeline('  return os;')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writePrettyPrint(self, sourceStream):
        sourceStream.writeline('std::ostream&')
        sourceStream.writeline('prettyprint(std::ostream& os, const {name}& value, ServerModel::Federation* federation)'.format(name = self.getName()))
        sourceStream.writeline('{')
        sourceStream.writeline('  os << "{ ";')
        sourceStream.writeline('  os << "first: "; prettyprint(os, value.first, federation); os << ", ";')
        sourceStream.writeline('  os << "second: "; prettyprint(os, value.second, federation); os << ", ";')
        sourceStream.writeline('  os << " }";')
        sourceStream.writeline('  return os;')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeByteSize(self, sourceStream):
        sourceStream.writeline('inline size_t byteSize(const {name}& value) noexcept'.format(name = self.getName()))
        sourceStream.writeline('{')
        sourceStream.pushIndent()
        sourceStream.writeline('return byteSize(value.first) + byteSize(value.second);');
        sourceStream.popIndent()
        sourceStream.writeline('}')
        sourceStream.writeline()

###############################################################################
class StructField(object):
    def __init__(self, name, typeName, abstract=False, override=False, hideOnPrint=False):
        if abstract and override:
            raise Exception('abstract and override can\'t be used together, field {0}'.format(name))
        self.__name = name
        self.__typeName = typeName
        self.__hasSwap = False
        self.__abstract = abstract
        self.__override = override
        self._hasPayload = None
        self._hideOnPrint = hideOnPrint


    def getName(self):
        return self.__name

    def getLowerName(self):
        return self.__name[0].lower() + self.__name[1:len(self.__name)]

    def getUpperName(self):
        return self.__name[0].upper() + self.__name[1:len(self.__name)]

    def getMemberName(self):
        return '_' + self.getLowerName()

    def getTypeName(self):
        return self.__typeName

    def resolveHasPayloadAndHasSwap(self, typeMap):
        t = typeMap.getType(self.getTypeName())
        if t is None:
            raise Exception("struct field type not defined: field={0} {1}".format(self.getName(), self.getTypeName()))
        t.resolveHasPayloadAndHasSwap(typeMap)
        self._hasPayload = t.hasPayload()

        self.__hasSwap = t.hasSwap()

    def hasPayload(self):
        return self._hasPayload

    def hideOnPrint(self):
        return self._hideOnPrint

    def writeSetter(self, sourceStream, valuePrefix):
        upperName = self.getUpperName()
        typeName = self.getTypeName()
        memberName = self.getMemberName()
        if self.__abstract:
            sourceStream.writeline('virtual void set{upperName}(const {typeName}& value) noexcept = 0;'.format(upperName = upperName, typeName = typeName))
            sourceStream.writeline('virtual void set{upperName}({typeName}&& value) noexcept = 0;'.format(upperName = upperName, typeName = typeName))
        else:
            override=""
            if self.__override:
                override = " override"
            sourceStream.writeline('void set{upperName}(const {typeName}& value) noexcept{override}'.format(upperName = upperName, typeName = typeName, override=override))
            sourceStream.writeline('{{ {prefix}{memberName} = value; }}'.format(memberName = memberName, prefix = valuePrefix))
            sourceStream.writeline('void set{upperName}({typeName}&& value) noexcept{override}'.format(upperName = upperName, typeName = typeName, override=override))
            sourceStream.writeline('{{ {prefix}{memberName} = std::move(value); }}'.format(memberName = memberName, prefix = valuePrefix))

    def writeGetter(self, sourceStream, valuePrefix):
        upperName = self.getUpperName()
        typeName = self.getTypeName()
        memberName = self.getMemberName()
        if self.__abstract:
            sourceStream.writeline('virtual {typeName}& get{upperName}() noexcept = 0;'.format(upperName = upperName, typeName = typeName))
        else:
            override=""
            if self.__override:
                override = " override"
            sourceStream.writeline('{typeName}& get{upperName}() noexcept{override}'.format(upperName = upperName, typeName = typeName, override=override))
            sourceStream.writeline('{{ return {prefix}{memberName}; }}'.format(memberName = memberName, prefix = valuePrefix))

    def writeConstGetter(self, sourceStream, valuePrefix):
        upperName = self.getUpperName()
        typeName = self.getTypeName()
        memberName = self.getMemberName()
        if self.__abstract:
            sourceStream.writeline('virtual const {typeName}& get{upperName}() const noexcept = 0;'.format(upperName = upperName, typeName = typeName))
        else:
            override=""
            if self.__override:
                override = " override"
            sourceStream.writeline('const {typeName}& get{upperName}() const noexcept{override}'.format(upperName = upperName, typeName = typeName, override=override))
            sourceStream.writeline('{{ return {prefix}{memberName}; }}'.format(memberName = memberName, prefix = valuePrefix))

    def writeMemberInstance(self, sourceStream):
        if not self.__abstract:
            typeName = self.getTypeName()
            memberName = self.getMemberName()
            initializer = ''
            if typeName == 'Bool':
                initializer = ' = false'
            elif typeName == 'Unsigned':
                initializer = ' = 0'
            else:
                typeOfField = typeMap.getType(typeName)
                if type(typeOfField) is EnumDataType:
                    firstValue = typeOfField.getEnumList()[0].getName()
                    initializer = ' = ' + firstValue
            sourceStream.writeline('{typeName} {memberName}{initializer};'.format(typeName = typeName, memberName = memberName, initializer=initializer))

    def writeSwap(self, sourceStream, value):
        if not self.__abstract:
            memberName = self.getMemberName()
            if self.__hasSwap:
                sourceStream.writeline('{memberName}.swap({value}.{memberName});'.format(memberName = memberName, value = value))
            else:
                sourceStream.writeline('std::swap({memberName}, {value}.{memberName});'.format(memberName = memberName, value = value))

class StructConstField(object):
    def __init__(self, name, typeName, value=None, abstract=False, override=False, hideOnPrint=False):
        self.__name = name
        self.__typeName = typeName
        self.__hasSwap = False
        self.__value = value
        self.__abstract = abstract
        self.__override = override
        self._hasPayload = None
        self._hideOnPrint = hideOnPrint
        if value is None and abstract is False:
            raise Exception("value must be specified: field {0}".format(name))

    def getName(self):
        return self.__name

    def getLowerName(self):
        return self.__name[0].lower() + self.__name[1:len(self.__name)]

    def getUpperName(self):
        return self.__name[0].upper() + self.__name[1:len(self.__name)]

    def getMemberName(self):
        return '_' + self.getLowerName()

    def getTypeName(self):
        return self.__typeName

    def resolveHasPayloadAndHasSwap(self, typeMap):
        t = typeMap.getType(self.getTypeName())
        t.resolveHasPayloadAndHasSwap(typeMap)
        self._hasPayload = t.hasPayload()

        self.__hasSwap = t.hasSwap()

    def hasPayload(self):
        return False

    def hideOnPrint(self):
        return self._hideOnPrint

    def writeSetter(self, sourceStream, valuePrefix):
        pass

    def writeGetter(self, sourceStream, valuePrefix):
        pass

    def writeConstGetter(self, sourceStream, valuePrefix):
        upperName = self.getUpperName()
        typeName = self.getTypeName()
        memberName = self.getMemberName()
        if self.__abstract:
            sourceStream.writeline('virtual const {typeName} get{upperName}() const noexcept = 0;'.format(upperName = upperName, typeName = typeName))
        else:
            override=""
            if self.__override:
                override = " override"
            sourceStream.writeline('const {typeName} get{upperName}() const noexcept{override} {{ return {value}; }}'.format(upperName = upperName, typeName = typeName, value = self.__value, override=override))

    def writeMemberInstance(self, sourceStream):
        pass

    def writeSwap(self, sourceStream, value):
        pass

###############################################################################
class StructDataType(DataType):
    def __init__(self, typeMap, name, abstract=None, parentObject = None, parentTypeName = None):
        DataType.__init__(self, typeMap, name, hasSwap=True, parentObject=parentObject)
        self.__parentTypeName = parentTypeName
        self.__fieldList = []
        self.__cow = False
        if abstract is not None and abstract.lower() == 'true':
            self.__abstract = True
        else:
            self.__abstract = False

    def setCopyOnWrite(self, cow):
        if self.__abstract and cow:
            raise Exception('copyOnWrite and abstract can\'t be used together')
        self.__cow = cow

    def getCopyOnWrite(self):
        return self.__cow

    def addField(self, name, typeName, const=None, value=None, hideOnPrint=False):
        override = False
        if not self.__abstract and self.getParentType():
            parentType = self.getParentType()
            fields = parentType.getFieldList()
            for field in fields:
                if field.getName() == name:
                    override = True
        if const is not None and const.lower() == 'true':
            self.__fieldList.append(StructConstField(name, typeName, value, abstract=self.__abstract, override=override, hideOnPrint=hideOnPrint))
        else:
            self.__fieldList.append(StructField(name, typeName, abstract=self.__abstract, override=override, hideOnPrint=hideOnPrint))

    def getFieldList(self):
        return self.__fieldList

    def getNonConstFieldList(self):
        result = []
        for field in self.__fieldList:
            if type(field) is StructField:
                result .append(field)
        return result

    def getParentTypeName(self):
        return self.__parentTypeName

    def getParentType(self):
        if self.__parentTypeName:
            return self.getType(self.__parentTypeName)

    def isAbstract(self):
        return self.__abstract

    def resolveHasPayloadAndHasSwap(self, typeMap):
        for field in self.__fieldList:
            field.resolveHasPayloadAndHasSwap(typeMap)
        for field in self.__fieldList:
            self._hasPayload = self.hasPayload() or field.hasPayload()

    def writeForwardDeclaration(self, sourceStream):
        sourceStream.writeline('class {name};'.format(name = self.getName()))

    def writeDeclaration(self, sourceStream):
        if self.getParentTypeName() is None:
            sourceStream.writeline('class OPENRTI_API {name} {{'.format(name = self.getName()))
        else:
            sourceStream.writeline('class OPENRTI_API {name} : public {parentTypeName} {{'.format(name = self.getName(), parentTypeName = self.getParentTypeName()))
        sourceStream.writeline('public:')
        sourceStream.pushIndent()

        if self.__cow:
            sourceStream.writeline('{name}() noexcept'.format(name = self.getName()))
            sourceStream.writeline(' : _impl(MakeShared<Implementation>())')
            sourceStream.writeline('{ }')
            valuePrefix = 'getImpl().'
            constValuePrefix = 'getConstImpl().'
        else:
            # default constructor
            sourceStream.writeline('{name}()'.format(name = self.getName()) + ' = default;')

            fields = self.getNonConstFieldList()
            fieldCount = len(fields)
            if not self.__abstract and fieldCount > 0:
                sourceStream.writeline('{name}('.format(name = self.getName()))
                sourceStream.pushIndent()
                index = 0
                for field in fields:
                    line = '{fieldTypeName} {paramName}'.format(paramName = field.getLowerName(), fieldTypeName=field.getTypeName())
                    index = index + 1
                    if index < fieldCount:
                        line += ','
                    else:
                        line += ') noexcept'
                    sourceStream.writeline(line)
                index = 0
                sourceStream.pushIndent()
                for field in fields:
                    if (index == 0): 
                        line = ': '
                    else:
                        line =', '
                    line += '{memberName}({paramName})'.format(paramName = field.getLowerName(), memberName = field.getMemberName())
                    index = index + 1
                    sourceStream.writeline(line)
                sourceStream.popIndent()
                sourceStream.writeline('{ }')
                sourceStream.popIndent()
            valuePrefix = ''
            constValuePrefix = ''

        sourceStream.writeline('{name}(const {name}&) = default;'.format(name = self.getName()))
        sourceStream.writeline('{name}({name}&&) = default;'.format(name = self.getName()))
        sourceStream.writeline('virtual ~{name}() noexcept = default;'.format(name = self.getName()))
        sourceStream.writeline('{name}& operator=(const {name}&) = default;'.format(name = self.getName()))
        sourceStream.writeline('{name}& operator=({name}&&) = default;'.format(name = self.getName()))

        for field in self.__fieldList:
            field.writeSetter(sourceStream, valuePrefix)
            field.writeGetter(sourceStream, valuePrefix)
            field.writeConstGetter(sourceStream, constValuePrefix)
            sourceStream.writeline()

        sourceStream.writeline('{name}& swap({name}& rhs) noexcept'.format(name = self.getName()))
        sourceStream.writeline('{')
        sourceStream.pushIndent()
        if self.__cow:
            sourceStream.writeline('_impl.swap(rhs._impl);')
        else:
            for field in self.__fieldList:
                field.writeSwap(sourceStream, 'rhs')
        sourceStream.writeline('return *this;')
        sourceStream.popIndent()
        sourceStream.writeline('}')

        sourceStream.writeline('bool operator==(const {name}& rhs) const noexcept'.format(name = self.getName()))
        sourceStream.writeline('{')
        if self.__cow:
            sourceStream.writeline('  if (_impl.get() == rhs._impl.get())')
            sourceStream.writeline('    return true;')
        for field in self.getFieldList():
            upperName = field.getUpperName()
            sourceStream.writeline('  if (get{upperName}() != rhs.get{upperName}()) return false;'.format(upperName = upperName))
        sourceStream.writeline('  return true;')
        sourceStream.writeline('}')
        sourceStream.writeline('bool operator<(const {name}& rhs) const noexcept'.format(name = self.getName()))
        sourceStream.writeline('{')
        if self.__cow:
            sourceStream.writeline('  if (_impl.get() == rhs._impl.get())')
            sourceStream.writeline('    return false;')
        for field in self.getFieldList():
            upperName = field.getUpperName()
            sourceStream.writeline('  if (get{upperName}() < rhs.get{upperName}()) return true;'.format(upperName = upperName))
            sourceStream.writeline('  if (rhs.get{upperName}() < get{upperName}()) return false;'.format(upperName = upperName))
        sourceStream.writeline('  return false;')
        sourceStream.writeline('}')
        #sourceStream.writeline('bool operator!=(const {name}& rhs) const noexcept'.format(name = self.getName()))
        #sourceStream.writeline('{ return !operator==(rhs); }')
        sourceStream.writeline('bool operator>(const {name}& rhs) const noexcept'.format(name = self.getName()))
        sourceStream.writeline('{ return rhs.operator<(*this); }')
        sourceStream.writeline('bool operator>=(const {name}& rhs) const noexcept'.format(name = self.getName()))
        sourceStream.writeline('{ return !operator<(rhs); }')
        sourceStream.writeline('bool operator<=(const {name}& rhs) const noexcept'.format(name = self.getName()))
        sourceStream.writeline('{ return !operator>(rhs); }')

        if not self.isAbstract():
            sourceStream.popIndent()
            sourceStream.writeline('private:')
            sourceStream.pushIndent()

            if self.__cow:
                sourceStream.writeline('struct OPENRTI_API Implementation final : public Referenced {')
                sourceStream.pushIndent()

                nonConstFields = self.getNonConstFieldList()
                fieldCount = len(nonConstFields)
                if fieldCount == 0:
                    sourceStream.writeline('Implementation() noexcept'.format(name = self.getName()))
                else:
                    sourceStream.writeline('Implementation() noexcept :'.format(name = self.getName()))
                sourceStream.pushIndent()
                index = 0
                for field in nonConstFields:
                    if type(field) is StructField:
                        line = '{memberName}()'.format(memberName = field.getMemberName())
                        index = index + 1
                        if index < fieldCount:
                            line += ','
                        sourceStream.writeline(line)
                sourceStream.popIndent()
                sourceStream.writeline('{ }')

            for field in self.__fieldList:
                field.writeMemberInstance(sourceStream)

            if self.__cow:
                sourceStream.popIndent()
                sourceStream.writeline('};')
                sourceStream.writeline()
                sourceStream.writeline('const Implementation& getConstImpl() const')
                sourceStream.writeline('{')
                sourceStream.writeline('  return *_impl;')
                sourceStream.writeline('}')
                sourceStream.writeline()
                sourceStream.writeline('Implementation& getImpl()')
                sourceStream.writeline('{')
                sourceStream.writeline('  if (1 < Referenced::count(_impl.get()))')
                sourceStream.writeline('    _impl = MakeShared<Implementation>(*_impl);')
                sourceStream.writeline('  return *_impl;')
                sourceStream.writeline('}')
                sourceStream.writeline()
                sourceStream.writeline('SharedPtr<Implementation> _impl;')

        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()

    def writeComponent(self, component, sourceStream, messageEncoding):
        getattr(messageEncoding, 'writeStruct' + component)(self, sourceStream)

    def writePrettyPrintDecl(self, sourceStream):
        if not self.getParentObject() is None:
            parentObjectType=self.getParentObjectType()
            parentObjectParameter=self.getParentObjectParameter()
            sourceStream.writeline('std::ostream& prettyprint(std::ostream& os, const {name}& value, {parentObjectType}* {parentObjectParameter});'.format(
            name = self.getName(), parentObjectType=parentObjectType, parentObjectParameter=parentObjectParameter))
        else:
            sourceStream.writeline('std::ostream& prettyprint(std::ostream& os, const {name}& value);'.format(name = self.getName()))

    def writeStreamOutDecl(self, sourceStream):
        sourceStream.writeline('std::ostream& operator<<(std::ostream& os, const {name}& value);'.format(name = self.getName()))

    def writeStreamOut(self, sourceStream):
        sourceStream.writeline('// ' + type(self).__name__ + " " + self.getName())
        valueParameterName = ""
        for field in self.__fieldList:
            if not field.hideOnPrint():
                valueParameterName = " value"
                break;
        sourceStream.writeline('std::ostream&')
        sourceStream.writeline('operator<<(std::ostream& os, const {name}& {value})'.format(name = self.getName(), value=valueParameterName))
        sourceStream.writeline('{')
        sourceStream.writeline('  os << "{name} {{ ";'.format(name = self.getName()))
        count = 0
        for field in self.__fieldList:
            count = count + 1
            lowerName = field.getLowerName()
            upperName = field.getUpperName()
            if not field.hideOnPrint():
                sourceStream.writeline('  os << "{lowerName}: " << value.get{upperName}();'.format(lowerName = lowerName, upperName = upperName))
                if count != len(self.__fieldList):
                    sourceStream.writeline('  os << ", ";')
            else:
                sourceStream.writeline('  // ' + type(field).__name__ + " " + field.getLowerName() + " (hidden)")
                sourceStream.writeline('  //os << "{lowerName}: " << value.get{upperName}();'.format(lowerName = lowerName, upperName = upperName))
                if count != len(self.__fieldList):
                    sourceStream.writeline('  //os << ", ";')

        sourceStream.writeline('  os << " }";')
        sourceStream.writeline('  return os;')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writePrettyPrint(self, sourceStream):
        parentObject=self.getParentObject()
        valueParameterName = ""
        if not parentObject is None:
            parentObjectType=self.getParentObjectType()
            parentObjectParameter=""
            fieldParents = set()
            for field in self.__fieldList:
                fieldType=self.getType(field.getTypeName())
                if not field.hideOnPrint():
                    if not fieldType.getParentObject() is None:
                        parentObjectParameter = self.getParentObjectParameter();
                        if fieldType.getParentObject() != self.getParentObject():
                            fieldValue=""
                            fieldParentObject=fieldType.getParentObject()
                            fieldParentObjectType=fieldType.getParentObjectType()
                            fieldParentObjectParameter=fieldType.getParentObjectParameter()
                            s = "{fieldParentObjectType}* {fieldParentObjectParameter} = {parentObjectParameter}->get{fieldParentObject}(value.get{fieldParentObject}Handle());".format(
                                fieldParentObject=fieldParentObject,
                                fieldParentObjectType=fieldParentObjectType, 
                                fieldParentObjectParameter=fieldParentObjectParameter,
                                parentObjectParameter=parentObjectParameter,
                                fieldValue=fieldValue)
                            fieldParents.add(s)
        sourceStream.writeline('std::ostream&')
        for field in self.__fieldList:
            if not field.hideOnPrint():
                valueParameterName = " value"
                break;
        if not parentObject is None:
            sourceStream.writeline('prettyprint(std::ostream& os, const {name}&{value}, {parentObjectType}* {parentObjectParameter})'.format(
                name = self.getName(), value=valueParameterName, parentObjectType=parentObjectType, parentObjectParameter=parentObjectParameter))
        else:
            sourceStream.writeline('prettyprint(std::ostream& os, const {name}&{value})'.format(name = self.getName(), value=valueParameterName))

        sourceStream.writeline('{')
        if not parentObject is None:
            for fieldParent in fieldParents:
                sourceStream.writeline("  " + fieldParent)
        sourceStream.writeline('  os << "{name} {{ ";'.format(name = self.getName()))
        count = 0
        for field in self.__fieldList:
            count = count + 1
            lowerName = field.getLowerName()
            upperName = field.getUpperName()
            if not field.hideOnPrint():
                fieldType=self.getType(field.getTypeName())
                if not parentObject is None and not fieldType.getParentObject() is None:
                    fieldParentObjectType=fieldType.getParentObjectType()
                    fieldParentObjectParameter=fieldType.getParentObjectParameter()
                    sourceStream.writeline('  os << "{lowerName}: "; prettyprint(os, value.get{upperName}(), {fieldParentObjectParameter});'.format(
                        lowerName = lowerName, upperName = upperName, fieldParentObjectParameter=fieldParentObjectParameter) + "//" + fieldType.getName() + " parent=" + fieldType.getParentObject())
                else:
                    sourceStream.writeline('  os << "{lowerName}: "<< value.get{upperName}();'.format(lowerName = lowerName, upperName = upperName))
                if count != len(self.__fieldList):
                    sourceStream.writeline('  os << ", ";')
            else:
                sourceStream.writeline('  // ' + type(field).__name__ + " " + field.getLowerName() + " (hidden)")

        sourceStream.writeline('  os << " }";')
        sourceStream.writeline('  return os;')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeByteSize(self, sourceStream):
        sourceStream.writeline('inline size_t byteSize(const {name}& value) noexcept'.format(name = self.getName()))
        sourceStream.writeline('{')
        sourceStream.pushIndent()
        sourceStream.writeline('size_t result = 0;');
        for field in self.getFieldList():
            fieldName = field.getName()
            sourceStream.writeline('result += byteSize(value.get{fieldName}());'.format(fieldName = fieldName))
        sourceStream.writeline('return result;');
        sourceStream.popIndent();
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeToString(self, sourceStream):
        sourceStream.writeline('// ' + type(self).__name__ + " " + self.getName())
        sourceStream.writeline('inline std::string to_string(const {name}& value)'.format(name = self.getName()))
        sourceStream.writeline('{')
        sourceStream.pushIndent();
        sourceStream.writeline('  std::ostringstream out;')
        sourceStream.writeline('  out << value;')
        sourceStream.writeline('  return out.str();')
        sourceStream.popIndent();
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeEncoder(self, sourceStream):
        if not self.isAbstract():
            name = self.getName()
            valueParameterName=""
            if len(self.getFieldList()) > 0:
                valueParameterName = " value"
            sourceStream.writeline('void write{name}(const {name}&{value})'.format(name = name, value=valueParameterName))
            sourceStream.writeline('{')
            for field in self.getFieldList():
                fieldName = field.getName()
                typeName = field.getTypeName()
                if type(field) is StructField:
                    sourceStream.writeline('  write{typeName}({value}.get{fieldName}());'.format(typeName = typeName, fieldName = fieldName, value=valueParameterName))
                else:
                    sourceStream.writeline('  write{typeName}({value}.get{fieldName}());'.format(typeName = typeName, fieldName = fieldName, value=valueParameterName))
            sourceStream.writeline('}')
            sourceStream.writeline()

    def writeDecoder(self, sourceStream):
        if not self.isAbstract():
            name = self.getName()
            valueParameterName=""
            if len(self.getFieldList()) > 0:
                valueParameterName = " value"
            sourceStream.writeline('void read{name}({name}&{value})'.format(name = name, value=valueParameterName))
            sourceStream.writeline('{')
            for field in self.getFieldList():
                fieldName = field.getName()
                typeName = field.getTypeName()
                if type(field) is StructField:
                    sourceStream.writeline('  read{typeName}({value}.get{fieldName}());'.format(typeName = typeName, fieldName = fieldName, value=valueParameterName))
                else:
                    sourceStream.writeline('  {typeName} _dummy{typeName};'.format(typeName = typeName, fieldName = fieldName))
                    sourceStream.writeline('  read{typeName}(_dummy{typeName});'.format(typeName = typeName, fieldName = fieldName))

            sourceStream.writeline('}')
            sourceStream.writeline()

###############################################################################
class MessageDataType(StructDataType):
    __opcodeMap = {
        'ConnectionLostMessage' : 1,
        'CreateFederationExecutionRequestMessage' : 2,
        'CreateFederationExecutionResponseMessage' : 3,
        'DestroyFederationExecutionRequestMessage' : 4,
        'DestroyFederationExecutionResponseMessage' : 5,
        'EnumerateFederationExecutionsRequestMessage' : 6,
        'EnumerateFederationExecutionsResponseMessage' : 7,
        'InsertFederationExecutionMessage' : 8,
        'ShutdownFederationExecutionMessage' : 9,
        'EraseFederationExecutionMessage' : 10,
        'ReleaseFederationHandleMessage' : 11,
        'InsertModulesMessage' : 12,
        'JoinFederationExecutionRequestMessage' : 13,
        'JoinFederationExecutionResponseMessage' : 14,
        'ResignFederationExecutionRequestMessage' : 15,
        'JoinFederateNotifyMessage' : 16,
        'ResignFederateNotifyMessage' : 17,
        'ChangeAutomaticResignDirectiveMessage' : 18,
        'RegisterFederationSynchronizationPointMessage' : 30,
        'RegisterFederationSynchronizationPointResponseMessage' : 31,
        'AnnounceSynchronizationPointMessage' : 32,
        'SynchronizationPointAchievedMessage' : 33,
        'FederationSynchronizedMessage' : 34,
        'EnableTimeRegulationRequestMessage' : 40,
        'EnableTimeRegulationResponseMessage' : 41,
        'DisableTimeRegulationRequestMessage' : 42,
        'CommitLowerBoundTimeStampMessage' : 43,
        'CommitLowerBoundTimeStampResponseMessage' : 44,
        'LockedByNextMessageRequestMessage' : 45,
        'InsertRegionMessage' : 46,
        'CommitRegionMessage' : 47,
        'EraseRegionMessage' : 48,
        'ChangeInteractionClassPublicationMessage' : 50,
        'ChangeObjectClassPublicationMessage' : 51,
        'ChangeInteractionClassSubscriptionMessage' : 52,
        'ChangeObjectClassSubscriptionMessage' : 53,
        'ObjectInstanceHandlesRequestMessage' : 60,
        'ObjectInstanceHandlesResponseMessage' : 61,
        'ReleaseMultipleObjectInstanceNameHandlePairsMessage' : 62,
        'ReserveObjectInstanceNameRequestMessage' : 63,
        'ReserveObjectInstanceNameResponseMessage' : 64,
        'ReserveMultipleObjectInstanceNameRequestMessage' : 65,
        'ReserveMultipleObjectInstanceNameResponseMessage' : 66,
        'InteractionMessage' : 80,
        'TimeStampedInteractionMessage' : 81,
        'InsertObjectInstanceMessage' : 90,
        'DeleteObjectInstanceMessage' : 91,
        'TimeStampedDeleteObjectInstanceMessage' : 92,
        # obsolete 'LocalDeleteObjectInstanceMessage' : 93,
        'DestroyObjectInstanceMessage' : 94,
        'AttributeUpdateMessage' : 94,
        'TimeStampedAttributeUpdateMessage' : 96,
        'RequestAttributeUpdateMessage' : 97,
        'RequestClassAttributeUpdateMessage' : 98,
        'ChangeObjectInstanceSubscriptionMessage' : 99,
        'EnableTimeConstrainedNotifyMessage' : 100,
        'DisableTimeConstrainedNotifyMessage' : 101,
        'QueryAttributeOwnershipRequestMessage' : 102,
        'QueryAttributeOwnershipResponseMessage' : 103,
        'CreateFederationExecutionRequest2Message' : 104,
        'JoinFederationExecutionRequest2Message' : 105,
        'InsertModules2Message' : 106,
        'InsertObjectInstanceWithRegionsMessage' : 107,
    }
    def getMessageOpcode(messageName):
        if messageName in MessageDataType.__opcodeMap:
            return MessageDataType.__opcodeMap[messageName]
        else:
            return None

    def __init__(self, typeMap, name, parentTypeName = None):
        StructDataType.__init__(self, typeMap, name, parentObject='Federation', parentTypeName=parentTypeName)
        self.__reliableExpression = None
        self.__objectInstanceExpression = None

    def isMessage(self):
        return True

    def setReliableExpression(self, reliableExpression):
        self.__reliableExpression = reliableExpression

    def getReliableExpression(self):
        return self.__reliableExpression

    def setObjectInstanceExpression(self, objectInstanceExpression):
        self.__objectInstanceExpression = objectInstanceExpression

    def getObjectInstanceExpression(self):
        return self.__objectInstanceExpression

    def writeForwardDeclaration(self, sourceStream):
        sourceStream.writeline('class {name};'.format(name = self.getName()))

    def writeDeclaration(self, sourceStream):
        if self.getParentTypeName() is None:
            sourceStream.writeline('class OPENRTI_API {name} {{'.format(name = self.getName()))
        else:
            sourceStream.writeline('class OPENRTI_API {name} final : public {parentTypeName} {{'.format(name = self.getName(), parentTypeName = self.getParentTypeName()))
        sourceStream.writeline('public:')
        sourceStream.pushIndent()
        sourceStream.writeline('{name}() noexcept {{}};'.format(name = self.getName()))
        sourceStream.writeline('{name}(const {name}&) = default;'.format(name = self.getName()))
        sourceStream.writeline('{name}({name}&&) noexcept = default;'.format(name = self.getName()))
        sourceStream.writeline('virtual ~{name}() noexcept = default;'.format(name = self.getName()))
        sourceStream.writeline('{name}& operator=(const {name}&) = default;'.format(name = self.getName()))
        sourceStream.writeline('{name}& operator=({name}&&) = default;'.format(name = self.getName()))

        sourceStream.writeline()
        sourceStream.writeline('virtual const char* getTypeName() const noexcept override;')
        opcode = MessageDataType.getMessageOpcode(self.getName())
        if not opcode is None:
            sourceStream.writeline('static const int OpCode = {opcode};'.format(opcode=opcode))
        else:
            print("MessageDataType.writeDeclaration: no opcode:", self.getName())
        sourceStream.writeline('virtual void out(std::ostream& os) const override;')
        sourceStream.writeline('virtual void out(std::ostream& os, ServerModel::Federation* federation) const override;')
        sourceStream.writeline('virtual void dispatch(const AbstractMessageDispatcher& dispatcher) const override;')
        sourceStream.writeline('virtual size_t messageSize() const noexcept override;')
        sourceStream.writeline()

        sourceStream.writeline('bool operator==(const AbstractMessage& rhs) const noexcept override;')
        sourceStream.writeline('bool operator==(const {name}& rhs) const noexcept;'.format(name = self.getName()))
        sourceStream.writeline('bool operator<(const {name}& rhs) const noexcept;'.format(name = self.getName()))
        sourceStream.writeline('bool operator!=(const {name}& rhs) const noexcept'.format(name = self.getName()))
        sourceStream.writeline('{ return !operator==(rhs); }')
        sourceStream.writeline('bool operator>(const {name}& rhs) const noexcept'.format(name = self.getName()))
        sourceStream.writeline('{ return rhs.operator<(*this); }')
        sourceStream.writeline('bool operator>=(const {name}& rhs) const noexcept'.format(name = self.getName()))
        sourceStream.writeline('{ return !operator<(rhs); }')
        sourceStream.writeline('bool operator<=(const {name}& rhs) const noexcept'.format(name = self.getName()))
        sourceStream.writeline('{ return !operator>(rhs); }')
        sourceStream.writeline()

        if self.getReliableExpression():
            sourceStream.writeline('bool getReliable() const noexcept override;')
            sourceStream.writeline()

        if self.getObjectInstanceExpression():
            sourceStream.writeline('virtual ObjectInstanceHandle getObjectInstanceHandleForMessage() const noexcept override;')
            sourceStream.writeline()

        for field in self.getFieldList():
            field.writeSetter(sourceStream, '')
            field.writeGetter(sourceStream, '')
            field.writeConstGetter(sourceStream, '')
            sourceStream.writeline()

        sourceStream.popIndent()
        sourceStream.writeline('private:')
        sourceStream.pushIndent()

        for field in self.getFieldList():
            field.writeMemberInstance(sourceStream)

        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()

    def writeImplementation(self, sourceStream):
        fieldCount = len(self.getFieldList())
        sourceStream.writeline('const char*')
        sourceStream.writeline('{name}::getTypeName() const noexcept'.format(name = self.getName()))
        sourceStream.writeline('{')
        sourceStream.writeline('  return "{name}";'.format(name = self.getName()))
        sourceStream.writeline('}')
        sourceStream.writeline()
        sourceStream.writeline('void')
        sourceStream.writeline('{name}::out(std::ostream& os) const'.format(name = self.getName()))
        sourceStream.writeline('{')
        sourceStream.writeline('  os << "{name} {{ ";'.format(name = self.getName()))
        count = 0
        fields = self.getFieldList()
        for field in fields:
            count = count + 1
            lowerName = field.getLowerName()
            upperName = field.getUpperName()
            if not field.hideOnPrint():
                sourceStream.writeline('  os << "{lowerName}: " << get{upperName}();'.format(lowerName = lowerName, upperName = upperName))
                if count != len(fields):
                    sourceStream.writeline('  os << ", ";')
            else:
                sourceStream.writeline('  // ' + type(field).__name__ + " " + field.getLowerName() + " (hidden)")
                sourceStream.writeline('  //os << "{lowerName}: " << get{upperName}();'.format(lowerName = lowerName, upperName = upperName))
                if count != len(fields):
                    sourceStream.writeline('  //os << ", ";')

        sourceStream.writeline('  os << " }";')
        # sourceStream.writeline('  os << "{name} " << *this;'.format(name = self.getName()))
        sourceStream.writeline('}')
        sourceStream.writeline()
        parentDecl=self.getParentTypeName()
        sourceStream.writeline('void')
        sourceStream.writeline('{name}::out(std::ostream& os, ServerModel::Federation* federation) const'.format(name = self.getName()))
        sourceStream.writeline('{')
        sourceStream.writeline('  prettyprint(os, *this, federation);')
        # sourceStream.writeline('  os << "{name} " << *this;'.format(name = self.getName()))
        sourceStream.writeline('}')
        sourceStream.writeline()

        sourceStream.writeline('void')
        sourceStream.writeline('{name}::dispatch(const AbstractMessageDispatcher& dispatcher) const'.format(name = self.getName()))
        sourceStream.writeline('{')
        sourceStream.writeline('  dispatcher.accept(*this);')
        sourceStream.writeline('}')
        sourceStream.writeline()

        sourceStream.writeline('size_t')
        sourceStream.writeline('{name}::messageSize() const noexcept'.format(name = self.getName()))
        sourceStream.writeline('{')
        sourceStream.pushIndent()
        sourceStream.writeline('size_t result = {parentTypeName}::messageSize();'.format(parentTypeName = self.getParentTypeName()));
        for field in fields:
            fieldName = field.getName()
            sourceStream.writeline('result += byteSize(get{fieldName}());'.format(fieldName = fieldName))
        sourceStream.writeline('return result;');
        sourceStream.popIndent();
        sourceStream.writeline('}')
        sourceStream.writeline()

        sourceStream.writeline('bool')
        sourceStream.writeline('{name}::operator==(const AbstractMessage& rhs) const noexcept'.format(name = self.getName()))
        sourceStream.writeline('{')
        sourceStream.writeline('  const {name}* message = dynamic_cast<const {name}*>(&rhs);'.format(name = self.getName()))
        sourceStream.writeline('  if (!message)')
        sourceStream.writeline('    return false;')
        sourceStream.writeline('  return operator==(*message);')
        sourceStream.writeline('}')
        sourceStream.writeline()
        sourceStream.writeline('bool')
        if len(fields) > 0:
            sourceStream.writeline('{name}::operator==(const {name}& rhs) const noexcept'.format(name = self.getName()))
        else:
            sourceStream.writeline('{name}::operator==(const {name}&) const noexcept'.format(name = self.getName()))
        sourceStream.writeline('{')
        for field in self.getFieldList():
            upperName = field.getUpperName()
            sourceStream.writeline('  if (get{upperName}() != rhs.get{upperName}()) return false;'.format(upperName = upperName))
        sourceStream.writeline('  return true;')
        sourceStream.writeline('}')
        sourceStream.writeline()
        sourceStream.writeline('bool')
        if len(fields) > 0:
            sourceStream.writeline('{name}::operator<(const {name}& rhs) const noexcept'.format(name = self.getName()))
        else:
            sourceStream.writeline('{name}::operator<(const {name}&) const noexcept'.format(name = self.getName()))
        sourceStream.writeline('{')
        for field in fields:
            upperName = field.getUpperName()
            sourceStream.writeline('  if (get{upperName}() < rhs.get{upperName}()) return true;'.format(upperName = upperName))
            sourceStream.writeline('  if (rhs.get{upperName}() < get{upperName}()) return false;'.format(upperName = upperName))
        sourceStream.writeline('  return false;')
        sourceStream.writeline('}')

        if self.getReliableExpression():
            sourceStream.writeline()
            sourceStream.writeline('bool')
            sourceStream.writeline('{name}::getReliable() const noexcept'.format(name = self.getName()))
            sourceStream.writeline('{')
            sourceStream.writeline('  return {expression};'.format(expression = self.getReliableExpression()))
            sourceStream.writeline('}')

        if self.getObjectInstanceExpression():
            sourceStream.writeline()
            sourceStream.writeline('ObjectInstanceHandle')
            sourceStream.writeline('{name}::getObjectInstanceHandleForMessage() const noexcept'.format(name = self.getName()))
            sourceStream.writeline('{')
            sourceStream.writeline('  return {expression};'.format(expression = self.getObjectInstanceExpression()))
            sourceStream.writeline('}')

        sourceStream.writeline()

    def writeToString(self, sourceStream):
        pass
 
    def writeByteSize(self, sourceStream):
        fields = self.getFieldList();
        if len(fields) > 0:
            sourceStream.writeline('inline size_t byteSize(const {name}& value) noexcept'.format(name = self.getName()))
        else:
            sourceStream.writeline('inline size_t byteSize(const {name}&) noexcept'.format(name = self.getName()))

        sourceStream.writeline('{')
        sourceStream.pushIndent()
        sourceStream.writeline('size_t result = sizeof(AbstractMessage);');
        for field in self.getFieldList():
            fieldName = field.getName()
            sourceStream.writeline('result += byteSize(value.get{fieldName}());'.format(fieldName = fieldName))
        sourceStream.writeline('return result;');
        sourceStream.popIndent();
        sourceStream.writeline('}')
        sourceStream.writeline()

###############################################################################
class MessageEncoding(object):
    def __init__(self, name):
        self.__name = name
        # Currently this is common, but as the first incompatible change starts
        # override this in the encodings

    def getName(self):
        return self.__name

    def writeCEncoder(self, dataType, sourceStream):
        name = dataType.getName()
        typeName = dataType.getTypeName()
        encoding = dataType.getEncoding()
        sourceStream.writeline('void write{name}(const {ctype}& value)'.format(name = name, ctype = typeName))
        sourceStream.writeline('{')
        if typeName == 'VariableLengthData':
            sourceStream.writeline('  writeSizeTCompressed(value.size());')
            sourceStream.writeline('  if (!value.empty())')
            sourceStream.writeline('    _messageEncoding.addWriteBuffer(value);')
        elif typeName == 'std::string':
            sourceStream.writeline('  writeSizeTCompressed(value.size());')
            sourceStream.writeline('  for (std::string::const_iterator i = value.begin(); i != value.end(); ++i) {')
            sourceStream.writeline('    writeChar(*i);')
            sourceStream.writeline('  }')
        else:
            sourceStream.writeline('  write{encoding}Compressed(value);'.format(encoding = encoding))
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeCDecoder(self, dataType, sourceStream):
        name = dataType.getName()
        typeName = dataType.getTypeName()
        encoding = dataType.getEncoding()
        sourceStream.writeline('void read{name}({ctype}& value)'.format(name = name, ctype = typeName))
        sourceStream.writeline('{')
        if typeName == 'VariableLengthData':
            sourceStream.writeline('  size_t size = readSizeTCompressed();')
            sourceStream.writeline('  value.resize(size);')
            sourceStream.writeline('  if (size)')
            sourceStream.writeline('    _messageEncoding.addReadBuffer(size);')
        elif typeName == 'std::string':
            sourceStream.writeline('  value.resize(readSizeTCompressed());')
            sourceStream.writeline('  for (std::string::iterator i = value.begin(); i != value.end(); ++i) {')
            sourceStream.writeline('    *i = readChar();')
            sourceStream.writeline('  }')
        else:
            sourceStream.writeline('  value = read{encoding}Compressed();'.format(encoding = encoding))
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeCPayloadDecoder(self, dataType, sourceStream):
        if not dataType.hasPayload():
            return
        name = dataType.getName()
        typeName = dataType.getTypeName()
        encoding = dataType.getEncoding()
        sourceStream.writeline('void readPayload{name}({ctype}& value)'.format(name = name, ctype = typeName))
        sourceStream.writeline('{')
        sourceStream.writeline('  if (!value.size())')
        sourceStream.writeline('    return;')
        sourceStream.writeline('  value = *_i;')
        sourceStream.writeline('  ++_i;')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeEnumEncoder(self, dataType, sourceStream):
        name = dataType.getName()
        sourceStream.writeline('void write{name}(const {name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  switch (value) {')
        value = 0
        for enum in dataType.getEnumList():
            sourceStream.writeline('  case {enum}:'.format(enum = enum.getName()))
            sourceStream.writeline('    writeUInt32Compressed({value});'.format(value = value))
            sourceStream.writeline('    break;')
            value = value + 1
        sourceStream.writeline('  default:')
        sourceStream.writeline('    writeUInt32Compressed({value});'.format(value = value))
        sourceStream.writeline('    break;')
        sourceStream.writeline('  }')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeEnumDecoder(self, dataType, sourceStream):
        name = dataType.getName()
        sourceStream.writeline('void read{name}({name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  switch (readUInt32Compressed()) {')
        value = 0
        for enum in dataType.getEnumList():
            sourceStream.writeline('  case {value}:'.format(value = value))
            sourceStream.writeline('    value = {enum};'.format(enum = enum.getName()))
            sourceStream.writeline('    break;')
            value = value + 1
        sourceStream.writeline('  default:')
        sourceStream.writeline('    value = {enum};'.format(enum = enum.getName()))
        sourceStream.writeline('    break;')
        sourceStream.writeline('  }')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeEnumPayloadDecoder(self, dataType, sourceStream):
        pass

    def writeVectorEncoder(self, dataType, sourceStream):
        name = dataType.getName()
        scalarName = dataType.getScalarTypeName()
        sourceStream.writeline('void write{name}(const {name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  writeSizeTCompressed(value.size());')
        sourceStream.writeline('  for ({name}::const_iterator i = value.begin(); i != value.end(); ++i) {{'.format(name = name))
        sourceStream.writeline('    write{scalarName}(*i);'.format(scalarName = scalarName))
        sourceStream.writeline('  }')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeVectorDecoder(self, dataType, sourceStream):
        name = dataType.getName()
        scalarName = dataType.getScalarTypeName()
        sourceStream.writeline('void read{name}({name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  value.resize(readSizeTCompressed());')
        sourceStream.writeline('  for ({name}::iterator i = value.begin(); i != value.end(); ++i) {{'.format(name = name))
        sourceStream.writeline('    read{scalarName}(*i);'.format(scalarName = scalarName))
        sourceStream.writeline('  }')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeVectorPayloadDecoder(self, dataType, sourceStream):
        if not dataType.hasPayload():
            return
        name = dataType.getName()
        scalarName = dataType.getScalarTypeName()
        sourceStream.writeline('void readPayload{name}({name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  for ({name}::iterator i = value.begin(); i != value.end(); ++i) {{'.format(name = name))
        sourceStream.writeline('    readPayload{scalarName}(*i);'.format(scalarName = scalarName))
        sourceStream.writeline('  }')
        sourceStream.writeline('}')
        sourceStream.writeline()


    def writeSetEncoder(self, dataType, sourceStream):
        name = dataType.getName()
        scalarName = dataType.getScalarTypeName()
        sourceStream.writeline('void write{name}(const {name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  writeSizeTCompressed(value.size());')
        sourceStream.writeline('  for ({name}::const_iterator i = value.begin(); i != value.end(); ++i) {{'.format(name = name))
        sourceStream.writeline('    write{scalarName}(*i);'.format(scalarName = scalarName))
        sourceStream.writeline('  }')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeSetDecoder(self, dataType, sourceStream):
        name = dataType.getName()
        scalarName = dataType.getScalarTypeName()
        sourceStream.writeline('void read{name}({name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  size_t size = readSizeTCompressed();')
        sourceStream.writeline('  for (; size != 0; --size) {')
        sourceStream.writeline('    {scalarName} scalar;'.format(scalarName = scalarName))
        sourceStream.writeline('    read{scalarName}(scalar);'.format(scalarName = scalarName))
        sourceStream.writeline('    value.insert(scalar);')
        sourceStream.writeline('  }')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeSetPayloadDecoder(self, dataType, sourceStream):
        if not dataType.hasPayload():
            return
        name = dataType.getName()
        scalarName = dataType.getScalarTypeName()
        sourceStream.writeline('void readPayload{name}({name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  for ({name}::iterator i = value.begin(); i != value.end(); ++i) {{'.format(name = name))
        sourceStream.writeline('    readPayload{scalarName}(*i);'.format(scalarName = scalarName))
        sourceStream.writeline('  }')
        sourceStream.writeline('}')
        sourceStream.writeline()


    def writeMapEncoder(self, dataType, sourceStream):
        name = dataType.getName()
        keyTypeName = dataType.getKeyTypeName()
        valueTypeName = dataType.getValueTypeName()
        sourceStream.writeline('void write{name}(const {name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  writeSizeTCompressed(value.size());')
        sourceStream.writeline('  for ({name}::const_iterator i = value.begin(); i != value.end(); ++i) {{'.format(name = name))
        sourceStream.writeline('    write{keyTypeName}(i->first);'.format(keyTypeName = keyTypeName))
        sourceStream.writeline('    write{valueTypeName}(i->second);'.format(valueTypeName = valueTypeName))
        sourceStream.writeline('  }')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeMapDecoder(self, dataType, sourceStream):
        name = dataType.getName()
        keyTypeName = dataType.getKeyTypeName()
        valueTypeName = dataType.getValueTypeName()
        sourceStream.writeline('void read{name}({name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  size_t size = readSizeTCompressed();')
        sourceStream.writeline('  for (; size != 0; --size) {')
        sourceStream.writeline('    {keyTypeName} key;'.format(keyTypeName = keyTypeName))
        sourceStream.writeline('    read{keyTypeName}(key);'.format(keyTypeName = keyTypeName))
        sourceStream.writeline('    read{valueTypeName}(value[key]);'.format(valueTypeName = valueTypeName))
        sourceStream.writeline('  }')
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeMapPayloadDecoder(self, dataType, sourceStream):
        if not dataType.hasPayload():
            return
        name = dataType.getName()
        keyTypeName = dataType.getKeyTypeName()
        valueTypeName = dataType.getValueTypeName()
        sourceStream.writeline('void readPayload{name}({name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  for ({name}::iterator i = value.begin(); i != value.end(); ++i) {{'.format(name = name))
        if dataType.keyHasPayload():
            sourceStream.writeline('    readPayload{keyTypeName}(i->first);'.format(keyTypeName = keyTypeName))
        if dataType.valueHasPayload():
            sourceStream.writeline('    readPayload{valueTypeName}(i->second);'.format(valueTypeName = valueTypeName))
        sourceStream.writeline('  }')
        sourceStream.writeline('}')
        sourceStream.writeline()


    def writePairEncoder(self, dataType, sourceStream):
        name = dataType.getName()
        firstTypeName = dataType.getFirstTypeName()
        secondTypeName = dataType.getSecondTypeName()
        sourceStream.writeline('void write{name}(const {name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  write{firstTypeName}(value.first);'.format(firstTypeName = firstTypeName))
        sourceStream.writeline('  write{secondTypeName}(value.second);'.format(secondTypeName = secondTypeName))
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writePairDecoder(self, dataType, sourceStream):
        name = dataType.getName()
        firstTypeName = dataType.getFirstTypeName()
        secondTypeName = dataType.getSecondTypeName()
        sourceStream.writeline('void read{name}({name}& value)'.format(name = name))
        sourceStream.writeline('{')
        sourceStream.writeline('  read{firstTypeName}(value.first);'.format(firstTypeName = firstTypeName))
        sourceStream.writeline('  read{secondTypeName}(value.second);'.format(secondTypeName = secondTypeName))
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writePairPayloadDecoder(self, dataType, sourceStream):
        if not dataType.hasPayload():
            return
        name = dataType.getName()
        firstTypeName = dataType.getFirstTypeName()
        secondTypeName = dataType.getSecondTypeName()
        sourceStream.writeline('void readPayload{name}({name}& value)'.format(name = name))
        sourceStream.writeline('{')
        if dataType.firstHasPayload():
            sourceStream.writeline('  readPayload{firstTypeName}(value.first);'.format(firstTypeName = firstTypeName))
        if dataType.secondHasPayload():
            sourceStream.writeline('  readPayload{secondTypeName}(value.second);'.format(secondTypeName = secondTypeName))
        sourceStream.writeline('}')
        sourceStream.writeline()


    def writeStructEncoder(self, dataType, sourceStream):
        dataType.writeEncoder(sourceStream)

    def writeStructDecoder(self, dataType, sourceStream):
        dataType.writeDecoder(sourceStream)

    def writeStructPayloadDecoder(self, dataType, sourceStream):
        if not dataType.hasPayload():
            return
        name = dataType.getName()
        sourceStream.writeline('void readPayload{name}({name}& value)'.format(name = name))
        sourceStream.writeline('{')
        for field in dataType.getFieldList():
            if field.hasPayload():
                fieldName = field.getName()
                typeName = field.getTypeName()
                sourceStream.writeline('  readPayload{typeName}(value.get{fieldName}());'.format(typeName = typeName, fieldName = fieldName))
        sourceStream.writeline('}')
        sourceStream.writeline()

    def writeEncodingDeclaration(self, messageMap, sourceStream):
        encodingName = self.getName()
        sourceStream.writeCopyright()
        sourceStream.writeline('#ifndef OpenRTI_' + encodingName + 'MessageEncoding_h')
        sourceStream.writeline('#define OpenRTI_' + encodingName + 'MessageEncoding_h')
        sourceStream.writeline()
        sourceStream.writeline('#include "DebugNew.h"')
        sourceStream.writeline('#include "AbstractMessageEncoding.h"')
        sourceStream.writeline('#include "Export.h"')
        sourceStream.writeline()
        sourceStream.writeline('namespace OpenRTI {')
        sourceStream.writeline()

        sourceStream.writeline('class OPENRTI_LOCAL ' + encodingName + 'MessageEncoding : public AbstractMessageEncoding {')
        sourceStream.writeline('public:')
        sourceStream.pushIndent()
        sourceStream.writeline(encodingName + 'MessageEncoding() noexcept;')
        sourceStream.writeline('virtual ~' + encodingName + 'MessageEncoding() noexcept;')
        sourceStream.writeline()

        sourceStream.writeline('const char* getName() const override;')
        sourceStream.writeline()

        sourceStream.writeline('void readPacket(const Buffer& buffer) override;')
        sourceStream.writeline('void decodeBody(const VariableLengthData& variableLengthData);')
        sourceStream.writeline('void decodePayload(const Buffer::const_iterator& i);')
        sourceStream.writeline('void writeMessage(const AbstractMessage& message) override;')
        sourceStream.writeline()

        sourceStream.popIndent()
        sourceStream.writeline('private:')
        sourceStream.pushIndent()

        sourceStream.writeline('class DecodeStream;')
        sourceStream.writeline('class DispatchFunctor;')
        sourceStream.writeline('class PayloadDecoder;')
        sourceStream.writeline('class EncodeStream;')
        sourceStream.writeline()
        sourceStream.writeline('SharedPtr<AbstractMessage> _message;')
        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()
        sourceStream.writeline('} // namespace OpenRTI')
        sourceStream.writeline()
        sourceStream.writeline('#endif')

    def writeEncodingImplementation(self, messageMap, sourceStream):
        encodingName = self.getName()
        encodingClass = encodingName + 'MessageEncoding'
        sourceStream.writeCopyright()
        sourceStream.writeline()
        sourceStream.writeline('#include "DebugNew.h"')
        sourceStream.writeline('#include "' + encodingName + 'MessageEncoding.h"')
        sourceStream.writeline('#include "AbstractMessageEncoding.h"')
        sourceStream.writeline('#include "DecodeDataStream.h"')
        sourceStream.writeline('#include "EncodeDataStream.h"')
        sourceStream.writeline('#include "Export.h"')
        sourceStream.writeline('#include "Message.h"')
        sourceStream.writeline('#include "AbstractNetworkStatistics.h"')
        sourceStream.writeline()
        sourceStream.writeline('#ifndef __CPlusPlusStd')
        sourceStream.writeline('#error "must include OpenRTIConfig.h!"')
        sourceStream.writeline('#endif')
        sourceStream.writeline()

        sourceStream.writeline('namespace OpenRTI {')
        sourceStream.writeline()

        sourceStream.writeline('class OPENRTI_LOCAL ' + encodingClass + '::EncodeStream : public EncodeDataStream {')
        sourceStream.writeline('public:')
        sourceStream.pushIndent()
        sourceStream.writeline('EncodeStream(VariableLengthData& variableLengthData, ' + encodingClass + '& messageEncoding) :')
        sourceStream.writeline('  EncodeDataStream(variableLengthData),')
        sourceStream.writeline('  _messageEncoding(messageEncoding)')
        sourceStream.writeline('{ }')

        for t in messageMap.getTypeList():
            t.writeComponent('Encoder', sourceStream, self)

        sourceStream.writeline(encodingName + 'MessageEncoding& _messageEncoding;')
        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()


        sourceStream.writeline('class OPENRTI_LOCAL ' + encodingClass + '::DispatchFunctor {')
        sourceStream.writeline('public:')
        sourceStream.pushIndent()
        sourceStream.writeline('DispatchFunctor(' + encodingClass + '& messageEncoding) :')
        sourceStream.writeline('  _messageEncoding(messageEncoding)')
        sourceStream.writeline('{ }')
        sourceStream.writeline()

        sourceStream.writeline('template<typename M>')
        sourceStream.writeline('void operator()(const M& message) const')
        sourceStream.writeline('{ encode(_messageEncoding, message); }')
        sourceStream.writeline()

        sourceStream.writeline('void')
        sourceStream.writeline('encode(' + encodingClass + '&, const AbstractMessage&) const')
        sourceStream.writeline('{')
        sourceStream.writeline('  throw RTIinternalError("Invalid message dispatched to encoding!");')
        sourceStream.writeline('}')
        sourceStream.writeline()

        for t in messageMap.getTypeList():
            messageName = t.getName()
            opcode = MessageDataType.getMessageOpcode(messageName)
            if opcode is None:
                if isinstance(t, MessageDataType): print("MessageEncoding.writeEncodingImplementation(encode): no opcode:", t.getName())
                continue
            sourceStream.writeline('void')
            sourceStream.writeline('encode(' + encodingClass + '& messageEncoding, const {messageName}& message) const'.format(messageName = messageName))
            sourceStream.writeline('{')
            sourceStream.pushIndent()
            sourceStream.writeline('EncodeDataStream headerStream(messageEncoding.addScratchWriteBuffer());')
            sourceStream.writeline('EncodeStream encodeStream(messageEncoding.addScratchWriteBuffer(), messageEncoding);')
            sourceStream.writeline('encodeStream.writeUInt16Compressed({messageName}::OpCode);'.format(messageName = messageName))
            sourceStream.writeline('encodeStream.write{messageName}(message);'.format(messageName = messageName))
            sourceStream.writeline('headerStream.writeUInt32BE(uint32_t(encodeStream.size()));')
            sourceStream.popIndent()
            sourceStream.writeline('}')
            sourceStream.writeline()

            #sourceStream.writeline('size_t')
            #sourceStream.writeline('encodedSize(' + encodingClass + '& messageEncoding, const {messageName}& message) const'.format(messageName = messageName))
            #sourceStream.writeline('{')
            #sourceStream.pushIndent()
            #sourceStream.writeline('size_t result = 0;')
            #sourceStream.writeline('result += 2;')
            #sourceStream.writeline('// encodeStream.write{messageName}(message);'.format(messageName = messageName))
            #sourceStream.writeline('result += 4;')
            #sourceStream.writeline('return result;')
            #sourceStream.popIndent()
            #sourceStream.writeline('}')
            #sourceStream.writeline()

        sourceStream.popIndent()
        sourceStream.writeline('private:')
        sourceStream.pushIndent()
        sourceStream.writeline(encodingClass + '& _messageEncoding;')
        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()


        sourceStream.writeline('class OPENRTI_LOCAL ' + encodingClass + '::DecodeStream : public DecodeDataStream {')
        sourceStream.writeline('public:')
        sourceStream.pushIndent()
        sourceStream.writeline('DecodeStream(const VariableLengthData& variableLengthData, ' + encodingClass + '& messageEncoding) :')
        sourceStream.writeline('  DecodeDataStream(variableLengthData),')
        sourceStream.writeline('  _messageEncoding(messageEncoding)')
        sourceStream.writeline('{ }')

        for t in messageMap.getTypeList():
            t.writeComponent('Decoder', sourceStream, self)

        sourceStream.popIndent()
        sourceStream.writeline('private:')
        sourceStream.pushIndent()
        sourceStream.writeline(encodingClass + '& _messageEncoding;')
        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()


        sourceStream.writeline('class OPENRTI_LOCAL ' + encodingClass + '::PayloadDecoder {')
        sourceStream.writeline('public:')
        sourceStream.pushIndent()
        sourceStream.writeline('PayloadDecoder(const Buffer::const_iterator& i) :')
        sourceStream.writeline('  _i(i)')
        sourceStream.writeline('{ }')

        for t in messageMap.getTypeList():
            t.writeComponent('PayloadDecoder', sourceStream, self)

        sourceStream.writeline('Buffer::const_iterator _i;')
        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()


        sourceStream.writeline(encodingName + 'MessageEncoding::' + encodingName + 'MessageEncoding() noexcept')
        sourceStream.writeline('{')
        sourceStream.writeline('}')
        sourceStream.writeline()
        sourceStream.writeline(encodingName + 'MessageEncoding::~' + encodingName + 'MessageEncoding() noexcept')
        sourceStream.writeline('{')
        sourceStream.writeline('}')
        sourceStream.writeline()

        sourceStream.writeline('const char*')
        sourceStream.writeline(encodingName + 'MessageEncoding::getName() const')
        sourceStream.writeline('{')
        sourceStream.writeline('  return "' + encodingName + '";')
        sourceStream.writeline('}')
        sourceStream.writeline()

        sourceStream.writeline('void')
        sourceStream.writeline(encodingName + 'MessageEncoding::readPacket(const Buffer& buffer)')
        sourceStream.writeline('{')
        sourceStream.pushIndent()
        sourceStream.writeline('Buffer::const_iterator i = buffer.begin();')
        sourceStream.writeline('if (i == buffer.end()) {')
        sourceStream.writeline('  addScratchReadBuffer(4);')
        sourceStream.writeline('} else if (++i == buffer.end()) {')
        sourceStream.writeline('  addScratchReadBuffer(buffer.front().getUInt32BE(0));')
        sourceStream.writeline('} else if (++i == buffer.end()) {')
        sourceStream.writeline('  decodeBody(*(--i));')
        sourceStream.writeline('} else {')
        sourceStream.writeline('  decodePayload(i);')
        sourceStream.writeline('}')
        sourceStream.writeline('if (getInputBufferComplete() && _message != nullptr)')
        sourceStream.writeline('{')
        sourceStream.pushIndent()
        sourceStream.writelineNoIndent('#ifdef ENABLE_NETWORKSTATISTICS')
        sourceStream.writeline('GetNetworkStatistics().MessageReceived(_message->getTypeName());')
        sourceStream.writelineNoIndent('#endif')
        sourceStream.writeline('getConnect()->send(SharedPtr<AbstractMessage>().swap(_message));')
        sourceStream.popIndent()
        sourceStream.writeline('}')
        sourceStream.popIndent()
        sourceStream.writeline('}')
        sourceStream.writeline()

        sourceStream.writeline('void')
        sourceStream.writeline(encodingClass + '::decodeBody(const VariableLengthData& variableLengthData)')
        sourceStream.writeline('{')
        sourceStream.pushIndent()
        sourceStream.writeline('DecodeStream decodeStream(variableLengthData, *this);')
        sourceStream.writeline('uint16_t opcode = decodeStream.readUInt16Compressed();')
        sourceStream.writeline('switch (opcode) {')

        for t in messageMap.getTypeList():
            messageName = t.getName()
            opcode = MessageDataType.getMessageOpcode(messageName)
            if opcode is None:
                if isinstance(t, MessageDataType): print("MessageEncoding.writeEncodingImplementation(decodeBody): no opcode:", t.getName())
                continue
            sourceStream.writeline('case {messageName}::OpCode:'.format(messageName = messageName))
            sourceStream.pushIndent()
            sourceStream.writeline('_message = MakeShared<{messageName}>();'.format(messageName = messageName))
            sourceStream.writeline('decodeStream.read{messageName}(static_cast<{messageName}&>(*_message));'.format(messageName = messageName))
            sourceStream.writeline('break;')
            sourceStream.popIndent()

        sourceStream.writeline('default:')
        sourceStream.writeline('  break;')
        sourceStream.writeline('}')
        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()

        sourceStream.writeline('void')
        sourceStream.writeline(encodingClass + '::decodePayload(const Buffer::const_iterator& i)')
        sourceStream.writeline('{')
        sourceStream.pushIndent()
        sourceStream.writeline('Buffer::const_iterator j = i;')
        sourceStream.writeline('DecodeDataStream decodeStream(*(--j));')
        sourceStream.writeline('uint16_t opcode = decodeStream.readUInt16Compressed();')
        sourceStream.writeline('PayloadDecoder payloadDecoder(i);')
        sourceStream.writeline('switch (opcode) {')
        for t in messageMap.getTypeList():
            messageName = t.getName()
            opcode = MessageDataType.getMessageOpcode(messageName)
            if opcode is None:
                if isinstance(t, MessageDataType): print("MessageEncoding.writeEncodingImplementation(decodePayload): no opcode:", t.getName())
                continue
            if not t.hasPayload():
                continue
            sourceStream.writeline('case {messageName}::OpCode:'.format(messageName = messageName))
            sourceStream.pushIndent()
            sourceStream.writeline('payloadDecoder.readPayload{messageName}(static_cast<{messageName}&>(*_message));'.format(messageName = messageName))
            sourceStream.writeline('break;')
            sourceStream.popIndent()
        sourceStream.writeline('default:')
        sourceStream.writeline('  break;')
        sourceStream.writeline('}')
        sourceStream.popIndent()
        sourceStream.writeline('}')
        sourceStream.writeline()

        sourceStream.writeline('void')
        sourceStream.writeline(encodingName + 'MessageEncoding::writeMessage(const AbstractMessage& message)')
        sourceStream.writeline('{')
        sourceStream.pushIndent()
        sourceStream.writeline('message.dispatchFunctor(DispatchFunctor(*this));')
        sourceStream.writelineNoIndent('#ifdef ENABLE_NETWORKSTATISTICS')
        sourceStream.writeline('GetNetworkStatistics().MessageSent(message.getTypeName());')
        sourceStream.writelineNoIndent('#endif')
        sourceStream.popIndent()
        sourceStream.writeline('}')
        sourceStream.writeline()

        sourceStream.writeline('} // namespace OpenRTI')
        sourceStream.writeline()

###############################################################################
# FIXME move actual value encodings to here

class TightBE1MessageEncoding(MessageEncoding):
    def __init__(self):
        MessageEncoding.__init__(self, 'TightBE1')

# class AlignedLE1MessageEncoding(MessageEncoding):
#     def __init__(self):
#         MessageEncoding.__init__(self, 'AlignedLE1')

# class AlignedBE1MessageEncoding(MessageEncoding):
#     def __init__(self):
#         MessageEncoding.__init__(self, 'AlignedBE1')


###############################################################################
class TypeMap(object):
    def __init__(self, root):
        self.__typeList = []
        self.__typeMap = {}
        for node in root.getchildren():
            if node.tag == 'message':
                message = MessageDataType(self, node.get('type') + 'Message', parentTypeName='AbstractMessage')
                for field in node.getchildren():
                    if field.tag == 'field':
                        hide = field.get('hide')
                        if hide is not None:
                            if hide.lower() == 'true' or hide == '1': 
                                hide = True
                            else:
                                hide = False
                        message.addField(field.get('name'), field.get('type'), hideOnPrint=hide)
                    elif field.tag == 'reliable':
                        message.setReliableExpression(field.get('expression'))
                    elif field.tag == 'objectInstance':
                        message.setObjectInstanceExpression(field.get('expression'))
                    #field = field.next
                self.addType(message)

            elif node.tag == 'type':
                typeName = node.get('type')
                if typeName == 'enum':
                    enum = EnumDataType(self, node.get('name'))
                    for enumerant in node.getchildren():
                        if enumerant.tag == 'enumerant':
                            enum.addEnum(enumerant.get('name'), enumerant.get('value'), enumerant.get('repr'))
                    self.addType(enum)

                elif typeName == 'vector':
                    scalarTypeName = node.get('scalar')
                    scalarType = self.__typeMap[scalarTypeName]
                    self.addType(VectorDataType(self, node.get('name'), scalarTypeName, scalarType.getParentObject()))

                elif typeName == 'set':
                    self.addType(SetDataType(self, node.get('name'), node.get('scalar')))

                elif typeName == 'map':
                    self.addType(MapDataType(self, node.get('name'), node.get('key'), node.get('value')))

                elif typeName == 'pair':
                    self.addType(PairDataType(self, node.get('name'), node.get('first'), node.get('second')))

                elif typeName == 'struct':
                    struct = StructDataType(self, node.get('name'), abstract=node.get('abstract'), parentObject=node.get('parent'), parentTypeName=node.get('base'))
                    struct.setCopyOnWrite(node.get('copyOnWrite') == 'true')
                    for field in node.getchildren():
                        if field.tag == 'field':
                            struct.addField(field.get('name'), field.get('type'), const=field.get('const'), value=field.get('value'))
                    self.addType(struct)
                else:
                    dataType = CDataType(self, node.get('name'), node.get('encoding'), node.get('ctype'), node.get('parent'))
                    self.addType(dataType)
            #node = node.next

        for t in self.__typeList:
            t.resolveHasPayloadAndHasSwap(self)

    def addType(self, t):
        self.__typeList.append(t)
        self.__typeMap[t.getName()] = t

    def getTypeList(self):
        return self.__typeList

    def getType(self, name):
        if name in self.__typeMap:
            return self.__typeMap[name]
        return None

    def writeDeclaration(self, sourceStream):
        sourceStream.writeCopyright()
        sourceStream.writeline('#ifndef OpenRTI_Message_h')
        sourceStream.writeline('#define OpenRTI_Message_h')
        sourceStream.writeline()
        sourceStream.writeline('#include <map>')
        sourceStream.writeline('#include <set>')
        sourceStream.writeline('#include <vector>')
        sourceStream.writeline('#include "AbstractMessage.h"')
        sourceStream.writeline('#include "AbstractMessageDispatcher.h"')
        sourceStream.writeline('#include "Handle.h"')
        sourceStream.writeline('#include "VariableLengthData.h"')
        sourceStream.writeline()
        sourceStream.writeline('#ifndef __CPlusPlusStd')
        sourceStream.writeline('#error "must include OpenRTIConfig.h!"')
        sourceStream.writeline('#endif')
        sourceStream.writeline()
        sourceStream.writeline('namespace OpenRTI {')

        sourceStream.writeline()
        for t in self.__typeList:
            t.writeForwardDeclaration(sourceStream)

        sourceStream.writeline()
        for t in self.__typeList:
            t.writeDeclaration(sourceStream)

        sourceStream.writeline()
        for t in self.__typeList:
            t.writeStreamOutDecl(sourceStream)

        sourceStream.writeline()
        sourceStream.writeline('template<typename T, typename ParentObjectClass>')
        sourceStream.writeline('std::ostream&')
        sourceStream.writeline('prettyprint(std::ostream& os, const T& value, ParentObjectClass*)')
        sourceStream.writeline('{')
        sourceStream.writeline('  os << value;')
        sourceStream.writeline('  return os;')
        sourceStream.writeline('}')
        sourceStream.writeline()

        for t in self.__typeList:
            t.writePrettyPrintDecl(sourceStream)

        sourceStream.writeline()
        for t in self.__typeList:
            t.writeToString(sourceStream)
        sourceStream.writeline()
        for t in self.__typeList:
            t.writeByteSize(sourceStream)
        sourceStream.writeline('} // namespace OpenRTI')
        sourceStream.writeline()
        sourceStream.writeline('#endif')

    def writeImplementation(self, sourceStream):
        sourceStream.writeCopyright()
        sourceStream.writeline()
        sourceStream.writeline('#include "DebugNew.h"')
        sourceStream.writeline('#include "Message.h"')
        sourceStream.writeline()
        sourceStream.writeline('#include <ostream>')
        sourceStream.writeline('#include "AbstractMessage.h"')
        sourceStream.writeline('#include "AbstractMessageDispatcher.h"')
        sourceStream.writeline('#include "StringUtils.h"')
        sourceStream.writeline('#include "ServerModel.h"')
        sourceStream.writeline()
        sourceStream.writeline('namespace OpenRTI {')
        sourceStream.writeline()
        for t in self.__typeList:
            t.writeImplementation(sourceStream)
        for t in self.__typeList:
            t.writeStreamOut(sourceStream)
            t.writePrettyPrint(sourceStream)
        sourceStream.writeline()
        sourceStream.writeline('} // namespace OpenRTI')

    def writeDispatcher(self, sourceStream):
        sourceStream.writeCopyright()
        sourceStream.writeline('#ifndef OpenRTI_AbstractMessageDispatcher_h')
        sourceStream.writeline('#define OpenRTI_AbstractMessageDispatcher_h')
        sourceStream.writeline()
        sourceStream.writeline('namespace OpenRTI {')
        sourceStream.writeline()
        sourceStream.writeline('class AbstractMessage;')
        sourceStream.writeline()

        for t in self.__typeList:
            if not t.isMessage():
                continue
            t.writeForwardDeclaration(sourceStream)

        sourceStream.writeline()

        sourceStream.writeline('class OPENRTI_LOCAL AbstractMessageDispatcher {')
        sourceStream.writeline('public:')
        sourceStream.pushIndent()
        sourceStream.writeline('virtual ~AbstractMessageDispatcher() noexcept {}')
        sourceStream.writeline()

        for t in self.__typeList:
            if not t.isMessage():
                continue
            sourceStream.writeline('virtual void accept(const {name}&) const = 0;'.format(name = t.getName()))

        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()

        sourceStream.writeline('template<typename T>')
        sourceStream.writeline('class OPENRTI_LOCAL FunctorMessageDispatcher : public AbstractMessageDispatcher {')
        sourceStream.writeline('public:')
        sourceStream.pushIndent()
        sourceStream.writeline('FunctorMessageDispatcher(T& t) : _t(t) {}')
        sourceStream.writeline('virtual ~FunctorMessageDispatcher() noexcept {}')
        sourceStream.writeline()

        for t in self.__typeList:
            if not t.isMessage():
                continue
            sourceStream.writeline('virtual void accept(const {name}& message) const override {{ _t(message); }}'.format(name = t.getName()))

        sourceStream.popIndent()
        sourceStream.writeline('private:')
        sourceStream.pushIndent()
        sourceStream.writeline('T& _t;')
        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()

        sourceStream.writeline('template<typename T>')
        sourceStream.writeline('class OPENRTI_LOCAL ConstFunctorMessageDispatcher : public AbstractMessageDispatcher {')
        sourceStream.writeline('public:')
        sourceStream.pushIndent()
        sourceStream.writeline('ConstFunctorMessageDispatcher(const T& t) : _t(t) {}')
        sourceStream.writeline('virtual ~ConstFunctorMessageDispatcher() noexcept {}')
        sourceStream.writeline()

        for t in self.__typeList:
            if not t.isMessage():
                continue
            sourceStream.writeline('virtual void accept(const {name}& message) const override {{ _t(message); }}'.format(name = t.getName()))

        sourceStream.popIndent()
        sourceStream.writeline('private:')
        sourceStream.pushIndent()
        sourceStream.writeline('const T& _t;')
        sourceStream.popIndent()
        sourceStream.writeline('};')
        sourceStream.writeline()

        sourceStream.writeline('} // namespace OpenRTI')
        sourceStream.writeline()
        sourceStream.writeline('#endif')

    def writeEncodingDeclaration(self, sourceStream, messageEncoding):
        messageEncoding.writeEncodingDeclaration(self, sourceStream)

    def writeEncodingImplementation(self, sourceStream, messageEncoding):
        messageEncoding.writeEncodingImplementation(self, sourceStream)


# The main application

import sys
import getopt
import xml.etree.ElementTree as etree

messageDefinitionFile = 'codegen/Message.xml'
outputMode = ''

# try:
(args, trail) = getopt.getopt(sys.argv[1:], 'm:O:')
# except Exception,e:
#     show_usage()

for (arg, val) in args:
    if arg == '-m':
        messageDefinitionFile = val
    elif arg == '-O':
        outputMode = val

# read the xml document describing the types
#doc = libxml2.readFile(messageDefinitionFile, None,
#    libxml2.XML_PARSE_DTDLOAD +
#    libxml2.XML_PARSE_DTDVALID +
#    libxml2.XML_PARSE_NOBLANKS)
doc = etree.parse(messageDefinitionFile)
rootElement = doc.getroot()
typeMap = TypeMap(rootElement)
# doc.freeDoc()

# These are the output modes for debugging specific stages
if outputMode == 'MessageDeclaration':
    typeMap.writeDeclaration(SourceStream(sys.stdout))
elif outputMode == 'MessageImplementation':
    typeMap.writeImplementation(SourceStream(sys.stdout))
elif outputMode == 'MessageDispatcher':
    typeMap.writeDispatcher(SourceStream(sys.stdout))
elif outputMode == 'MessageEncodingDeclaration':
    messageEncoding = TightBE1MessageEncoding()
    typeMap.writeEncodingDeclaration(SourceStream(SourceStream(sys.stdout)), messageEncoding)
elif outputMode == 'MessageEncodingImplementation':
    messageEncoding = TightBE1MessageEncoding()
    typeMap.writeEncodingImplementation(SourceStream(SourceStream(sys.stdout)), messageEncoding)
else:
    # This is the shortcut for 'just do all output into the current directory'
    print('write ' + 'Message.h')
    typeMap.writeDeclaration(SourceStream(open('Message.h', 'w+')))
    print('write ' + 'Message.cpp')
    typeMap.writeImplementation(SourceStream(open('Message.cpp', 'w+')))
    print('write ' + 'AbstractMessageDispatcher.h')
    typeMap.writeDispatcher(SourceStream(open('AbstractMessageDispatcher.h', 'w+')))

    messageEncoding = TightBE1MessageEncoding()
    print('write ' + 'TightBE1MessageEncoding.h')
    typeMap.writeEncodingDeclaration(SourceStream(open('TightBE1MessageEncoding.h', 'w+')), messageEncoding)
    print('write ' + 'TightBE1MessageEncoding.cpp')
    typeMap.writeEncodingImplementation(SourceStream(open('TightBE1MessageEncoding.cpp', 'w+')), messageEncoding)
