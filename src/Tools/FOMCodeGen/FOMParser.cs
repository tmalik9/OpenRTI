
using System;
using System.Collections.Generic;
using System.Xml;

namespace FOMCodeGen
{
  public class FOMParser
  {
    public class ModelIdentificationStruct
    {
      public string Name { get; set; }
      public string Version { get; set; }
      public string Description { get; set; }
      public string Purpose { get; set; }
      public string Copyright { get; set; }
    }
    public class DataType
    {
      public DataType(string name)
      {
        Name = name;
      }
      // The name of the data type, as specified in the FOM
      public string Name { get; set; }
      // The corresponding C++ type (usually the same as the name of the defined type, unless defined otherwise)
      public virtual string CPPType
      {
        get { return Name; }
      }
      // The name of the encoding class (either built in or generated by the code generator)
      public virtual string Encoding
      {
        get { return Name + "Encoding"; }
      }
      // Flags whether to generate or not the encoding class
      public bool Generate { get; set; }
      // An optional comment, generated from the 'semantics' tag in the FOM.
      public string Comment
      {
        get {
          if (_comment != null && _comment != "")
            return FormatAsComment(_comment);
          else
            return null;
        }
        set { _comment = value; }
      }
      private string _comment;
    }
    // A BasicDataRepresentation is a predefined wrapper for a built in C++ simple type (numeric)
    public class BasicDataRepresentation : DataType
    {
      public BasicDataRepresentation(string name, string cppType) : base(name)
      {
        _cppType = cppType;
      }
      private string _cppType;
      public override string CPPType
      {
        get { return _cppType; }
      }
      public override string Encoding
      {
        get { return "rti1516e::" + Name; }
      }
    }
    // A SimpleDataType is basically a typedef to a BasicDataRepresentation
    public class SimpleDataType : DataType
    {
      public SimpleDataType(string name, BasicDataRepresentation representation) : base(name)
      {
        Representation = representation;
      }
      // The BasicDataRepresentation this name is typedef'd to
      public BasicDataRepresentation Representation { get; set; }
      public override string Encoding
      {
        get { return Representation.Encoding; }
      }
    }

    // A member of a enumeration
    public class Enumerator
    {
      public Enumerator(string name, string value)
      {
        Name = name;
        Value = value;
      }
      public string Name { get; set; }
      public string Value { get; set; }
    }
    // An enumeration type
    public class EnumeratedDataType : DataType
    {
      public EnumeratedDataType(string name, BasicDataRepresentation representation) : base(name)
      {
        Representation = representation;
        Enumerators = new Dictionary<string, Enumerator>();
      }
      // The BasicDataRepresentation this type is based on
      public BasicDataRepresentation Representation { get; set; }
      public Dictionary<string, Enumerator> Enumerators { get; set; }
      public override string Encoding
      {
        get { return Representation.Encoding; }
      }
    }
    // An array data type, one of HLAfixedArray or HLAvariableArray.
    public class ArrayDataType : DataType
    {
      public ArrayDataType(string name, DataType dataType) : base(name)
      {
        DataType = dataType;
      }
      public DataType DataType { get; set; }
    }

    public class FixedArrayDataType : ArrayDataType
    {
      public FixedArrayDataType(string name, DataType dataType, string cardinality) : base(name, dataType)
      {
        DataType = dataType;
        Cardinality = cardinality;
      }
      public string Cardinality { get; set; }
      public override string CPPType
      {
        get { return "const std::vector<" + DataType.CPPType + ">&"; }
      }
    }

    public class VariableArrayDataType : ArrayDataType
    {
      public VariableArrayDataType(string name, DataType dataType) : base(name, dataType)
      {
      }
      public override string CPPType
      {
        get { return "const std::vector<" + DataType.CPPType + ">&"; }
      }
    }

    public class FixedRecordField
    {
      public FixedRecordField(string name, DataType dataType, uint version)
      {
        Name = name;
        DataType = dataType;
        Version = version;
      }
      public string Name { get; set; }
      public DataType DataType { get; set; }
      public uint Version { get; set; }
      public string Comment { get; set; }
    }
    public class FixedRecordDataType : DataType
    {
      public FixedRecordDataType(string name, uint version) : base(name)
      {
        Fields = new List<FixedRecordField>();
        Version = version;
        HasChilds = false;
      }
      public uint Version { get; set; }
      public List<FixedRecordField> Fields { get; set; }
      public List<FixedRecordField> AllFields
      {
        get
        {
          List<FixedRecordField> allFields = new List<FixedRecordField>();
          FixedRecordDataType baseClass = BaseClass;
          if (baseClass != null)
          {
            var baseClassFields = baseClass.AllFields;
            foreach (var field in baseClassFields)
              allFields.Add(field);
          }
          foreach (var field in Fields)
            allFields.Add(field);
          return allFields;
        }
      }
      public FixedRecordDataType BaseClass { get; set; }
      public bool HasChilds { get; set; }
    }

    public Dictionary<string, DataType> DataTypes { get; set; }
    public string Filename { get; set; }
    public string[] Namespace { get; set; }
    public ModelIdentificationStruct ModelIdentification { get; set; }
    private Dictionary<string, string> mBasicDataRepresentations = new Dictionary<string, string>()
    {
      { "HLAASCIIchar", "char" },
      { "HLAASCIIstring", "std::string" },
      { "HLAboolean", "bool" },
      { "HLAbyte", "uint8_t" },
      { "HLAfloat32BE", "float" },
      { "HLAfloat32LE", "float" },
      { "HLAfloat64BE", "double" },
      { "HLAfloat64LE", "double" },
      { "HLAinteger16LE", "int16_t" },
      { "HLAinteger16BE", "int16_t" },
      { "HLAinteger32BE", "int32_t" },
      { "HLAinteger32LE", "int32_t" },
      { "HLAinteger64BE", "int64_t" },
      { "HLAinteger64LE", "int64_t" },
      { "HLAoctet", "uint8_t" },
      { "HLAoctetPairBE", "OctetPair" },
      { "HLAoctetPairLE", "OctetPair" },
      { "HLAunicodeChar", "wchar_t" },
      { "HLAunicodeString", "std::wstring" },
    };
    public static string FormatAsComment(string value, string prefix = "")
    {
      var lines = value.Split('\n');
      string result = "";
      bool firstLine = true;
      string spaces = new string(' ', prefix.Length);
      foreach (var line in lines)
      {
        if (firstLine)
          result += "// " + prefix + line;
        else
          result += "\n// " + spaces + line;
        firstLine = false;
      }
      return result;
    }
    public FOMParser(string filename, string enclosingNamespace)
    {
      DataTypes = new Dictionary<string, DataType>();
      foreach (var entry in mBasicDataRepresentations)
      {
        DataTypes.Add(entry.Key, new BasicDataRepresentation(entry.Key, entry.Value));
      }
      Filename = filename;
      Namespace = enclosingNamespace.Split('.');
      ModelIdentification = new ModelIdentificationStruct();

      XmlDocument doc = new XmlDocument();
      doc.Load(filename);


      var modelIdentificationNode = doc.DocumentElement.SelectSingleNode("/objectModel/modelIdentification");
      if (modelIdentificationNode != null)
      {
        if (modelIdentificationNode["name"] != null)
        {
          ModelIdentification.Name = modelIdentificationNode["name"].FirstChild.InnerText;
        }
        if (modelIdentificationNode["version"] != null)
        {
          ModelIdentification.Version = modelIdentificationNode["version"].FirstChild.InnerText;
        }
        if (modelIdentificationNode["description"] != null)
        {
          ModelIdentification.Description = modelIdentificationNode["description"].FirstChild.InnerText;
        }
        if (modelIdentificationNode["purpose"] != null)
        {
          ModelIdentification.Purpose = modelIdentificationNode["purpose"].FirstChild.InnerText;
        }
        if (modelIdentificationNode["copyright"] != null)
        {
          ModelIdentification.Copyright = modelIdentificationNode["copyright"].FirstChild.InnerText;
        }
      }
      var simpleDataTypeNodes = doc.DocumentElement.SelectNodes("/objectModel/dataTypes/simpleDataTypes/simpleData");
      foreach (XmlElement simpleDataTypeNode in simpleDataTypeNodes)
      {
        string name = simpleDataTypeNode["name"].FirstChild.InnerText;
        string representation = simpleDataTypeNode["representation"].FirstChild.InnerText;
        var simpleType = new SimpleDataType(name, DataTypes[representation] as BasicDataRepresentation);
        DataTypes[name] = simpleType;
        simpleType.Generate = (simpleDataTypeNode["nocode"] == null);
        if (simpleDataTypeNode["semantics"] != null && simpleDataTypeNode["semantics"].FirstChild != null) simpleType.Comment = simpleDataTypeNode["semantics"].FirstChild.InnerText;
      }

      var enumeratedDataTypeNodes = doc.DocumentElement.SelectNodes("/objectModel/dataTypes/enumeratedDataTypes/enumeratedData");
      foreach (XmlElement enumeratedDataTypeNode in enumeratedDataTypeNodes)
      {
        string name = enumeratedDataTypeNode["name"].FirstChild.InnerText;
        string representation = enumeratedDataTypeNode["representation"].FirstChild.InnerText;
        var enumeratedDataType = new EnumeratedDataType(name, DataTypes[representation] as BasicDataRepresentation);
        DataTypes[name] = enumeratedDataType;
        foreach (XmlElement enumeratorNode in enumeratedDataTypeNode.SelectNodes("enumerator"))
        {
          string enumeratorName = enumeratorNode["name"].FirstChild.InnerText;
          string enumeratorValue = enumeratorNode["value"].FirstChild.InnerText;
          enumeratedDataType.Enumerators.Add(enumeratorName, new Enumerator(enumeratorName, enumeratorValue));
        }
        enumeratedDataType.Generate = (enumeratedDataTypeNode["nocode"] == null);
        if (enumeratedDataTypeNode["semantics"] != null && enumeratedDataTypeNode["semantics"].FirstChild != null)
          enumeratedDataType.Comment = enumeratedDataTypeNode["semantics"].FirstChild.InnerText;
      }

      var arrayDataTypeNodes = doc.DocumentElement.SelectNodes("/objectModel/dataTypes/arrayDataTypes/arrayData");
      foreach (XmlElement arrayDataTypeNode in arrayDataTypeNodes)
      {
        string name = arrayDataTypeNode["name"].FirstChild.InnerText;
        string dataType = arrayDataTypeNode["dataType"].FirstChild.InnerText;
        string cardinality = arrayDataTypeNode["cardinality"].FirstChild.InnerText;
        string encoding = arrayDataTypeNode["encoding"].FirstChild.InnerText;
        if (encoding == "HLAvariableArray")
        {
          if (cardinality != "Dynamic")
          {
            throw new ApplicationException("array with encoding \"HLAvariableArray\" must specify cardinality \"Dynamic\"");
          }
          var arrayDataType = new VariableArrayDataType(name, DataTypes[dataType]);
          DataTypes[name] = arrayDataType;
          arrayDataType.Generate = (arrayDataTypeNode["nocode"] == null);
          if (arrayDataTypeNode["semantics"] != null && arrayDataTypeNode["semantics"].FirstChild != null)
            arrayDataType.Comment = arrayDataTypeNode["semantics"].FirstChild.InnerText;
        }
        else if (encoding == "HLAfixedArray")
        {
          int result = 0;
          if (!int.TryParse(cardinality, out result))
          {
            throw new ApplicationException("array with encoding \"HLAfixedArray\" must specify integer cardinality");
          }
          var arrayDataType = new FixedArrayDataType(name, DataTypes[dataType], cardinality);
          DataTypes[name] = arrayDataType;
          arrayDataType.Generate = (arrayDataTypeNode["nocode"] == null);
          if (arrayDataTypeNode["semantics"] != null) arrayDataType.Comment = arrayDataTypeNode["semantics"].FirstChild.InnerText;
        }
        else
        {
          throw new ApplicationException("encoding must be either \"HLAfixedArray\" or \"HLAvariableArray\"");
        }
      }

      var fixedRecordDataTypeNodes = doc.DocumentElement.SelectNodes("/objectModel/dataTypes/fixedRecordDataTypes/fixedRecordData");
      foreach (XmlElement fixedRecordDataTypeNode in fixedRecordDataTypeNodes)
      {
        string name = fixedRecordDataTypeNode["name"].FirstChild.InnerText;
        FixedRecordDataType includedFixedRecordType = null;
        if (fixedRecordDataTypeNode["include"] != null)
        {
          includedFixedRecordType = DataTypes[fixedRecordDataTypeNode["include"].FirstChild.InnerText] as FixedRecordDataType;
          includedFixedRecordType.HasChilds = true;
        }

        uint recordVersion = 0;
        if (fixedRecordDataTypeNode["version"] != null)
        {
          string versionString = fixedRecordDataTypeNode["version"].FirstChild.InnerText;
          if (!uint.TryParse(versionString, out recordVersion))
          {
            throw new ApplicationException("record version must be an integer: \"" + versionString + "\"");
          }
        }
        else if (includedFixedRecordType != null)
        {
          recordVersion = includedFixedRecordType.Version;
        }
        var fixedRecordDataType = new FixedRecordDataType(name, recordVersion);
        DataTypes[name] = fixedRecordDataType;
        fixedRecordDataType.BaseClass = includedFixedRecordType;

        foreach (XmlElement fieldNode in fixedRecordDataTypeNode.SelectNodes("field"))
        {
          string fieldName = fieldNode["name"].FirstChild.InnerText;
          string fieldDataType = fieldNode["dataType"].FirstChild.InnerText;
          uint fieldVersion = recordVersion;
          if (fieldNode["version"] != null)
          {
            string versionString = fieldNode["version"].FirstChild.InnerText;
            if (!uint.TryParse(versionString, out fieldVersion))
            {
              throw new ApplicationException("field version must be an integer: \"" + versionString + "\"");
            }
          }
          var field = new FixedRecordField(fieldName, DataTypes[fieldDataType], fieldVersion);
          if (fieldNode["semantics"] != null && fieldNode["semantics"].FirstChild != null)
          {
            field.Comment = fieldNode["semantics"].FirstChild.InnerText;
          }
          fixedRecordDataType.Fields.Add(field);
        }
        FixedRecordField previousField = null;
        foreach (var field in fixedRecordDataType.Fields)
        {
          if (field.Version > fixedRecordDataType.Version)
          {
            throw new ApplicationException(string.Format("fixed record \"{0}\" version {1}, field \"{2}\" version {3}: field version must be lower or equal to record version",
              fixedRecordDataType.Name, fixedRecordDataType.Version, field.Name, field.Version));
          }
          if (previousField != null && previousField.Version > field.Version)
          {
            throw new ApplicationException(string.Format("fixed record \"{0}\", field \"{1}\" version {2}: field version must be greater or equal to previous field \"{3}\" version {4}",
              fixedRecordDataType.Name, field.Name, field.Version, previousField.Name, previousField.Version));
          }
          previousField = field;
        }
        fixedRecordDataType.Generate = (fixedRecordDataTypeNode["nocode"] == null);
        if (fixedRecordDataTypeNode["semantics"] != null)
        {
          fixedRecordDataType.Comment = fixedRecordDataTypeNode["semantics"].FirstChild.InnerText;
        }
      }
    }
  }
}
