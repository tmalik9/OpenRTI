<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>

// Code automatically generated by T4 template from <#=FOM.Filename#>, do not edit
#pragma once

#include <vector>
#include "RTI/Handle.h"
#include "RTI/RTIambassador.h"
#include "RTI/encoding/BasicDataElements.h"
#include "RTI/encoding/HLAfixedRecord.h"
#include "RTI/encoding/HLAfixedArray.h"
#include "RTI/encoding/HLAvariableArray.h"
<#=FOM.PredefinedTypeIncludes#>
#include "<#=ObjectInterfacesHeaderFilename#>"
#include "<#=EncodingHeaderFilename#>"

<#
foreach (var namespacePart in FOM.Namespace)
{
#>
namespace <#=namespacePart#> {
<# } #>

<# 
foreach (var objectClass in FOM.ObjectClasses)
{
#>
class <#=objectClass.Name#>;
class <#=objectClass.Name#>ObjectClass : public I<#=objectClass.Name#>ObjectClass
{
  public:
    // I<#=objectClass.Name#>ObjectClass
    void Publish() override;
    void Unpublish() override;
    void Subscribe() override;
    void Unsubscribe() override;
    I<#=objectClass.Name#>* GetObjectInstance(const std::wstring& instanceName) override;
    I<#=objectClass.Name#>* CreateObjectInstance(const std::wstring& instanceName) override;

    // internal
<#
  if (objectClass.BaseClass != null)
  {
#>
    <#=objectClass.Name#>ObjectClass(rti1516ev::RTIambassador* rtiAmbassador, <#=objectClass.BaseClass.Name#>ObjectClass* baseClass);

<# } else {#>
    <#=objectClass.Name#>ObjectClass(rti1516ev::RTIambassador* rtiAmbassador);
<# } #>
<# 
  var baseClass = objectClass.BaseClass;
  while (baseClass != null)
  {
    foreach (var attribute in baseClass.Attributes)
    {
      if (attribute.DataType != null)
      { #>
    // attribute <#=attribute.Name#> : <#=attribute.DataType.Name#>
    rti1516ev::AttributeHandle Get<#=attribute.Name#>AttributeHandle() const { return mBaseClass->Get<#=attribute.Name#>AttributeHandle(); }
<#    } else { #>
    // attribute <#=attribute.Name#> : no data type
<#
      } // if (attribute.DataType != null)
    } // foreach (var attribute in objectClass.Attributes)
    baseClass = baseClass.BaseClass;
  } // while (baseClass != null)
#>
<# 
  foreach (var attribute in objectClass.Attributes)
  {
    if (attribute.DataType != null)
    { #>
    // attribute <#=attribute.Name#> : <#=attribute.DataType.Name#>
    rti1516ev::AttributeHandle Get<#=attribute.Name#>AttributeHandle() const { return m<#=attribute.Name#>AttributeHandle; }
<#  } else { #>
    // attribute <#=attribute.Name#> : no data type
<#  
    } // if (attribute.DataType != null)
  } // foreach (var attribute in objectClass.Attributes)
#>
    void DiscoverObjectInstance (rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    rti1516ev::ObjectClassHandle GetObjectClassHandle() const { return mObjectClassHandle; }
    I<#=objectClass.Name#>* GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle);
  private:
    rti1516ev::RTIambassador* mRtiAmbassador;
    // object class handle
    rti1516ev::ObjectClassHandle mObjectClassHandle;
<# if (objectClass.BaseClass != null) { #>
    <#=objectClass.BaseClass.Name#>ObjectClass* mBaseClass;
<# } #>
    bool mPublished = false;
    bool mSubscribed = false;
    // Attribute handles
<# 
  foreach (var attribute in objectClass.Attributes)
  {
    if (attribute.DataType != null)
    {
#>    // attribute <#=attribute.Name#> : <#=attribute.DataType.Name#>
    rti1516ev::AttributeHandle m<#=attribute.Name#>AttributeHandle;
<#  } else {
#>    // attribute <#=attribute.Name#> : no data type
<#  
    } // if (attribute.DataType != null)
  } // foreach (var attribute in objectClass.Attributes)
#>
    std::map<std::wstring, <#=objectClass.Name#>*> mObjectInstancesByName;
    std::map<rti1516ev::ObjectInstanceHandle, <#=objectClass.Name#>*> mObjectInstancesByHandle;
};

class <#=objectClass.Name#> : public I<#=objectClass.Name#>
{
  public:

    <#=objectClass.Name#>();
    <#=objectClass.Name#>(rti1516ev::RTIambassador* ambassador, const std::wstring& instanceName, rti1516ev::ObjectInstanceHandle instanceHandle);
    ~<#=objectClass.Name#>();
    <#=objectClass.Name#>(const <#=objectClass.Name#>&) = delete;
    <#=objectClass.Name#>(<#=objectClass.Name#>&&) = delete;
    <#=objectClass.Name#>& operator=(const <#=objectClass.Name#>&) = delete;
    <#=objectClass.Name#>& operator=(<#=objectClass.Name#>&&) = delete;
    std::wstring GetObjectInstanceName() const override { return mInstanceName; }

<#
  foreach (var attribute in objectClass.AllAttributes)
  {
    if (attribute.DataType != null)
    {
#>    // attribute <#=attribute.Name#> : <#=attribute.DataType.Name#>
    <#=attribute.DataType.ReturnCppType#> Get<#=attribute.Name#>() const override;
    void Set<#=attribute.Name#>(<#=attribute.DataType.CPPType#> newValue) override;
<#  } else { #>
    // attribute <#=attribute.Name#> : no data type
<#
    } // if (attribute.DataType != null)
  } // foreach (var attribute in objectClass.AllAttributes)
#>
    // I<#=objectClass.Name#>
<# if (objectClass.HasValidAttributes) { #>
    void UpdateAllAttributeValues() override;
    void UpdateAllAttributeValues(const rti1516ev::LogicalTime& time) override;
    void UpdateModifiedAttributeValues() override;
    void UpdateModifiedAttributeValues(const rti1516ev::LogicalTime& time) override;
<# if (objectClass.ChildClasses.Count == 0) { #>
    uint32_t RegisterUpdateCallback(UpdateCallbackType callback) override;
    void UnregisterUpdateCallback(uint32_t callbackToken) override;
<# } // if (objectClass.ChildClasses.Count == 0) #>
<# } // if (objectClass.HasValidAttributes) #>

    rti1516ev::AttributeHandleValueMap GetAllAttributeValues() const;
    rti1516ev::AttributeHandleValueMap GetModifiedAttributeValues() const;
<# if (objectClass.HasValidAttributes) { #>
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes);
<# } #>
    AttributeBits GetUpdatedAttributes() const override { return mLastUpdated; }
  private:
<# if (objectClass.HasValidAttributes) { #>
    void ClearDirtyBits()
    {
      mDirty = kNone;
    }
    void ExecuteUpdateCallbacks();
<# } #>
    // modified by last reflectAttributeValues
    <#=objectClass.Name#>ObjectClass* mObjectClass;
    std::wstring mInstanceName;
    rti1516ev::ObjectInstanceHandle mObjectInstanceHandle;
    rti1516ev::RTIambassador* mRtiAmbassador;
    // modified by ReflectAttributeValues
    AttributeBits mLastUpdated = kNone;
    // to be sent with next updateAttributes
    AttributeBits mDirty = kNone;
<# if (objectClass.HasValidAttributes && objectClass.ChildClasses.Count == 0) { #>
    std::map<uint32_t, UpdateCallbackType> mUpdateCallbacks;
    uint32_t mLastCallbackToken = 0;
<# } #>
    // Attribute value encoders
<# 
  foreach (var attribute in objectClass.AllAttributes)
  {
    if (attribute.DataType != null)
    {
#>    // attribute <#=attribute.Name#> : <#=attribute.DataType.Name#>
    <#=attribute.DataType.Encoding#> m<#=attribute.Name#>;
<#  } else {
#>    // attribute <#=attribute.Name#> : no data type
<#  
    } // if (attribute.DataType != null)
  } // foreach (var attribute in objectClass.Attributes)
#>
};

<# } // foreach (var objectClass in FOM.ObjectClasses) #> 

class ClassRegistry : public IClassRegistry
{
  public:
    ClassRegistry(rti1516ev::RTIambassador* rtiAmbassador);
    ~ClassRegistry();
<# foreach (var objectClass in FOM.ObjectClasses) { #>
    I<#=objectClass.Name#>ObjectClass* get<#=objectClass.Name#>ObjectClass() const override { return m<#=objectClass.Name#>ObjectClass.get(); }
<# } #>


    void DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    void ReflectAttributeValues(rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes);
    static ClassRegistry* GetInstance() { return sClassRegistry; }
  private:
    void Initialize();

  private:
    static ClassRegistry* sClassRegistry;
    rti1516ev::RTIambassador* mRtiAmbassador;
<# foreach (var objectClass in FOM.ObjectClasses) { #>
    std::unique_ptr<<#=objectClass.Name#>ObjectClass> m<#=objectClass.Name#>ObjectClass;
<# } #>
}; // class ClassRegistry

<#
foreach (var namespacePart in FOM.Namespace)
{
#>
} // namespace <#=namespacePart#>
<#  } #>
