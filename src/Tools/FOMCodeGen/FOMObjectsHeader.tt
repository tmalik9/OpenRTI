<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>

// Code automatically generated by FOMCodeGen version <#=FOM.GeneratorVersion#> from <#=System.IO.Path.GetFileName(FOM.Filename)#>, do not edit
#pragma once

#include <vector>
#include <mutex>
#include "RTI/Handle.h"
#include "RTI/RTIambassador.h"
#include "RTI/encoding/BasicDataElements.h"
#include "RTI/encoding/HLAfixedRecord.h"
#include "RTI/encoding/HLAfixedArray.h"
#include "RTI/encoding/HLAvariableArray.h"
<#if (FOM.IsFloatTime) {#>
#include "RTI/time/HLAloat64Time.h"
<# } else { #>
#include "RTI/time/HLAinteger64Time.h"
<# } #>

<#=FOM.GetPredefinedTypeIncludes(FOMParser.FileContext.kObjectHeader)#>
#include "<#=ObjectInterfacesHeaderFilename#>"
#include "<#=EncodingHeaderFilename#>"

class ObjectClassRegistry;

<#
foreach (var namespacePart in FOM.Namespace)
{
#>
namespace <#=namespacePart#> {
<# } #>

class ObjectClassRegistry;

<# 
foreach (var objectClass in FOM.ObjectClasses)
{
#>
class <#=objectClass.Name#>;
class <#=objectClass.Name#>ObjectClass : public I<#=objectClass.Name#>ObjectClass
{
  public:
    // I<#=objectClass.Name#>ObjectClass
    <#=objectClass.Name#>ObjectClass() = default;
    virtual ~<#=objectClass.Name#>ObjectClass();
    void Publish() override;
    void Unpublish() override;
    void Subscribe(bool deliverToSelf) override;
    void Unsubscribe() override;
    std::shared_ptr<I<#=objectClass.Name#>> GetObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<I<#=objectClass.Name#>> CreateObjectInstance(const std::wstring& instanceName) override;
    std::shared_ptr<I<#=objectClass.Name#>> CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback) override;
    uint32_t RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback) override;
    void UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<I<#=objectClass.Name#>> newObjectInstance);

    uint32_t RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback) override;
    void UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken) override;
    void ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<I<#=objectClass.Name#>> newObjectInstance);
    // Set a user-defined creator function, which returns subclasses of <#=objectClass.Name#>
    using ObjectInstanceCreatorFunction = std::function<<#=objectClass.Name#>*(<#=objectClass.Name#>ObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)>;
    // When using custom object instance classes, don't forget to set the creator function *before* subscribing to the object class.
    void SetObjectInstanceCreator(ObjectInstanceCreatorFunction creatorFunction) { mCreatorFunction = creatorFunction; }
    // internal
<#
  if (objectClass.BaseClass != null)
  {
#>
    <#=objectClass.Name#>ObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, <#=objectClass.BaseClass.Name#>ObjectClass* baseClass);

<# } else {#>
    <#=objectClass.Name#>ObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry);
<# } #>
<# 
  var baseClass = objectClass.BaseClass;
  while (baseClass != null)
  {
    foreach (var attribute in baseClass.Attributes)
    {
      if (attribute.DataType != null)
      { #>
    // attribute <#=attribute.Name#> : <#=attribute.DataType.Name#>
    rti1516ev::AttributeHandle Get<#=attribute.Name#>AttributeHandle() const { return mBaseClass->Get<#=attribute.Name#>AttributeHandle(); }
<#    } else { #>
    // attribute <#=attribute.Name#> : no data type
<#
      } // if (attribute.DataType != null)
    } // foreach (var attribute in objectClass.Attributes)
    baseClass = baseClass.BaseClass;
  } // while (baseClass != null)
#>
<# 
  foreach (var attribute in objectClass.Attributes)
  {
    if (attribute.DataType != null)
    { #>
    // attribute <#=attribute.Name#> : <#=attribute.DataType.Name#>
    rti1516ev::AttributeHandle Get<#=attribute.Name#>AttributeHandle() const { return m<#=attribute.Name#>AttributeHandle; }
<#  } else { #>
    // attribute <#=attribute.Name#> : no data type
<#  
    } // if (attribute.DataType != null)
  } // foreach (var attribute in objectClass.Attributes)
#>
    void DiscoverObjectInstance (rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    rti1516ev::ObjectClassHandle GetObjectClassHandle() const { return mObjectClassHandle; }
    std::shared_ptr<I<#=objectClass.Name#>> GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle);
    rti1516ev::AttributeHandleSet GetAllAttributeHandles();
    ObjectClassRegistry* GetObjectClassRegistry() const { return mRegistry; }

    // add object instance to maps (and to maps of base classes)
    void InsertObjectInstanceName(std::shared_ptr<I<#=objectClass.Name#>> objectInstance, const std::wstring& objectInstanceName);
    void InsertObjectInstanceHandle(std::shared_ptr<I<#=objectClass.Name#>> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle);
    // remove object instance from maps (and from maps of base classes)
    void EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName);
  private:
    ObjectClassRegistry* mRegistry;
    rti1516ev::RTIambassador* mRtiAmbassador;
    // object class handle
    rti1516ev::ObjectClassHandle mObjectClassHandle;
<# if (objectClass.BaseClass != null) { #>
    <#=objectClass.BaseClass.Name#>ObjectClass* mBaseClass;
<# } #>
    ObjectInstanceCreatorFunction mCreatorFunction;
    bool mPublished = false;
    bool mSubscribed = false;
    // Attribute handles
<# 
  foreach (var attribute in objectClass.Attributes)
  {
    if (attribute.DataType != null)
    {
#>    // attribute <#=attribute.Name#> : <#=attribute.DataType.Name#>
    rti1516ev::AttributeHandle m<#=attribute.Name#>AttributeHandle;
<#  } else {
#>    // attribute <#=attribute.Name#> : no data type
<#  
    } // if (attribute.DataType != null)
  } // foreach (var attribute in objectClass.Attributes)
#>
    // this mutex guards the data structures below
    mutable std::recursive_mutex mMutex;
    std::map<std::wstring, std::shared_ptr<I<#=objectClass.Name#>>> mObjectInstancesByName;
    std::map<rti1516ev::ObjectInstanceHandle, std::shared_ptr<I<#=objectClass.Name#>>> mObjectInstancesByHandle;

    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, DiscoverObjectInstanceCallback> mDiscoverCallbacks;
    uint32_t mLastDiscoverObjectInstanceCallbackToken = 0;
    std::map<uint32_t, RemoveObjectInstanceCallback> mRemoveObjectInstanceCallbacks;
    uint32_t mLastRemoveObjectInstanceCallbackToken = 0;
};

class <#=objectClass.Name#> : public I<#=objectClass.Name#>
{
  public:

    virtual ~<#=objectClass.Name#>();
    <#=objectClass.Name#>(const <#=objectClass.Name#>&) = delete;
    <#=objectClass.Name#>(<#=objectClass.Name#>&&) = delete;
    <#=objectClass.Name#>& operator=(const <#=objectClass.Name#>&) = delete;
    <#=objectClass.Name#>& operator=(<#=objectClass.Name#>&&) = delete;
    I<#=objectClass.Name#>ObjectClass* GetObjectClass() const { return mObjectClass; }
    ObjectClassRegistry* GetObjectClassRegistry() const { return mObjectClass->GetObjectClassRegistry(); }
    std::wstring GetObjectInstanceName() const override { return mObjectInstanceName; }
    rti1516ev::ObjectInstanceHandle GetObjectInstanceHandle() const { return mObjectInstanceHandle; }
    bool IsValid() const override;
    bool IsOwner() const override;
    void Release() override;
<#
  foreach (var attribute in objectClass.AllAttributes)
  {
    if (attribute.DataType != null)
    {
#>    // attribute <#=attribute.Name#> : <#=attribute.DataType.Name#>
    <#=attribute.DataType.ReturnCppType#> Get<#=attribute.Name#>() const override;
<#    if (attribute.DataType is FOMParser.FixedRecordDataType) { #>
    <#=attribute.DataType.ModifiableReturnCppType#> Get<#=attribute.Name#>() override;
<#    } #>
    void Set<#=attribute.Name#>(<#=attribute.DataType.ParameterCppType#> newValue) override;
<#  } else { #>
    // attribute <#=attribute.Name#> : no data type
<#
    } // if (attribute.DataType != null)
  } // foreach (var attribute in objectClass.AllAttributes)
#>
    // I<#=objectClass.Name#>
<# if (objectClass.HasValidAttributes) { #>
    void UpdateAllAttributeValues() override;
    void UpdateAllAttributeValues(<#=FOM.NativeTimeType#> time) override;
    void UpdateModifiedAttributeValues() override;
    void UpdateModifiedAttributeValues(<#=FOM.NativeTimeType#> time) override;
    void RequestAttributeValues() override;
    void RequestAllAttributeValues() override;
<# if (objectClass.ChildClasses.Count == 0) { #>
    uint32_t RegisterUpdateCallback(UpdateCallback callback) override;
    void UnregisterUpdateCallback(uint32_t callbackToken) override;
<# } // if (objectClass.ChildClasses.Count == 0) #>
<# } // if (objectClass.HasValidAttributes) #>

<# if (objectClass.HasValidAttributes) { #>
    // bitmask of attributes ever received
    AttributeBits GetReceivedAttributes() const override;
    // bitmask of attributes received in last update (cleared after update callbacks executed)
    AttributeBits GetUpdatedAttributes() const override;
    // bitmask of attributes ever modified
    AttributeBits GetInitializedAttributes() const override;
    // bitmask of attributes modified since last updateAttributeValues/provideAttributeValues
    AttributeBits GetModifiedAttributes() const override;
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes);
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType);
    void ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributes);
<# } #>
  protected:
    friend class <#=objectClass.Name#>ObjectClass;

    <#=objectClass.Name#>();
    <#=objectClass.Name#>(<#=objectClass.Name#>ObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* ambassador);

<# if (objectClass.HasValidAttributes && objectClass.ChildClasses.Count == 0) { #>
    void ExecuteUpdateCallbacks(optional<<#=FOM.NativeTimeType#>> time, optional<OrderType> orderType);
<# } #>

    // get attribute handle/value map of all attributes
    rti1516ev::AttributeHandleValueMap GetAllAttributeValues() const;
    // get attribute handle/value map of attributes which have been modified since last call to UpdateModifiedAttributeValues
    rti1516ev::AttributeHandleValueMap GetModifiedAttributeValues() const;

    rti1516ev::RTIambassador* mRtiAmbassador;
    // this mutex guards all of the fields below
    mutable std::recursive_mutex mMutex;

    <#=objectClass.Name#>ObjectClass* mObjectClass;
    std::wstring mObjectInstanceName;
    rti1516ev::ObjectInstanceHandle mObjectInstanceHandle;
    bool mIsOwner = false;
<# if (objectClass.HasValidAttributes) { #>
    // modified by any ReflectAttributeValues in the past
    AttributeBits mValuesReceived = kNone;
    // modified by any attribute setter
    AttributeBits mValuesSet = kNone;
    // modified by last ReflectAttributeValues
    AttributeBits mLastUpdated = kNone;
    // to be sent with next UpdateModifiedAttributeValues
    AttributeBits mDirty = kNone;
<# } #>
<# if (objectClass.HasValidAttributes && objectClass.ChildClasses.Count == 0) { #>
    mutable std::mutex mCallbackListMutex;
    std::map<uint32_t, UpdateCallback> mUpdateCallbacks;
    uint32_t mLastCallbackToken = 0;
<# } #>
    // Attribute value encoders
<# 
  foreach (var attribute in objectClass.AllAttributes)
  {
    if (attribute.DataType != null)
    {
#>    // attribute <#=attribute.Name#> : <#=attribute.DataType.Name#>
    <#=attribute.DataType.Encoding#> m<#=attribute.Name#>;
<#  } else {
#>    // attribute <#=attribute.Name#> : no data type
<#  
    } // if (attribute.DataType != null)
  } // foreach (var attribute in objectClass.Attributes)
#>
};

<# } // foreach (var objectClass in FOM.ObjectClasses) #> 

class ObjectClassRegistry : public IObjectClassRegistry
{
  public:
    ObjectClassRegistry();
    ~ObjectClassRegistry();
    void Initialize(rti1516ev::RTIambassador* rtiAmbassador);
    void Finalize();

<# foreach (var objectClass in FOM.ObjectClasses) { #>
    I<#=objectClass.Name#>ObjectClass* Get<#=objectClass.Name#>ObjectClass() const override { return m<#=objectClass.Name#>ObjectClass.get(); }
<# } #>

    void DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    void ReflectAttributeValues(rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes);
    void ReflectAttributeValues(rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType);
    void ProvideAttributeValues(rti1516ev::ObjectClassHandle theObjectClass, rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleSet& attributeHandles);
    void ObjectInstanceNameReservationSucceeded(std::wstring const & theObjectInstanceName);
    void ObjectInstanceNameReservationFailed(std::wstring const & theObjectInstanceName);
    void RegisterObjectInstanceName(const std::wstring& theObjectInstanceName, std::function<void(bool)> completionCallback);

  private:
    std::map<std::wstring, std::function<void(bool)> > mObjectInstanceNameReservationCallbacks;
    rti1516ev::RTIambassador* mRtiAmbassador;
<# foreach (var objectClass in FOM.ObjectClasses) { #>
    std::unique_ptr<<#=objectClass.Name#>ObjectClass> m<#=objectClass.Name#>ObjectClass;
<# } #>
}; // class ObjectClassRegistry

<#
foreach (var namespacePart in FOM.Namespace)
{
#>
} // namespace <#=namespacePart#>
<#  } #>
