<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>

// Code automatically generated by T4 template from <#=System.IO.Path.GetFileName(FOM.Filename)#>, do not edit
#pragma once

#include <vector>
#include "RTI/Handle.h"
#include "RTI/RTIambassador.h"
#include "RTI/encoding/BasicDataElements.h"
#include "RTI/encoding/HLAfixedRecord.h"
#include "RTI/encoding/HLAfixedArray.h"
#include "RTI/encoding/HLAvariableArray.h"

<#=FOM.GetPredefinedTypeIncludes(FOMParser.FileContext.kObjectHeader)#>
#include "<#=ObjectInterfacesHeaderFilename#>"
#include "<#=EncodingHeaderFilename#>"

<#
foreach (var namespacePart in FOM.Namespace)
{
#>
namespace <#=namespacePart#> {
<# } #>

<# 
foreach (var objectClass in FOM.ObjectClasses)
{
#>
class <#=objectClass.Name#>;
class <#=objectClass.Name#>ObjectClass : public I<#=objectClass.Name#>ObjectClass
{
  public:
    // I<#=objectClass.Name#>ObjectClass
    <#=objectClass.Name#>ObjectClass() = default;
    virtual ~<#=objectClass.Name#>ObjectClass() = default;
    void Publish() override;
    void Unpublish() override;
    void Subscribe() override;
    void Unsubscribe() override;
    I<#=objectClass.Name#>* GetObjectInstance(const std::wstring& instanceName) override;
    I<#=objectClass.Name#>* CreateObjectInstance(const std::wstring& instanceName) override;
    uint32_t RegisterDiscoverCallback(DiscoverCallbackType callback) override;
    void UnregisterDiscoverCallback(uint32_t callbackToken) override;
    void ExecuteDiscoverCallbacks(I<#=objectClass.Name#>* newObjectInstance);

    // internal
<#
  if (objectClass.BaseClass != null)
  {
#>
    <#=objectClass.Name#>ObjectClass(rti1516ev::RTIambassador* rtiAmbassador, <#=objectClass.BaseClass.Name#>ObjectClass* baseClass);

<# } else {#>
    <#=objectClass.Name#>ObjectClass(rti1516ev::RTIambassador* rtiAmbassador);
<# } #>
<# 
  var baseClass = objectClass.BaseClass;
  while (baseClass != null)
  {
    foreach (var attribute in baseClass.Attributes)
    {
      if (attribute.DataType != null)
      { #>
    // attribute <#=attribute.Name#> : <#=attribute.DataType.Name#>
    rti1516ev::AttributeHandle Get<#=attribute.Name#>AttributeHandle() const { return mBaseClass->Get<#=attribute.Name#>AttributeHandle(); }
<#    } else { #>
    // attribute <#=attribute.Name#> : no data type
<#
      } // if (attribute.DataType != null)
    } // foreach (var attribute in objectClass.Attributes)
    baseClass = baseClass.BaseClass;
  } // while (baseClass != null)
#>
<# 
  foreach (var attribute in objectClass.Attributes)
  {
    if (attribute.DataType != null)
    { #>
    // attribute <#=attribute.Name#> : <#=attribute.DataType.Name#>
    rti1516ev::AttributeHandle Get<#=attribute.Name#>AttributeHandle() const { return m<#=attribute.Name#>AttributeHandle; }
<#  } else { #>
    // attribute <#=attribute.Name#> : no data type
<#  
    } // if (attribute.DataType != null)
  } // foreach (var attribute in objectClass.Attributes)
#>
    void DiscoverObjectInstance (rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    rti1516ev::ObjectClassHandle GetObjectClassHandle() const { return mObjectClassHandle; }
    I<#=objectClass.Name#>* GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle);
    rti1516ev::AttributeHandleSet GetAllAttributeHandles();
  private:
    rti1516ev::RTIambassador* mRtiAmbassador;
    // object class handle
    rti1516ev::ObjectClassHandle mObjectClassHandle;
<# if (objectClass.BaseClass != null) { #>
    <#=objectClass.BaseClass.Name#>ObjectClass* mBaseClass;
<# } #>
    bool mPublished = false;
    bool mSubscribed = false;
    // Attribute handles
<# 
  foreach (var attribute in objectClass.Attributes)
  {
    if (attribute.DataType != null)
    {
#>    // attribute <#=attribute.Name#> : <#=attribute.DataType.Name#>
    rti1516ev::AttributeHandle m<#=attribute.Name#>AttributeHandle;
<#  } else {
#>    // attribute <#=attribute.Name#> : no data type
<#  
    } // if (attribute.DataType != null)
  } // foreach (var attribute in objectClass.Attributes)
#>
    std::map<std::wstring, <#=objectClass.Name#>*> mObjectInstancesByName;
    std::map<rti1516ev::ObjectInstanceHandle, <#=objectClass.Name#>*> mObjectInstancesByHandle;

    std::map<uint32_t, DiscoverCallbackType> mDiscoverCallbacks;
    uint32_t mLastCallbackToken = 0;
};

class <#=objectClass.Name#> : public I<#=objectClass.Name#>
{
  public:

    virtual ~<#=objectClass.Name#>();
    <#=objectClass.Name#>(const <#=objectClass.Name#>&) = delete;
    <#=objectClass.Name#>(<#=objectClass.Name#>&&) = delete;
    <#=objectClass.Name#>& operator=(const <#=objectClass.Name#>&) = delete;
    <#=objectClass.Name#>& operator=(<#=objectClass.Name#>&&) = delete;
    I<#=objectClass.Name#>ObjectClass* GetObjectClass() const { return mObjectClass; }
    std::wstring GetObjectInstanceName() const override { return mInstanceName; }
    rti1516ev::ObjectInstanceHandle GetObjectInstanceHandle() const { return mObjectInstanceHandle; }
<#
  foreach (var attribute in objectClass.AllAttributes)
  {
    if (attribute.DataType != null)
    {
#>    // attribute <#=attribute.Name#> : <#=attribute.DataType.Name#>
    <#=attribute.DataType.ReturnCppType#> Get<#=attribute.Name#>() const override;
    void Set<#=attribute.Name#>(<#=attribute.DataType.ParameterCppType#> newValue) override;
<#  } else { #>
    // attribute <#=attribute.Name#> : no data type
<#
    } // if (attribute.DataType != null)
  } // foreach (var attribute in objectClass.AllAttributes)
#>
    // I<#=objectClass.Name#>
<# if (objectClass.HasValidAttributes) { #>
    void UpdateAllAttributeValues() override;
    void UpdateAllAttributeValues(const rti1516ev::LogicalTime& time) override;
    void UpdateModifiedAttributeValues() override;
    void UpdateModifiedAttributeValues(const rti1516ev::LogicalTime& time) override;
    AttributeBits GetUpdatedAttributes() const override { return mLastUpdated; }
    void RequestAttributeValues() override;
    void RequestAllAttributeValues() override;
<# if (objectClass.ChildClasses.Count == 0) { #>
    uint32_t RegisterUpdateCallback(UpdateCallbackType callback) override;
    void UnregisterUpdateCallback(uint32_t callbackToken) override;
<# } // if (objectClass.ChildClasses.Count == 0) #>
<# } // if (objectClass.HasValidAttributes) #>

    // get attribute handle/value map of all attributes
    rti1516ev::AttributeHandleValueMap GetAllAttributeValues() const;
    // get attribute handle/value map of attributes which have been modified since last call to UpdateModifiedAttributeValues
    rti1516ev::AttributeHandleValueMap GetModifiedAttributeValues() const;
<# if (objectClass.HasValidAttributes) { #>
    void ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes);
    void ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributes);
<# } #>
    bool IsValid() const { return mObjectInstanceHandle.isValid(); }
    bool IsOwner() const { return mIsOwner; }
  private:
    friend class <#=objectClass.Name#>ObjectClass;

    <#=objectClass.Name#>();
    <#=objectClass.Name#>(<#=objectClass.Name#>ObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* ambassador);

<# if (objectClass.HasValidAttributes && objectClass.ChildClasses.Count == 0) { #>
    void ExecuteUpdateCallbacks();
<# } #>
    <#=objectClass.Name#>ObjectClass* mObjectClass;
    std::wstring mInstanceName;
    rti1516ev::RTIambassador* mRtiAmbassador;
    rti1516ev::ObjectInstanceHandle mObjectInstanceHandle;
    bool mIsOwner = false;
<# if (objectClass.HasValidAttributes) { #>
    // modified by ReflectAttributeValues
    AttributeBits mLastUpdated = kNone;
    // to be sent with next updateAttributes
    AttributeBits mDirty = kNone;
<# } #>
<# if (objectClass.HasValidAttributes && objectClass.ChildClasses.Count == 0) { #>
    std::map<uint32_t, UpdateCallbackType> mUpdateCallbacks;
    uint32_t mLastCallbackToken = 0;
<# } #>
    // Attribute value encoders
<# 
  foreach (var attribute in objectClass.AllAttributes)
  {
    if (attribute.DataType != null)
    {
#>    // attribute <#=attribute.Name#> : <#=attribute.DataType.Name#>
    <#=attribute.DataType.Encoding#> m<#=attribute.Name#>;
<#  } else {
#>    // attribute <#=attribute.Name#> : no data type
<#  
    } // if (attribute.DataType != null)
  } // foreach (var attribute in objectClass.Attributes)
#>
};

<# } // foreach (var objectClass in FOM.ObjectClasses) #> 

class ObjectClassRegistry : public IObjectClassRegistry
{
  public:
    ObjectClassRegistry();
    ~ObjectClassRegistry();
    void Initialize(rti1516ev::RTIambassador* rtiAmbassador);
    static ObjectClassRegistry* GetInstance() { return sClassRegistry; }

<# foreach (var objectClass in FOM.ObjectClasses) { #>
    I<#=objectClass.Name#>ObjectClass* Get<#=objectClass.Name#>ObjectClass() const override { return m<#=objectClass.Name#>ObjectClass.get(); }
<# } #>

    void DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName);
    void RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject);
    void ReflectAttributeValues(rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes);
    void ProvideAttributeValues(rti1516ev::ObjectClassHandle theObjectClass, rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleSet& attributeHandles);
    void ObjectInstanceNameReservationSucceeded(std::wstring const & theObjectInstanceName);
    void ObjectInstanceNameReservationFailed(std::wstring const & theObjectInstanceName);
    void RegisterObjectInstanceName(const std::wstring& theObjectInstanceName, std::function<void(bool)> completionCallback);

  private:
    std::map<std::wstring, std::function<void(bool)> > mInstanceNameReservationCallbacks;
    static ObjectClassRegistry* sClassRegistry;
    rti1516ev::RTIambassador* mRtiAmbassador;
<# foreach (var objectClass in FOM.ObjectClasses) { #>
    std::unique_ptr<<#=objectClass.Name#>ObjectClass> m<#=objectClass.Name#>ObjectClass;
<# } #>
}; // class ObjectClassRegistry

<#
foreach (var namespacePart in FOM.Namespace)
{
#>
} // namespace <#=namespacePart#>
<#  } #>
