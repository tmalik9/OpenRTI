<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>

// Code automatically generated by FOMCodeGen version <#=FOM.GeneratorVersion#> from <#=System.IO.Path.GetFileName(FOM.Filename)#>, do not edit
<# if (FOM.UsePrecompiledHeaders) { #>
#include "stdafx.h"
<#}#>

#include <vector>
#include <cassert>
#include "<#=ObjectsHeaderFilename#>"

<#
foreach (var namespacePart in FOM.Namespace)
{
#>
namespace <#=namespacePart#> {
<#  } #>

<# 
foreach (var objectClass in FOM.ObjectClasses)
{
  if (objectClass.BaseClass != null)
  {
#>
// object class type '<#=objectClass.Name#>'
<#=objectClass.Name#>ObjectClass::<#=objectClass.Name#>ObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry, <#=objectClass.BaseClass.Name#>ObjectClass* baseClass)
<# } else {#>
<#=objectClass.Name#>ObjectClass::<#=objectClass.Name#>ObjectClass(rti1516ev::RTIambassador* rtiAmbassador, ObjectClassRegistry* registry)
<# } #>
{
  mRegistry = registry;
  mRtiAmbassador = rtiAmbassador;
<# if (objectClass.BaseClass != null) { #>
  mBaseClass = baseClass;
<# } #>
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"<#=objectClass.QualifiedName#>");
<# 
  foreach (var attribute in objectClass.Attributes)
  {
    if (attribute.DataType != null)
    {
#>  // attribute <#=attribute.Name#> : <#=attribute.DataType.Name#>
  m<#=attribute.Name#>AttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"<#=attribute.Name#>");
<#  } else { #>
// attribute <#=objectClass.Name#>.<#=attribute.Name#> : no data type
<#  
    } // if (attribute.DataType != null)
  } // foreach (var attribute in objectClass.Attributes)
#>
  SetObjectInstanceCreator([](<#=objectClass.Name#>ObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador) -> <#=objectClass.Name#>* {
    return new <#=objectClass.Name#>(objectClass, instanceName, rtiAmbassador);
  });
}

<#=objectClass.Name#>ObjectClass::~<#=objectClass.Name#>ObjectClass()
{
  //std::lock_guard<std::recursive_mutex> lock(mMutex);
  while (!mObjectInstancesByHandle.empty())
  {
    // careful - hold the reference to the object instance until it has been removed from the maps,
    // otherwise it's mutex will be destroyed while held
    auto objectInstance = mObjectInstancesByHandle.begin()->second;
    objectInstance->Release();
  }
  assert(mObjectInstancesByHandle.empty());
  assert(mObjectInstancesByName.empty());
}

void <#=objectClass.Name#>ObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void <#=objectClass.Name#>ObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void <#=objectClass.Name#>ObjectClass::Subscribe(bool deliverToSelf)
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes = GetAllAttributeHandles();
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    if (deliverToSelf) mRtiAmbassador->setObjectClassDeliverToSelf(mObjectClassHandle, true);
    mSubscribed = true;
  }
}

void <#=objectClass.Name#>ObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

rti1516ev::AttributeHandleSet <#=objectClass.Name#>ObjectClass::GetAllAttributeHandles()
{
  rti1516ev::AttributeHandleSet result;
<# 
  foreach (var attribute in objectClass.AllAttributes)
  {
    if (attribute.DataType != null)
    {
#>
  result.insert(Get<#=attribute.Name#>AttributeHandle());
<#  
    } // if (attribute.DataType != null)
  } // foreach (var attribute in objectClass.AllAttributes)
#>
  return result;
}

void <#=objectClass.Name#>ObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  assert(mObjectInstancesByName.find(objectInstanceName) == mObjectInstancesByName.end());
  assert(mObjectInstancesByHandle.find(objectInstanceHandle) == mObjectInstancesByHandle.end());
  std::shared_ptr<<#=objectClass.Name#>> newObject = std::shared_ptr<<#=objectClass.Name#>>(mCreatorFunction(this, objectInstanceName, mRtiAmbassador));
  newObject->mObjectInstanceHandle = objectInstanceHandle;
  newObject->mIsOwner = false;
  InsertObjectInstanceName(newObject, objectInstanceName);
  InsertObjectInstanceHandle(newObject, objectInstanceHandle);
  ExecuteDiscoverObjectInstanceCallbacks(newObject);
}

void <#=objectClass.Name#>ObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  std::wstring objectInstanceName = mRtiAmbassador->getObjectInstanceName(objectInstanceHandle);
  auto iter = mObjectInstancesByName.find(objectInstanceName);
  assert(iter != mObjectInstancesByName.end());
  auto objectInstance = std::dynamic_pointer_cast<<#=objectClass.Name#>>(iter->second);
  ExecuteRemoveObjectInstanceCallbacks(objectInstance);
  objectInstance->mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  EraseObjectInstance(objectInstanceHandle, objectInstanceName);
}

std::shared_ptr<I<#=objectClass.Name#>> <#=objectClass.Name#>ObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
<# if (objectClass.BaseClass != null) { #>
  else
  {
    std::shared_ptr<I<#=objectClass.BaseClass.Name#>> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceName);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<I<#=objectClass.Name#>>(baseClassObjectInterface);
    }
  }
<# } #>
  return nullptr;
}

std::shared_ptr<I<#=objectClass.Name#>> <#=objectClass.Name#>ObjectClass::GetObjectInstance(rti1516ev::ObjectInstanceHandle instanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByHandle.find(instanceHandle);
  if (iter != mObjectInstancesByHandle.end())
  {
    return iter->second;
  }
<# if (objectClass.BaseClass != null) { #>
  else
  {
    std::shared_ptr<I<#=objectClass.BaseClass.Name#>> baseClassObjectInterface = mBaseClass->GetObjectInstance(instanceHandle);
    if (baseClassObjectInterface != nullptr)
    {
      return std::dynamic_pointer_cast<I<#=objectClass.Name#>>(baseClassObjectInterface);
    }
  }
<# } #>
  return nullptr;
}

std::shared_ptr<I<#=objectClass.Name#>> <#=objectClass.Name#>ObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"<#=objectClass.Name#>");
  }
  std::shared_ptr<<#=objectClass.Name#>> newObject = std::shared_ptr<<#=objectClass.Name#>>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
    }
  });
  return newObject;
}

std::shared_ptr<I<#=objectClass.Name#>> <#=objectClass.Name#>ObjectClass::CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"<#=objectClass.Name#>");
  }
  std::shared_ptr<<#=objectClass.Name#>> newObject = std::shared_ptr<<#=objectClass.Name#>>(mCreatorFunction(this, instanceName, mRtiAmbassador));
  InsertObjectInstanceName(newObject, instanceName);
  mRegistry->RegisterObjectInstanceName(instanceName, [this, newObject, instanceName, createdCallback](bool success) {
    if (success) {
      std::lock_guard<std::recursive_mutex> lock(mMutex);
      rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
      newObject->mObjectInstanceHandle = instanceHandle;
      newObject->mIsOwner = true;
      InsertObjectInstanceHandle(newObject, instanceHandle);
      createdCallback(newObject, true);
    }
    else
    {
      createdCallback(newObject, false);
    }
  });
  return newObject;
}

uint32_t <#=objectClass.Name#>ObjectClass::RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastDiscoverObjectInstanceCallbackToken++;
  mDiscoverCallbacks.insert(std::make_pair(mLastDiscoverObjectInstanceCallbackToken, callback));
  return mLastDiscoverObjectInstanceCallbackToken;
}

void <#=objectClass.Name#>ObjectClass::UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mDiscoverCallbacks.erase(callbackToken);
}

void <#=objectClass.Name#>ObjectClass::ExecuteDiscoverObjectInstanceCallbacks(std::shared_ptr<I<#=objectClass.Name#>> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mDiscoverCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

uint32_t <#=objectClass.Name#>ObjectClass::RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mLastRemoveObjectInstanceCallbackToken++;
  mRemoveObjectInstanceCallbacks.insert(std::make_pair(mLastRemoveObjectInstanceCallbackToken, callback));
  return mLastRemoveObjectInstanceCallbackToken;
}

void <#=objectClass.Name#>ObjectClass::UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  mRemoveObjectInstanceCallbacks.erase(callbackToken);
}

void <#=objectClass.Name#>ObjectClass::ExecuteRemoveObjectInstanceCallbacks(std::shared_ptr<I<#=objectClass.Name#>> newObjectInstance)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mRemoveObjectInstanceCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(newObjectInstance);
  }
}

void <#=objectClass.Name#>ObjectClass::InsertObjectInstanceName(std::shared_ptr<I<#=objectClass.Name#>> objectInstance, const std::wstring& objectInstanceName)
{
  // prerequisite: mMutex must be locked
  mObjectInstancesByName.insert(std::make_pair(objectInstanceName, objectInstance));
<# if (objectClass.BaseClass != null) { #>
  mBaseClass->InsertObjectInstanceName(objectInstance, objectInstanceName);
<# } #>
}

void <#=objectClass.Name#>ObjectClass::InsertObjectInstanceHandle(std::shared_ptr<I<#=objectClass.Name#>> objectInstance, rti1516ev::ObjectInstanceHandle objectInstanceHandle)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mObjectInstancesByHandle.insert(std::make_pair(objectInstanceHandle, objectInstance));
<# if (objectClass.BaseClass != null) { #>
  mBaseClass->InsertObjectInstanceHandle(objectInstance, objectInstanceHandle);
<# } #>
}

void <#=objectClass.Name#>ObjectClass::EraseObjectInstance(rti1516ev::ObjectInstanceHandle objectInstanceHandle, const std::wstring& objectInstanceName)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
<# if (objectClass.BaseClass != null) { #>
  mBaseClass->EraseObjectInstance(objectInstanceHandle, objectInstanceName);
<# } #>
  mObjectInstancesByName.erase(objectInstanceName);
  mObjectInstancesByHandle.erase(objectInstanceHandle);
}


// object instances of type '<#=objectClass.Name#>'
<#=objectClass.Name#>::<#=objectClass.Name#>()
  : mRtiAmbassador()
  , mObjectClass()
  , mObjectInstanceName()
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

<#=objectClass.Name#>::<#=objectClass.Name#>(<#=objectClass.Name#>ObjectClass* objectClass, const std::wstring& instanceName, rti1516ev::RTIambassador* rtiAmbassador)
  : mRtiAmbassador(rtiAmbassador)
  , mObjectClass(objectClass)
  , mObjectInstanceName(instanceName)
  , mObjectInstanceHandle()
  , mIsOwner(false)
{
}

<#=objectClass.Name#>::~<#=objectClass.Name#>()
{
  if (mObjectInstanceHandle.isValid() && mIsOwner)
  {
    try
    {
      mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
    }
    catch (const rti1516ev::NotConnected&)
    {
    }
    catch (const rti1516ev::FederateNotExecutionMember&)
    {
    }
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
    mIsOwner = false;
  }
}

bool <#=objectClass.Name#>::IsValid() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mObjectInstanceHandle.isValid();
}

bool <#=objectClass.Name#>::IsOwner() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mIsOwner;
}

void <#=objectClass.Name#>::Release()
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  if (mObjectInstanceHandle.isValid())
  {
    if (mIsOwner)
    {
      try
      {
        mRtiAmbassador->deleteObjectInstance(mObjectInstanceHandle, rti1516ev::VariableLengthData());
      }
      catch (const rti1516ev::NotConnected&)
      {
      }
      catch (const rti1516ev::FederateNotExecutionMember&)
      {
      }
      mIsOwner = false;
    }
    mObjectClass->EraseObjectInstance(mObjectInstanceHandle, mObjectInstanceName);
    mObjectInstanceHandle = rti1516ev::ObjectInstanceHandle();
  }
}

<# 
  foreach (var attribute in objectClass.AllAttributes)
  {
    if (attribute.DataType != null)
    {
#>// attribute <#=attribute.Name#> : <#=attribute.DataType.Name#>
<#=attribute.DataType.ReturnCppType#> <#=objectClass.Name#>::Get<#=attribute.Name#>() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return <#=attribute.DataType.CppGetter("m" + attribute.Name)#>;
}
<#    if (attribute.DataType is FOMParser.FixedRecordDataType) { #>

<#=attribute.DataType.ModifiableReturnCppType#> <#=objectClass.Name#>::Get<#=attribute.Name#>()
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mDirty |= k<#=attribute.Name#>Bit;
  mValuesSet |= k<#=attribute.Name#>Bit;
  return <#=attribute.DataType.CppGetter("m" + attribute.Name)#>;
}
<#    } #>

void <#=objectClass.Name#>::Set<#=attribute.Name#>(<#=attribute.DataType.ParameterCppType#> newValue)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  // CanTranslateToCpp=<#= attribute.DataType.CanTranslateToCpp #>
  <#=attribute.DataType.CppSetter("m" + attribute.Name, "newValue")#>;
  mDirty |= k<#=attribute.Name#>Bit;
  mValuesSet |= k<#=attribute.Name#>Bit;
}

<#  } else { #>
// attribute <#=objectClass.Name#>.<#=attribute.Name#> : no data type

<#  
    } // if (attribute.DataType != null)
  } // foreach (var attribute in objectClass.AllAttributes)
#>
rti1516ev::AttributeHandleValueMap <#=objectClass.Name#>::GetAllAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
<#
  foreach (var attribute in objectClass.AllAttributes)
  {
    if (attribute.DataType != null)
    {
#>
  result[mObjectClass->Get<#=attribute.Name#>AttributeHandle()] = m<#=attribute.Name#>.encode();
<#
    } // if
  } // foreach
#>
  return result;
}

rti1516ev::AttributeHandleValueMap <#=objectClass.Name#>::GetModifiedAttributeValues() const
{
  rti1516ev::AttributeHandleValueMap result;
<#
  foreach (var attribute in objectClass.AllAttributes)
  {
    if (attribute.DataType != null)
    {
#>
  if (mDirty & k<#=attribute.Name#>Bit)
  {
    result[mObjectClass->Get<#=attribute.Name#>AttributeHandle()] = m<#=attribute.Name#>.encode();
  }
<#
    } // if
  } // foreach
#>
  return result;
}

<# if (objectClass.HasValidAttributes) { #>
<#=objectClass.Name#>::AttributeBits <#=objectClass.Name#>::GetReceivedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesReceived;
}

<#=objectClass.Name#>::AttributeBits <#=objectClass.Name#>::GetUpdatedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mLastUpdated;
}

<#=objectClass.Name#>::AttributeBits <#=objectClass.Name#>::GetInitializedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mValuesSet;
}

<#=objectClass.Name#>::AttributeBits <#=objectClass.Name#>::GetModifiedAttributes() const
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  return mDirty;
}

void <#=objectClass.Name#>::UpdateAllAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
  }
}

void <#=objectClass.Name#>::UpdateAllAttributeValues(<#=FOM.NativeTimeType#> time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetAllAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), <#=FOM.LogicalTimeType#>(time));
  }
}

void <#=objectClass.Name#>::UpdateModifiedAttributeValues()
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData());
    mDirty = kNone;
  }
}

void <#=objectClass.Name#>::UpdateModifiedAttributeValues(<#=FOM.NativeTimeType#> time)
{
  if (mObjectInstanceHandle.isValid())
  {
    rti1516ev::AttributeHandleValueMap attributes = GetModifiedAttributeValues();
    mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, attributes, rti1516ev::VariableLengthData(), <#=FOM.LogicalTimeType#>(time));
    mDirty = kNone;
  }
}

void <#=objectClass.Name#>::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
<#
  {
  bool firstInObjectInstanceReflectAttributeValues = true;
  foreach (var attribute in objectClass.AllAttributes)
  {
    if (attribute.DataType != null)
    {
#>
<# if (firstInObjectInstanceReflectAttributeValues)  {#>
    if (attributeHandle == mObjectClass->Get<#=attribute.Name#>AttributeHandle())
<# } else { #>
    else if (attributeHandle == mObjectClass->Get<#=attribute.Name#>AttributeHandle())
<# } #>
    {
      m<#=attribute.Name#>.decode(attributeHandleValue.second);
      mLastUpdated |= k<#=attribute.Name#>Bit;
    }
<#
      firstInObjectInstanceReflectAttributeValues = false;
    } // if
  } // foreach
  }
#>
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
<# if (objectClass.HasValidAttributes && objectClass.ChildClasses.Count == 0) { #>
  ExecuteUpdateCallbacks(optional<<#=FOM.NativeTimeType#>>(), optional<OrderType>());
<# } #>
  mLastUpdated = kNone;
} // <#=objectClass.Name#>::ReflectAttributeValues

void <#=objectClass.Name#>::ReflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes, const rti1516ev::LogicalTime& <#= (objectClass.HasValidAttributes && objectClass.ChildClasses.Count == 0) ? "theTime" : "/* theTime */" #>, OrderType <#= (objectClass.HasValidAttributes && objectClass.ChildClasses.Count == 0) ? "orderType" : "/* orderType */"#>)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
<#
  {
  bool firstInObjectInstanceReflectAttributeValues = true;
  foreach (var attribute in objectClass.AllAttributes)
  {
    if (attribute.DataType != null)
    {
#>
<# if (firstInObjectInstanceReflectAttributeValues)  {#>
    if (attributeHandle == mObjectClass->Get<#=attribute.Name#>AttributeHandle())
<# } else { #>
    else if (attributeHandle == mObjectClass->Get<#=attribute.Name#>AttributeHandle())
<# } #>
    {
      m<#=attribute.Name#>.decode(attributeHandleValue.second);
      mLastUpdated |= k<#=attribute.Name#>Bit;
    }
<#
      firstInObjectInstanceReflectAttributeValues = false;
    } // if
  } // foreach
  }
#>
  } // for (auto& attributeHandleValue : attributes)
  mValuesReceived |= mLastUpdated;
<# if (objectClass.HasValidAttributes && objectClass.ChildClasses.Count == 0) { #>
  ExecuteUpdateCallbacks(static_cast<const <#=FOM.LogicalTimeType#>&>(theTime).getTime(), orderType);
<# } #>
  mLastUpdated = kNone;
} // <#=objectClass.Name#>::ReflectAttributeValues

// request attributes not being part of the last update
void <#=objectClass.Name#>::RequestAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
<#
  foreach (var attribute in objectClass.AllAttributes)
  {
    if (attribute.DataType != null)
    {
#>
    if ((mLastUpdated & k<#=attribute.Name#>Bit) == 0)
    {
      requestAttributes.insert(mObjectClass->Get<#=attribute.Name#>AttributeHandle());
    }
<#
    } // if
  } // foreach
#>
  } // scope of lock_guard
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// request all attributes, regardless of current state
void <#=objectClass.Name#>::RequestAllAttributeValues()
{
  rti1516ev::AttributeHandleSet requestAttributes;
<#
  foreach (var attribute in objectClass.AllAttributes)
  {
    if (attribute.DataType != null)
    {
#>
  requestAttributes.insert(mObjectClass->Get<#=attribute.Name#>AttributeHandle());
<#
    } // if
  } // foreach
#>
  mRtiAmbassador->requestAttributeValueUpdate(mObjectInstanceHandle, requestAttributes, rti1516ev::VariableLengthData());
}

// provide requested attributes set since last sent update
void <#=objectClass.Name#>::ProvideAttributeValues(const rti1516ev::AttributeHandleSet& attributeHandles)
{
  rti1516ev::AttributeHandleValueMap updateAttributes;
  {
    std::lock_guard<std::recursive_mutex> lock(mMutex);
    for (auto& attributeHandle : attributeHandles)
    {
<#
  {
  bool firstInObjectInstanceProvideAttributeValues = true;
  foreach (var attribute in objectClass.AllAttributes)
  {
    if (attribute.DataType != null)
    {
#>
<# if (firstInObjectInstanceProvideAttributeValues)  {#>
      if (attributeHandle == mObjectClass->Get<#=attribute.Name#>AttributeHandle() && (mValuesSet & k<#=attribute.Name#>Bit) != 0)
<# } else { #>
      else if (attributeHandle == mObjectClass->Get<#=attribute.Name#>AttributeHandle() && (mValuesSet & k<#=attribute.Name#>Bit) != 0)
<# } #>
      {
        updateAttributes.insert(std::make_pair(attributeHandle, m<#=attribute.Name#>.encode()));
        mDirty &= ~k<#=attribute.Name#>Bit;
      }
<#
      firstInObjectInstanceProvideAttributeValues = false;
    } // if
  } // foreach
  }
#>
    } // for (auto& attributeHandleValue : attributes)
  } // scope of lock_guard
  mRtiAmbassador->updateAttributeValues(mObjectInstanceHandle, updateAttributes, rti1516ev::VariableLengthData());
} // <#=objectClass.Name#>::ReflectAttributeValues

<# if (objectClass.ChildClasses.Count == 0) { #>
uint32_t <#=objectClass.Name#>::RegisterUpdateCallback(UpdateCallback callback)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mLastCallbackToken++;
  mUpdateCallbacks.insert(std::make_pair(mLastCallbackToken, callback));
  return mLastCallbackToken;
}

void <#=objectClass.Name#>::UnregisterUpdateCallback(uint32_t callbackToken)
{
  std::lock_guard<std::recursive_mutex> lock(mMutex);
  mUpdateCallbacks.erase(callbackToken);
}

void <#=objectClass.Name#>::ExecuteUpdateCallbacks(optional<<#=FOM.NativeTimeType#>> time, optional<OrderType> orderType)
{
  std::lock_guard<std::mutex> lock(mCallbackListMutex);
  for (auto& callbackEntry : mUpdateCallbacks)
  {
    auto& callback = callbackEntry.second;
    callback(std::static_pointer_cast<I<#=objectClass.Name#>>(shared_from_this()), time, orderType);
  }
}

<# } // if (objectClass.ChildClasses.Count == 0) #>
<# } // if (objectClass.HasValidAttributes) #>

<# } // foreach (var objectClass in FOM.ObjectClasses) #> 

ObjectClassRegistry::ObjectClassRegistry()
  : mRtiAmbassador(nullptr)
{
}

ObjectClassRegistry::~ObjectClassRegistry()
{
}

void ObjectClassRegistry::Initialize(rti1516ev::RTIambassador* rtiAmbassador)
{
  mRtiAmbassador = rtiAmbassador;
<# foreach (var objectClass in FOM.ObjectClasses) { #>
  try
  {
<#   if (objectClass.BaseClass != null) { #>
    assert(m<#=objectClass.BaseClass.Name#>ObjectClass.get() != nullptr);
    m<#=objectClass.Name#>ObjectClass = std::unique_ptr<<#=objectClass.Name#>ObjectClass>(new <#=objectClass.Name#>ObjectClass(mRtiAmbassador, this, m<#=objectClass.BaseClass.Name#>ObjectClass.get()));
<#   } else { #>
    m<#=objectClass.Name#>ObjectClass = std::unique_ptr<<#=objectClass.Name#>ObjectClass>(new <#=objectClass.Name#>ObjectClass(mRtiAmbassador, this));
<#   } // if #>
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
<# } // foreach #>
} // Initialize

void ObjectClassRegistry::Finalize()
{
<# foreach (var objectClass in FOM.ReverseObjectClasses) { #>
  m<#=objectClass.Name#>ObjectClass.reset();
<# } // foreach #>
  mRtiAmbassador = nullptr;
} // Initialize

void ObjectClassRegistry::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle theObject, std::wstring const & theObjectInstanceName)
{
  rti1516ev::ObjectClassHandle theObjectClass = mRtiAmbassador->getKnownObjectClassHandle(theObject);
<# 
  bool first = true;
  foreach (var objectClass in FOM.ObjectClasses)
  {
#>
<#  if (first) { #>
  if (m<#=objectClass.Name#>ObjectClass != nullptr && theObjectClass == m<#=objectClass.Name#>ObjectClass->GetObjectClassHandle())
<# } else { #>
  else if (m<#=objectClass.Name#>ObjectClass != nullptr && theObjectClass == m<#=objectClass.Name#>ObjectClass->GetObjectClassHandle())
<# } // if
   first=false;
#>
  {
    m<#=objectClass.Name#>ObjectClass->DiscoverObjectInstance(theObject, theObjectInstanceName);
  }
<# } // foreach #>
}

void ObjectClassRegistry::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject)
{
  rti1516ev::ObjectClassHandle theObjectClass = mRtiAmbassador->getKnownObjectClassHandle(theObject);
<# 
  bool firstInRemoveObjectInstance = true;
  foreach (var objectClass in FOM.ObjectClasses)
  {
#>
<#  if (firstInRemoveObjectInstance) { #>
  if (m<#=objectClass.Name#>ObjectClass != nullptr && theObjectClass == m<#=objectClass.Name#>ObjectClass->GetObjectClassHandle())
<# } else { #>
  else if (m<#=objectClass.Name#>ObjectClass != nullptr && theObjectClass == m<#=objectClass.Name#>ObjectClass->GetObjectClassHandle())
<# } // if
   firstInRemoveObjectInstance=false;
#>
  {
    m<#=objectClass.Name#>ObjectClass->RemoveObjectInstance(theObject);
  }
<# } // foreach #>
}

void ObjectClassRegistry::ReflectAttributeValues(rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes)
{
  rti1516ev::ObjectClassHandle theObjectClass = mRtiAmbassador->getKnownObjectClassHandle(theObject);
<# 
  bool firstInClassRegistryReflectAttributeValues = true;
  foreach (var objectClass in FOM.ObjectClasses)
  {
    if (objectClass.HasValidAttributes)
    { 
      if (firstInClassRegistryReflectAttributeValues) { #>
  if (m<#=objectClass.Name#>ObjectClass != nullptr && theObjectClass == m<#=objectClass.Name#>ObjectClass->GetObjectClassHandle())
<#    } else { #>
  else if (m<#=objectClass.Name#>ObjectClass != nullptr && theObjectClass == m<#=objectClass.Name#>ObjectClass->GetObjectClassHandle())
<#    } // if
      firstInClassRegistryReflectAttributeValues = false; #>
  {
    std::static_pointer_cast<<#=objectClass.Name#>>(m<#=objectClass.Name#>ObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes);
  }
<#  
    } // if (objectClass.hasValidAttributes)
} // foreach 
#>
}

void ObjectClassRegistry::ReflectAttributeValues(rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleValueMap & attributes, const rti1516ev::LogicalTime& theTime, OrderType orderType)
{
  rti1516ev::ObjectClassHandle theObjectClass = mRtiAmbassador->getKnownObjectClassHandle(theObject);
<# 
  bool firstInClassRegistryReflectAttributeValuesWithTime = true;
  foreach (var objectClass in FOM.ObjectClasses)
  {
    if (objectClass.HasValidAttributes)
    { 
      if (firstInClassRegistryReflectAttributeValuesWithTime) { #>
  if (m<#=objectClass.Name#>ObjectClass != nullptr && theObjectClass == m<#=objectClass.Name#>ObjectClass->GetObjectClassHandle())
<#    } else { #>
  else if (m<#=objectClass.Name#>ObjectClass != nullptr && theObjectClass == m<#=objectClass.Name#>ObjectClass->GetObjectClassHandle())
<#    } // if
      firstInClassRegistryReflectAttributeValuesWithTime = false; #>
  {
    std::static_pointer_cast<<#=objectClass.Name#>>(m<#=objectClass.Name#>ObjectClass->GetObjectInstance(theObject))->ReflectAttributeValues(attributes, theTime, orderType);
  }
<#  
    } // if (objectClass.hasValidAttributes)
} // foreach 
#>
}

void ObjectClassRegistry::ProvideAttributeValues(rti1516ev::ObjectClassHandle theObjectClass, rti1516ev::ObjectInstanceHandle theObject, const rti1516ev::AttributeHandleSet& attributeHandles)
{
<# 
  bool firstInClassRegistryProvideAttributeValues = true;
  foreach (var objectClass in FOM.ObjectClasses)
  {
    if (objectClass.HasValidAttributes)
    { 
      if (firstInClassRegistryProvideAttributeValues) { #>
  if (m<#=objectClass.Name#>ObjectClass != nullptr && theObjectClass == m<#=objectClass.Name#>ObjectClass->GetObjectClassHandle())
<#    } else { #>
  else if (m<#=objectClass.Name#>ObjectClass != nullptr && theObjectClass == m<#=objectClass.Name#>ObjectClass->GetObjectClassHandle())
<#    } // if
      firstInClassRegistryProvideAttributeValues = false; #>
  {
    auto objectInstance = std::static_pointer_cast<<#=objectClass.Name#>>(m<#=objectClass.Name#>ObjectClass->GetObjectInstance(theObject));
    if (objectInstance != nullptr)
    {
      objectInstance->ProvideAttributeValues(attributeHandles);
    }
  }
<#  
    } // if (objectClass.hasValidAttributes)
} // foreach 
#>
}

void ObjectClassRegistry::RegisterObjectInstanceName(const std::wstring& theObjectInstanceName, std::function<void(bool)> completionCallback)
{
  mObjectInstanceNameReservationCallbacks.insert(std::make_pair(theObjectInstanceName, completionCallback));
  mRtiAmbassador->reserveObjectInstanceName(theObjectInstanceName);
}

void ObjectClassRegistry::ObjectInstanceNameReservationSucceeded(const std::wstring& theObjectInstanceName)
{
  auto iter = mObjectInstanceNameReservationCallbacks.find(theObjectInstanceName);
  if (iter != mObjectInstanceNameReservationCallbacks.end())
  {
    iter->second(true);
    mObjectInstanceNameReservationCallbacks.erase(iter);
  }
}

void ObjectClassRegistry::ObjectInstanceNameReservationFailed(const std::wstring& theObjectInstanceName)
{
  auto iter = mObjectInstanceNameReservationCallbacks.find(theObjectInstanceName);
  if (iter != mObjectInstanceNameReservationCallbacks.end())
  {
    iter->second(false);
    mObjectInstanceNameReservationCallbacks.erase(iter);
  }
}

<# foreach (var namespacePart in FOM.Namespace) { #>
} // namespace <#=namespacePart#>
<# } #>
