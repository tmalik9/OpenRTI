<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>

// Code automatically generated by T4 template from <#=FOM.Filename#>, do not edit
<# if (FOM.UsePrecompiledHeaders) { #>
#include "stdafx.h"
<#}#>

#include <vector>
#include <cassert>

<#=FOM.PredefinedTypeIncludes#>

#include "<#=ObjectsHeaderFilename#>"

<#
foreach (var namespacePart in FOM.Namespace)
{
#>
namespace <#=namespacePart#> {
<#  } #>
<# 
foreach (var objectClass in FOM.ObjectClasses)
{
  if (objectClass.BaseClass != null)
  {
#>
// object class type '<#=objectClass.Name#>'
<#=objectClass.Name#>ObjectClass::<#=objectClass.Name#>ObjectClass(rti1516ev::RTIambassador* rtiAmbassador, <#=objectClass.BaseClass.Name#>ObjectClass* baseClass)
<# } else {#>
<#=objectClass.Name#>ObjectClass::<#=objectClass.Name#>ObjectClass(rti1516ev::RTIambassador* rtiAmbassador)
<# } #>
{
  mRtiAmbassador = rtiAmbassador;
<# if (objectClass.BaseClass != null) { #>
  mBaseClass = baseClass;
<# } #>
  mObjectClassHandle = rtiAmbassador->getObjectClassHandle(L"<#=objectClass.QualifiedName#>");
<# 
  foreach (var attribute in objectClass.Attributes)
  {
    if (attribute.DataType != null)
    {
#>  // attribute <#=attribute.Name#> : <#=attribute.DataType.Name#>
  m<#=attribute.Name#>AttributeHandle = rtiAmbassador->getAttributeHandle(mObjectClassHandle, L"<#=attribute.Name#>");
<#  } else { #>
// attribute <#=objectClass.Name#>.<#=attribute.Name#> : no data type
<#  
    } // if (attribute.DataType != null)
  } // foreach (var attribute in objectClass.Attributes)
#>
}

void <#=objectClass.Name#>ObjectClass::Publish()
{
  if (!mPublished)
  {
    rti1516ev::AttributeHandleSet attributes;
    mRtiAmbassador->publishObjectClassAttributes(mObjectClassHandle, attributes);
    mPublished = true;
  }
}

void <#=objectClass.Name#>ObjectClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishObjectClass(mObjectClassHandle);
    mPublished = false;
  }
}

void <#=objectClass.Name#>ObjectClass::Subscribe()
{
  if (!mSubscribed)
  {
    rti1516ev::AttributeHandleSet attributes;
    mRtiAmbassador->subscribeObjectClassAttributes(mObjectClassHandle, attributes);
    mSubscribed = true;
  }
}

void <#=objectClass.Name#>ObjectClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeObjectClass(mObjectClassHandle);
    mSubscribed = false;
  }
}

void <#=objectClass.Name#>ObjectClass::DiscoverObjectInstance(rti1516ev::ObjectInstanceHandle theObject, const std::wstring& theObjectInstanceName)
{
  auto iter = mObjectInstancesByName.find(theObjectInstanceName);
  assert(iter == mObjectInstancesByName.end());
  <#=objectClass.Name#>* newObject = new <#=objectClass.Name#>(mRtiAmbassador, theObjectInstanceName, theObject);
  mObjectInstancesByName.insert(std::make_pair(theObjectInstanceName, newObject));
}

void <#=objectClass.Name#>ObjectClass::RemoveObjectInstance(rti1516ev::ObjectInstanceHandle theObject)
{
  std::wstring instanceName = mRtiAmbassador->getObjectInstanceName(theObject);
  auto iter = mObjectInstancesByName.find(instanceName);
  assert(iter != mObjectInstancesByName.end());
  mObjectInstancesByName.erase(iter);
}

<#=objectClass.Name#>* <#=objectClass.Name#>ObjectClass::GetObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return iter->second;
  }
  else
  {
    return nullptr;
  }
}

<#=objectClass.Name#>* <#=objectClass.Name#>ObjectClass::CreateObjectInstance(const std::wstring& instanceName)
{
  auto iter = mObjectInstancesByName.find(instanceName);
  if (iter != mObjectInstancesByName.end())
  {
    return nullptr;
  }
  if (!mPublished)
  {
    throw rti1516ev::ObjectClassNotPublished(L"<#=objectClass.Name#>");
  }
  rti1516ev::ObjectInstanceHandle instanceHandle = mRtiAmbassador->registerObjectInstance(mObjectClassHandle, instanceName);
  <#=objectClass.Name#>* newObject = new <#=objectClass.Name#>(mRtiAmbassador, instanceName, instanceHandle);
  mObjectInstancesByName.insert(std::make_pair(instanceName, newObject));
  return newObject;
}

// object instances of type '<#=objectClass.Name#>'
<#=objectClass.Name#>::<#=objectClass.Name#>()
{
}

<#=objectClass.Name#>::<#=objectClass.Name#>(rti1516ev::RTIambassador* rtiAmbassador, const std::wstring& instanceName, rti1516ev::ObjectInstanceHandle instanceHandle)
  : mInstanceName(instanceName)
  , mInstanceHandle(instanceHandle)
  , mRtiAmbassador(rtiAmbassador)
{
}

<#=objectClass.Name#>::~<#=objectClass.Name#>()
{
}

<# 
  foreach (var attribute in objectClass.Attributes)
  {
    if (attribute.DataType != null)
    {
#>// attribute <#=attribute.Name#> : <#=attribute.DataType.Name#>
<#=attribute.DataType.ReturnCppType#> <#=objectClass.Name#>::Get<#=attribute.Name#>() const
{
<# if (attribute.DataType is FOMParser.EnumeratedDataType) { #>
  return static_cast<<#=attribute.DataType.CPPType#>>(m<#=attribute.Name#>.get());
<# } else if (attribute.DataType.CanTranslateToCpp) { #>
  return m<#=attribute.Name#>.get();
<# } else {#>
  return m<#=attribute.Name#>Encoder;
<# } #>
}

void <#=objectClass.Name#>::Set<#=attribute.Name#>(<#=attribute.DataType.CPPType#> newValue)
{
<# if (attribute.DataType.CanTranslateToCpp) { #>
  m<#=attribute.Name#>.set(newValue);
<# } else {#>
  m<#=attribute.Name#>Encoder = newValue;
<# } #>
}

<#  } else { #>
// attribute <#=objectClass.Name#>.<#=attribute.Name#> : no data type

<#  
    } // if (attribute.DataType != null)
  } // foreach (var attribute in objectClass.Attributes)
#>
rti1516ev::AttributeHandleValueMap <#=objectClass.Name#>::getChangedAttributes() const
{
  rti1516ev::AttributeHandleValueMap result;
  
<# if (objectClass.BaseClass != null) { #>
  result = <#=objectClass.BaseClass.Name#>::getChangedAttributes();
<# } #>
<#
  foreach (var attribute in objectClass.Attributes)
  {
    if (attribute.DataType != null)
    {
#>
  if (mDirty & k<#=attribute.Name#>Bit)
  {
    result[mObjectClass->Get<#=attribute.Name#>AttributeHandle()] = m<#=attribute.Name#>.encode();
  }
<#
    } // if
  } // foreach
#>
  return result;
}

<# if (objectClass.HasValidAttributes) { #>
void <#=objectClass.Name#>::reflectAttributeValues(const rti1516ev::AttributeHandleValueMap& attributes)
{
  for (auto& attributeHandleValue : attributes)
  {
    rti1516ev::AttributeHandle attributeHandle = attributeHandleValue.first;
<#
  bool first = true;
  foreach (var attribute in objectClass.Attributes)
  {
    if (attribute.DataType != null)
    {
#>
<# if (first)  {#>
    if (attributeHandle == mObjectClass->Get<#=attribute.Name#>AttributeHandle())
<# } else { #>
    else if (attributeHandle == mObjectClass->Get<#=attribute.Name#>AttributeHandle())
<# } #>
    {
      mLastUpdated |= k<#=attribute.Name#>Bit;
    }
<#
      first = false;
    } // if
  } // foreach
#>
  } // for (auto& attributeHandleValue : attributes)
} // <#=objectClass.Name#>::reflectAttributeValues
<# } #>

<# } // foreach (var objectClass in FOM.ObjectClasses) #> 

void ClassRegistry::Initialize(rti1516ev::RTIambassador* rtiAmbassador)
{
<# 
  foreach (var objectClass in FOM.ObjectClasses)
  {
    if (objectClass.BaseClass != null)
    {
#>
  m<#=objectClass.Name#>ObjectClass = std::unique_ptr<<#=objectClass.Name#>ObjectClass>(new <#=objectClass.Name#>ObjectClass(rtiAmbassador, get<#=objectClass.BaseClass.Name#>ObjectClass()));
<# } else { #>
  m<#=objectClass.Name#>ObjectClass = std::unique_ptr<<#=objectClass.Name#>ObjectClass>(new <#=objectClass.Name#>ObjectClass(rtiAmbassador));
<# } // if #>
<# } // foreach #>
} // Initialize

<# foreach (var namespacePart in FOM.Namespace) { #>
} // namespace <#=namespacePart#>
<# } #>
