<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>

// Code automatically generated from <#=FOM.Filename#>, do not edit

#pragma once

#include <vector>
#include <cstring>

#include "RTI/encoding/BasicDataElements.h"
#include "RTI/encoding/HLAfixedRecord.h"
#include "RTI/encoding/HLAfixedArray.h"
#include "RTI/encoding/HLAvariableArray.h"
<#=FOM.PredefinedTypeIncludes#>

#include "<#=DataTypesHeaderFilename#>"

<# foreach (var namespacePart in FOM.Namespace) { #>
namespace <#=namespacePart#> {
<# } #>

<#=FOM.EncodingForwardDeclarations#>

<#
foreach (var dataType in FOM.DataTypes.Values)
{
  if (dataType is FOMParser.FixedRecordDataType && dataType.Generate)
  {
    var fixedRecordDataType = dataType as FOMParser.FixedRecordDataType;
    if (dataType.Comment != null && dataType.Comment != "")
    {#>
<#=dataType.Comment#>
<#  } #>
class <#=fixedRecordDataType.Encoding#> : public <#=dataType.Name#>, public rti1516e::HLAfixedRecord
{
  public:
    <#=dataType.Name#>Encoding();
    virtual ~<#=dataType.Name#>Encoding();
    uint32_t getVersion() const override;
<# foreach (var field in fixedRecordDataType.AllFields) { #>
    void Set<#=field.Name#>(<#=field.DataType.CPPType#> value) override;
<# if (field.DataType is FOMParser.ArrayDataType) {
     var arrayDataType = field.DataType as FOMParser.ArrayDataType;
#>
    void Set<#=field.Name#>(const <#=arrayDataType.DataType.CPPType#>* value, size_t size) override;
<# } #>
    <#=field.DataType.CPPType#> Get<#=field.Name#>() const override;
    bool Is<#=field.Name#>Available() const override;
<# } // foreach fixedRecordDataType.Fields #>
  private:
<#
    foreach (var field in fixedRecordDataType.AllFields)
    {
#>
    <#=field.DataType.Encoding#> m<#=field.Name#>;
<#
    } // foreach fixedRecordDataType.Fields
#>
}; // class <#=dataType.Name#>Encoding

<#
  } // if (dataType is FOMParser.FixedRecordDataType)
  else if (dataType is FOMParser.FixedArrayDataType && dataType.Generate)
  {
    var fixedArrayDataType = dataType as FOMParser.FixedArrayDataType;
    var elementDataType = fixedArrayDataType.DataType;
    int cardinality = Int32.Parse(fixedArrayDataType.Cardinality);
    if (dataType.Comment != null && dataType.Comment != "")
    {#>
<#=dataType.Comment#>
<#  } #>
<#  if (elementDataType is FOMParser.BasicDataRepresentation || elementDataType is FOMParser.SimpleDataType)
    { // array of simple or basic types: access data by reference/pointer
#>
// fixed array of simple type <#=fixedArrayDataType.DataType.Name#>
class <#=dataType.Name#>Encoding : public rti1516e::HLAfixedArray
{
  public:
    <#=dataType.Name#>Encoding();
<# if (cardinality > 0) {#>
    <#=dataType.Name#>Encoding(<#=fixedArrayDataType.CPPType#> data);
    void set(<#=fixedArrayDataType.CPPType#> data);
    void set(const <#=fixedArrayDataType.DataType.CPPType#>* data, size_t size);
    <#=fixedArrayDataType.CPPType#> get() const;
<#  } #>
  private:
<# if (cardinality > 0) {#>
    std::vector<<#=fixedArrayDataType.DataType.CPPType#>> mData;
    <#=fixedArrayDataType.DataType.Encoding#> mEncoding[<#=fixedArrayDataType.Cardinality#>];
<#  } #>
}; // class <#=dataType.Name#>
<#  } else {  // array of complex type #>
// fixed array of complex type <#=fixedArrayDataType.DataType.Name#>
class <#=dataType.Name#>Encoding : public rti1516e::HLAfixedArray
{
  public:
    <#=dataType.Name#>Encoding()
      : HLAfixedArray(<#=fixedArrayDataType.DataType.Encoding#>(), <#=fixedArrayDataType.Cardinality#>)
    {
<# if (cardinality > 0) {#>
      for (int i=0; i < <#=cardinality#>; i++)
      {
        mEncoding[i] = mData[i];
        setElementPointer(i, &mEncoding[i]);
      }
<#  } #>
    }
<# if (cardinality > 0) {#>
    <#=dataType.Name#>Encoding(<#=fixedArrayDataType.CPPType#> data)
      : HLAfixedArray(<#=fixedArrayDataType.DataType.Encoding#>(), <#=fixedArrayDataType.Cardinality#>)
      , mData(<#=fixedArrayDataType.Cardinality#>)
    {
      set(data.data(), data.size());
      for (int i=0;i<<#=fixedArrayDataType.Cardinality#>;i++)
      {
        mEncoding[i].setDataPointer(&mData[i]);
        setElementPointer(i, &mEncoding[i]);
      }
    }
    void set(<#=fixedArrayDataType.CPPType#> data) {
      set(data.data(), data.size());
    }
    void set(const <#=fixedArrayDataType.DataType.CPPType#>* data, size_t size) 
    {
      if (size <= <#=fixedArrayDataType.Cardinality#>) {
        memcpy(mData.data(), data, size);
      } else {
        memcpy(mData.data(), data, <#=fixedArrayDataType.Cardinality#>);
      }
    }
    <#=fixedArrayDataType.CPPType#> get() const { return mData; }
<#  } #>
  private:
<# if (cardinality > 0) {#>
    std::vector<<#=fixedArrayDataType.DataType.CPPType#>> mData;
    <#=fixedArrayDataType.DataType.Encoding#> mEncoding[<#=fixedArrayDataType.Cardinality#>];
<#  } #>
}; // class <#=dataType.Name#>
<#  } // if (elementDataType is FOMParser.BasicDataRepresentation || elementDataType is FOMParser.SimpleDataType)
  }  // if (dataType is FOMParser.FixedArrayDataType)
  else if (dataType is FOMParser.VariableArrayDataType && dataType.Generate)
  {
    var variableArrayDataType = dataType as FOMParser.VariableArrayDataType;
    var elementDataType = variableArrayDataType.DataType;
    if (dataType.Comment != null && dataType.Comment != "")
    {#>
<#=dataType.Comment#>
<#  } #>
<#  if (elementDataType is FOMParser.BasicDataRepresentation || elementDataType is FOMParser.SimpleDataType)
    { // array of simple or basic types: access data by reference/pointer
#>
// variable array of simple type <#= variableArrayDataType.DataType.Name #>
class <#=dataType.Name#>Encoding : public rti1516e::HLAvariableArray
{
  public:
    <#=dataType.Name#>Encoding();
    <#=dataType.Name#>Encoding(<#=variableArrayDataType.CPPType#> data);
    void set(<#=variableArrayDataType.CPPType#> data);
    void set(const <#=variableArrayDataType.DataType.CPPType#>* data, size_t size);
    <#=variableArrayDataType.CPPType#> get() const;
    void resize(size_t size);
    virtual size_t decodeFrom(const rti1516e::Octet* buffer, size_t bufferSize, size_t index) override;
  private:
    void update();
    std::vector<<#=variableArrayDataType.DataType.CPPType#>> mData;
    std::vector<<#=variableArrayDataType.DataType.Encoding#>> mEncoding;
}; // class <#=dataType.Name#>

<#  } else { #>
// variable array of complex type <#= variableArrayDataType.DataType.Name #>
class <#=dataType.Name#>Encoding : public rti1516e::HLAvariableArray
{
  public:
    <#=dataType.Name#>Encoding();
    <#=dataType.Name#>Encoding(<#=variableArrayDataType.CPPType#> data);
    void set(<#=variableArrayDataType.ConstCppType#> data);
    void set(<#=variableArrayDataType.NonConstCppType#> data);
    void set(const <#=variableArrayDataType.DataType.Encoding#>* data, size_t size);
    void set(<#=variableArrayDataType.DataType.Encoding#>* data, size_t size);
    virtual size_t decodeFrom(const rti1516e::Octet* buffer, size_t bufferSize, size_t index) override;
}; // class <#=dataType.Name#>

<#
    } // if (elementDataType is FOMParser.BasicDataRepresentation || elementDataType is FOMParser.SimpleDataType)
  } // if (dataType is FOMParser.VariableArrayDataType)
} // foreach (var dataType in FOM.DataTypes.Values)
#>
<#
foreach (var namespacePart in FOM.Namespace)
{
#>
} // namespace <#=namespacePart#>
<#  } #>

