<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>

// Code automatically generated by FOMCodeGen version <#=FOM.GeneratorVersion#> from <#=System.IO.Path.GetFileName(FOM.Filename)#>, do not edit

<# if (FOM.ModelIdentification.Name != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Name, "Name: ")#>
<# } #>
<# if (FOM.ModelIdentification.Copyright != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Copyright, "Copyright: ")#>
<# } #>
<# if (FOM.ModelIdentification.Version != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Version, "Version: ")#>
<# } #>
<# if (FOM.ModelIdentification.Description != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Description, "Description: ")#>
<# } #>
<# if (FOM.ModelIdentification.Purpose != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Purpose, "Purpose: ")#>
<# } #>

#pragma once

#include <vector>
#include <ostream>

<#=FOM.GetPredefinedTypeIncludes(FOMParser.FileContext.kDataTypes)#>

<#
foreach (var namespacePart in FOM.Namespace)
{
#>
namespace <#=namespacePart#> {
<#  } #>

enum class OrderType { RECEIVE, TIMESTAMP, INTERPOLATED };

<#=FOM.DataTypeForwardDeclarations#>

<#
foreach (var dataType in FOM.DataTypes)
{
  if (dataType is FOMParser.SimpleDataType && dataType.Generate)
  {
    var simpleDataType = dataType as FOMParser.SimpleDataType;
    if (dataType.Comment != null && dataType.Comment != "")
    {#>
<#=dataType.Comment#>
<# } #>
typedef <#=simpleDataType.Representation.CPPType#> <#=simpleDataType.Name#>;

<#} // if (dataType is FOMParser.SimpleDataType)
  else if (dataType is FOMParser.FixedRecordDataType)
  {
    var fixedRecordDataType = dataType as FOMParser.FixedRecordDataType;
    if (dataType.Comment != null && dataType.Comment != "")
    {#>
<#=fixedRecordDataType.Comment#>
<#  } #>
class <#=fixedRecordDataType.Name#><#=fixedRecordDataType.BaseClass != null ? " : public " + fixedRecordDataType.BaseClass.Name : ""#>
{
  public:
    virtual ~<#=fixedRecordDataType.Name#>() noexcept {}
<# if (fixedRecordDataType.BaseClass == null) { #>
    virtual uint32_t getVersion() const = 0;
<#  } #>
<# foreach (var field in fixedRecordDataType.Fields) { #>
    virtual void Set<#=field.Name#>(<#=field.DataType.ParameterCppType#> value) = 0;
<# if (field.DataType is FOMParser.ArrayDataType) {
     var arrayDataType = field.DataType as FOMParser.ArrayDataType;
#>
    virtual void Set<#=field.Name#>(const <#=arrayDataType.DataType.CPPType#>* value, size_t size) = 0;
<# } #>
    virtual <#=field.DataType.ReturnCppType#> Get<#=field.Name#>() const = 0;
    virtual bool Is<#=field.Name#>Available() const = 0;
<# } // foreach fixedRecordDataType.Fields #>

}; // class <#=dataType.Name#>

<#
  } // if (dataType is FOMParser.FixedRecordDataType)
  else if (dataType is FOMParser.EnumeratedDataType && dataType.Generate)
  {
    var enumeratedDataType = dataType as FOMParser.EnumeratedDataType;
#>
enum class <#=dataType.Name#> : <#=enumeratedDataType.Representation.CPPType#>
{
<#
    foreach (var enumerator in enumeratedDataType.Enumerators.Values)
    {
#>
      <#=enumerator.Name#> = <#=enumerator.Value#>,
<#
    } // foreach enumeratedDataType.Enumerators.Values
#>
}; // enum <#=dataType.Name#>

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, <#=dataType.Name#> value)
{
  switch (value)
  {
<#
    foreach (var enumerator in enumeratedDataType.Enumerators.Values)
    {
#>
    case <#=dataType.Name#>::<#=enumerator.Name#>: os << "<#=enumerator.Name#>"; break;
<#
    } // foreach enumeratedDataType.Enumerators.Values
#>
  }
  return os;
}


<#
  } // if (dataType is FOMParser.EnumeratedDataType)
} // foreach (var dataType in FOM.DataTypes.Values)
#>

<#
foreach (var namespacePart in FOM.Namespace)
{
#>
} // namespace <#=namespacePart#>
<#  } #>
