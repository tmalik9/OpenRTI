<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>

// Code automatically generated by FOMCodeGen version <#=FOM.GeneratorVersion#> from <#=System.IO.Path.GetFileName(FOM.Filename)#>, do not edit

<# if (FOM.ModelIdentification.Name != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Name, "Name: ")#>
<# } #>
<# if (FOM.ModelIdentification.Copyright != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Copyright, "Copyright: ")#>
<# } #>
<# if (FOM.ModelIdentification.Version != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Version, "Version: ")#>
<# } #>
<# if (FOM.ModelIdentification.Description != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Description, "Description: ")#>
<# } #>
<# if (FOM.ModelIdentification.Purpose != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Purpose, "Purpose: ")#>
<# } #>

#pragma once

#include <vector>
#include <ostream>
#include <cassert>
#include <new>
#include <utility>
#include <type_traits>

<#=FOM.GetPredefinedTypeIncludes(FOMParser.FileContext.kDataTypes)#>

<#
foreach (var namespacePart in FOM.Namespace)
{
#>
namespace <#=namespacePart#> {
<#  } #>

// define placement_new in case some other header has redefined operator new to sth. different (e.g. MS crtdbg)
#ifndef _PLACEMENT_NEW_DEFINED
#pragma push_macro("new")
#undef new
template <class X, typename ... Types>
inline X* placement_new(void* addr, Types&& ... args)
{
  return new (addr) X(std::forward<Types>(args)...);
}
#pragma pop_macro("new")
#define _PLACEMENT_NEW_DEFINED
#endif

// define our own simplified 'optional' types, similar to but independent of std::optional (since C++17) or boost::optional
class bad_optional_access : public std::exception
{
public:
  virtual const char* what() const noexcept override { return ("Bad optional access"); }
};
#pragma warning(push)
#pragma warning(disable: 4324) // MSVC: 'struct_name' : structure was padded due to __declspec(align())
// (empty) base template
template<typename T, bool X=std::is_class<T>::value > struct optional {};
// specialization for classes and structs used by-value, w. in-place copy-construction
template<typename T> struct optional<T, true>
{
  static_assert(!std::is_reference< T >::value, "reference is not supported as optional value");
  // constructors
  optional() : _valid(false) {}
  optional(const optional& rhs): _valid(rhs._valid) { create(rhs); }
  optional(const T& w): _valid(true) { create(w); }
  template<typename Other>
  optional(const Other& w): _valid(true) { create(w); }
  template<typename Other>
  optional(const optional<Other>& rhs): _valid(rhs._valid) { create(rhs._value); }

  // destructor
  ~optional() { if(_valid) destroy(); }

  // check for value presence
  bool has_value() const { return _valid; }
  explicit operator bool() const { return _valid; }
  bool operator ! () const { return !_valid; }

  // assign
  optional& operator = (optional const& rhs) { return assign(rhs); }
  optional& operator = (T const& w) { return assign(w); }

  // unchecked access to value
  const T& operator * () const & { return *get(); }
  T& operator * () & { return *get(); }
  T const* operator -> () const { return get(); }
  T* operator -> () { return get(); }
  // checked access to value
  constexpr const T& value() const & {
    if (!_valid) {
      throw bad_optional_access{};
    }
    return *get();
  }
  constexpr T& value() & {
    if (!_valid) {
      throw bad_optional_access{};
    }
    return *get();
  }
private:
  template<typename Other>
  void create(const Other& w) { placement_new<T>(_value, w); }
  void create(const optional& rhs) { if(_valid) create(*rhs.get()); }
  void destroy() { get()->~T(); }
  T const* get() const { assert(_valid && "no optional value"); return reinterpret_cast< const T* >(_value); }
  T* get() { assert(_valid && "no optional value"); return reinterpret_cast< T* >(_value); }
  void cleanup() { destroy(); _valid = false; }
  optional& assign(const T& w) {
    if(_valid) *get() = w;
    else create(w), _valid = true;
    return *this;
  }
  optional& assign(const optional& rhs) {
    if(rhs._valid) return assign(*rhs.get());
    if(!_valid) return *this;
    cleanup();
    return *this;
  }
  bool _valid;
  alignas(alignof(T)) uint8_t _value[sizeof(T)];
};
// Specialization for const-ref parameters, implemented by holding a pointer to the original variable.
// Note that non-const references are *not* supported (but could be easily added)!
template<typename T> struct optional<const T&, false>
{
  // constructors
  optional() : _valid(false), _pointer() {}
  optional(const optional& rhs): _valid(rhs._valid), _pointer(rhs._pointer) { }
  optional(const T& rhs): _valid(true), _pointer(&rhs) { }
  template<typename Other>
  optional(const Other& rhs): _valid(true), _pointer(&rhs) { }
  template<typename Other>
  optional(const optional<Other>& rhs): _valid(rhs._valid), _pointer(rhs._pointer) { }

  // destructor
  ~optional() { }

  // check for value presence
  bool has_value() const { return _valid; }
  explicit operator bool() const { return _valid; }
  bool operator ! () const { return !_valid; }

  // assign
  optional& operator = (const optional& rhs) {
    _valid = rhs._valid;
    _pointer = rhs._pointer;
    return *this;
  }
  optional& operator = (const T& w) {
    _valid = true;
    _pointer = &w;
    return *this;
  }
  // unchecked access to value
  T const& operator * () const & { return *get(); }
  T const* operator -> () const & { return get(); }
  // checked access to value
  constexpr const T& value() const & {
    if (!_valid) {
      throw bad_optional_access{};
    }
    return *get();
  }
  constexpr T& value() & {
    if (!_valid) {
      throw bad_optional_access{};
    }
    return *get();
  }
private:
  const T* get() const {
    assert(_valid && "no optional value");
    return _pointer;
  }
  bool _valid;
  const T* _pointer = nullptr;
};
// Specialization for everything else, which includes fundamental types and pointer types.
template<typename T> struct optional<T, false>
{
  // constructors
  optional() : _valid(false), _value() {}
  optional(const optional& rhs): _valid(rhs._valid), _value(rhs._value) { }
  optional(const T& rhs): _valid(true), _value(rhs) { }
  template<typename Other>
  optional(const Other& rhs): _valid(true), _value(rhs) { }
  template<typename Other>
  optional(const optional<Other>& rhs): _valid(rhs._valid), _value(rhs._value) { }

  // destructor
  ~optional() { }

  // check for value presence
  bool has_value() const { return _valid; }
  explicit operator bool() const { return _valid; }
  bool operator ! () const { return !_valid; }

  // assign
  optional& operator = (const optional& rhs) {
    _valid = rhs._valid;
    _value = rhs._value;
    return *this;
  }
  optional& operator = (const T& w) {
    _valid = true;
    _value = w;
    return *this;
  }
  // unchecked access to value
  T const& operator * () const & { return _value; }
  T const* operator -> () const { return &_value; }
  // checked access to value
  constexpr const T& value() const & {
    if (!_valid) {
      throw bad_optional_access{};
    }
    return _value;
  }
  constexpr T& value() & {
    if (!_valid) {
      throw bad_optional_access{};
    }
    return _value;
  }
private:
  bool _valid;
  T _value;
};
#pragma warning(pop)

// extended receive order type, includes 'interpolated' for application-generated timestamps
enum class OrderType { RECEIVE, TIMESTAMP, INTERPOLATED };

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, OrderType value)
{
  switch (value)
  {
    case OrderType::RECEIVE: os << "RECEIVE"; break;
    case OrderType::TIMESTAMP: os << "TIMESTAMP"; break;
    case OrderType::INTERPOLATED: os << "INTERPOLATED"; break;
  }
  return os;
}

inline std::string to_string(OrderType value)
{
  switch (value)
  {
    case OrderType::RECEIVE: return "RECEIVE";
    case OrderType::TIMESTAMP: return "TIMESTAMP";
    case OrderType::INTERPOLATED: return "INTERPOLATED";
  }
}

inline std::wstring to_wstring(OrderType value)
{
  switch (value)
  {
    case OrderType::RECEIVE: return L"RECEIVE";
    case OrderType::TIMESTAMP: return L"TIMESTAMP";
    case OrderType::INTERPOLATED: return L"INTERPOLATED";
  }
}
<#=
FOM.DataTypeForwardDeclarations
#>
<#
foreach (var dataType in FOM.DataTypes)
{
  if (dataType is FOMParser.SimpleDataType && dataType.Generate)
  {
    var simpleDataType = dataType as FOMParser.SimpleDataType;
    if (dataType.Comment != null && dataType.Comment != "")
    {#>
<#=dataType.Comment#>
<# } #>
typedef <#=simpleDataType.Representation.CPPType#> <#=simpleDataType.Name#>;

<#} // if (dataType is FOMParser.SimpleDataType)
  else if (dataType is FOMParser.FixedRecordDataType)
  {
    var fixedRecordDataType = dataType as FOMParser.FixedRecordDataType;
    if (dataType.Comment != null && dataType.Comment != "")
    {#>
<#=fixedRecordDataType.Comment#>
<#  } #>
class <#=fixedRecordDataType.Name#><#=fixedRecordDataType.BaseClass != null ? " : public " + fixedRecordDataType.BaseClass.Name : ""#>
{
  public:
    virtual ~<#=fixedRecordDataType.Name#>() noexcept {}
<# if (fixedRecordDataType.BaseClass == null) { #>
    virtual uint32_t getVersion() const = 0;
<#  } #>
<# foreach (var field in fixedRecordDataType.Fields) { #>
    virtual void Set<#=field.Name#>(<#=field.DataType.ParameterCppType#> value) = 0;
<# if (field.DataType is FOMParser.ArrayDataType) {
     var arrayDataType = field.DataType as FOMParser.ArrayDataType;
#>
    virtual void Set<#=field.Name#>(const <#=arrayDataType.DataType.CPPType#>* value, size_t size) = 0;
<# } #>
    virtual <#=field.DataType.ReturnCppType#> Get<#=field.Name#>() const = 0;
    virtual bool Is<#=field.Name#>Available() const = 0;
<# } // foreach fixedRecordDataType.Fields #>

}; // class <#=dataType.Name#>

<#
  } // if (dataType is FOMParser.FixedRecordDataType)
  else if (dataType is FOMParser.EnumeratedDataType && dataType.Generate)
  {
    var enumeratedDataType = dataType as FOMParser.EnumeratedDataType;
#>
enum class <#=dataType.Name#> : <#=enumeratedDataType.Representation.CPPType#>
{
<#
    foreach (var enumerator in enumeratedDataType.Enumerators.Values)
    {
#>
      <#=enumerator.Name#> = <#=enumerator.Value#>,
<#
    } // foreach enumeratedDataType.Enumerators.Values
#>
}; // enum <#=dataType.Name#>

template<typename char_type, typename traits_type>
std::basic_ostream<char_type, traits_type>&
operator<<(std::basic_ostream<char_type, traits_type>& os, <#=dataType.Name#> value)
{
  switch (value)
  {
<#
    foreach (var enumerator in enumeratedDataType.Enumerators.Values)
    {
#>
    case <#=dataType.Name#>::<#=enumerator.Name#>: os << "<#=enumerator.Name#>"; break;
<#
    } // foreach enumeratedDataType.Enumerators.Values
#>
    default: os << "<invalid <#=dataType.Name#>>"; break;
  }
  return os;
}

inline std::string to_string(<#=dataType.Name#> value)
{
  switch (value)
  {
<#
    foreach (var enumerator in enumeratedDataType.Enumerators.Values)
    {
#>
    case <#=dataType.Name#>::<#=enumerator.Name#>: return "<#=enumerator.Name#>";
<#
    } // foreach enumeratedDataType.Enumerators.Values
#>
    default: return "<invalid <#=dataType.Name#>>";
  }
}

inline std::wstring to_wstring(<#=dataType.Name#> value)
{
  switch (value)
  {
<#
    foreach (var enumerator in enumeratedDataType.Enumerators.Values)
    {
#>
    case <#=dataType.Name#>::<#=enumerator.Name#>: return L"<#=enumerator.Name#>";
<#
    } // foreach enumeratedDataType.Enumerators.Values
#>
    default: return L"<invalid <#=dataType.Name#>>";
  }
}

<#
  } // if (dataType is FOMParser.EnumeratedDataType)
} // foreach (var dataType in FOM.DataTypes.Values)
#>

<#
foreach (var namespacePart in FOM.Namespace)
{
#>
} // namespace <#=namespacePart#>
<#  } #>
