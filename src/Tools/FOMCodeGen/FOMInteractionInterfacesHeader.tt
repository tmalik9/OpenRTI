<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>

// Code automatically generated by FOMCodeGen version <#=FOM.GeneratorVersion#> from <#=System.IO.Path.GetFileName(FOM.Filename)#>, do not edit

<# if (FOM.ModelIdentification.Name != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Name, "Name: ")#>
<# } #>
<# if (FOM.ModelIdentification.Copyright != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Copyright, "Copyright: ")#>
<# } #>
<# if (FOM.ModelIdentification.Version != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Version, "Version: ")#>
<# } #>
<# if (FOM.ModelIdentification.Description != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Description, "Description: ")#>
<# } #>
<# if (FOM.ModelIdentification.Purpose != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Purpose, "Purpose: ")#>
<# } #>

#pragma once

#include <vector>
#include <functional>

<#=FOM.GetPredefinedTypeIncludes(FOMParser.FileContext.kInteractionInterfaces)#>
#include "<#=DataTypesHeaderFilename#>"
#include "<#=ObjectInterfacesHeaderFilename#>"

<# foreach (var namespacePart in FOM.Namespace) { #>
namespace <#=namespacePart#> {
<# } #>

<# foreach (var interactionClass in FOM.InteractionClasses) { #>
// I<#=interactionClass.Name#>InteractionClass represents the HLA interaction class <#=interactionClass.QualifiedName#>.
class I<#=interactionClass.Name#>InteractionClass
{
  public:
    // Publish/unpublish the interaction class. Sending an interaction of this class requires publishing the interaction class.
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    // Subscribe the interaction class. Receiving interactions requires having subscribed to this interaction class.
    // Note that the appropriate callbacks should have been registered *before* subscribing to the interaction class.
    virtual void Subscribe(bool deliverToSelf) = 0;
<# if (interactionClass.HasValidParameters) {#>
    // Subscribe the interaction class with filter values. Only interactions with parameters matching the given values will be received.
    // Filtered subscriptions may be issued several times with differing value tuples. 'nullopt' may be used as a wildcard, matching
    // any incoming value.
    virtual void Subscribe(<#=interactionClass.CppParameterList#>, bool deliverToSelf) = 0;
<#}#>
    // Unsubscribe the interaction class, cancelling reception of interactions. Calling Unsubscribe will also clear all filtered subscriptions, if any.
    virtual void Unsubscribe() = 0;
    // Send an interaction as receive order message.
    virtual void send(<#=interactionClass.CppParameterList#>) = 0;
    // Send a time stamped interaction.
    virtual void sendWithTime(<#=interactionClass.CppParameterList#><# if (interactionClass.HasValidParameters) {#>, <#}#><#=FOM.NativeTimeType#> time) = 0;
    // Register an interaction callback. The optional time stamp will be delivered by the application. When the time stamp is valid,
    // the optional order type will indicate the source of the time stamp.
    using ReceiveCallback = std::function<void(<#=interactionClass.CppParameterList#><# if (interactionClass.HasValidParameters) {#>, <#}#>optional<<#=FOM.NativeTimeType#>> time, optional<OrderType> orderType)>;
    using ReceiveCallbackHandle = uint32_t;
    constexpr static ReceiveCallbackHandle kInvalidCallbackHandle = 0xffffffff;
    virtual ReceiveCallbackHandle RegisterReceiveCallback(ReceiveCallback callback) = 0;
    virtual void UnregisterReceiveCallback(ReceiveCallbackHandle callbackHandle) = 0;
};

<# } // foreach (var interactionClass in FOM.InteractionClasses) #>

class IInteractionClassRegistry
{
  public:
<# foreach (var interactionClass in FOM.InteractionClasses) { #>
    virtual I<#=interactionClass.Name#>InteractionClass* Get<#=interactionClass.Name#>InteractionClass() const = 0;
<# } #>
  protected:
    virtual ~IInteractionClassRegistry() {}
}; // class IInteractionClassRegistry

<# foreach (var namespacePart in FOM.Namespace) { #>
} // namespace <#=namespacePart#>
<# } #>
