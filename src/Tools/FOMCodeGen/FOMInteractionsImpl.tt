<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>

// Code automatically generated by FOMCodeGen version <#=FOM.GeneratorVersion#> from <#=System.IO.Path.GetFileName(FOM.Filename)#>, do not edit
<# if (FOM.UsePrecompiledHeaders) { #>
#include "stdafx.h"
<#}#>

#include <vector>
#include <cassert>

<# if (FOM.IsFloatTime) { #>
#include "RTI/time/HLAfloat64Time.h"
<#} else {#>
#include "RTI/time/HLAinteger64Time.h"
<#}#>

#include "<#=InteractionsHeaderFilename#>"
#include "<#=ObjectsHeaderFilename#>"

<#
foreach (var namespacePart in FOM.Namespace)
{
#>
namespace <#=namespacePart#> {
<#  } #>

inline std::string to_string(const std::wstring& str)
{
  if (str.empty()) return std::string();
  const std::ctype<wchar_t>& CType = std::use_facet<std::ctype<wchar_t> >(std::locale());
  std::vector<char> stringBuffer(str.length());
  CType.narrow(str.data(), str.data() + str.length(), '_', &stringBuffer[0]);
  return std::string(&stringBuffer[0], stringBuffer.size());
}

<# 
foreach (var interactionClass in FOM.InteractionClasses)
{
  if (interactionClass.BaseClass != null)
  {
#>
// object class type '<#=interactionClass.Name#>'
<#=interactionClass.Name#>InteractionClass::<#=interactionClass.Name#>InteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry, <#=interactionClass.BaseClass.Name#>InteractionClass* baseClass)
<# } else {#>
<#=interactionClass.Name#>InteractionClass::<#=interactionClass.Name#>InteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry)
<# } #>
{
  mInteractionClassRegistry = interactionClassRegistry;
  mRtiAmbassador = rtiAmbassador;

<# if (interactionClass.BaseClass != null) { #>
  mBaseClass = baseClass;
<# } #>
  mInteractionClassHandle = rtiAmbassador->getInteractionClassHandle(L"<#=interactionClass.QualifiedName#>");
<# 
  foreach (var parameter in interactionClass.Parameters)
  {
    if (parameter.DataType != null)
    { #>
  // parameter <#=parameter.Name#> : <#=parameter.DataType.Name#>
<#  } else { #>
  // parameter <#=interactionClass.Name#>.<#=parameter.Name#> : no data type
<#  } // if (parameter.DataType != null) #>
  m<#=parameter.Name#>ParameterHandle = rtiAmbassador->getParameterHandle(mInteractionClassHandle, L"<#=parameter.Name#>");
<#  } // foreach (var parameter in interactionClass.Parameters)
#>
}

// get the corresponding *object* class registry, for access to objects sent as parameters
ObjectClassRegistry* <#=interactionClass.Name#>InteractionClass::GetObjectClassRegistry()
{
  return mInteractionClassRegistry->GetObjectClassRegistry();
}

void <#=interactionClass.Name#>InteractionClass::Publish()
{
  if (!mPublished)
  {
    mRtiAmbassador->publishInteractionClass(mInteractionClassHandle);
    mPublished = true;
  }
}

void <#=interactionClass.Name#>InteractionClass::Unpublish()
{
  if (mPublished)
  {
    mRtiAmbassador->unpublishInteractionClass(mInteractionClassHandle);
    mPublished = false;
  }
}

void <#=interactionClass.Name#>InteractionClass::Subscribe(bool deliverToSelf)
{
  mRtiAmbassador->subscribeInteractionClass(mInteractionClassHandle);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  mSubscribed = true;
}

<# if (interactionClass.HasValidParameters) {#>
void <#=interactionClass.Name#>InteractionClass::Subscribe(<#=interactionClass.CppParameterList#>, bool deliverToSelf)
{
  rti1516ev::ParameterHandleValueMap parameters;
<# 
  foreach (var parameter in interactionClass.AllParameters)
  {
    if (parameter.DataType != null)
    { #>
  if (<#=parameter.Name#>)
  {
    <#= parameter.ToEncoderExpression() #>
    parameters.insert(std::make_pair(Get<#=parameter.Name#>ParameterHandle(), <#=parameter.Name#>Encoder.encode()));
  }
<#  
    } // if (parameter.DataType != null)
  } // foreach (var parameter in interactionClass.Parameters)
#>
  mRtiAmbassador->subscribeInteractionClassWithFilter(mInteractionClassHandle, parameters);
  mRtiAmbassador->setInteractionClassDeliverToSelf(mInteractionClassHandle, deliverToSelf);
  // we must always set mSubscribed, otherwise we can't unsubscribe
  mSubscribed = true;
}
<#}#>

void <#=interactionClass.Name#>InteractionClass::Unsubscribe()
{
  if (mSubscribed)
  {
    mRtiAmbassador->unsubscribeInteractionClass(mInteractionClassHandle);
    mSubscribed = false;
  }
}

void <#=interactionClass.Name#>InteractionClass::send(<#=interactionClass.CppParameterList#>)
{
  rti1516ev::ParameterHandleValueMap parameters;
<# 
  foreach (var parameter in interactionClass.AllParameters)
  {
    if (parameter.DataType != null)
    { #>
  if (<#=parameter.Name#>)
  {
    <#= parameter.ToEncoderExpression() #>
    parameters.insert(std::make_pair(Get<#=parameter.Name#>ParameterHandle(), <#=parameter.Name#>Encoder.encode()));
  }
<#  } else { #>
  parameters.insert(std::make_pair(Get<#=parameter.Name#>ParameterHandle(), rti1516ev::VariableLengthData()));
<#  } // if (parameter.DataType != null)
  } // foreach (var parameter in interactionClass.Parameters)
#>
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData());
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void <#=interactionClass.Name#>InteractionClass::sendWithTime(<#=interactionClass.CppParameterList#><# if (interactionClass.HasValidParameters) {#>, <#}#><#=FOM.NativeTimeType#> time)
{
  rti1516ev::ParameterHandleValueMap parameters;
<# 
  foreach (var parameter in interactionClass.AllParameters)
  {
    if (parameter.DataType != null)
    { #>
  if (<#=parameter.Name#>)
  {
    <#= parameter.ToEncoderExpression() #>
    parameters.insert(std::make_pair(Get<#=parameter.Name#>ParameterHandle(), <#=parameter.Name#>Encoder.encode()));
  }
<#  } else { #>
  parameters.insert(std::make_pair(Get<#=parameter.Name#>ParameterHandle(), rti1516ev::VariableLengthData()));
<#  } // if (parameter.DataType != null)
  } // foreach (var parameter in interactionClass.Parameters)
#>
  try {
    mRtiAmbassador->sendInteraction(GetInteractionClassHandle(), parameters, rti1516ev::VariableLengthData(), <#=FOM.LogicalTimeType#>(time));
  }
  catch (const rti1516ev::InvalidLogicalTime& e)
  {
    throw InvalidLogicalTime(to_string(e.what()));
  }
  catch (const rti1516ev::Exception& e)
  {
    throw std::runtime_error(to_string(e.what()));
  }
}

void <#=interactionClass.Name#>InteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap&<#if (interactionClass.HasValidParameters) {#> parameters <#}#>, bool sentBySelf)
{
<#
  List<string> callArguments1 = new List<string>();
  var timeArgument1 = "optional<" + FOM.NativeTimeType + ">()";
  foreach (var parameter in interactionClass.AllParameters) {
    if (parameter.DataType != null) {
      string parameterName = (parameter.Name != parameter.DataType.Name ? parameter.Name : parameter.Name + "P");
      callArguments1.Add(parameterName);
#>
  optional<<#=parameter.DataType.ParameterCppType#>> <#=parameterName#>;
<#  
    } // if (parameter.DataType != null)
  } // foreach (var parameter in interactionClass.Parameters)
#>
<#
  foreach (var parameter in interactionClass.AllParameters) {
    if (parameter.DataType != null) {
      var parameterName = (parameter.Name != parameter.DataType.Name ? parameter.Name : parameter.Name + "P");
#>
<# // IMPORTANT NOTE: the decoders must stay in the function's scope, otherwise the optionals declared above may become invalid #>
  <#=parameter.DataType.Encoding#> <#=parameter.Name#>Decoder;
  rti1516ev::ParameterHandleValueMap::const_iterator <#=parameter.Name#>Iter = parameters.find(Get<#=parameter.Name#>ParameterHandle());
  if (<#=parameter.Name#>Iter != parameters.end())
  {
    <#=parameter.Name#>Decoder.decode(<#=parameter.Name#>Iter->second);
    <#=parameterName#> = <#=parameter.DataType.CppGetter(parameter.Name + "Decoder")#>;
  }
<#  
    } // if (parameter.DataType != null)
  } // foreach (var parameter in interactionClass.Parameters)
#>
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
<#    if (callArguments1.Count > 0) { #>
    callback(<#=string.Join(", ", callArguments1)#>, <#=timeArgument1#>, optional<OrderType>(), sentBySelf);
<#    } else {#>
    callback(<#=timeArgument1#>, optional<OrderType>(), sentBySelf);
<#    }#>
  }
}

void <#=interactionClass.Name#>InteractionClass::ReceiveInteraction(const rti1516ev::ParameterHandleValueMap&<#if (interactionClass.HasValidParameters) {#> parameters <#}#>, const rti1516ev::LogicalTime& time, OrderType orderType, bool sentBySelf)
{
<#
{
  List<string> callArguments2 = new List<string>();
  var timeArgument2 = "static_cast<const " + FOM.LogicalTimeType + "&>(time).getTime()";
  foreach (var parameter in interactionClass.AllParameters) {
    if (parameter.DataType != null) {
      string parameterName = (parameter.Name != parameter.DataType.Name ? parameter.Name : parameter.Name + "P");
      callArguments2.Add(parameterName);
#>
  optional<<#=parameter.DataType.ParameterCppType#>> <#=parameterName#>;
<#  
    } // if (parameter.DataType != null)
  } // foreach (var parameter in interactionClass.Parameters)
#>

<#
  foreach (var parameter in interactionClass.AllParameters) {
    if (parameter.DataType != null) {
      string parameterName = (parameter.Name != parameter.DataType.Name ? parameter.Name : parameter.Name + "P");
#>
  <#=parameter.DataType.Encoding#> <#=parameter.Name#>Decoder;
  rti1516ev::ParameterHandleValueMap::const_iterator <#=parameter.Name#>Iter = parameters.find(Get<#=parameter.Name#>ParameterHandle());
  if (<#=parameter.Name#>Iter != parameters.end())
  {
    <#=parameter.Name#>Decoder.decode(<#=parameter.Name#>Iter->second);
    <#=parameterName#> = <#=parameter.DataType.CppGetter(parameter.Name + "Decoder")#>;
  }
<#  
    } // if (parameter.DataType != null)
  } // foreach (var parameter in interactionClass.Parameters)
#>
  for (auto& entry : mReceiveCallbacks) {
    auto& callback = entry.second;
<#    if (callArguments2.Count > 0) { #>
    callback(<#=string.Join(", ", callArguments2)#>, <#=timeArgument2#>, orderType, sentBySelf);
<#    } else {#>
    callback(<#=timeArgument2#>, orderType, sentBySelf);
<#    }#>
<#}#>
  }
}

uint32_t <#=interactionClass.Name#>InteractionClass::RegisterReceiveCallback(ReceiveCallback callback)
{
  uint32_t key = mReceiveCallbacksNextKey++;
  mReceiveCallbacks.insert(std::make_pair(key, callback));
  return key;
}

rti1516ev::ParameterHandleSet <#=interactionClass.Name#>InteractionClass::GetAllParameterHandles()
{
  rti1516ev::ParameterHandleSet result;
<# 
  foreach (var parameter in interactionClass.AllParameters) {
#>
  result.insert(Get<#=parameter.Name#>ParameterHandle());
<#  
  } // foreach (var parameter in interactionClass.Parameters)
#>
  return result;
}

<# } // foreach (var interactionClass in FOM.InteractionClasses) #> 

InteractionClassRegistry::InteractionClassRegistry(ObjectClassRegistry* objectClassRegistry)
  : mRtiAmbassador(nullptr), mObjectClassRegistry(objectClassRegistry)
{
}

InteractionClassRegistry::~InteractionClassRegistry()
{
}

void InteractionClassRegistry::Initialize(rti1516ev::RTIambassador* rtiAmbassador)
{
  mRtiAmbassador = rtiAmbassador;
<#  foreach (var interactionClass in FOM.InteractionClasses) { #>
  try
  {
<#    if (interactionClass.BaseClass != null) { #>
    assert(m<#=interactionClass.BaseClass.Name#>InteractionClass.get() != nullptr);
    m<#=interactionClass.Name#>InteractionClass = std::unique_ptr<<#=interactionClass.Name#>InteractionClass>(new <#=interactionClass.Name#>InteractionClass(mRtiAmbassador, this, m<#=interactionClass.BaseClass.Name#>InteractionClass.get()));
<#    } else { #>
    m<#=interactionClass.Name#>InteractionClass = std::unique_ptr<<#=interactionClass.Name#>InteractionClass>(new <#=interactionClass.Name#>InteractionClass(mRtiAmbassador, this));
<#    } // if #>
  }
  catch (const rti1516ev::NameNotFound&)
  {
  }
<#  } // foreach #>
} // Initialize

void InteractionClassRegistry::Finalize()
{
<#  foreach (var interactionClass in FOM.InteractionClasses) { #>
  m<#=interactionClass.Name#>InteractionClass.reset();
<# } // foreach #>
  mRtiAmbassador = nullptr;
} // Initialize

void InteractionClassRegistry::ReceiveInteraction(rti1516ev::InteractionClassHandle theInteractionClass,
                                                  const rti1516ev::ParameterHandleValueMap & parameters,
                                                  bool sentBySelf)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
<# 
  bool firstInClassRegistryReceiveInteractionParameter = true;
  foreach (var interactionClass in FOM.InteractionClasses)
  {
    if (firstInClassRegistryReceiveInteractionParameter) { #>
  if (theInteractionClass == m<#=interactionClass.Name#>InteractionClass->GetInteractionClassHandle())
<#  } else { #>
  else if (theInteractionClass == m<#=interactionClass.Name#>InteractionClass->GetInteractionClassHandle())
<#  } // if
    firstInClassRegistryReceiveInteractionParameter = false; #>
  {
    m<#=interactionClass.Name#>InteractionClass->ReceiveInteraction(parameters, sentBySelf);
  }
<#  
} // foreach 
#>
}

void InteractionClassRegistry::ReceiveInteraction(rti1516ev::InteractionClassHandle theInteractionClass,
                                                  const rti1516ev::ParameterHandleValueMap & parameters,
                                                  const rti1516ev::LogicalTime& time,
                                                  OrderType orderType,
                                                  bool sentBySelf)
{
  if (mRtiAmbassador == nullptr)
  {
    throw NotInitialized();
  }
<# 
  bool firstInClassRegistryReceiveWithTimeParameter = true;
  foreach (var interactionClass in FOM.InteractionClasses)
  {
    if (firstInClassRegistryReceiveWithTimeParameter) { #>
  if (theInteractionClass == m<#=interactionClass.Name#>InteractionClass->GetInteractionClassHandle())
<#  } else { #>
  else if (theInteractionClass == m<#=interactionClass.Name#>InteractionClass->GetInteractionClassHandle())
<#  } // if (firstInClassRegistryReceiveWithTimeParameter)
    firstInClassRegistryReceiveWithTimeParameter = false; #>
  {
    m<#=interactionClass.Name#>InteractionClass->ReceiveInteraction(parameters, time, orderType, sentBySelf);
  }
<#} // foreach #>
}

<# foreach (var namespacePart in FOM.Namespace) { #>
} // namespace <#=namespacePart#>
<# } #>
