<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>

// Code automatically generated by FOMCodeGen version <#=FOM.GeneratorVersion#> from <#=System.IO.Path.GetFileName(FOM.Filename)#>, do not edit

#pragma once

#include <vector>
#include "RTI/Handle.h"
#include "RTI/RTIambassador.h"
#include "RTI/encoding/BasicDataElements.h"
#include "RTI/encoding/HLAfixedRecord.h"
#include "RTI/encoding/HLAfixedArray.h"
#include "RTI/encoding/HLAvariableArray.h"

<#=FOM.GetPredefinedTypeIncludes(FOMParser.FileContext.kInteractionHeader)#>
#include "<#=InteractionInterfacesHeaderFilename#>"
#include "<#=EncodingHeaderFilename#>"

<# foreach (var namespacePart in FOM.Namespace) { #>
namespace <#=namespacePart#> {
<# } #>

class InteractionClassRegistry;
class ObjectClassRegistry;

<# foreach (var interactionClass in FOM.InteractionClasses) { #>
class <#=interactionClass.Name#>;
class <#=interactionClass.Name#>InteractionClass : public I<#=interactionClass.Name#>InteractionClass
{
  public:
    // I<#=interactionClass.Name#>InteractionClass
    <#=interactionClass.Name#>InteractionClass() = default;
    virtual ~<#=interactionClass.Name#>InteractionClass() = default;
    ObjectClassRegistry* GetObjectClassRegistry();
    InteractionClassRegistry* GetInteractionClassRegistry() { return mInteractionClassRegistry; }
    void Publish() override;
    void Unpublish() override;
    void Subscribe(bool deliverToSelf) override;
<# if (interactionClass.HasValidParameters) {#>
    virtual void Subscribe(<#=interactionClass.CppParameterList#>, bool deliverToSelf) override;
<#}#>
    void Unsubscribe() override;
    void send(<#=interactionClass.CppParameterList#>) override;
    void sendWithTime(<#=interactionClass.CppParameterList#><# if (interactionClass.HasValidParameters) {#>, <#}#><#=FOM.NativeTimeType#> time) override;
    uint32_t RegisterReceiveCallback(ReceiveCallback callback) override;

    // internal
    void ReceiveInteraction(const rti1516ev::ParameterHandleValueMap & parameters);
    void ReceiveInteraction(const rti1516ev::ParameterHandleValueMap & parameters, const rti1516ev::LogicalTime& time, OrderType receivedOrder);
    rti1516ev::InteractionClassHandle GetInteractionClassHandle() const { return mInteractionClassHandle; }
<#   if (interactionClass.BaseClass != null) { #>
    <#=interactionClass.Name#>InteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry, <#=interactionClass.BaseClass.Name#>InteractionClass* baseClass);
<#   } else {#>
    <#=interactionClass.Name#>InteractionClass(rti1516ev::RTIambassador* rtiAmbassador, InteractionClassRegistry* interactionClassRegistry);
<#   } // if (interactionClass.BaseClass != null) #>
<# 
  var baseClass = interactionClass.BaseClass;
  while (baseClass != null)
  {
    foreach (var parameter in baseClass.Parameters)
    {
      if (parameter.DataType != null)
      { #>
    // parameter <#=parameter.Name#> : <#=parameter.DataType.Name#>
<#    } else { #>
    // parameter <#=parameter.Name#> : no data type
<#    } // if (parameter.DataType != null) #>
    rti1516ev::ParameterHandle Get<#=parameter.Name#>ParameterHandle() const { return mBaseClass->Get<#=parameter.Name#>ParameterHandle(); }
<#  } // foreach (var parameter in interactionClass.Parameters)
    baseClass = baseClass.BaseClass;
  } // while (baseClass != null)
#>
<# 
  foreach (var parameter in interactionClass.Parameters)
  {
    if (parameter.DataType != null)
    { #>
    // parameter <#=parameter.Name#> : <#=parameter.DataType.Name#>
<#  } else { #>
    // parameter <#=parameter.Name#> : no data type
<# } // if (parameter.DataType != null) #>
    rti1516ev::ParameterHandle Get<#=parameter.Name#>ParameterHandle() const { return m<#=parameter.Name#>ParameterHandle; }
<#} // foreach (var parameter in interactionClass.Parameters) #>
    rti1516ev::ParameterHandleSet GetAllParameterHandles();
  private:
    InteractionClassRegistry* mInteractionClassRegistry;
    rti1516ev::RTIambassador* mRtiAmbassador;
    // interaction class handle
    rti1516ev::InteractionClassHandle mInteractionClassHandle;
<# if (interactionClass.BaseClass != null) { #>
    <#=interactionClass.BaseClass.Name#>InteractionClass* mBaseClass;
<# } #>
    bool mPublished = false;
    bool mSubscribed = false;
    // Parameter handles
<# 
  foreach (var parameter in interactionClass.Parameters)
  {
    if (parameter.DataType != null)
    {
#>    // parameter <#=parameter.Name#> : <#=parameter.DataType.Name#>
<#  } else {
#>    // parameter <#=parameter.Name#> : no data type
<#  } // if (parameter.DataType != null) #>
    rti1516ev::ParameterHandle m<#=parameter.Name#>ParameterHandle;
<#} // foreach (var parameter in interactionClass.Parameters)
#>
    std::map<uint32_t, ReceiveCallback> mReceiveCallbacks;
    uint32_t mReceiveCallbacksNextKey = 0;
};

<# } // foreach (var interactionClass in FOM.InteractionClasses) #> 

class ObjectClassRegistry;
class InteractionClassRegistry : public IInteractionClassRegistry
{
  public:
    InteractionClassRegistry(ObjectClassRegistry* objectClassRegistry);
    ~InteractionClassRegistry();
    ObjectClassRegistry* GetObjectClassRegistry() { return mObjectClassRegistry; }
    void Initialize(rti1516ev::RTIambassador* rtiAmbassador);
    void Finalize();

<# foreach (var interactionClass in FOM.InteractionClasses) { #>
    I<#=interactionClass.Name#>InteractionClass* Get<#=interactionClass.Name#>InteractionClass() const override { return m<#=interactionClass.Name#>InteractionClass.get(); }
<# } #>

    void ReceiveInteraction(rti1516ev::InteractionClassHandle theInteraction, const rti1516ev::ParameterHandleValueMap & parameters);
    void ReceiveInteraction(rti1516ev::InteractionClassHandle theInteraction, const rti1516ev::ParameterHandleValueMap & parameters, const rti1516ev::LogicalTime&, OrderType orderType);

  private:
    rti1516ev::RTIambassador* mRtiAmbassador;
    ObjectClassRegistry* mObjectClassRegistry;
<# foreach (var interactionClass in FOM.InteractionClasses) { #>
    std::unique_ptr<<#=interactionClass.Name#>InteractionClass> m<#=interactionClass.Name#>InteractionClass;
<# } #>
}; // class InteractionClassRegistry

<#
foreach (var namespacePart in FOM.Namespace)
{
#>
} // namespace <#=namespacePart#>
<#  } #>
