<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>

// Code automatically generated by FOMCodeGen version <#=FOM.GeneratorVersion#> from <#=System.IO.Path.GetFileName(FOM.Filename)#>, do not edit

<# if (FOM.ModelIdentification.Name != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Name, "Name: ")#>
<# } #>
<# if (FOM.ModelIdentification.Copyright != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Copyright, "Copyright: ")#>
<# } #>
<# if (FOM.ModelIdentification.Version != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Version, "Version: ")#>
<# } #>
<# if (FOM.ModelIdentification.Description != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Description, "Description: ")#>
<# } #>
<# if (FOM.ModelIdentification.Purpose != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Purpose, "Purpose: ")#>
<# } #>

#pragma once

#include <vector>
#include <functional>
#include <memory>

<#=FOM.GetPredefinedTypeIncludes(FOMParser.FileContext.kObjectInterfaces)#>
#include "<#=DataTypesHeaderFilename#>"

<#
foreach (var namespacePart in FOM.Namespace)
{
#>
namespace <#=namespacePart#> {
<# } #>

<# 
foreach (var objectClass in FOM.ObjectClasses)
{
#>
class I<#=objectClass.Name#>;
// I<#=objectClass.Name#>ObjectClass represents the HLA object class <#=objectClass.QualifiedName#>.
// Instances of I<#=objectClass.Name#> represent the corresponding HLA object instances.
class I<#=objectClass.Name#>ObjectClass
{
  public:
    using DiscoverObjectInstanceCallback = std::function<void(std::shared_ptr<I<#=objectClass.Name#>>)>;
    using RemoveObjectInstanceCallback = std::function<void(std::shared_ptr<I<#=objectClass.Name#>>)>;
    using ObjectCreatedCallbackType = std::function<void(std::shared_ptr<I<#=objectClass.Name#>>, bool success)>;
    // Publish/unpublish this object class. Creating object instances requires publishing the object class.
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    // Subscribe/unsubscribe this object class. Taking part in object discovery and receiving attribute updates requires subscribing the object class.
    // Note that the appropriate callbacks should have been registered *before* subscribing to the object class.
    virtual void Subscribe(bool deliverToSelf) = 0;
    virtual void Unsubscribe() = 0;
    // Return an existing object instance by name, or nullptr if not existant.
    virtual std::shared_ptr<I<#=objectClass.Name#>> GetObjectInstance(const std::wstring& instanceName) = 0;
    // Create an instance of I<#=objectClass.Name#>. Returns nullptr if the object instance already exists.
    // If another federate has already created an object instance with the same name and the same object class,
    // the discover object instance mechanism will reuse the object returned by 'create object instance'.
    // A discover object instance callback should be installed by the application to appropriately handle this case.
    virtual std::shared_ptr<I<#=objectClass.Name#>> CreateObjectInstance(const std::wstring& instanceName) = 0;
    // Create an instance of I<#=objectClass.Name#>, and notify the application about having completed the HLA object registration.
    // The callback's 'success' parameter indicates whether the object instance name could successfully be reserved for the object.
    virtual std::shared_ptr<I<#=objectClass.Name#>> CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback) = 0;

    // install a discover object instance callback for this HLA object class
    virtual uint32_t RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback) = 0;
    virtual void UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken) = 0;

    // install a remove object instance callback for the HLA object class
    virtual uint32_t RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback) = 0;
    virtual void UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken) = 0;
};

class I<#=objectClass.Name#><#
  if (objectClass.BaseClass != null)
  {
#> : public I<#=objectClass.BaseClass.Name#>
<# } else {
#> : public std::enable_shared_from_this<I<#=objectClass.Name#>>
<# } // if #>
{
<# 
  string attributeBitsClass = "uint32_t";
  string attributeBitsPostfix = "";
  if (objectClass.Attributes.Count > 32)
  {
    attributeBitsClass = "uint64_t";
    attributeBitsPostfix = "ull";
  }
#>
  public:
<# if (objectClass.BaseClass == null)  {#>
    using AttributeBits = <#=attributeBitsClass#>;
    static const AttributeBits kNone = 0x0;
<# } #>
<# 
  ulong bit;
  if (objectClass.BaseClass != null)
    bit = (ulong)(1 << objectClass.BaseClass.AllAttributes.Count);
  else
    bit = 1;
  foreach (var attribute in objectClass.Attributes)
  {
    if (attribute.DataType != null)
    { #>
    static const AttributeBits k<#=attribute.Name#>Bit = 0x<#=bit.ToString("X")#><#=attributeBitsPostfix#>;
<#
      bit = bit << 1;
    } // if (attribute.DataType != null)
  } // foreach (var attribute in objectClass.Attributes)
#>

    I<#=objectClass.Name#>() {}
<# if (objectClass.BaseClass == null)  {#>
    virtual ~I<#=objectClass.Name#>() {}
<#  } else { #>
    ~I<#=objectClass.Name#>() {}
<# } #>
    // copying and moving an object instance is not allowed
    I<#=objectClass.Name#>(const I<#=objectClass.Name#>&) = delete;
    I<#=objectClass.Name#>(I<#=objectClass.Name#>&&) = delete;
    I<#=objectClass.Name#>& operator=(const I<#=objectClass.Name#>&) = delete;
    I<#=objectClass.Name#>& operator=(I<#=objectClass.Name#>&&) = delete;

<# if (objectClass.BaseClass == null)  {#>
    virtual std::wstring GetObjectInstanceName() const = 0;
    // has this object a valid HLA object instance handle?
    virtual bool IsValid() const = 0;
    // has this object been created by this federate?
    virtual bool IsOwner() const = 0;
    // Delete the object from HLA and the class registry.
    // Be careful to keep a shared_ptr to the object while executing Release!
    virtual void Release() = 0;
<# } #>
<# 
  foreach (var attribute in objectClass.Attributes)
  {
    if (attribute.DataType != null)
    { #>
    // attribute <#=attribute.Name#> : <#=attribute.DataType.Name#>
    virtual <#=attribute.DataType.ReturnCppType#> Get<#=attribute.Name#>() const = 0;
<#    if (attribute.DataType is FOMParser.FixedRecordDataType) { #>
    virtual <#=attribute.DataType.ModifiableReturnCppType#> Get<#=attribute.Name#>() = 0;
<#  } #>
    virtual void Set<#=attribute.Name#>(<#=attribute.DataType.ParameterCppType#> newValue) = 0;
<#  } else { #>
    // attribute <#=attribute.Name#> : no data type
<#  
    } // if (attribute.DataType != null)
  } // foreach (var attribute in objectClass.Attributes)
#>
<# if (objectClass.HasValidAttributes) { #>
<# if (objectClass.BaseClass != null && !objectClass.BaseClass.HasValidAttributes) { // first child class with valid attributes #>
    // send all attribute values
    virtual void UpdateAllAttributeValues() = 0;
    // send all attribute values, as TSO message
    virtual void UpdateAllAttributeValues(<#=FOM.NativeTimeType#> time) = 0;
    // send attribute values which have been modified since last call
    virtual void UpdateModifiedAttributeValues() = 0;
    // send attribute values which have been modified since last call, as TSO message
    virtual void UpdateModifiedAttributeValues(<#=FOM.NativeTimeType#> time) = 0;
    // bitmask of attributes ever received
    virtual AttributeBits GetReceivedAttributes() const = 0;
    // bitmask of attributes received in last update (cleared after update callbacks executed)
    virtual AttributeBits GetUpdatedAttributes() const = 0;
    // bitmask of attributes ever modified
    virtual AttributeBits GetInitializedAttributes() const = 0;
    // bitmask of attributes modified since last updateAttributeValues/provideAttributeValues
    // (cleared by UpdateAttributeValues or ProvideAttributeValues)
    virtual AttributeBits GetModifiedAttributes() const = 0;
    // request attribute values which haven't been updated in last reflectAttributeValues
    virtual void RequestAttributeValues() = 0;
    // request all attribute values
    virtual void RequestAllAttributeValues() = 0;
<# } #>
<# if (objectClass.ChildClasses.Count == 0) { #>
    using UpdateCallback = std::function<void(std::shared_ptr<I<#=objectClass.Name#>>, optional<<#=FOM.NativeTimeType#>> time, optional<OrderType> orderType)>;
    virtual uint32_t RegisterUpdateCallback(UpdateCallback callback) = 0;
    virtual void UnregisterUpdateCallback(uint32_t callbackToken) = 0;
<# } // if (objectClass.ChildClasses.Count == 0) #>
<# } // if (objectClass.HasValidAttributes) #>
};

<# } // foreach (var objectClass in FOM.ObjectClasses) #>

class IObjectClassRegistry
{
  public:
<# foreach (var objectClass in FOM.ObjectClasses) { #>
    virtual I<#=objectClass.Name#>ObjectClass* Get<#=objectClass.Name#>ObjectClass() const = 0;
<# } #>
  protected:
    virtual ~IObjectClassRegistry() {}
}; // class IObjectClassRegistry

<#
foreach (var namespacePart in FOM.Namespace)
{
#>
} // namespace <#=namespacePart#>
<#  } #>
