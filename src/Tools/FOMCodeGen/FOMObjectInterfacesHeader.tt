<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>

// Code automatically generated by FOMCodeGen version <#=FOM.GeneratorVersion#> from <#=System.IO.Path.GetFileName(FOM.Filename)#>, do not edit

<# if (FOM.ModelIdentification.Name != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Name, "Name: ")#>
<# } #>
<# if (FOM.ModelIdentification.Copyright != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Copyright, "Copyright: ")#>
<# } #>
<# if (FOM.ModelIdentification.Version != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Version, "Version: ")#>
<# } #>
<# if (FOM.ModelIdentification.Description != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Description, "Description: ")#>
<# } #>
<# if (FOM.ModelIdentification.Purpose != null) { #>
<#=FOMParser.FormatAsComment(FOM.ModelIdentification.Purpose, "Purpose: ")#>
<# } #>

#pragma once

#include <vector>
#include <functional>
#include <memory>

<#=FOM.GetPredefinedTypeIncludes(FOMParser.FileContext.kObjectInterfaces)#>
#include "<#=DataTypesHeaderFilename#>"

<#
foreach (var namespacePart in FOM.Namespace)
{
#>
namespace <#=namespacePart#> {
<# } #>

<# 
foreach (var objectClass in FOM.ObjectClasses)
{
#>
class I<#=objectClass.Name#>;
class I<#=objectClass.Name#>ObjectClass
{
  public:
    using DiscoverObjectInstanceCallback = std::function<void(std::shared_ptr<I<#=objectClass.Name#>>)>;
    using RemoveObjectInstanceCallback = std::function<void(std::shared_ptr<I<#=objectClass.Name#>>)>;
    using ObjectCreatedCallbackType = std::function<void(std::shared_ptr<I<#=objectClass.Name#>>, bool success)>;
    virtual void Publish() = 0;
    virtual void Unpublish() = 0;
    virtual void Subscribe(bool deliverToSelf) = 0;
    virtual void Unsubscribe() = 0;
    virtual std::shared_ptr<I<#=objectClass.Name#>> GetObjectInstance(const std::wstring& instanceName) = 0;
    virtual std::shared_ptr<I<#=objectClass.Name#>> CreateObjectInstance(const std::wstring& instanceName) = 0;
    virtual std::shared_ptr<I<#=objectClass.Name#>> CreateObjectInstance(const std::wstring& instanceName, ObjectCreatedCallbackType createdCallback) = 0;

    virtual uint32_t RegisterDiscoverObjectInstanceCallback(DiscoverObjectInstanceCallback callback) = 0;
    virtual void UnregisterDiscoverObjectInstanceCallback(uint32_t callbackToken) = 0;

    virtual uint32_t RegisterRemoveObjectInstanceCallback(RemoveObjectInstanceCallback callback) = 0;
    virtual void UnregisterRemoveObjectInstanceCallback(uint32_t callbackToken) = 0;
};

class I<#=objectClass.Name#><#
  if (objectClass.BaseClass != null)
  {
#> : public I<#=objectClass.BaseClass.Name#>
<# } else {
#>

<# } // if #>
{
<# 
  string attributeBitsClass = "uint32_t";
  string attributeBitsPostfix = "";
  if (objectClass.Attributes.Count > 32)
  {
    attributeBitsClass = "uint64_t";
    attributeBitsPostfix = "ull";
  }
#>
  public:
<# if (objectClass.BaseClass == null)  {#>
    using AttributeBits = <#=attributeBitsClass#>;
    static const AttributeBits kNone = 0x0;
<# } #>
<# 
  ulong bit;
  if (objectClass.BaseClass != null)
    bit = (ulong)(1 << objectClass.BaseClass.AllAttributes.Count);
  else
    bit = 1;
  foreach (var attribute in objectClass.Attributes)
  {
    if (attribute.DataType != null)
    { #>
    static const AttributeBits k<#=attribute.Name#>Bit = 0x<#=bit.ToString("X")#><#=attributeBitsPostfix#>;
<#
      bit = bit << 1;
    } // if (attribute.DataType != null)
  } // foreach (var attribute in objectClass.Attributes)
#>

    I<#=objectClass.Name#>() {}
<# if (objectClass.BaseClass == null)  {#>
    virtual ~I<#=objectClass.Name#>() {}
<#  } else { #>
    ~I<#=objectClass.Name#>() {}
<# } #>
    I<#=objectClass.Name#>(const I<#=objectClass.Name#>&) = delete;
    I<#=objectClass.Name#>(I<#=objectClass.Name#>&&) = delete;
    I<#=objectClass.Name#>& operator=(const I<#=objectClass.Name#>&) = delete;
    I<#=objectClass.Name#>& operator=(I<#=objectClass.Name#>&&) = delete;

<# if (objectClass.BaseClass == null)  {#>
    virtual std::wstring GetObjectInstanceName() const = 0;
    virtual bool IsValid() const = 0;
    virtual bool IsOwner() const = 0;
    virtual void Release() = 0;
<# } #>
<# 
  foreach (var attribute in objectClass.Attributes)
  {
    if (attribute.DataType != null)
    { #>
    // attribute <#=attribute.Name#> : <#=attribute.DataType.Name#>
    virtual <#=attribute.DataType.ReturnCppType#> Get<#=attribute.Name#>() const = 0;
<#    if (attribute.DataType is FOMParser.FixedRecordDataType) { #>
    virtual <#=attribute.DataType.ModifiableReturnCppType#> Get<#=attribute.Name#>() = 0;
<#  } #>
    virtual void Set<#=attribute.Name#>(<#=attribute.DataType.ParameterCppType#> newValue) = 0;
<#  } else { #>
    // attribute <#=attribute.Name#> : no data type
<#  
    } // if (attribute.DataType != null)
  } // foreach (var attribute in objectClass.Attributes)
#>
<# if (objectClass.HasValidAttributes) { #>
<# if (objectClass.BaseClass != null && !objectClass.BaseClass.HasValidAttributes) { // first child class with valid attributes #>
    // send all attribute values
    virtual void UpdateAllAttributeValues() = 0;
    // send all attribute values, as TSO message
    virtual void UpdateAllAttributeValues(<#=FOM.NativeTimeType#> time) = 0;
    // send attribute values which have been modified since last call
    virtual void UpdateModifiedAttributeValues() = 0;
    // send attribute values which have been modified since last call, as TSO message
    virtual void UpdateModifiedAttributeValues(<#=FOM.NativeTimeType#> time) = 0;
    // get bitmap of attribute values which have been udpated in last call to reflectAttributeValues
    virtual AttributeBits GetUpdatedAttributes() const = 0;
    // request attribute values which haven't been updated in last reflectAttributeValues
    virtual void RequestAttributeValues() = 0;
    // request all attribute values
    virtual void RequestAllAttributeValues() = 0;
<# } #>
<# if (objectClass.ChildClasses.Count == 0) { #>
    using UpdateCallback = std::function<void(I<#=objectClass.Name#>*)>;
    virtual uint32_t RegisterUpdateCallback(UpdateCallback callback) = 0;
    virtual void UnregisterUpdateCallback(uint32_t callbackToken) = 0;
    using UpdateCallbackWithTime = std::function<void(I<#=objectClass.Name#>*, <#=FOM.NativeTimeType#> time, OrderType orderType)>;
    virtual uint32_t RegisterUpdateCallbackWithTime(UpdateCallbackWithTime callback) = 0;
    virtual void UnregisterUpdateCallbackWithTime(uint32_t callbackToken) = 0;
<# } // if (objectClass.ChildClasses.Count == 0) #>
<# } // if (objectClass.HasValidAttributes) #>
};

<# } // foreach (var objectClass in FOM.ObjectClasses) #>

class IObjectClassRegistry
{
  public:
<# foreach (var objectClass in FOM.ObjectClasses) { #>
    virtual I<#=objectClass.Name#>ObjectClass* Get<#=objectClass.Name#>ObjectClass() const = 0;
<# } #>
  protected:
    virtual ~IObjectClassRegistry() {}
}; // class IObjectClassRegistry

<#
foreach (var namespacePart in FOM.Namespace)
{
#>
} // namespace <#=namespacePart#>
<#  } #>
